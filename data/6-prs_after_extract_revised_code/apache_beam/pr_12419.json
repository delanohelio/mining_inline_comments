{"pr_number": 12419, "pr_title": "[BEAM-10303] Handle split when truncate observes windows.", "pr_createdAt": "2020-07-30T03:02:21Z", "pr_url": "https://github.com/apache/beam/pull/12419", "timeline": [{"oid": "96fea2ac3f78a1ca400a0fbb541e9d945f63ac98", "url": "https://github.com/apache/beam/commit/96fea2ac3f78a1ca400a0fbb541e9d945f63ac98", "message": "Handle split when truncate observes windows.", "committedDate": "2020-07-31T22:25:38Z", "type": "forcePushed"}, {"oid": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "url": "https://github.com/apache/beam/commit/c12679c5b3530c447a06199e0b3525b2f1f0f435", "message": "Handle split when truncate observes windows.", "committedDate": "2020-08-03T18:37:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTY5OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464651698", "bodyText": "nit: here and below on 550\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  (HandlesSplits) Iterables.get(mainOutputConsumers, 0);\n          \n          \n            \n                                  (HandlesSplits) Iterables.getOnlyElement(mainOutputConsumers);", "author": "lukecwik", "createdAt": "2020-08-03T20:43:31Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -515,15 +515,18 @@\n               && Iterables.get(mainOutputConsumers, 0) instanceof HandlesSplits) {\n             mainInputConsumer =\n                 new SplittableFnDataReceiver() {\n+                  private final HandlesSplits splitDelegate =\n+                      (HandlesSplits) Iterables.get(mainOutputConsumers, 0);", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -512,11 +526,11 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n             || !sideInputMapping.isEmpty()) {\n           // Only forward split/progress when the only consumer is splittable.\n           if (mainOutputConsumers.size() == 1\n-              && Iterables.get(mainOutputConsumers, 0) instanceof HandlesSplits) {\n+              && Iterables.getOnlyElement(mainOutputConsumers) instanceof HandlesSplits) {\n             mainInputConsumer =\n                 new SplittableFnDataReceiver() {\n                   private final HandlesSplits splitDelegate =\n-                      (HandlesSplits) Iterables.get(mainOutputConsumers, 0);\n+                      (HandlesSplits) Iterables.getOnlyElement(mainOutputConsumers);\n \n                   @Override\n                   public void accept(WindowedValue input) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDM3Ng==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464654376", "bodyText": "we should be using the truncate transform id and not the process sized elements transform id\nThis will remove the assumption about what the input coder is and we can append our additional primaries and residuals on top of any additional residuals/primaries added by the downstream split.\nDoing this might require fixing Dataflow runner v2.", "author": "lukecwik", "createdAt": "2020-08-03T20:49:04Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1035,6 +1046,130 @@ private Progress getProgress() {\n     return null;\n   }\n \n+  private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n+      double fractionOfRemainder, HandlesSplits splitDelegate) {\n+    WindowedValue primaryInFullyProcessedWindowsRoot;\n+    WindowedValue residualInUnprocessedWindowsRoot;\n+    // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n+    // the same as the SDF/Process transform.\n+    Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n+    BundleApplication windowedPrimaryRoot;\n+    DelayedBundleApplication windowedResidualRoot;\n+    synchronized (splitLock) {\n+      // There is nothing to split if we are between truncate processing calls.\n+      if (currentWindowIterator == null) {\n+        return null;\n+      }\n+      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n+      if (splitResult == null) {\n+        return null;\n+      }\n+\n+      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n+      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n+\n+      // We have a successful split from downstream sdf process.\n+      // Convert the split taking into account the processed windows, the current window and the\n+      // yet to be processed windows.\n+      List<BoundedWindow> primaryFullyProcessedWindows =\n+          ImmutableList.copyOf(\n+              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+      // Advances the iterator consuming the remaining windows.\n+      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n+      // If the window has been observed then the splitAndSize method would have already\n+      // output sizes for each window separately.\n+      //\n+      // TODO: Consider using the original size on the element instead of recomputing\n+      // this here.\n+      double fullSize =\n+          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+              ? 0\n+              : doFnInvoker.invokeGetSize(\n+                  new DelegatingArgumentProvider<InputT, OutputT>(\n+                      processContext,\n+                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n+                          + \"/GetPrimarySize\") {\n+                    @Override\n+                    public Object restriction() {\n+                      return currentRestriction;\n+                    }\n+\n+                    @Override\n+                    public RestrictionTracker<?, ?> restrictionTracker() {\n+                      return doFnInvoker.invokeNewTracker(this);\n+                    }\n+                  });\n+      primaryInFullyProcessedWindowsRoot =\n+          primaryFullyProcessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  primaryFullyProcessedWindows,\n+                  currentElement.getPane());\n+      residualInUnprocessedWindowsRoot =\n+          residualUnprocessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  residualUnprocessedWindows,\n+                  currentElement.getPane());\n+    }\n+\n+    List<BundleApplication> primaryRoots = new ArrayList<>();\n+    List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n+\n+    if (primaryInFullyProcessedWindowsRoot != null) {\n+      ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder primaryApplicationInOtherWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(windowedPrimaryRoot.getTransformId())", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjEyNTMzMQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r476125331", "bodyText": "I think we should still use transform id and main input id from process sized elements. There are 3 possible cases:\n\nWe only have splits on window boundary\nWe only have element split on the last window\nWe have both element splits and window splits.\n\nIf we choose transfrom id and input id from truncate for element split, it's also wrong conceptually. I prefer process sized elements because it will simplify the implementation on the runner side. For example, the runner doesn't need to distinguish window splits or element splits. If we treat truncate and process as a whole, it also make sense to use transform id from process.", "author": "boyuanzz", "createdAt": "2020-08-25T03:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NDM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1034,271 +1057,365 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       return 0;\n     }\n+\n+    @Override\n+    public String getPTranformId() {\n+      return pTransformId;\n+    }\n+\n+    @Override\n+    public String getMainInputId() {\n+      return mainInputId;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputIds() {\n+      return pTransform.getOutputsMap().keySet();\n+    }\n   }\n \n   private Progress getProgress() {\n-    // TODO(BEAM-10303): The progress should be scaled with respect to window observation.\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(), windowCurrentIndex, windowStopIndex);\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindow != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            windowCurrentIndex,\n+            windowStopIndex);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static Progress scaleProgress(\n+      Progress progress, int currentWindowIndex, int stopWindowIndex) {\n+    double totalWorkPerWindow = progress.getWorkCompleted() + progress.getWorkRemaining();\n+    double completed = totalWorkPerWindow * currentWindowIndex + progress.getWorkCompleted();\n+    double remaining =\n+        totalWorkPerWindow * (stopWindowIndex - currentWindowIndex - 1)\n+            + progress.getWorkRemaining();\n+    return Progress.from(completed, remaining);\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n       double fractionOfRemainder, HandlesSplits splitDelegate) {\n-    WindowedValue primaryInFullyProcessedWindowsRoot;\n-    WindowedValue residualInUnprocessedWindowsRoot;\n     // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n     // the same as the SDF/Process transform.\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    BundleApplication windowedPrimaryRoot;\n-    DelayedBundleApplication windowedResidualRoot;\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between truncate processing calls.\n-      if (currentWindowIterator == null) {\n-        return null;\n-      }\n-      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n+      if (currentWindow == null) {\n         return null;\n       }\n \n-      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n-      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n-\n-      // We have a successful split from downstream sdf process.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n+      Progress elementProgress = getProgress();\n+      Progress scaledProgress = scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+      watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n \n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      primaryInFullyProcessedWindowsRoot =\n-          primaryFullyProcessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  primaryFullyProcessedWindows,\n-                  currentElement.getPane());\n-      residualInUnprocessedWindowsRoot =\n-          residualUnprocessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  residualUnprocessedWindows,\n-                  currentElement.getPane());\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n+\n+        } else {\n+          downstreamSplitResult = splitDelegate.trySplit(scaledFractionOfRemainder);\n+          if (downstreamSplitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                      + \"/GetSize\");\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        downstreamSplitResult = splitDelegate.trySplit(fractionOfRemainder);\n+        if (downstreamSplitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n \n-    if (primaryInFullyProcessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n-        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+        fullInputCoder.encode(\n+            windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot(),\n+            primaryInOtherWindowsBytes);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedPrimaryRoot.getTransformId())\n-              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n-    if (residualInUnprocessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getResidualInUnprocessedWindowsRoot() != null) {\n       ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n-            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+            windowedSplitResult.getResidualInUnprocessedWindowsRoot(),\n+            residualInUnprocessedWindowsBytesOut);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMap = new HashMap<>();\n+      if (!watermarkAndState.getKey().equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n+                .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : splitDelegate.getOutputIds()) {\n+          outputWatermarkMap.put(outputId, outputWatermark);\n+        }\n+      }\n+\n       BundleApplication.Builder residualApplicationInUnprocessedWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedResidualRoot.getApplication().getTransformId())\n-              .setInputId(windowedResidualRoot.getApplication().getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .putAllOutputWatermarks(outputWatermarkMap)\n               .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n-      // TODO: Consider using currentWatermark in unprocessed window?\n+\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualApplicationInUnprocessedWindows)\n               .build());\n     }\n \n-    primaryRoots.add(windowedPrimaryRoot);\n-    residualRoots.add(windowedResidualRoot);\n+    if (downstreamSplitResult != null) {\n+      primaryRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getPrimaryRoots()));\n+      residualRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getResidualRoots()));\n+    }\n \n     return HandlesSplits.SplitResult.of(primaryRoots, residualRoots);\n   }\n \n+  private WindowedSplitResult computeWindowSplitResult(\n+      int toIndex,\n+      int fromIndex,\n+      SplitResult<RestrictionT> splitResult,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState,\n+      String errorContext) {\n+    List<BoundedWindow> primaryFullyProcessedWindows = currentWindows.subList(0, toIndex);\n+    List<BoundedWindow> residualUnprocessedWindows =\n+        currentWindows.subList(fromIndex, windowStopIndex);\n+    WindowedSplitResult windowedSplitResult;\n+    double fullSize =\n+        primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getPrimary();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getResidual();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+\n+    windowedSplitResult =\n+        WindowedSplitResult.forRoots(\n+            primaryFullyProcessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    primaryFullyProcessedWindows,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                        primarySize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n+                        residualSize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            residualUnprocessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    residualUnprocessedWindows,\n+                    currentElement.getPane()));\n+    return windowedSplitResult;\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForElementAndRestriction(\n       double fractionOfRemainder, Duration resumeDelay) {\n     KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n-    WindowedSplitResult windowedSplitResult;\n+    WindowedSplitResult windowedSplitResult = null;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between element and restriction processing calls.\n       if (currentTracker == null) {\n         return null;\n       }\n-\n       // Make sure to get the output watermark before we split to ensure that the lower bound\n       // applies to the residual.\n       watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n-      SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n-        return null;\n-      }\n \n-      // We have a successful self split, either runner initiated or via a self checkpoint.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n-\n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      double primarySize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        Progress elementProgress = getProgress();\n+        Progress scaledProgress =\n+            scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+        double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetPrimarySize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getPrimary();\n-                }\n+                      + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      double residualSize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+        } else {\n+          SplitResult<RestrictionT> splitResult =\n+              currentTracker.trySplit(scaledFractionOfRemainder);\n+          if (splitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetResidualSize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getResidual();\n-                }\n+                      + \"/GetSize\");\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      windowedSplitResult =\n-          WindowedSplitResult.forRoots(\n-              primaryFullyProcessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      primaryFullyProcessedWindows,\n-                      currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                      primarySize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n-                      residualSize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              residualUnprocessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      residualUnprocessedWindows,\n-                      currentElement.getPane()));\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+        if (splitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    if (windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2MjM0MQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464662341", "bodyText": "ditto, we should be using the truncate transfrom id and truncate input id.", "author": "lukecwik", "createdAt": "2020-08-03T21:06:44Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1035,6 +1046,130 @@ private Progress getProgress() {\n     return null;\n   }\n \n+  private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n+      double fractionOfRemainder, HandlesSplits splitDelegate) {\n+    WindowedValue primaryInFullyProcessedWindowsRoot;\n+    WindowedValue residualInUnprocessedWindowsRoot;\n+    // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n+    // the same as the SDF/Process transform.\n+    Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n+    BundleApplication windowedPrimaryRoot;\n+    DelayedBundleApplication windowedResidualRoot;\n+    synchronized (splitLock) {\n+      // There is nothing to split if we are between truncate processing calls.\n+      if (currentWindowIterator == null) {\n+        return null;\n+      }\n+      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n+      if (splitResult == null) {\n+        return null;\n+      }\n+\n+      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n+      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n+\n+      // We have a successful split from downstream sdf process.\n+      // Convert the split taking into account the processed windows, the current window and the\n+      // yet to be processed windows.\n+      List<BoundedWindow> primaryFullyProcessedWindows =\n+          ImmutableList.copyOf(\n+              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+      // Advances the iterator consuming the remaining windows.\n+      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n+      // If the window has been observed then the splitAndSize method would have already\n+      // output sizes for each window separately.\n+      //\n+      // TODO: Consider using the original size on the element instead of recomputing\n+      // this here.\n+      double fullSize =\n+          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+              ? 0\n+              : doFnInvoker.invokeGetSize(\n+                  new DelegatingArgumentProvider<InputT, OutputT>(\n+                      processContext,\n+                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n+                          + \"/GetPrimarySize\") {\n+                    @Override\n+                    public Object restriction() {\n+                      return currentRestriction;\n+                    }\n+\n+                    @Override\n+                    public RestrictionTracker<?, ?> restrictionTracker() {\n+                      return doFnInvoker.invokeNewTracker(this);\n+                    }\n+                  });\n+      primaryInFullyProcessedWindowsRoot =\n+          primaryFullyProcessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  primaryFullyProcessedWindows,\n+                  currentElement.getPane());\n+      residualInUnprocessedWindowsRoot =\n+          residualUnprocessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  residualUnprocessedWindows,\n+                  currentElement.getPane());\n+    }\n+\n+    List<BundleApplication> primaryRoots = new ArrayList<>();\n+    List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n+\n+    if (primaryInFullyProcessedWindowsRoot != null) {\n+      ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder primaryApplicationInOtherWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(windowedPrimaryRoot.getTransformId())\n+              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setElement(primaryInOtherWindowsBytes.toByteString());\n+      primaryRoots.add(primaryApplicationInOtherWindows.build());\n+    }\n+    if (residualInUnprocessedWindowsRoot != null) {\n+      ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(\n+            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder residualApplicationInUnprocessedWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(windowedResidualRoot.getApplication().getTransformId())", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1034,271 +1057,365 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       return 0;\n     }\n+\n+    @Override\n+    public String getPTranformId() {\n+      return pTransformId;\n+    }\n+\n+    @Override\n+    public String getMainInputId() {\n+      return mainInputId;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputIds() {\n+      return pTransform.getOutputsMap().keySet();\n+    }\n   }\n \n   private Progress getProgress() {\n-    // TODO(BEAM-10303): The progress should be scaled with respect to window observation.\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(), windowCurrentIndex, windowStopIndex);\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindow != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            windowCurrentIndex,\n+            windowStopIndex);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static Progress scaleProgress(\n+      Progress progress, int currentWindowIndex, int stopWindowIndex) {\n+    double totalWorkPerWindow = progress.getWorkCompleted() + progress.getWorkRemaining();\n+    double completed = totalWorkPerWindow * currentWindowIndex + progress.getWorkCompleted();\n+    double remaining =\n+        totalWorkPerWindow * (stopWindowIndex - currentWindowIndex - 1)\n+            + progress.getWorkRemaining();\n+    return Progress.from(completed, remaining);\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n       double fractionOfRemainder, HandlesSplits splitDelegate) {\n-    WindowedValue primaryInFullyProcessedWindowsRoot;\n-    WindowedValue residualInUnprocessedWindowsRoot;\n     // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n     // the same as the SDF/Process transform.\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    BundleApplication windowedPrimaryRoot;\n-    DelayedBundleApplication windowedResidualRoot;\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between truncate processing calls.\n-      if (currentWindowIterator == null) {\n-        return null;\n-      }\n-      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n+      if (currentWindow == null) {\n         return null;\n       }\n \n-      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n-      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n-\n-      // We have a successful split from downstream sdf process.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n+      Progress elementProgress = getProgress();\n+      Progress scaledProgress = scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+      watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n \n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      primaryInFullyProcessedWindowsRoot =\n-          primaryFullyProcessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  primaryFullyProcessedWindows,\n-                  currentElement.getPane());\n-      residualInUnprocessedWindowsRoot =\n-          residualUnprocessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  residualUnprocessedWindows,\n-                  currentElement.getPane());\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n+\n+        } else {\n+          downstreamSplitResult = splitDelegate.trySplit(scaledFractionOfRemainder);\n+          if (downstreamSplitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                      + \"/GetSize\");\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        downstreamSplitResult = splitDelegate.trySplit(fractionOfRemainder);\n+        if (downstreamSplitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n \n-    if (primaryInFullyProcessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n-        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+        fullInputCoder.encode(\n+            windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot(),\n+            primaryInOtherWindowsBytes);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedPrimaryRoot.getTransformId())\n-              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n-    if (residualInUnprocessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getResidualInUnprocessedWindowsRoot() != null) {\n       ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n-            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+            windowedSplitResult.getResidualInUnprocessedWindowsRoot(),\n+            residualInUnprocessedWindowsBytesOut);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMap = new HashMap<>();\n+      if (!watermarkAndState.getKey().equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n+                .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : splitDelegate.getOutputIds()) {\n+          outputWatermarkMap.put(outputId, outputWatermark);\n+        }\n+      }\n+\n       BundleApplication.Builder residualApplicationInUnprocessedWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedResidualRoot.getApplication().getTransformId())\n-              .setInputId(windowedResidualRoot.getApplication().getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .putAllOutputWatermarks(outputWatermarkMap)\n               .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n-      // TODO: Consider using currentWatermark in unprocessed window?\n+\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualApplicationInUnprocessedWindows)\n               .build());\n     }\n \n-    primaryRoots.add(windowedPrimaryRoot);\n-    residualRoots.add(windowedResidualRoot);\n+    if (downstreamSplitResult != null) {\n+      primaryRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getPrimaryRoots()));\n+      residualRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getResidualRoots()));\n+    }\n \n     return HandlesSplits.SplitResult.of(primaryRoots, residualRoots);\n   }\n \n+  private WindowedSplitResult computeWindowSplitResult(\n+      int toIndex,\n+      int fromIndex,\n+      SplitResult<RestrictionT> splitResult,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState,\n+      String errorContext) {\n+    List<BoundedWindow> primaryFullyProcessedWindows = currentWindows.subList(0, toIndex);\n+    List<BoundedWindow> residualUnprocessedWindows =\n+        currentWindows.subList(fromIndex, windowStopIndex);\n+    WindowedSplitResult windowedSplitResult;\n+    double fullSize =\n+        primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getPrimary();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getResidual();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+\n+    windowedSplitResult =\n+        WindowedSplitResult.forRoots(\n+            primaryFullyProcessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    primaryFullyProcessedWindows,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                        primarySize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n+                        residualSize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            residualUnprocessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    residualUnprocessedWindows,\n+                    currentElement.getPane()));\n+    return windowedSplitResult;\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForElementAndRestriction(\n       double fractionOfRemainder, Duration resumeDelay) {\n     KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n-    WindowedSplitResult windowedSplitResult;\n+    WindowedSplitResult windowedSplitResult = null;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between element and restriction processing calls.\n       if (currentTracker == null) {\n         return null;\n       }\n-\n       // Make sure to get the output watermark before we split to ensure that the lower bound\n       // applies to the residual.\n       watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n-      SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n-        return null;\n-      }\n \n-      // We have a successful self split, either runner initiated or via a self checkpoint.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n-\n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      double primarySize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        Progress elementProgress = getProgress();\n+        Progress scaledProgress =\n+            scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+        double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetPrimarySize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getPrimary();\n-                }\n+                      + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      double residualSize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+        } else {\n+          SplitResult<RestrictionT> splitResult =\n+              currentTracker.trySplit(scaledFractionOfRemainder);\n+          if (splitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetResidualSize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getResidual();\n-                }\n+                      + \"/GetSize\");\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      windowedSplitResult =\n-          WindowedSplitResult.forRoots(\n-              primaryFullyProcessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      primaryFullyProcessedWindows,\n-                      currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                      primarySize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n-                      residualSize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              residualUnprocessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      residualUnprocessedWindows,\n-                      currentElement.getPane()));\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+        if (splitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    if (windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2Mjg4Ng==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464662886", "bodyText": "We should always be using the initial watermark state for the unprocessed windows and not reporting any watermark for these residual roots since it should be the same as it was.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // TODO: Consider using currentWatermark in unprocessed window?", "author": "lukecwik", "createdAt": "2020-08-03T21:08:01Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1035,6 +1046,130 @@ private Progress getProgress() {\n     return null;\n   }\n \n+  private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n+      double fractionOfRemainder, HandlesSplits splitDelegate) {\n+    WindowedValue primaryInFullyProcessedWindowsRoot;\n+    WindowedValue residualInUnprocessedWindowsRoot;\n+    // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n+    // the same as the SDF/Process transform.\n+    Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n+    BundleApplication windowedPrimaryRoot;\n+    DelayedBundleApplication windowedResidualRoot;\n+    synchronized (splitLock) {\n+      // There is nothing to split if we are between truncate processing calls.\n+      if (currentWindowIterator == null) {\n+        return null;\n+      }\n+      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n+      if (splitResult == null) {\n+        return null;\n+      }\n+\n+      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n+      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n+\n+      // We have a successful split from downstream sdf process.\n+      // Convert the split taking into account the processed windows, the current window and the\n+      // yet to be processed windows.\n+      List<BoundedWindow> primaryFullyProcessedWindows =\n+          ImmutableList.copyOf(\n+              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+      // Advances the iterator consuming the remaining windows.\n+      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n+      // If the window has been observed then the splitAndSize method would have already\n+      // output sizes for each window separately.\n+      //\n+      // TODO: Consider using the original size on the element instead of recomputing\n+      // this here.\n+      double fullSize =\n+          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+              ? 0\n+              : doFnInvoker.invokeGetSize(\n+                  new DelegatingArgumentProvider<InputT, OutputT>(\n+                      processContext,\n+                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n+                          + \"/GetPrimarySize\") {\n+                    @Override\n+                    public Object restriction() {\n+                      return currentRestriction;\n+                    }\n+\n+                    @Override\n+                    public RestrictionTracker<?, ?> restrictionTracker() {\n+                      return doFnInvoker.invokeNewTracker(this);\n+                    }\n+                  });\n+      primaryInFullyProcessedWindowsRoot =\n+          primaryFullyProcessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  primaryFullyProcessedWindows,\n+                  currentElement.getPane());\n+      residualInUnprocessedWindowsRoot =\n+          residualUnprocessedWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                      fullSize),\n+                  currentElement.getTimestamp(),\n+                  residualUnprocessedWindows,\n+                  currentElement.getPane());\n+    }\n+\n+    List<BundleApplication> primaryRoots = new ArrayList<>();\n+    List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n+\n+    if (primaryInFullyProcessedWindowsRoot != null) {\n+      ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder primaryApplicationInOtherWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(windowedPrimaryRoot.getTransformId())\n+              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setElement(primaryInOtherWindowsBytes.toByteString());\n+      primaryRoots.add(primaryApplicationInOtherWindows.build());\n+    }\n+    if (residualInUnprocessedWindowsRoot != null) {\n+      ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(\n+            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder residualApplicationInUnprocessedWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(windowedResidualRoot.getApplication().getTransformId())\n+              .setInputId(windowedResidualRoot.getApplication().getInputId())\n+              .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n+      // We don't want to change the output watermarks or set the checkpoint resume time since\n+      // that applies to the current window.\n+      // TODO: Consider using currentWatermark in unprocessed window?", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4Njg3Mg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464686872", "bodyText": "We should always be using the initial watermark state for the unprocessed windows\n\nYes, my point is we should considering set residual's watermarkHold as initial watermark. Otherwise, the runner will use MIN_TIMESTAMP  as default, which may hold back the watermark unnecessarily.", "author": "boyuanzz", "createdAt": "2020-08-03T22:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2Mjg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5OTE1Nw==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464699157", "bodyText": "That is a good point.", "author": "lukecwik", "createdAt": "2020-08-03T22:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2Mjg4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1034,271 +1057,365 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       return 0;\n     }\n+\n+    @Override\n+    public String getPTranformId() {\n+      return pTransformId;\n+    }\n+\n+    @Override\n+    public String getMainInputId() {\n+      return mainInputId;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputIds() {\n+      return pTransform.getOutputsMap().keySet();\n+    }\n   }\n \n   private Progress getProgress() {\n-    // TODO(BEAM-10303): The progress should be scaled with respect to window observation.\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(), windowCurrentIndex, windowStopIndex);\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindow != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            windowCurrentIndex,\n+            windowStopIndex);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static Progress scaleProgress(\n+      Progress progress, int currentWindowIndex, int stopWindowIndex) {\n+    double totalWorkPerWindow = progress.getWorkCompleted() + progress.getWorkRemaining();\n+    double completed = totalWorkPerWindow * currentWindowIndex + progress.getWorkCompleted();\n+    double remaining =\n+        totalWorkPerWindow * (stopWindowIndex - currentWindowIndex - 1)\n+            + progress.getWorkRemaining();\n+    return Progress.from(completed, remaining);\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n       double fractionOfRemainder, HandlesSplits splitDelegate) {\n-    WindowedValue primaryInFullyProcessedWindowsRoot;\n-    WindowedValue residualInUnprocessedWindowsRoot;\n     // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n     // the same as the SDF/Process transform.\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    BundleApplication windowedPrimaryRoot;\n-    DelayedBundleApplication windowedResidualRoot;\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between truncate processing calls.\n-      if (currentWindowIterator == null) {\n-        return null;\n-      }\n-      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n+      if (currentWindow == null) {\n         return null;\n       }\n \n-      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n-      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n-\n-      // We have a successful split from downstream sdf process.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n+      Progress elementProgress = getProgress();\n+      Progress scaledProgress = scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+      watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n \n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      primaryInFullyProcessedWindowsRoot =\n-          primaryFullyProcessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  primaryFullyProcessedWindows,\n-                  currentElement.getPane());\n-      residualInUnprocessedWindowsRoot =\n-          residualUnprocessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  residualUnprocessedWindows,\n-                  currentElement.getPane());\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n+\n+        } else {\n+          downstreamSplitResult = splitDelegate.trySplit(scaledFractionOfRemainder);\n+          if (downstreamSplitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                      + \"/GetSize\");\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        downstreamSplitResult = splitDelegate.trySplit(fractionOfRemainder);\n+        if (downstreamSplitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n \n-    if (primaryInFullyProcessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n-        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+        fullInputCoder.encode(\n+            windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot(),\n+            primaryInOtherWindowsBytes);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedPrimaryRoot.getTransformId())\n-              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n-    if (residualInUnprocessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getResidualInUnprocessedWindowsRoot() != null) {\n       ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n-            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+            windowedSplitResult.getResidualInUnprocessedWindowsRoot(),\n+            residualInUnprocessedWindowsBytesOut);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMap = new HashMap<>();\n+      if (!watermarkAndState.getKey().equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n+                .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : splitDelegate.getOutputIds()) {\n+          outputWatermarkMap.put(outputId, outputWatermark);\n+        }\n+      }\n+\n       BundleApplication.Builder residualApplicationInUnprocessedWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedResidualRoot.getApplication().getTransformId())\n-              .setInputId(windowedResidualRoot.getApplication().getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .putAllOutputWatermarks(outputWatermarkMap)\n               .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n-      // TODO: Consider using currentWatermark in unprocessed window?\n+\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualApplicationInUnprocessedWindows)\n               .build());\n     }\n \n-    primaryRoots.add(windowedPrimaryRoot);\n-    residualRoots.add(windowedResidualRoot);\n+    if (downstreamSplitResult != null) {\n+      primaryRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getPrimaryRoots()));\n+      residualRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getResidualRoots()));\n+    }\n \n     return HandlesSplits.SplitResult.of(primaryRoots, residualRoots);\n   }\n \n+  private WindowedSplitResult computeWindowSplitResult(\n+      int toIndex,\n+      int fromIndex,\n+      SplitResult<RestrictionT> splitResult,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState,\n+      String errorContext) {\n+    List<BoundedWindow> primaryFullyProcessedWindows = currentWindows.subList(0, toIndex);\n+    List<BoundedWindow> residualUnprocessedWindows =\n+        currentWindows.subList(fromIndex, windowStopIndex);\n+    WindowedSplitResult windowedSplitResult;\n+    double fullSize =\n+        primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getPrimary();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getResidual();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+\n+    windowedSplitResult =\n+        WindowedSplitResult.forRoots(\n+            primaryFullyProcessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    primaryFullyProcessedWindows,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                        primarySize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n+                        residualSize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            residualUnprocessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    residualUnprocessedWindows,\n+                    currentElement.getPane()));\n+    return windowedSplitResult;\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForElementAndRestriction(\n       double fractionOfRemainder, Duration resumeDelay) {\n     KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n-    WindowedSplitResult windowedSplitResult;\n+    WindowedSplitResult windowedSplitResult = null;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between element and restriction processing calls.\n       if (currentTracker == null) {\n         return null;\n       }\n-\n       // Make sure to get the output watermark before we split to ensure that the lower bound\n       // applies to the residual.\n       watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n-      SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n-        return null;\n-      }\n \n-      // We have a successful self split, either runner initiated or via a self checkpoint.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n-\n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      double primarySize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        Progress elementProgress = getProgress();\n+        Progress scaledProgress =\n+            scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+        double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetPrimarySize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getPrimary();\n-                }\n+                      + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      double residualSize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+        } else {\n+          SplitResult<RestrictionT> splitResult =\n+              currentTracker.trySplit(scaledFractionOfRemainder);\n+          if (splitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetResidualSize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getResidual();\n-                }\n+                      + \"/GetSize\");\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      windowedSplitResult =\n-          WindowedSplitResult.forRoots(\n-              primaryFullyProcessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      primaryFullyProcessedWindows,\n-                      currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                      primarySize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n-                      residualSize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              residualUnprocessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      residualUnprocessedWindows,\n-                      currentElement.getPane()));\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+        if (splitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    if (windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2Mzg0OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464663848", "bodyText": "Same as above.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // TODO: Consider using currentWatermark in unprocessed window?", "author": "lukecwik", "createdAt": "2020-08-03T21:10:04Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1193,6 +1328,7 @@ public Object restriction() {\n               .setElement(bytesOut.toByteString());\n       // We don't want to change the output watermarks or set the checkpoint resume time since\n       // that applies to the current window.\n+      // TODO: Consider using currentWatermark in unprocessed window?", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5OTY0NQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464699645", "bodyText": "resolved since this suggestion was not right.", "author": "lukecwik", "createdAt": "2020-08-03T22:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2Mzg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1326,9 +1456,9 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n               .setTransformId(pTransformId)\n               .setInputId(mainInputId)\n               .setElement(bytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n-      // TODO: Consider using currentWatermark in unprocessed window?\n+      if (!outputWatermarkMap.isEmpty()) {\n+        residualInUnprocessedWindowsRoot.putAllOutputWatermarks(outputWatermarkMap);\n+      }\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualInUnprocessedWindowsRoot)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NTQ5OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464665498", "bodyText": "We should be scaling the fraction of the remainder relative to the number of windows we have to find the best split point.\nThis logic should essentially mirror \n  \n    \n      beam/sdks/python/apache_beam/runners/common.py\n    \n    \n         Line 892\n      in\n      13c77a8\n    \n    \n    \n    \n\n        \n          \n           def _try_split(fraction, \n        \n    \n  \n\n except that we will be using the truncate transform id, input id, and coder.\nI suggest following the approach there where we have a static method that does all the heavy lifting so we can test it well and we have some simple wrappers which pass forward all the necessary arguments to the static method that is visible for testing.", "author": "lukecwik", "createdAt": "2020-08-03T21:13:59Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1035,6 +1046,130 @@ private Progress getProgress() {\n     return null;\n   }\n \n+  private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n+      double fractionOfRemainder, HandlesSplits splitDelegate) {", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5Nzk0Ng==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464697946", "bodyText": "That means trySplitForElementAndRestriction requires the same change.", "author": "boyuanzz", "createdAt": "2020-08-03T22:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5OTUwMQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464699501", "bodyText": "Yeah, that would make sense and would allow us to share a bunch of code between the truncate split logic and the process sized elements split logic.", "author": "lukecwik", "createdAt": "2020-08-03T22:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwMDY5MA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464700690", "bodyText": "I see, let's do the scale progress PR first. I'll refactor the code in #12430 a little bit.", "author": "boyuanzz", "createdAt": "2020-08-03T22:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NTQ5OA=="}], "type": "inlineReview", "revised_code": {"commit": "802cd9282881d4893cc08f4688f4575aec1b84de", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex a559c2060a..4ccc742cbe 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1034,271 +1057,365 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       return 0;\n     }\n+\n+    @Override\n+    public String getPTranformId() {\n+      return pTransformId;\n+    }\n+\n+    @Override\n+    public String getMainInputId() {\n+      return mainInputId;\n+    }\n+\n+    @Override\n+    public Set<String> getOutputIds() {\n+      return pTransform.getOutputsMap().keySet();\n+    }\n   }\n \n   private Progress getProgress() {\n-    // TODO(BEAM-10303): The progress should be scaled with respect to window observation.\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(), windowCurrentIndex, windowStopIndex);\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindow != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            windowCurrentIndex,\n+            windowStopIndex);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static Progress scaleProgress(\n+      Progress progress, int currentWindowIndex, int stopWindowIndex) {\n+    double totalWorkPerWindow = progress.getWorkCompleted() + progress.getWorkRemaining();\n+    double completed = totalWorkPerWindow * currentWindowIndex + progress.getWorkCompleted();\n+    double remaining =\n+        totalWorkPerWindow * (stopWindowIndex - currentWindowIndex - 1)\n+            + progress.getWorkRemaining();\n+    return Progress.from(completed, remaining);\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n       double fractionOfRemainder, HandlesSplits splitDelegate) {\n-    WindowedValue primaryInFullyProcessedWindowsRoot;\n-    WindowedValue residualInUnprocessedWindowsRoot;\n     // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n     // the same as the SDF/Process transform.\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    BundleApplication windowedPrimaryRoot;\n-    DelayedBundleApplication windowedResidualRoot;\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between truncate processing calls.\n-      if (currentWindowIterator == null) {\n-        return null;\n-      }\n-      HandlesSplits.SplitResult splitResult = splitDelegate.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n+      if (currentWindow == null) {\n         return null;\n       }\n \n-      windowedPrimaryRoot = Iterables.getOnlyElement(splitResult.getPrimaryRoots());\n-      windowedResidualRoot = Iterables.getOnlyElement(splitResult.getResidualRoots());\n-\n-      // We have a successful split from downstream sdf process.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n+      Progress elementProgress = getProgress();\n+      Progress scaledProgress = scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+      watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n \n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      primaryInFullyProcessedWindowsRoot =\n-          primaryFullyProcessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  primaryFullyProcessedWindows,\n-                  currentElement.getPane());\n-      residualInUnprocessedWindowsRoot =\n-          residualUnprocessedWindows.isEmpty()\n-              ? null\n-              : WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                      fullSize),\n-                  currentElement.getTimestamp(),\n-                  residualUnprocessedWindows,\n-                  currentElement.getPane());\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n+\n+        } else {\n+          downstreamSplitResult = splitDelegate.trySplit(scaledFractionOfRemainder);\n+          if (downstreamSplitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  null,\n+                  PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                      + \"/GetSize\");\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        downstreamSplitResult = splitDelegate.trySplit(fractionOfRemainder);\n+        if (downstreamSplitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n \n-    if (primaryInFullyProcessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n-        fullInputCoder.encode(primaryInFullyProcessedWindowsRoot, primaryInOtherWindowsBytes);\n+        fullInputCoder.encode(\n+            windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot(),\n+            primaryInOtherWindowsBytes);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedPrimaryRoot.getTransformId())\n-              .setInputId(windowedPrimaryRoot.getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n-    if (residualInUnprocessedWindowsRoot != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getResidualInUnprocessedWindowsRoot() != null) {\n       ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n-            residualInUnprocessedWindowsRoot, residualInUnprocessedWindowsBytesOut);\n+            windowedSplitResult.getResidualInUnprocessedWindowsRoot(),\n+            residualInUnprocessedWindowsBytesOut);\n       } catch (IOException e) {\n         throw new RuntimeException(e);\n       }\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMap = new HashMap<>();\n+      if (!watermarkAndState.getKey().equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n+                .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : splitDelegate.getOutputIds()) {\n+          outputWatermarkMap.put(outputId, outputWatermark);\n+        }\n+      }\n+\n       BundleApplication.Builder residualApplicationInUnprocessedWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(windowedResidualRoot.getApplication().getTransformId())\n-              .setInputId(windowedResidualRoot.getApplication().getInputId())\n+              .setTransformId(splitDelegate.getPTranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .putAllOutputWatermarks(outputWatermarkMap)\n               .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n-      // TODO: Consider using currentWatermark in unprocessed window?\n+\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualApplicationInUnprocessedWindows)\n               .build());\n     }\n \n-    primaryRoots.add(windowedPrimaryRoot);\n-    residualRoots.add(windowedResidualRoot);\n+    if (downstreamSplitResult != null) {\n+      primaryRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getPrimaryRoots()));\n+      residualRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getResidualRoots()));\n+    }\n \n     return HandlesSplits.SplitResult.of(primaryRoots, residualRoots);\n   }\n \n+  private WindowedSplitResult computeWindowSplitResult(\n+      int toIndex,\n+      int fromIndex,\n+      SplitResult<RestrictionT> splitResult,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState,\n+      String errorContext) {\n+    List<BoundedWindow> primaryFullyProcessedWindows = currentWindows.subList(0, toIndex);\n+    List<BoundedWindow> residualUnprocessedWindows =\n+        currentWindows.subList(fromIndex, windowStopIndex);\n+    WindowedSplitResult windowedSplitResult;\n+    double fullSize =\n+        primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getPrimary();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return splitResult.getResidual();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+\n+    windowedSplitResult =\n+        WindowedSplitResult.forRoots(\n+            primaryFullyProcessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    primaryFullyProcessedWindows,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                        primarySize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n+                        residualSize),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            residualUnprocessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        KV.of(\n+                            currentElement.getValue(),\n+                            KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                        fullSize),\n+                    currentElement.getTimestamp(),\n+                    residualUnprocessedWindows,\n+                    currentElement.getPane()));\n+    return windowedSplitResult;\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForElementAndRestriction(\n       double fractionOfRemainder, Duration resumeDelay) {\n     KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n-    WindowedSplitResult windowedSplitResult;\n+    WindowedSplitResult windowedSplitResult = null;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between element and restriction processing calls.\n       if (currentTracker == null) {\n         return null;\n       }\n-\n       // Make sure to get the output watermark before we split to ensure that the lower bound\n       // applies to the residual.\n       watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n-      SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n-      if (splitResult == null) {\n-        return null;\n-      }\n \n-      // We have a successful self split, either runner initiated or via a self checkpoint.\n-      // Convert the split taking into account the processed windows, the current window and the\n-      // yet to be processed windows.\n-      List<BoundedWindow> primaryFullyProcessedWindows =\n-          ImmutableList.copyOf(\n-              Iterables.limit(currentElement.getWindows(), currentWindowIterator.previousIndex()));\n-      // Advances the iterator consuming the remaining windows.\n-      List<BoundedWindow> residualUnprocessedWindows = ImmutableList.copyOf(currentWindowIterator);\n-      // If the window has been observed then the splitAndSize method would have already\n-      // output sizes for each window separately.\n-      //\n-      // TODO: Consider using the original size on the element instead of recomputing\n-      // this here.\n-      double fullSize =\n-          primaryFullyProcessedWindows.isEmpty() && residualUnprocessedWindows.isEmpty()\n-              ? 0\n-              : doFnInvoker.invokeGetSize(\n-                  new DelegatingArgumentProvider<InputT, OutputT>(\n-                      processContext,\n-                      PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                          + \"/GetPrimarySize\") {\n-                    @Override\n-                    public Object restriction() {\n-                      return currentRestriction;\n-                    }\n-\n-                    @Override\n-                    public RestrictionTracker<?, ?> restrictionTracker() {\n-                      return doFnInvoker.invokeNewTracker(this);\n-                    }\n-                  });\n-      double primarySize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+      if (windowCurrentIndex != windowStopIndex - 1) {\n+        Progress elementProgress = getProgress();\n+        Progress scaledProgress =\n+            scaleProgress(elementProgress, windowCurrentIndex, windowStopIndex);\n+        double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+\n+        // The fraction is out of the current window and hence we will split at the closest window\n+        // boundary.\n+        if (scaledFractionOfRemainder >= elementProgress.getWorkCompleted()) {\n+          int newWindowStopIndex =\n+              (int)\n+                  Math.min(\n+                      windowStopIndex - 1,\n+                      windowCurrentIndex\n+                          + Math.max(\n+                              1,\n+                              Math.round(\n+                                  elementProgress.getWorkCompleted()\n+                                      + scaledFractionOfRemainder\n+                                          / (elementProgress.getWorkCompleted()\n+                                              + elementProgress.getWorkRemaining()))));\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetPrimarySize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getPrimary();\n-                }\n+                      + \"/GetSize\");\n+          windowStopIndex = newWindowStopIndex;\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      double residualSize =\n-          doFnInvoker.invokeGetSize(\n-              new DelegatingArgumentProvider<InputT, OutputT>(\n-                  processContext,\n+        } else {\n+          SplitResult<RestrictionT> splitResult =\n+              currentTracker.trySplit(scaledFractionOfRemainder);\n+          if (splitResult == null) {\n+            return null;\n+          }\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  windowCurrentIndex,\n+                  windowCurrentIndex + 1,\n+                  null,\n+                  watermarkAndState,\n                   PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n-                      + \"/GetResidualSize\") {\n-                @Override\n-                public Object restriction() {\n-                  return splitResult.getResidual();\n-                }\n+                      + \"/GetSize\");\n \n-                @Override\n-                public RestrictionTracker<?, ?> restrictionTracker() {\n-                  return doFnInvoker.invokeNewTracker(this);\n-                }\n-              });\n-      windowedSplitResult =\n-          WindowedSplitResult.forRoots(\n-              primaryFullyProcessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      primaryFullyProcessedWindows,\n-                      currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                      primarySize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          currentElement.getValue(),\n-                          KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n-                      residualSize),\n-                  currentElement.getTimestamp(),\n-                  currentWindow,\n-                  currentElement.getPane()),\n-              residualUnprocessedWindows.isEmpty()\n-                  ? null\n-                  : WindowedValue.of(\n-                      KV.of(\n-                          KV.of(\n-                              currentElement.getValue(),\n-                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n-                          fullSize),\n-                      currentElement.getTimestamp(),\n-                      residualUnprocessedWindows,\n-                      currentElement.getPane()));\n+          windowStopIndex = windowCurrentIndex + 1;\n+        }\n+      } else {\n+        SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+        if (splitResult == null) {\n+          return null;\n+        }\n+      }\n     }\n \n     List<BundleApplication> primaryRoots = new ArrayList<>();\n     List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n     Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n-    if (windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n       ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n       try {\n         fullInputCoder.encode(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NjkwNg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464666906", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean splitAtTruncate = false;\n          \n          \n            \n                private long processedWindowCount = 0;\n          \n          \n            \n                private final boolean splitAtTruncate;\n          \n          \n            \n                private long processedWindowCount;", "author": "lukecwik", "createdAt": "2020-08-03T21:17:03Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -1452,11 +1452,22 @@ public Instant getInitialWatermarkEstimatorState() {\n   static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n     private final PCollectionView<String> singletonSideInput;\n+    private static final long PROCESSED_WINDOW = 1;\n+    private boolean splitAtTruncate = false;\n+    private long processedWindowCount = 0;", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb1e1bbcfe7034c6514bf14a1740323fe770e10", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 29ac6ef091..6c8b897174 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -132,3473 +138,4296 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n-    private static final long PROCESSED_WINDOW = 1;\n-    private boolean splitAtTruncate = false;\n-    private long processedWindowCount = 0;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n-        PCollectionView<String> singletonSideInput) {\n-      WindowObservingTestSplittableDoFn doFn =\n-          new WindowObservingTestSplittableDoFn(singletonSideInput);\n-      doFn.splitAtTruncate = true;\n-      return doFn;\n-    }\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n \n-    @Override\n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      // Waiting for split when we are on the second window.\n-      if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n-        enableAndWaitForTrySplitToHappen();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n       }\n-      processedWindowCount += 1;\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMap,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMap,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder()\n-                .setElement(primaryBytes.toByteString())\n-                .setInputId(\"testSDFProcessFnInputId\")\n-                .setTransformId(\"testSDFProcessFnPTransformId\")\n-                .build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder()\n-                        .setElement(residualBytes.toByteString())\n-                        .setInputId(\"testSDFProcessFnInputId\")\n-                        .setTransformId(\"testSDFProcessFnPTransformId\")\n-                        .build())\n-                .build()));\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n-\n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n-    }\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add /* addProgressRequestCallback */,\n-            splitListener /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainOutputValues.clear();\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n-    // Setup and launch the trySplit thread.\n-    ExecutorService executorService = Executors.newSingleThreadExecutor();\n-    Future<HandlesSplits.SplitResult> trySplitFuture =\n-        executorService.submit(\n-            () -> {\n-              try {\n-                doFn.waitForSplitElementToBeProcessed();\n-\n-                return ((HandlesSplits) mainInput).trySplit(0);\n-              } finally {\n-                doFn.releaseWaitingProcessElementThread();\n-              }\n-            });\n-\n-    WindowedValue<?> splitValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            window1,\n-            window2,\n-            window3);\n-    mainInput.accept(splitValue);\n-    HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-    // We expect that there are outputs from window1 and window2\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window1,\n-                splitValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window2,\n-                splitValue.getPane())));\n-\n-    SplitResult expectedElementSplit = createSplitResult(0);\n-    BundleApplication expectedElementSplitPrimary =\n-        Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window1,\n-            splitValue.getPane()),\n-        primaryBytes);\n-    BundleApplication expectedWindowedPrimary =\n-        BundleApplication.newBuilder()\n-            .setElement(primaryBytes.toByteString())\n-            .setInputId(expectedElementSplitPrimary.getInputId())\n-            .setTransformId(expectedElementSplitPrimary.getTransformId())\n-            .build();\n-    DelayedBundleApplication expectedElementSplitResidual =\n-        Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window3,\n-            splitValue.getPane()),\n-        residualBytes);\n-    DelayedBundleApplication expectedWindowedResidual =\n-        DelayedBundleApplication.newBuilder()\n-            .setApplication(\n-                BundleApplication.newBuilder()\n-                    .setElement(residualBytes.toByteString())\n-                    .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n-                    .setTransformId(expectedElementSplitResidual.getApplication().getTransformId())\n-                    .build())\n-            .build();\n-    assertThat(\n-        trySplitResult.getPrimaryRoots(),\n-        contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n-    assertThat(\n-        trySplitResult.getResidualRoots(),\n-        contains(expectedWindowedResidual, expectedElementSplitResidual));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+              valueInGlobalWindow(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window1,\n+                  secondValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window2,\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    private static SplitResult createSplitResult(double fractionOfRemainder) {\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      try {\n+        DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n+        DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n+      } catch (Exception e) {\n+        // No-op.\n+      }\n+      return SplitResult.of(\n+          ImmutableList.of(\n+              BundleApplication.newBuilder()\n+                  .setElement(primaryBytes.toByteString())\n+                  .setInputId(\"mainInputId-process\")\n+                  .setTransformId(\"processPTransfromId\")\n+                  .build()),\n+          ImmutableList.of(\n+              DelayedBundleApplication.newBuilder()\n+                  .setApplication(\n+                      BundleApplication.newBuilder()\n+                          .setElement(residualBytes.toByteString())\n+                          .setInputId(\"mainInputId-process\")\n+                          .setTransformId(\"processPTransfromId\")\n+                          .build())\n+                  .build()));\n+    }\n+\n+    private static class SplittableFnDataReceiver\n+        implements HandlesSplits, FnDataReceiver<WindowedValue> {\n+      SplittableFnDataReceiver(\n+          List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n+        this.mainOutputValues = mainOutputValues;\n+      }\n+\n+      private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+\n+      @Override\n+      public SplitResult trySplit(double fractionOfRemainder) {\n+        return createSplitResult(fractionOfRemainder);\n+      }\n+\n+      @Override\n+      public double getProgress() {\n+        return 0.7;\n+      }\n+\n+      @Override\n+      public String getPTranformId() {\n+        return \"processPTransfromId\";\n+      }\n+\n+      @Override\n+      public String getMainInputId() {\n+        return \"mainInputId-process\";\n+      }\n+\n+      @Override\n+      public Set<String> getOutputIds() {\n+        return ImmutableSet.of(\"output-process\");\n+      }\n+\n+      @Override\n+      public void accept(WindowedValue input) throws Exception {\n+        mainOutputValues.add(input);\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add /* addProgressRequestCallback */,\n+              splitListener /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainOutputValues.clear();\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n+      // Setup and launch the trySplit thread.\n+      ExecutorService executorService = Executors.newSingleThreadExecutor();\n+      Future<HandlesSplits.SplitResult> trySplitFuture =\n+          executorService.submit(\n+              () -> {\n+                try {\n+                  doFn.waitForSplitElementToBeProcessed();\n+\n+                  return ((HandlesSplits) mainInput).trySplit(0);\n+                } finally {\n+                  doFn.releaseWaitingProcessElementThread();\n+                }\n+              });\n+\n+      WindowedValue<?> splitValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              window1,\n+              window2,\n+              window3);\n+      mainInput.accept(splitValue);\n+      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+      // We expect that there are outputs from window1 and window2\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window1,\n+                  splitValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window2,\n+                  splitValue.getPane())));\n+\n+      SplitResult expectedElementSplit = createSplitResult(0);\n+      BundleApplication expectedElementSplitPrimary =\n+          Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window1,\n+              splitValue.getPane()),\n+          primaryBytes);\n+      BundleApplication expectedWindowedPrimary =\n+          BundleApplication.newBuilder()\n+              .setElement(primaryBytes.toByteString())\n+              .setInputId(expectedElementSplitPrimary.getInputId())\n+              .setTransformId(expectedElementSplitPrimary.getTransformId())\n+              .build();\n+      DelayedBundleApplication expectedElementSplitResidual =\n+          Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window3,\n+              splitValue.getPane()),\n+          residualBytes);\n+      DelayedBundleApplication expectedWindowedResidual =\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setElement(residualBytes.toByteString())\n+                      .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n+                      .setTransformId(\n+                          expectedElementSplitResidual.getApplication().getTransformId())\n+                      .build())\n+              .build();\n+      assertThat(\n+          trySplitResult.getPrimaryRoots(),\n+          contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n+      assertThat(\n+          trySplitResult.getResidualRoots(),\n+          contains(expectedWindowedResidual, expectedElementSplitResidual));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n+      assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  5.0)));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  2.0)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n   }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+  @RunWith(JUnit4.class)\n+  public static class SplitTest {\n+    private IntervalWindow window1;\n+    private IntervalWindow window2;\n+    private IntervalWindow window3;\n+    private WindowedValue<String> currentElement;\n+    private OffsetRange currentRestriction;\n+    private Instant currentWatermarkEstimatorState;\n+    KV<Instant, Instant> watermarkAndState;\n+\n+    private KV<WindowedValue, WindowedValue> createSplitInWindow(\n+        OffsetRange primaryRestriction, OffsetRange residualRestriction, BoundedWindow window) {\n+      return KV.of(\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(primaryRestriction, currentWatermarkEstimatorState)),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()),\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(residualRestriction, watermarkAndState.getValue())),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()));\n+    }\n+\n+    private KV<WindowedValue, WindowedValue> createSplitAcrossWindows(\n+        List<BoundedWindow> primaryWindows, List<BoundedWindow> residualWindows) {\n+      return KV.of(\n+          primaryWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  primaryWindows,\n+                  currentElement.getPane()),\n+          residualWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  residualWindows,\n+                  currentElement.getPane()));\n+    }\n+\n+    @Before\n+    public void setUp() {\n+      window1 = new IntervalWindow(Instant.ofEpochMilli(0), Instant.ofEpochMilli(10));\n+      window2 = new IntervalWindow(Instant.ofEpochMilli(10), Instant.ofEpochMilli(20));\n+      window3 = new IntervalWindow(Instant.ofEpochMilli(20), Instant.ofEpochMilli(30));\n+      currentElement =\n+          WindowedValue.of(\n+              \"a\",\n+              Instant.ofEpochMilli(57),\n+              ImmutableList.of(window1, window2, window3),\n+              PaneInfo.NO_FIRING);\n+      currentRestriction = new OffsetRange(0L, 100L);\n+      currentWatermarkEstimatorState = Instant.ofEpochMilli(21);\n+      watermarkAndState = KV.of(Instant.ofEpochMilli(42), Instant.ofEpochMilli(42));\n+    }\n+\n+    @Test\n+    public void testScaleProgress() throws Exception {\n+      Progress elementProgress = Progress.from(2, 8);\n+      // There is only one window.\n+      Progress scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 1);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the first window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 3);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(28, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the second window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 1, 3);\n+      assertEquals(12, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(18, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the last window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 2, 3);\n+      assertEquals(22, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 84), new OffsetRange(84, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 63), new OffsetRange(63, 100), window2);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 44), new OffsetRange(44, 100), window3);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.9,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+    private HandlesSplits createSplitDelegate(\n+        double progress, double expectedFraction, HandlesSplits.SplitResult result) {\n+      return new HandlesSplits() {\n+        @Override\n+        public SplitResult trySplit(double fractionOfRemainder) {\n+          checkArgument(fractionOfRemainder == expectedFraction);\n+          return result;\n+        }\n+\n+        @Override\n+        public double getProgress() {\n+          return progress;\n+        }\n+\n+        @Override\n+        public String getPTranformId() {\n+          return \"transfrom_id\";\n+        }\n+\n+        @Override\n+        public String getMainInputId() {\n+          return \"input_id\";\n+        }\n+\n+        @Override\n+        public Set<String> getOutputIds() {\n+          return ImmutableSet.of(\"output\");\n+        }\n+      };\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.54, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.34, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.2, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, null);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2NzE3MA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464667170", "bodyText": "nit: update the constructor to take this parameter instead of mutating it on the instance.", "author": "lukecwik", "createdAt": "2020-08-03T21:17:39Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -1452,11 +1452,22 @@ public Instant getInitialWatermarkEstimatorState() {\n   static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n     private final PCollectionView<String> singletonSideInput;\n+    private static final long PROCESSED_WINDOW = 1;\n+    private boolean splitAtTruncate = false;\n+    private long processedWindowCount = 0;\n \n     private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n       this.singletonSideInput = singletonSideInput;\n     }\n \n+    private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+        PCollectionView<String> singletonSideInput) {\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInput);", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb1e1bbcfe7034c6514bf14a1740323fe770e10", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 29ac6ef091..6c8b897174 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -132,3473 +138,4296 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n-    private static final long PROCESSED_WINDOW = 1;\n-    private boolean splitAtTruncate = false;\n-    private long processedWindowCount = 0;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n-        PCollectionView<String> singletonSideInput) {\n-      WindowObservingTestSplittableDoFn doFn =\n-          new WindowObservingTestSplittableDoFn(singletonSideInput);\n-      doFn.splitAtTruncate = true;\n-      return doFn;\n-    }\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n \n-    @Override\n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      // Waiting for split when we are on the second window.\n-      if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n-        enableAndWaitForTrySplitToHappen();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n       }\n-      processedWindowCount += 1;\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMap,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMap,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder()\n-                .setElement(primaryBytes.toByteString())\n-                .setInputId(\"testSDFProcessFnInputId\")\n-                .setTransformId(\"testSDFProcessFnPTransformId\")\n-                .build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder()\n-                        .setElement(residualBytes.toByteString())\n-                        .setInputId(\"testSDFProcessFnInputId\")\n-                        .setTransformId(\"testSDFProcessFnPTransformId\")\n-                        .build())\n-                .build()));\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n-\n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n-    }\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add /* addProgressRequestCallback */,\n-            splitListener /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainOutputValues.clear();\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n-    // Setup and launch the trySplit thread.\n-    ExecutorService executorService = Executors.newSingleThreadExecutor();\n-    Future<HandlesSplits.SplitResult> trySplitFuture =\n-        executorService.submit(\n-            () -> {\n-              try {\n-                doFn.waitForSplitElementToBeProcessed();\n-\n-                return ((HandlesSplits) mainInput).trySplit(0);\n-              } finally {\n-                doFn.releaseWaitingProcessElementThread();\n-              }\n-            });\n-\n-    WindowedValue<?> splitValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            window1,\n-            window2,\n-            window3);\n-    mainInput.accept(splitValue);\n-    HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-    // We expect that there are outputs from window1 and window2\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window1,\n-                splitValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window2,\n-                splitValue.getPane())));\n-\n-    SplitResult expectedElementSplit = createSplitResult(0);\n-    BundleApplication expectedElementSplitPrimary =\n-        Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window1,\n-            splitValue.getPane()),\n-        primaryBytes);\n-    BundleApplication expectedWindowedPrimary =\n-        BundleApplication.newBuilder()\n-            .setElement(primaryBytes.toByteString())\n-            .setInputId(expectedElementSplitPrimary.getInputId())\n-            .setTransformId(expectedElementSplitPrimary.getTransformId())\n-            .build();\n-    DelayedBundleApplication expectedElementSplitResidual =\n-        Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window3,\n-            splitValue.getPane()),\n-        residualBytes);\n-    DelayedBundleApplication expectedWindowedResidual =\n-        DelayedBundleApplication.newBuilder()\n-            .setApplication(\n-                BundleApplication.newBuilder()\n-                    .setElement(residualBytes.toByteString())\n-                    .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n-                    .setTransformId(expectedElementSplitResidual.getApplication().getTransformId())\n-                    .build())\n-            .build();\n-    assertThat(\n-        trySplitResult.getPrimaryRoots(),\n-        contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n-    assertThat(\n-        trySplitResult.getResidualRoots(),\n-        contains(expectedWindowedResidual, expectedElementSplitResidual));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+              valueInGlobalWindow(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window1,\n+                  secondValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window2,\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    private static SplitResult createSplitResult(double fractionOfRemainder) {\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      try {\n+        DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n+        DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n+      } catch (Exception e) {\n+        // No-op.\n+      }\n+      return SplitResult.of(\n+          ImmutableList.of(\n+              BundleApplication.newBuilder()\n+                  .setElement(primaryBytes.toByteString())\n+                  .setInputId(\"mainInputId-process\")\n+                  .setTransformId(\"processPTransfromId\")\n+                  .build()),\n+          ImmutableList.of(\n+              DelayedBundleApplication.newBuilder()\n+                  .setApplication(\n+                      BundleApplication.newBuilder()\n+                          .setElement(residualBytes.toByteString())\n+                          .setInputId(\"mainInputId-process\")\n+                          .setTransformId(\"processPTransfromId\")\n+                          .build())\n+                  .build()));\n+    }\n+\n+    private static class SplittableFnDataReceiver\n+        implements HandlesSplits, FnDataReceiver<WindowedValue> {\n+      SplittableFnDataReceiver(\n+          List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n+        this.mainOutputValues = mainOutputValues;\n+      }\n+\n+      private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+\n+      @Override\n+      public SplitResult trySplit(double fractionOfRemainder) {\n+        return createSplitResult(fractionOfRemainder);\n+      }\n+\n+      @Override\n+      public double getProgress() {\n+        return 0.7;\n+      }\n+\n+      @Override\n+      public String getPTranformId() {\n+        return \"processPTransfromId\";\n+      }\n+\n+      @Override\n+      public String getMainInputId() {\n+        return \"mainInputId-process\";\n+      }\n+\n+      @Override\n+      public Set<String> getOutputIds() {\n+        return ImmutableSet.of(\"output-process\");\n+      }\n+\n+      @Override\n+      public void accept(WindowedValue input) throws Exception {\n+        mainOutputValues.add(input);\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add /* addProgressRequestCallback */,\n+              splitListener /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainOutputValues.clear();\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n+      // Setup and launch the trySplit thread.\n+      ExecutorService executorService = Executors.newSingleThreadExecutor();\n+      Future<HandlesSplits.SplitResult> trySplitFuture =\n+          executorService.submit(\n+              () -> {\n+                try {\n+                  doFn.waitForSplitElementToBeProcessed();\n+\n+                  return ((HandlesSplits) mainInput).trySplit(0);\n+                } finally {\n+                  doFn.releaseWaitingProcessElementThread();\n+                }\n+              });\n+\n+      WindowedValue<?> splitValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              window1,\n+              window2,\n+              window3);\n+      mainInput.accept(splitValue);\n+      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+      // We expect that there are outputs from window1 and window2\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window1,\n+                  splitValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window2,\n+                  splitValue.getPane())));\n+\n+      SplitResult expectedElementSplit = createSplitResult(0);\n+      BundleApplication expectedElementSplitPrimary =\n+          Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window1,\n+              splitValue.getPane()),\n+          primaryBytes);\n+      BundleApplication expectedWindowedPrimary =\n+          BundleApplication.newBuilder()\n+              .setElement(primaryBytes.toByteString())\n+              .setInputId(expectedElementSplitPrimary.getInputId())\n+              .setTransformId(expectedElementSplitPrimary.getTransformId())\n+              .build();\n+      DelayedBundleApplication expectedElementSplitResidual =\n+          Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window3,\n+              splitValue.getPane()),\n+          residualBytes);\n+      DelayedBundleApplication expectedWindowedResidual =\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setElement(residualBytes.toByteString())\n+                      .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n+                      .setTransformId(\n+                          expectedElementSplitResidual.getApplication().getTransformId())\n+                      .build())\n+              .build();\n+      assertThat(\n+          trySplitResult.getPrimaryRoots(),\n+          contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n+      assertThat(\n+          trySplitResult.getResidualRoots(),\n+          contains(expectedWindowedResidual, expectedElementSplitResidual));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n+      assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  5.0)));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  2.0)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n   }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+  @RunWith(JUnit4.class)\n+  public static class SplitTest {\n+    private IntervalWindow window1;\n+    private IntervalWindow window2;\n+    private IntervalWindow window3;\n+    private WindowedValue<String> currentElement;\n+    private OffsetRange currentRestriction;\n+    private Instant currentWatermarkEstimatorState;\n+    KV<Instant, Instant> watermarkAndState;\n+\n+    private KV<WindowedValue, WindowedValue> createSplitInWindow(\n+        OffsetRange primaryRestriction, OffsetRange residualRestriction, BoundedWindow window) {\n+      return KV.of(\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(primaryRestriction, currentWatermarkEstimatorState)),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()),\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(residualRestriction, watermarkAndState.getValue())),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()));\n+    }\n+\n+    private KV<WindowedValue, WindowedValue> createSplitAcrossWindows(\n+        List<BoundedWindow> primaryWindows, List<BoundedWindow> residualWindows) {\n+      return KV.of(\n+          primaryWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  primaryWindows,\n+                  currentElement.getPane()),\n+          residualWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  residualWindows,\n+                  currentElement.getPane()));\n+    }\n+\n+    @Before\n+    public void setUp() {\n+      window1 = new IntervalWindow(Instant.ofEpochMilli(0), Instant.ofEpochMilli(10));\n+      window2 = new IntervalWindow(Instant.ofEpochMilli(10), Instant.ofEpochMilli(20));\n+      window3 = new IntervalWindow(Instant.ofEpochMilli(20), Instant.ofEpochMilli(30));\n+      currentElement =\n+          WindowedValue.of(\n+              \"a\",\n+              Instant.ofEpochMilli(57),\n+              ImmutableList.of(window1, window2, window3),\n+              PaneInfo.NO_FIRING);\n+      currentRestriction = new OffsetRange(0L, 100L);\n+      currentWatermarkEstimatorState = Instant.ofEpochMilli(21);\n+      watermarkAndState = KV.of(Instant.ofEpochMilli(42), Instant.ofEpochMilli(42));\n+    }\n+\n+    @Test\n+    public void testScaleProgress() throws Exception {\n+      Progress elementProgress = Progress.from(2, 8);\n+      // There is only one window.\n+      Progress scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 1);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the first window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 3);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(28, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the second window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 1, 3);\n+      assertEquals(12, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(18, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the last window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 2, 3);\n+      assertEquals(22, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 84), new OffsetRange(84, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 63), new OffsetRange(63, 100), window2);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 44), new OffsetRange(44, 100), window3);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.9,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+    private HandlesSplits createSplitDelegate(\n+        double progress, double expectedFraction, HandlesSplits.SplitResult result) {\n+      return new HandlesSplits() {\n+        @Override\n+        public SplitResult trySplit(double fractionOfRemainder) {\n+          checkArgument(fractionOfRemainder == expectedFraction);\n+          return result;\n+        }\n+\n+        @Override\n+        public double getProgress() {\n+          return progress;\n+        }\n+\n+        @Override\n+        public String getPTranformId() {\n+          return \"transfrom_id\";\n+        }\n+\n+        @Override\n+        public String getMainInputId() {\n+          return \"input_id\";\n+        }\n+\n+        @Override\n+        public Set<String> getOutputIds() {\n+          return ImmutableSet.of(\"output\");\n+        }\n+      };\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.54, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.34, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.2, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, null);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3MTg4MQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r464671881", "bodyText": "We'll want to cover more scenarios then just this, see the ones I added in ac6d80e#diff-1b0bb2e59974e0a12a61a762a9add92a\nThis would likely require refactoring the trySplit method to be a static method where all the parameters are passed to the method so that we don't have to worry about all the additional setup and we'll just be testing the core of the method. We can keep one variant around using this approach which well help ensure that we are using the correct locks.", "author": "lukecwik", "createdAt": "2020-08-03T21:28:27Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -3013,19 +3069,107 @@ public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObser\n             startFunctionRegistry,\n             finishFunctionRegistry,\n             teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n+            progressRequestCallbacks::add /* addProgressRequestCallback */,\n+            splitListener /* bundleSplitListener */,\n             null /* bundleFinalizer */);\n+\n+    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n     FnDataReceiver<WindowedValue<?>> mainInput =\n         consumers.getMultiplexingConsumer(inputPCollectionId);\n     assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    assertEquals(0, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertNull(((HandlesSplits) mainInput).trySplit(0.4));\n+    mainOutputValues.clear();\n+    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+    BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n+    // Setup and launch the trySplit thread.\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<HandlesSplits.SplitResult> trySplitFuture =\n+        executorService.submit(\n+            () -> {\n+              try {\n+                doFn.waitForSplitElementToBeProcessed();\n+\n+                return ((HandlesSplits) mainInput).trySplit(0);\n+              } finally {\n+                doFn.releaseWaitingProcessElementThread();\n+              }\n+            });\n+\n+    WindowedValue<?> splitValue =\n+        valueInWindows(\n+            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+            window1,\n+            window2,\n+            window3);\n+    mainInput.accept(splitValue);\n+    HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+    // We expect that there are outputs from window1 and window2\n+    assertThat(\n+        mainOutputValues,\n+        contains(\n+            WindowedValue.of(\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0),\n+                splitValue.getTimestamp(),\n+                window1,\n+                splitValue.getPane()),\n+            WindowedValue.of(\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane())));\n+\n+    SplitResult expectedElementSplit = createSplitResult(0);", "originalCommit": "c12679c5b3530c447a06199e0b3525b2f1f0f435", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efb1e1bbcfe7034c6514bf14a1740323fe770e10", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 29ac6ef091..6c8b897174 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -132,3473 +138,4296 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n-    private static final long PROCESSED_WINDOW = 1;\n-    private boolean splitAtTruncate = false;\n-    private long processedWindowCount = 0;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n-        PCollectionView<String> singletonSideInput) {\n-      WindowObservingTestSplittableDoFn doFn =\n-          new WindowObservingTestSplittableDoFn(singletonSideInput);\n-      doFn.splitAtTruncate = true;\n-      return doFn;\n-    }\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n \n-    @Override\n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n-        throws Exception {\n-      // Waiting for split when we are on the second window.\n-      if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n-        enableAndWaitForTrySplitToHappen();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n       }\n-      processedWindowCount += 1;\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMap,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMap,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder()\n-                .setElement(primaryBytes.toByteString())\n-                .setInputId(\"testSDFProcessFnInputId\")\n-                .setTransformId(\"testSDFProcessFnPTransformId\")\n-                .build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder()\n-                        .setElement(residualBytes.toByteString())\n-                        .setInputId(\"testSDFProcessFnInputId\")\n-                        .setTransformId(\"testSDFProcessFnPTransformId\")\n-                        .build())\n-                .build()));\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n-\n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n-    }\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add /* addProgressRequestCallback */,\n-            splitListener /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainOutputValues.clear();\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n-    // Setup and launch the trySplit thread.\n-    ExecutorService executorService = Executors.newSingleThreadExecutor();\n-    Future<HandlesSplits.SplitResult> trySplitFuture =\n-        executorService.submit(\n-            () -> {\n-              try {\n-                doFn.waitForSplitElementToBeProcessed();\n-\n-                return ((HandlesSplits) mainInput).trySplit(0);\n-              } finally {\n-                doFn.releaseWaitingProcessElementThread();\n-              }\n-            });\n-\n-    WindowedValue<?> splitValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            window1,\n-            window2,\n-            window3);\n-    mainInput.accept(splitValue);\n-    HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-    // We expect that there are outputs from window1 and window2\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window1,\n-                splitValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                splitValue.getTimestamp(),\n-                window2,\n-                splitValue.getPane())));\n-\n-    SplitResult expectedElementSplit = createSplitResult(0);\n-    BundleApplication expectedElementSplitPrimary =\n-        Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window1,\n-            splitValue.getPane()),\n-        primaryBytes);\n-    BundleApplication expectedWindowedPrimary =\n-        BundleApplication.newBuilder()\n-            .setElement(primaryBytes.toByteString())\n-            .setInputId(expectedElementSplitPrimary.getInputId())\n-            .setTransformId(expectedElementSplitPrimary.getTransformId())\n-            .build();\n-    DelayedBundleApplication expectedElementSplitResidual =\n-        Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    inputCoder.encode(\n-        WindowedValue.of(\n-            KV.of(KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n-            splitValue.getTimestamp(),\n-            window3,\n-            splitValue.getPane()),\n-        residualBytes);\n-    DelayedBundleApplication expectedWindowedResidual =\n-        DelayedBundleApplication.newBuilder()\n-            .setApplication(\n-                BundleApplication.newBuilder()\n-                    .setElement(residualBytes.toByteString())\n-                    .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n-                    .setTransformId(expectedElementSplitResidual.getApplication().getTransformId())\n-                    .build())\n-            .build();\n-    assertThat(\n-        trySplitResult.getPrimaryRoots(),\n-        contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n-    assertThat(\n-        trySplitResult.getResidualRoots(),\n-        contains(expectedWindowedResidual, expectedElementSplitResidual));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+              valueInGlobalWindow(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window1,\n+                  secondValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window2,\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    private static SplitResult createSplitResult(double fractionOfRemainder) {\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      try {\n+        DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n+        DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n+      } catch (Exception e) {\n+        // No-op.\n+      }\n+      return SplitResult.of(\n+          ImmutableList.of(\n+              BundleApplication.newBuilder()\n+                  .setElement(primaryBytes.toByteString())\n+                  .setInputId(\"mainInputId-process\")\n+                  .setTransformId(\"processPTransfromId\")\n+                  .build()),\n+          ImmutableList.of(\n+              DelayedBundleApplication.newBuilder()\n+                  .setApplication(\n+                      BundleApplication.newBuilder()\n+                          .setElement(residualBytes.toByteString())\n+                          .setInputId(\"mainInputId-process\")\n+                          .setTransformId(\"processPTransfromId\")\n+                          .build())\n+                  .build()));\n+    }\n+\n+    private static class SplittableFnDataReceiver\n+        implements HandlesSplits, FnDataReceiver<WindowedValue> {\n+      SplittableFnDataReceiver(\n+          List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n+        this.mainOutputValues = mainOutputValues;\n+      }\n+\n+      private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+\n+      @Override\n+      public SplitResult trySplit(double fractionOfRemainder) {\n+        return createSplitResult(fractionOfRemainder);\n+      }\n+\n+      @Override\n+      public double getProgress() {\n+        return 0.7;\n+      }\n+\n+      @Override\n+      public String getPTranformId() {\n+        return \"processPTransfromId\";\n+      }\n+\n+      @Override\n+      public String getMainInputId() {\n+        return \"mainInputId-process\";\n+      }\n+\n+      @Override\n+      public Set<String> getOutputIds() {\n+        return ImmutableSet.of(\"output-process\");\n+      }\n+\n+      @Override\n+      public void accept(WindowedValue input) throws Exception {\n+        mainOutputValues.add(input);\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindows()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          WindowObservingTestSplittableDoFn.forSplitAtTruncate(singletonSideInputView);\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add /* addProgressRequestCallback */,\n+              splitListener /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainOutputValues.clear();\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      BoundedWindow window3 = new IntervalWindow(new Instant(7), new Instant(12));\n+      // Setup and launch the trySplit thread.\n+      ExecutorService executorService = Executors.newSingleThreadExecutor();\n+      Future<HandlesSplits.SplitResult> trySplitFuture =\n+          executorService.submit(\n+              () -> {\n+                try {\n+                  doFn.waitForSplitElementToBeProcessed();\n+\n+                  return ((HandlesSplits) mainInput).trySplit(0);\n+                } finally {\n+                  doFn.releaseWaitingProcessElementThread();\n+                }\n+              });\n+\n+      WindowedValue<?> splitValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              window1,\n+              window2,\n+              window3);\n+      mainInput.accept(splitValue);\n+      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+      // We expect that there are outputs from window1 and window2\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window1,\n+                  splitValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"7\", KV.of(new OffsetRange(0, 3), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  splitValue.getTimestamp(),\n+                  window2,\n+                  splitValue.getPane())));\n+\n+      SplitResult expectedElementSplit = createSplitResult(0);\n+      BundleApplication expectedElementSplitPrimary =\n+          Iterables.getOnlyElement(expectedElementSplit.getPrimaryRoots());\n+      ByteString.Output primaryBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window1,\n+              splitValue.getPane()),\n+          primaryBytes);\n+      BundleApplication expectedWindowedPrimary =\n+          BundleApplication.newBuilder()\n+              .setElement(primaryBytes.toByteString())\n+              .setInputId(expectedElementSplitPrimary.getInputId())\n+              .setTransformId(expectedElementSplitPrimary.getTransformId())\n+              .build();\n+      DelayedBundleApplication expectedElementSplitResidual =\n+          Iterables.getOnlyElement(expectedElementSplit.getResidualRoots());\n+      ByteString.Output residualBytes = ByteString.newOutput();\n+      inputCoder.encode(\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 6), GlobalWindow.TIMESTAMP_MIN_VALUE)), 6.0),\n+              splitValue.getTimestamp(),\n+              window3,\n+              splitValue.getPane()),\n+          residualBytes);\n+      DelayedBundleApplication expectedWindowedResidual =\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setElement(residualBytes.toByteString())\n+                      .setInputId(expectedElementSplitResidual.getApplication().getInputId())\n+                      .setTransformId(\n+                          expectedElementSplitResidual.getApplication().getTransformId())\n+                      .build())\n+              .build();\n+      assertThat(\n+          trySplitResult.getPrimaryRoots(),\n+          contains(expectedWindowedPrimary, expectedElementSplitPrimary));\n+      assertThat(\n+          trySplitResult.getResidualRoots(),\n+          contains(expectedWindowedResidual, expectedElementSplitResidual));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWithoutObservingWindow()\n+        throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n+      assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n+    }\n+\n+    @Test\n+    public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  5.0)));\n+      mainInput.accept(\n+          valueInGlobalWindow(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  2.0)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0)),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n+\n+    @Test\n+    public void\n+        testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n+            throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createTruncateReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      1.0),\n+                  firstValue.getTimestamp(),\n+                  ImmutableList.of(window1, window2),\n+                  firstValue.getPane())));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n   }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedTruncateAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+  @RunWith(JUnit4.class)\n+  public static class SplitTest {\n+    private IntervalWindow window1;\n+    private IntervalWindow window2;\n+    private IntervalWindow window3;\n+    private WindowedValue<String> currentElement;\n+    private OffsetRange currentRestriction;\n+    private Instant currentWatermarkEstimatorState;\n+    KV<Instant, Instant> watermarkAndState;\n+\n+    private KV<WindowedValue, WindowedValue> createSplitInWindow(\n+        OffsetRange primaryRestriction, OffsetRange residualRestriction, BoundedWindow window) {\n+      return KV.of(\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(primaryRestriction, currentWatermarkEstimatorState)),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()),\n+          WindowedValue.of(\n+              KV.of(\n+                  currentElement.getValue(),\n+                  KV.of(residualRestriction, watermarkAndState.getValue())),\n+              currentElement.getTimestamp(),\n+              window,\n+              currentElement.getPane()));\n+    }\n+\n+    private KV<WindowedValue, WindowedValue> createSplitAcrossWindows(\n+        List<BoundedWindow> primaryWindows, List<BoundedWindow> residualWindows) {\n+      return KV.of(\n+          primaryWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  primaryWindows,\n+                  currentElement.getPane()),\n+          residualWindows.isEmpty()\n+              ? null\n+              : WindowedValue.of(\n+                  KV.of(\n+                      currentElement.getValue(),\n+                      KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                  currentElement.getTimestamp(),\n+                  residualWindows,\n+                  currentElement.getPane()));\n+    }\n+\n+    @Before\n+    public void setUp() {\n+      window1 = new IntervalWindow(Instant.ofEpochMilli(0), Instant.ofEpochMilli(10));\n+      window2 = new IntervalWindow(Instant.ofEpochMilli(10), Instant.ofEpochMilli(20));\n+      window3 = new IntervalWindow(Instant.ofEpochMilli(20), Instant.ofEpochMilli(30));\n+      currentElement =\n+          WindowedValue.of(\n+              \"a\",\n+              Instant.ofEpochMilli(57),\n+              ImmutableList.of(window1, window2, window3),\n+              PaneInfo.NO_FIRING);\n+      currentRestriction = new OffsetRange(0L, 100L);\n+      currentWatermarkEstimatorState = Instant.ofEpochMilli(21);\n+      watermarkAndState = KV.of(Instant.ofEpochMilli(42), Instant.ofEpochMilli(42));\n+    }\n+\n+    @Test\n+    public void testScaleProgress() throws Exception {\n+      Progress elementProgress = Progress.from(2, 8);\n+      // There is only one window.\n+      Progress scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 1);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the first window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 0, 3);\n+      assertEquals(2, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(28, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the second window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 1, 3);\n+      assertEquals(12, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(18, scaledResult.getWorkRemaining(), 0.0);\n+\n+      // We are at the last window of 3 in total.\n+      scaledResult = FnApiDoFnRunner.scaleProgress(elementProgress, 2, 3);\n+      assertEquals(22, scaledResult.getWorkCompleted(), 0.0);\n+      assertEquals(8, scaledResult.getWorkRemaining(), 0.0);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 31), new OffsetRange(31, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 84), new OffsetRange(84, 100), window1);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 63), new OffsetRange(63, 100), window2);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedElementSplit =\n+          createSplitInWindow(new OffsetRange(0, 44), new OffsetRange(44, 100), window3);\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(expectedElementSplit.getKey(), result.getKey().getPrimarySplitRoot());\n+      assertEquals(expectedElementSplit.getValue(), result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(100L);\n+      assertNull(tracker.trySplit(0.0));\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window3,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0,\n+              tracker,\n+              watermarkAndState,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+    @Test\n+    public void testTrySplitForProcessOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      OffsetRangeTracker tracker = new OffsetRangeTracker(currentRestriction);\n+      tracker.tryClaim(30L);\n+      KV<WindowedSplitResult, Integer> result =\n+          FnApiDoFnRunner.trySplitForProcess(\n+              currentElement,\n+              currentRestriction,\n+              window2,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.9,\n+              tracker,\n+              watermarkAndState,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getPrimarySplitRoot());\n+      assertNull(result.getKey().getResidualSplitRoot());\n+      assertEquals(\n+          expectedWindowSplit.getKey(), result.getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(), result.getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+    private HandlesSplits createSplitDelegate(\n+        double progress, double expectedFraction, HandlesSplits.SplitResult result) {\n+      return new HandlesSplits() {\n+        @Override\n+        public SplitResult trySplit(double fractionOfRemainder) {\n+          checkArgument(fractionOfRemainder == expectedFraction);\n+          return result;\n+        }\n+\n+        @Override\n+        public double getProgress() {\n+          return progress;\n+        }\n+\n+        @Override\n+        public String getPTranformId() {\n+          return \"transfrom_id\";\n+        }\n+\n+        @Override\n+        public String getMainInputId() {\n+          return \"input_id\";\n+        }\n+\n+        @Override\n+        public Set<String> getOutputIds() {\n+          return ImmutableSet.of(\"output\");\n+        }\n+      };\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateCheckpointOnFirstWindowAfterOneSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              2);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.54, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(), ImmutableList.of(window2, window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnMiddleWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.34, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              1,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window3));\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult splitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.2, splitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.2,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertEquals(3, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of());\n+      assertEquals(splitResult, result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnFirstWindowFallback() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateSplitOnLastWindowWhenNoElementSplit() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      HandlesSplits splitDelegate = createSplitDelegate(1.0, 0.0, null);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.0,\n+              splitDelegate,\n+              2,\n+              3);\n+      assertNull(result);\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundUp() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDown() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.3,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(1, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1), ImmutableList.of(window2, window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n+\n+    @Test\n+    public void testTrySplitForTruncateOnWindowBoundaryRoundDownOnLastWindow() throws Exception {\n+      List<BoundedWindow> windows = ImmutableList.copyOf(currentElement.getWindows());\n+      SplitResult unusedSplitResult =\n+          SplitResult.of(\n+              ImmutableList.of(BundleApplication.getDefaultInstance()),\n+              ImmutableList.of(DelayedBundleApplication.getDefaultInstance()));\n+      HandlesSplits splitDelegate = createSplitDelegate(0.3, 0.0, unusedSplitResult);\n+      KV<KV<WindowedSplitResult, SplitResult>, Integer> result =\n+          FnApiDoFnRunner.trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              window1,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              0.6,\n+              splitDelegate,\n+              0,\n+              3);\n+      assertEquals(2, (int) result.getValue());\n+      KV<WindowedValue, WindowedValue> expectedWindowSplit =\n+          createSplitAcrossWindows(ImmutableList.of(window1, window2), ImmutableList.of(window3));\n+      assertNull(result.getKey().getValue());\n+      assertEquals(\n+          expectedWindowSplit.getKey(),\n+          result.getKey().getKey().getPrimaryInFullyProcessedWindowsRoot());\n+      assertEquals(\n+          expectedWindowSplit.getValue(),\n+          result.getKey().getKey().getResidualInUnprocessedWindowsRoot());\n+    }\n   }\n }\n"}}, {"oid": "802cd9282881d4893cc08f4688f4575aec1b84de", "url": "https://github.com/apache/beam/commit/802cd9282881d4893cc08f4688f4575aec1b84de", "message": "try split with windows.", "committedDate": "2020-08-19T03:50:54Z", "type": "forcePushed"}, {"oid": "efb1e1bbcfe7034c6514bf14a1740323fe770e10", "url": "https://github.com/apache/beam/commit/efb1e1bbcfe7034c6514bf14a1740323fe770e10", "message": "Handle split when truncate observes windows.", "committedDate": "2020-08-24T18:04:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjEyNzU2MQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r476127561", "bodyText": "Explanation on why in python test it's 64 but here is 63:\nJava uses BigDecimal and result here is 63.9xxxxx. When Java performs BigDecimal.longValue(), it wil round down to 63.\n`", "author": "boyuanzz", "createdAt": "2020-08-25T03:46:45Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -133,3333 +138,4296 @@\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range) {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n+\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements for the first window.\n-                  assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(7.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMap,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMap,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder().setElement(primaryBytes.toByteString()).build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder().setElement(residualBytes.toByteString()).build())\n-                .build()));\n-  }\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n-    }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+              valueInGlobalWindow(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertNull(((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window1,\n+                  secondValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                  secondValue.getTimestamp(),\n+                  window2,\n+                  secondValue.getPane())));\n+      mainOutputValues.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  @Test\n-  public void testProcessElementForWindowedTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideI", "originalCommit": "efb1e1bbcfe7034c6514bf14a1740323fe770e10", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 6c8b897174..19425a5f4d 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -1480,7 +1480,7 @@ public class FnApiDoFnRunnerTest implements Serializable {\n \n       @GetInitialWatermarkEstimatorState\n       public Instant getInitialWatermarkEstimatorState() {\n-        return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n       }\n \n       @NewWatermarkEstimator\n"}}, {"oid": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "url": "https://github.com/apache/beam/commit/1753e9ec69ab3b623b42741ab404f799e8c3a338", "message": "Handle split when truncate observes windows.", "committedDate": "2020-08-25T18:24:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxNzQwMQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477017401", "bodyText": "Please add a comment stating the lifetime of currentWindows", "author": "lukecwik", "createdAt": "2020-08-26T03:52:34Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -247,8 +247,7 @@\n   /** Only valid during {@code processElement...} methods, null otherwise. */\n   private WindowedValue<InputT> currentElement;\n \n-  /** Only valid during {@link #processElementForSizedElementAndRestriction}. */\n-  private ListIterator<BoundedWindow> currentWindowIterator;\n+  private List<BoundedWindow> currentWindows;", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -247,6 +248,11 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n   /** Only valid during {@code processElement...} methods, null otherwise. */\n   private WindowedValue<InputT> currentElement;\n \n+  /**\n+   * Only valud during {@link\n+   * #processElementForWindowObservingSizedElementAndRestriction(WindowedValue)} and {@link\n+   * #processElementForWindowObservingTruncateRestriction(WindowedValue)}.\n+   */\n   private List<BoundedWindow> currentWindows;\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDk0MA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477020940", "bodyText": "We should call this something else since trySplitForTruncate and trySplitForProcess should effectively be the same.\nDitto for trySplitForWindowObservingTruncate and trySplitForWindowObservingProcess.", "author": "lukecwik", "createdAt": "2020-08-26T04:06:30Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1080,136 +1121,484 @@ private static Progress scaleProgress(\n     return Progress.from(completed, remaining);\n   }\n \n+  private WindowedSplitResult calculateRestrictionSize(\n+      WindowedSplitResult splitResult, String errorContext) {\n+    double fullSize =\n+        splitResult.getResidualInUnprocessedWindowsRoot() == null\n+                && splitResult.getPrimaryInFullyProcessedWindowsRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult.getPrimarySplitRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return ((KV<?, KV<?, ?>>) splitResult.getPrimarySplitRoot().getValue())\n+                        .getValue()\n+                        .getKey();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult.getResidualSplitRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return ((KV<?, KV<?, ?>>) splitResult.getResidualSplitRoot().getValue())\n+                        .getValue()\n+                        .getKey();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    return WindowedSplitResult.forRoots(\n+        splitResult.getPrimaryInFullyProcessedWindowsRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getPrimaryInFullyProcessedWindowsRoot().getValue(), fullSize),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getTimestamp(),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getWindows(),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getPane()),\n+        splitResult.getPrimarySplitRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getPrimarySplitRoot().getValue(), primarySize),\n+                splitResult.getPrimarySplitRoot().getTimestamp(),\n+                splitResult.getPrimarySplitRoot().getWindows(),\n+                splitResult.getPrimarySplitRoot().getPane()),\n+        splitResult.getResidualSplitRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getResidualSplitRoot().getValue(), residualSize),\n+                splitResult.getResidualSplitRoot().getTimestamp(),\n+                splitResult.getResidualSplitRoot().getWindows(),\n+                splitResult.getResidualSplitRoot().getPane()),\n+        splitResult.getResidualInUnprocessedWindowsRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getResidualInUnprocessedWindowsRoot().getValue(), fullSize),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getTimestamp(),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getWindows(),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getPane()));\n+  }\n+\n+  @VisibleForTesting\n+  static <WatermarkEstimatorStateT>\n+      KV<KV<WindowedSplitResult, HandlesSplits.SplitResult>, Integer> trySplitForTruncate(", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODI4Nw==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477498287", "bodyText": "If we decided to unify trySplitForTruncate  and trySplitForProcess , then it's natural to unify trySplitForWindowObservingTruncate and trySplitForWindowObservingProcess .\nI was trying to unify trySplitForTruncate  and trySplitForProcess  and here were concerns that prevented me doing so:\n\n\nIn order to compute scaled fractionOfRemainer produce element split, trySplitForProcess needs currentRestrictionTracker, where trySplitForTruncate needs splitDelegate.  If unifying these 2, we need both RestrictionTracker and HandleSplits as part of parameter list, which is already very long. In the function body, we also need separate branches to get element progress and splits from one of currentRestrictionTracker and splitDelegate.\n\n\ntrySplitForProcess returns <WindowedSplitResult, Integer> where trySplitForTruncate returns <<WindowedSplitResult, HandlesSplits.SplitResult>, Integer>. If unifying, we need to return <WindowedSplitResult,  HandlesSplits.SplitResult, Integer>, then in the caller function body, we still need separate branches to construct primary and residual.\n\n\nI'm OK to unify them but the way we can do only works for splitting at process and truncate. I don't think it's extendable to other splitting in the future if any. Also I feel like it makes the logic harder to understand, given that it's already complicated.", "author": "boyuanzz", "createdAt": "2020-08-26T18:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwNjg3Nw==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477506877", "bodyText": "I think since we have all the tests we can merge it as is and do a follow-up exploring clean-up options.", "author": "lukecwik", "createdAt": "2020-08-26T18:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMDk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1345,8 +1336,8 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(splitDelegate.getPtranformId())\n-              .setInputId(splitDelegate.getMainInputId())\n+              .setTransformId(pTransformId)\n+              .setInputId(mainInputId)\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMjI4OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477022288", "bodyText": "putAllOutputWatermarks should do nothing if the input map is empty so the if check is extraneous.", "author": "lukecwik", "createdAt": "2020-08-26T04:11:24Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1237,8 +1639,10 @@ public Object restriction() {\n               .setTransformId(pTransformId)\n               .setInputId(mainInputId)\n               .setElement(bytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n+      if (!outputWatermarkMapForUnprocessedWindows.isEmpty()) {", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1639,10 +1620,22 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n               .setTransformId(pTransformId)\n               .setInputId(mainInputId)\n               .setElement(bytesOut.toByteString());\n-      if (!outputWatermarkMapForUnprocessedWindows.isEmpty()) {\n-        residualInUnprocessedWindowsRoot.putAllOutputWatermarks(\n-            outputWatermarkMapForUnprocessedWindows);\n+      // We don't want to change the output watermarks or set the checkpoint resume time since\n+      // that applies to the current window.\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMapForUnprocessedWindows = new HashMap<>();\n+      if (!initialWatermark.equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(initialWatermark.getMillis() / 1000)\n+                .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : pTransform.getOutputsMap().keySet()) {\n+          outputWatermarkMapForUnprocessedWindows.put(outputId, outputWatermark);\n+        }\n       }\n+      residualInUnprocessedWindowsRoot.putAllOutputWatermarks(\n+          outputWatermarkMapForUnprocessedWindows);\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualInUnprocessedWindowsRoot)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMjU2MA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477022560", "bodyText": "Ditto, population the output map with an empty input map should be a no-op making the if check extraneous.", "author": "lukecwik", "createdAt": "2020-08-26T04:12:39Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1264,17 +1668,21 @@ public Object restriction() {\n             .setTransformId(pTransformId)\n             .setInputId(mainInputId)\n             .setElement(residualBytes.toByteString());\n-\n+    Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+        outputWatermarkMap = new HashMap<>();\n     if (!watermarkAndState.getKey().equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+      org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+              .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n+              .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n+              .build();\n       for (String outputId : pTransform.getOutputsMap().keySet()) {\n-        residualApplication.putOutputWatermarks(\n-            outputId,\n-            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                .setSeconds(watermarkAndState.getKey().getMillis() / 1000)\n-                .setNanos((int) (watermarkAndState.getKey().getMillis() % 1000) * 1000000)\n-                .build());\n+        outputWatermarkMap.put(outputId, outputWatermark);\n       }\n     }\n+    if (!outputWatermarkMap.isEmpty()) {\n+      residualApplication.putAllOutputWatermarks(outputWatermarkMap);", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1680,9 +1673,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n         outputWatermarkMap.put(outputId, outputWatermark);\n       }\n     }\n-    if (!outputWatermarkMap.isEmpty()) {\n-      residualApplication.putAllOutputWatermarks(outputWatermarkMap);\n-    }\n+    residualApplication.putAllOutputWatermarks(outputWatermarkMap);\n     residualRoots.add(\n         DelayedBundleApplication.newBuilder()\n             .setApplication(residualApplication)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzEwMQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477023101", "bodyText": "I was under the impression that we would be able to pass this information forward locally through the method without needing to expose it within HandleSplits.", "author": "lukecwik", "createdAt": "2020-08-26T04:14:46Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/HandlesSplits.java", "diffHunk": "@@ -35,6 +36,12 @@\n   /** Returns the current progress of the active element as a fraction between 0.0 and 1.0. */\n   double getProgress();\n \n+  String getPtranformId();", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MjQ0OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477462448", "bodyText": "Yes, we can pass these information locally for current transform. But I also need these information from process transform when current transform is truncate.  Whether this change is needed depends on the decision on which transform id and main input id we should use for split from truncate. As I mentioned in previous comment:\nI think we should still use transform id and main input id from process sized elements. There are 3 possible cases:\n\n\nWe only have splits on window boundary\n\n\nWe only have element split on the last window\n\n\nWe have both element splits and window splits.\n\n\nIf we choose transfrom id and input id from truncate for element split, it's also wrong conceptually. I prefer process sized elements because it will simplify the implementation on the runner side. For example, the runner doesn't need to distinguish window splits or element splits. If we treat truncate and process as a whole, it also make sense to use transform id from process.", "author": "boyuanzz", "createdAt": "2020-08-26T17:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MjMyMg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477472322", "bodyText": "I believe we should be using the transform ids from the local transform. In the window observing truncate case where we have both element splits from process and window splits from truncate then:\n\nthe element splits should use the transform/input id from process\nthe whole window splits should use the transform/input id from truncate\n\nWe may need changes on Dataflow runner v2 to make sure it supports this.", "author": "lukecwik", "createdAt": "2020-08-26T17:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxODU2Mg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477618562", "bodyText": "Discussed offline. We decided that window splits are populated with truncate transform id and element splits are populated with process transform id.", "author": "boyuanzz", "createdAt": "2020-08-26T22:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/HandlesSplits.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/HandlesSplits.java\nindex 5325b90d25..54e19837e0 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/HandlesSplits.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/HandlesSplits.java\n\n@@ -36,12 +35,6 @@ public interface HandlesSplits {\n   /** Returns the current progress of the active element as a fraction between 0.0 and 1.0. */\n   double getProgress();\n \n-  String getPtranformId();\n-\n-  String getMainInputId();\n-\n-  Collection<String> getOutputIds();\n-\n   @AutoValue\n   abstract class SplitResult {\n     public static SplitResult of(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzQ3MA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477023470", "bodyText": "You might want to make use of an @AutoValue for the return type to make it clear the updated stop index is being returned.", "author": "lukecwik", "createdAt": "2020-08-26T04:16:06Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1080,136 +1121,484 @@ private static Progress scaleProgress(\n     return Progress.from(completed, remaining);\n   }\n \n+  private WindowedSplitResult calculateRestrictionSize(\n+      WindowedSplitResult splitResult, String errorContext) {\n+    double fullSize =\n+        splitResult.getResidualInUnprocessedWindowsRoot() == null\n+                && splitResult.getPrimaryInFullyProcessedWindowsRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return currentRestriction;\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double primarySize =\n+        splitResult.getPrimarySplitRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return ((KV<?, KV<?, ?>>) splitResult.getPrimarySplitRoot().getValue())\n+                        .getValue()\n+                        .getKey();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    double residualSize =\n+        splitResult.getResidualSplitRoot() == null\n+            ? 0\n+            : doFnInvoker.invokeGetSize(\n+                new DelegatingArgumentProvider<InputT, OutputT>(processContext, errorContext) {\n+                  @Override\n+                  public Object restriction() {\n+                    return ((KV<?, KV<?, ?>>) splitResult.getResidualSplitRoot().getValue())\n+                        .getValue()\n+                        .getKey();\n+                  }\n+\n+                  @Override\n+                  public RestrictionTracker<?, ?> restrictionTracker() {\n+                    return doFnInvoker.invokeNewTracker(this);\n+                  }\n+                });\n+    return WindowedSplitResult.forRoots(\n+        splitResult.getPrimaryInFullyProcessedWindowsRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getPrimaryInFullyProcessedWindowsRoot().getValue(), fullSize),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getTimestamp(),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getWindows(),\n+                splitResult.getPrimaryInFullyProcessedWindowsRoot().getPane()),\n+        splitResult.getPrimarySplitRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getPrimarySplitRoot().getValue(), primarySize),\n+                splitResult.getPrimarySplitRoot().getTimestamp(),\n+                splitResult.getPrimarySplitRoot().getWindows(),\n+                splitResult.getPrimarySplitRoot().getPane()),\n+        splitResult.getResidualSplitRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getResidualSplitRoot().getValue(), residualSize),\n+                splitResult.getResidualSplitRoot().getTimestamp(),\n+                splitResult.getResidualSplitRoot().getWindows(),\n+                splitResult.getResidualSplitRoot().getPane()),\n+        splitResult.getResidualInUnprocessedWindowsRoot() == null\n+            ? null\n+            : WindowedValue.of(\n+                KV.of(splitResult.getResidualInUnprocessedWindowsRoot().getValue(), fullSize),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getTimestamp(),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getWindows(),\n+                splitResult.getResidualInUnprocessedWindowsRoot().getPane()));\n+  }\n+\n+  @VisibleForTesting\n+  static <WatermarkEstimatorStateT>\n+      KV<KV<WindowedSplitResult, HandlesSplits.SplitResult>, Integer> trySplitForTruncate(\n+          WindowedValue currentElement,\n+          Object currentRestriction,\n+          BoundedWindow currentWindow,\n+          List<BoundedWindow> windows,\n+          WatermarkEstimatorStateT currentWatermarkEstimatorState,\n+          double fractionOfRemainder,\n+          HandlesSplits splitDelegate,\n+          int currentWindowIndex,\n+          int stopWindowIndex) {\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    int newWindowStopIndex = stopWindowIndex;\n+    // If we are not on the last window, try to compute the split which is on the current window or\n+    // on a future window.\n+    if (currentWindowIndex != stopWindowIndex - 1) {\n+      // Compute the fraction of the remainder relative to the scaled progress.\n+      double elementCompleted = splitDelegate.getProgress();\n+      Progress elementProgress = Progress.from(elementCompleted, 1 - elementCompleted);\n+      Progress scaledProgress = scaleProgress(elementProgress, currentWindowIndex, stopWindowIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+      // The fraction is out of the current window and hence we will split at the closest window\n+      // boundary.\n+      if (scaledFractionOfRemainder >= elementProgress.getWorkRemaining()) {\n+        newWindowStopIndex =\n+            (int)\n+                Math.min(\n+                    stopWindowIndex - 1,\n+                    currentWindowIndex\n+                        + Math.max(\n+                            1,\n+                            Math.round(\n+                                (elementProgress.getWorkCompleted() + scaledFractionOfRemainder)\n+                                    / (elementProgress.getWorkCompleted()\n+                                        + elementProgress.getWorkRemaining()))));\n+        windowedSplitResult =\n+            computeWindowSplitResult(\n+                currentElement,\n+                currentRestriction,\n+                currentWindow,\n+                windows,\n+                currentWatermarkEstimatorState,\n+                newWindowStopIndex,\n+                newWindowStopIndex,\n+                stopWindowIndex,\n+                null,\n+                null);\n+\n+      } else {\n+        // Compute the downstream element split with the scaled fraction.\n+        downstreamSplitResult = splitDelegate.trySplit(scaledFractionOfRemainder);\n+        newWindowStopIndex = currentWindowIndex + 1;\n+        windowedSplitResult =\n+            computeWindowSplitResult(\n+                currentElement,\n+                currentRestriction,\n+                currentWindow,\n+                windows,\n+                currentWatermarkEstimatorState,\n+                currentWindowIndex,\n+                newWindowStopIndex,\n+                stopWindowIndex,\n+                null,\n+                null);\n+      }\n+    } else {\n+      // We are on the last window then compute the downstream element split with given fraction.\n+      newWindowStopIndex = stopWindowIndex;\n+      downstreamSplitResult = splitDelegate.trySplit(fractionOfRemainder);\n+      // We cannot produce any split if the downstream is not splittable.\n+      if (downstreamSplitResult == null) {\n+        return null;\n+      }\n+      windowedSplitResult =\n+          computeWindowSplitResult(\n+              currentElement,\n+              currentRestriction,\n+              currentWindow,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              currentWindowIndex,\n+              stopWindowIndex,\n+              stopWindowIndex,\n+              null,\n+              null);\n+    }\n+    return KV.of(KV.of(windowedSplitResult, downstreamSplitResult), newWindowStopIndex);\n+  }\n+\n+  private HandlesSplits.SplitResult trySplitForWindowObservingTruncateRestriction(\n+      double fractionOfRemainder, HandlesSplits splitDelegate) {\n+    // Note that the assumption here is the fullInputCoder of the Truncate transform should be the\n+    // the same as the SDF/Process transform.\n+    Coder fullInputCoder = WindowedValue.getFullCoder(inputCoder, windowCoder);\n+    WindowedSplitResult windowedSplitResult = null;\n+    HandlesSplits.SplitResult downstreamSplitResult = null;\n+    synchronized (splitLock) {\n+      // There is nothing to split if we are between truncate processing calls.\n+      if (currentWindow == null) {\n+        return null;\n+      }\n+\n+      KV<KV<WindowedSplitResult, HandlesSplits.SplitResult>, Integer> result =\n+          trySplitForTruncate(\n+              currentElement,\n+              currentRestriction,\n+              currentWindow,\n+              currentWindows,\n+              currentWatermarkEstimatorState,\n+              fractionOfRemainder,\n+              splitDelegate,\n+              windowCurrentIndex,\n+              windowStopIndex);\n+      if (result == null) {\n+        return null;\n+      }\n+      windowStopIndex = result.getValue();\n+      windowedSplitResult =\n+          calculateRestrictionSize(\n+              result.getKey().getKey(),\n+              PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN + \"/GetSize\");\n+      downstreamSplitResult = result.getKey().getValue();\n+    }\n+\n+    List<BundleApplication> primaryRoots = new ArrayList<>();\n+    List<DelayedBundleApplication> residualRoots = new ArrayList<>();\n+\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot() != null) {\n+      ByteString.Output primaryInOtherWindowsBytes = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(\n+            windowedSplitResult.getPrimaryInFullyProcessedWindowsRoot(),\n+            primaryInOtherWindowsBytes);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      BundleApplication.Builder primaryApplicationInOtherWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(splitDelegate.getPtranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .setElement(primaryInOtherWindowsBytes.toByteString());\n+      primaryRoots.add(primaryApplicationInOtherWindows.build());\n+    }\n+    if (windowedSplitResult != null\n+        && windowedSplitResult.getResidualInUnprocessedWindowsRoot() != null) {\n+      ByteString.Output residualInUnprocessedWindowsBytesOut = ByteString.newOutput();\n+      try {\n+        fullInputCoder.encode(\n+            windowedSplitResult.getResidualInUnprocessedWindowsRoot(),\n+            residualInUnprocessedWindowsBytesOut);\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMap = new HashMap<>();\n+      if (!initialWatermark.equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(initialWatermark.getMillis() / 1000)\n+                .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : splitDelegate.getOutputIds()) {\n+          outputWatermarkMap.put(outputId, outputWatermark);\n+        }\n+      }\n+\n+      BundleApplication.Builder residualApplicationInUnprocessedWindows =\n+          BundleApplication.newBuilder()\n+              .setTransformId(splitDelegate.getPtranformId())\n+              .setInputId(splitDelegate.getMainInputId())\n+              .putAllOutputWatermarks(outputWatermarkMap)\n+              .setElement(residualInUnprocessedWindowsBytesOut.toByteString());\n+\n+      residualRoots.add(\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(residualApplicationInUnprocessedWindows)\n+              .build());\n+    }\n+\n+    if (downstreamSplitResult != null) {\n+      primaryRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getPrimaryRoots()));\n+      residualRoots.add(Iterables.getOnlyElement(downstreamSplitResult.getResidualRoots()));\n+    }\n+\n+    return HandlesSplits.SplitResult.of(primaryRoots, residualRoots);\n+  }\n+\n+  private static <WatermarkEstimatorStateT> WindowedSplitResult computeWindowSplitResult(\n+      WindowedValue currentElement,\n+      Object currentRestriction,\n+      BoundedWindow currentWindow,\n+      List<BoundedWindow> windows,\n+      WatermarkEstimatorStateT currentWatermarkEstimatorState,\n+      int toIndex,\n+      int fromIndex,\n+      int stopWindowIndex,\n+      SplitResult<?> splitResult,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState) {\n+    List<BoundedWindow> primaryFullyProcessedWindows = windows.subList(0, toIndex);\n+    List<BoundedWindow> residualUnprocessedWindows = windows.subList(fromIndex, stopWindowIndex);\n+    WindowedSplitResult windowedSplitResult;\n+\n+    windowedSplitResult =\n+        WindowedSplitResult.forRoots(\n+            primaryFullyProcessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        currentElement.getValue(),\n+                        KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                    currentElement.getTimestamp(),\n+                    primaryFullyProcessedWindows,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        currentElement.getValue(),\n+                        KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            splitResult == null\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        currentElement.getValue(),\n+                        KV.of(splitResult.getResidual(), watermarkAndState.getValue())),\n+                    currentElement.getTimestamp(),\n+                    currentWindow,\n+                    currentElement.getPane()),\n+            residualUnprocessedWindows.isEmpty()\n+                ? null\n+                : WindowedValue.of(\n+                    KV.of(\n+                        currentElement.getValue(),\n+                        KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                    currentElement.getTimestamp(),\n+                    residualUnprocessedWindows,\n+                    currentElement.getPane()));\n+    return windowedSplitResult;\n+  }\n+\n+  @VisibleForTesting\n+  static <WatermarkEstimatorStateT> KV<WindowedSplitResult, Integer> trySplitForProcess(\n+      WindowedValue currentElement,\n+      Object currentRestriction,\n+      BoundedWindow currentWindow,\n+      List<BoundedWindow> windows,\n+      WatermarkEstimatorStateT currentWatermarkEstimatorState,\n+      double fractionOfRemainder,\n+      RestrictionTracker currentTracker,\n+      KV<Instant, WatermarkEstimatorStateT> watermarkAndState,\n+      int currentWindowIndex,\n+      int stopWindowIndex) {\n+    WindowedSplitResult windowedSplitResult = null;\n+    int newWindowStopIndex = stopWindowIndex;\n+    // If we are not on the last window, try to compute the split which is on the current window or\n+    // on a future window.\n+    if (currentWindowIndex != stopWindowIndex - 1) {\n+      // Compute the fraction of the remainder relative to the scaled progress.\n+      Progress elementProgress;\n+      if (currentTracker instanceof HasProgress) {\n+        elementProgress = ((HasProgress) currentTracker).getProgress();\n+      } else {\n+        elementProgress = Progress.from(0, 1);\n+      }\n+      Progress scaledProgress = scaleProgress(elementProgress, currentWindowIndex, stopWindowIndex);\n+      double scaledFractionOfRemainder = scaledProgress.getWorkRemaining() * fractionOfRemainder;\n+\n+      // The fraction is out of the current window and hence we will split at the closest window\n+      // boundary.\n+      if (scaledFractionOfRemainder >= elementProgress.getWorkRemaining()) {\n+        newWindowStopIndex =\n+            (int)\n+                Math.min(\n+                    stopWindowIndex - 1,\n+                    currentWindowIndex\n+                        + Math.max(\n+                            1,\n+                            Math.round(\n+                                (elementProgress.getWorkCompleted() + scaledFractionOfRemainder)\n+                                    / (elementProgress.getWorkCompleted()\n+                                        + elementProgress.getWorkRemaining()))));\n+        windowedSplitResult =\n+            computeWindowSplitResult(\n+                currentElement,\n+                currentRestriction,\n+                currentWindow,\n+                windows,\n+                currentWatermarkEstimatorState,\n+                newWindowStopIndex,\n+                newWindowStopIndex,\n+                stopWindowIndex,\n+                null,\n+                watermarkAndState);\n+      } else {\n+        // Compute the element split with the scaled fraction.\n+        SplitResult<?> elementSplit =\n+            currentTracker.trySplit(scaledFractionOfRemainder / elementProgress.getWorkRemaining());\n+        newWindowStopIndex = currentWindowIndex + 1;\n+        if (elementSplit != null) {\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  currentElement,\n+                  currentRestriction,\n+                  currentWindow,\n+                  windows,\n+                  currentWatermarkEstimatorState,\n+                  currentWindowIndex,\n+                  newWindowStopIndex,\n+                  stopWindowIndex,\n+                  elementSplit,\n+                  watermarkAndState);\n+        } else {\n+          windowedSplitResult =\n+              computeWindowSplitResult(\n+                  currentElement,\n+                  currentRestriction,\n+                  currentWindow,\n+                  windows,\n+                  currentWatermarkEstimatorState,\n+                  newWindowStopIndex,\n+                  newWindowStopIndex,\n+                  stopWindowIndex,\n+                  null,\n+                  watermarkAndState);\n+        }\n+      }\n+    } else {\n+      // We are on the last window then compute the element split with given fraction.\n+      newWindowStopIndex = stopWindowIndex;\n+      SplitResult<?> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+      if (splitResult == null) {\n+        return null;\n+      }\n+      windowedSplitResult =\n+          computeWindowSplitResult(\n+              currentElement,\n+              currentRestriction,\n+              currentWindow,\n+              windows,\n+              currentWatermarkEstimatorState,\n+              currentWindowIndex,\n+              stopWindowIndex,\n+              stopWindowIndex,\n+              splitResult,\n+              watermarkAndState);\n+    }\n+    return KV.of(windowedSplitResult, newWindowStopIndex);\n+  }\n+\n   private HandlesSplits.SplitResult trySplitForElementAndRestriction(\n       double fractionOfRemainder, Duration resumeDelay) {\n     KV<Instant, WatermarkEstimatorStateT> watermarkAndState;\n-    WindowedSplitResult windowedSplitResult;\n+    WindowedSplitResult windowedSplitResult = null;\n     synchronized (splitLock) {\n       // There is nothing to split if we are between element and restriction processing calls.\n       if (currentTracker == null) {\n         return null;\n       }\n-\n       // Make sure to get the output watermark before we split to ensure that the lower bound\n       // applies to the residual.\n       watermarkAndState = currentWatermarkEstimator.getWatermarkAndState();\n-      SplitResult<RestrictionT> splitResult = currentTracker.trySplit(fractionOfRemainder);\n+      KV<WindowedSplitResult, Integer> splitResult =", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NDY3MQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477554671", "bodyText": "Let's leave it as it is and I'll update it together with clean-up?", "author": "boyuanzz", "createdAt": "2020-08-26T19:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1345,8 +1336,8 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n       }\n       BundleApplication.Builder primaryApplicationInOtherWindows =\n           BundleApplication.newBuilder()\n-              .setTransformId(splitDelegate.getPtranformId())\n-              .setInputId(splitDelegate.getMainInputId())\n+              .setTransformId(pTransformId)\n+              .setInputId(mainInputId)\n               .setElement(primaryInOtherWindowsBytes.toByteString());\n       primaryRoots.add(primaryApplicationInOtherWindows.build());\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNDQ3OA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477024478", "bodyText": "We should leave the comment since it still makes sense. We could update it to just state that we are using the initial watermark for the output watermarks.", "author": "lukecwik", "createdAt": "2020-08-26T04:20:12Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1237,8 +1639,10 @@ public Object restriction() {\n               .setTransformId(pTransformId)\n               .setInputId(mainInputId)\n               .setElement(bytesOut.toByteString());\n-      // We don't want to change the output watermarks or set the checkpoint resume time since\n-      // that applies to the current window.\n+      if (!outputWatermarkMapForUnprocessedWindows.isEmpty()) {", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex db939e5237..8c7b677e06 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -1639,10 +1620,22 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n               .setTransformId(pTransformId)\n               .setInputId(mainInputId)\n               .setElement(bytesOut.toByteString());\n-      if (!outputWatermarkMapForUnprocessedWindows.isEmpty()) {\n-        residualInUnprocessedWindowsRoot.putAllOutputWatermarks(\n-            outputWatermarkMapForUnprocessedWindows);\n+      // We don't want to change the output watermarks or set the checkpoint resume time since\n+      // that applies to the current window.\n+      Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+          outputWatermarkMapForUnprocessedWindows = new HashMap<>();\n+      if (!initialWatermark.equals(GlobalWindow.TIMESTAMP_MIN_VALUE)) {\n+        org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp outputWatermark =\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                .setSeconds(initialWatermark.getMillis() / 1000)\n+                .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                .build();\n+        for (String outputId : pTransform.getOutputsMap().keySet()) {\n+          outputWatermarkMapForUnprocessedWindows.put(outputId, outputWatermark);\n+        }\n       }\n+      residualInUnprocessedWindowsRoot.putAllOutputWatermarks(\n+          outputWatermarkMapForUnprocessedWindows);\n       residualRoots.add(\n           DelayedBundleApplication.newBuilder()\n               .setApplication(residualInUnprocessedWindowsRoot)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNTIxOQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477025219", "bodyText": "This is very hard to review, could we separate out the creation of the single enclosed class containing the existing tests as a separate commit.", "author": "lukecwik", "createdAt": "2020-08-26T04:22:59Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -133,3333 +138,4337 @@\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MDk4Mg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477460982", "bodyText": "Sorry for the inconvenience. Do you prefer a separate commit or a followup PR?", "author": "boyuanzz", "createdAt": "2020-08-26T17:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MDYzOQ==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477470639", "bodyText": "I did the review, we can disregard this comment.", "author": "lukecwik", "createdAt": "2020-08-26T17:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyNTIxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 19425a5f4d..b388587410 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -138,7 +137,6 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyODUzMg==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477028532", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                  // Java uses BigDecimal so 0.2 * 170 = 63.9...\n          \n          \n            \n                  // BigDecimal.longValue() will round down to 63 instead of the expected 64", "author": "lukecwik", "createdAt": "2020-08-26T04:35:45Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -133,3333 +138,4337 @@\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range) {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n+\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements for the first window.\n-                  assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(7.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        Instant initialWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMapForUnprocessedWindows =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(initialWatermark.getMillis() / 1000)\n+                        .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMapForUnprocessedWindows,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\n+                        \"2\",\n+                        KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant initialWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMapInUnprocessedResiduals =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(initialWatermark.getMillis() / 1000)\n+                        .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMapInUnprocessedResiduals,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder().setElement(primaryBytes.toByteString()).build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder().setElement(residualBytes.toByteString()).build())\n-                .build()));\n-  }\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n-    }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      \"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)))),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      \"2\",\n+                      KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertNull(((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      \"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 19425a5f4d..b388587410 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -138,7 +137,6 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyOTczNA==", "url": "https://github.com/apache/beam/pull/12419#discussion_r477029734", "bodyText": "If we consolidate the split implementations between truncate and process we won't need these tests that follow here.", "author": "lukecwik", "createdAt": "2020-08-26T04:40:29Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -133,3333 +138,4337 @@\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n import org.joda.time.Instant;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /** Tests for {@link FnApiDoFnRunner}. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class FnApiDoFnRunnerTest implements Serializable {\n \n-  @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n+  @RunWith(JUnit4.class)\n+  public static class ExecutionTest implements Serializable {\n+    @Rule public transient ResetDateTimeProvider dateTimeProvider = new ResetDateTimeProvider();\n \n-  private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(FnApiDoFnRunnerTest.class);\n \n-  public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n+    public static final String TEST_TRANSFORM_ID = \"pTransformId\";\n \n-  private static class ConcatCombineFn extends CombineFn<String, String, String> {\n-    @Override\n-    public String createAccumulator() {\n-      return \"\";\n-    }\n+    private static class ConcatCombineFn extends CombineFn<String, String, String> {\n+      @Override\n+      public String createAccumulator() {\n+        return \"\";\n+      }\n \n-    @Override\n-    public String addInput(String accumulator, String input) {\n-      return accumulator.concat(input);\n-    }\n+      @Override\n+      public String addInput(String accumulator, String input) {\n+        return accumulator.concat(input);\n+      }\n \n-    @Override\n-    public String mergeAccumulators(Iterable<String> accumulators) {\n-      StringBuilder builder = new StringBuilder();\n-      for (String value : accumulators) {\n-        builder.append(value);\n+      @Override\n+      public String mergeAccumulators(Iterable<String> accumulators) {\n+        StringBuilder builder = new StringBuilder();\n+        for (String value : accumulators) {\n+          builder.append(value);\n+        }\n+        return builder.toString();\n       }\n-      return builder.toString();\n-    }\n \n-    @Override\n-    public String extractOutput(String accumulator) {\n-      return accumulator;\n+      @Override\n+      public String extractOutput(String accumulator) {\n+        return accumulator;\n+      }\n     }\n-  }\n \n-  private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n-    private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n-    private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n+    private static class TestStatefulDoFn extends DoFn<KV<String, String>, String> {\n+      private static final TupleTag<String> mainOutput = new TupleTag<>(\"mainOutput\");\n+      private static final TupleTag<String> additionalOutput = new TupleTag<>(\"output\");\n \n-    @StateId(\"value\")\n-    private final StateSpec<ValueState<String>> valueStateSpec =\n-        StateSpecs.value(StringUtf8Coder.of());\n+      @StateId(\"value\")\n+      private final StateSpec<ValueState<String>> valueStateSpec =\n+          StateSpecs.value(StringUtf8Coder.of());\n \n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n \n-    @StateId(\"combine\")\n-    private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n-        StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n+      @StateId(\"combine\")\n+      private final StateSpec<CombiningState<String, String, String>> combiningStateSpec =\n+          StateSpecs.combining(StringUtf8Coder.of(), new ConcatCombineFn());\n \n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"value\") ValueState<String> valueState,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n-      context.output(\"value:\" + valueState.read());\n-      valueState.write(context.element().getValue());\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"value\") ValueState<String> valueState,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @StateId(\"combine\") CombiningState<String, String, String> combiningState) {\n+        context.output(\"value:\" + valueState.read());\n+        valueState.write(context.element().getValue());\n \n-      context.output(\"bag:\" + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n+        context.output(\"bag:\" + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n \n-      context.output(\"combine:\" + combiningState.read());\n-      combiningState.add(context.element().getValue());\n+        context.output(\"combine:\" + combiningState.read());\n+        combiningState.add(context.element().getValue());\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testUsingUserState() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    FakeBeamFnStateClient fakeClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n-    mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"value:X0\"),\n-            valueInGlobalWindow(\"bag:[X0]\"),\n-            valueInGlobalWindow(\"combine:X0\"),\n-            valueInGlobalWindow(\"value:null\"),\n-            valueInGlobalWindow(\"bag:[]\"),\n-            valueInGlobalWindow(\"combine:\"),\n-            valueInGlobalWindow(\"value:X1\"),\n-            valueInGlobalWindow(\"bag:[X0, X1]\"),\n-            valueInGlobalWindow(\"combine:X0X1\"),\n-            valueInGlobalWindow(\"value:Y1\"),\n-            valueInGlobalWindow(\"bag:[Y1]\"),\n-            valueInGlobalWindow(\"combine:Y1\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n-            .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n-            .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n-            .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n-            .build(),\n-        fakeClient.getData());\n-  }\n+    @Test\n+    public void testUsingUserState() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestStatefulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      FakeBeamFnStateClient fakeClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"value\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"combine\", \"X\"), encode(\"X0\")));\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n-  private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n-    return StateKey.newBuilder()\n-        .setBagUserState(\n-            StateKey.BagUserState.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setUserStateId(userStateId)\n-                .setKey(encode(key))\n-                .setWindow(\n-                    ByteString.copyFrom(\n-                        CoderUtils.encodeToByteArray(\n-                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  private static class TestSideInputDoFn extends DoFn<String, String> {\n-    private final PCollectionView<String> defaultSingletonSideInput;\n-    private final PCollectionView<String> singletonSideInput;\n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n-    private final TupleTag<String> additionalOutput;\n-\n-    private TestSideInputDoFn(\n-        PCollectionView<String> defaultSingletonSideInput,\n-        PCollectionView<String> singletonSideInput,\n-        PCollectionView<Iterable<String>> iterableSideInput,\n-        TupleTag<String> additionalOutput) {\n-      this.defaultSingletonSideInput = defaultSingletonSideInput;\n-      this.singletonSideInput = singletonSideInput;\n-      this.iterableSideInput = iterableSideInput;\n-      this.additionalOutput = additionalOutput;\n-    }\n-\n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n-      context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n-      for (String sideInputValue : context.sideInput(iterableSideInput)) {\n-        context.output(context.element() + \":\" + sideInputValue);\n-      }\n-      context.output(additionalOutput, context.element() + \":additional\");\n-    }\n-  }\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y1\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"X\", \"X2\")));\n+      mainInput.accept(valueInGlobalWindow(KV.of(\"Y\", \"Y2\")));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"value:X0\"),\n+              valueInGlobalWindow(\"bag:[X0]\"),\n+              valueInGlobalWindow(\"combine:X0\"),\n+              valueInGlobalWindow(\"value:null\"),\n+              valueInGlobalWindow(\"bag:[]\"),\n+              valueInGlobalWindow(\"combine:\"),\n+              valueInGlobalWindow(\"value:X1\"),\n+              valueInGlobalWindow(\"bag:[X0, X1]\"),\n+              valueInGlobalWindow(\"combine:X0X1\"),\n+              valueInGlobalWindow(\"value:Y1\"),\n+              valueInGlobalWindow(\"bag:[Y1]\"),\n+              valueInGlobalWindow(\"combine:Y1\")));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> defaultSingletonSideInputView =\n-        valuePCollection.apply(\n-            View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(\n-                    new TestSideInputDoFn(\n-                        defaultSingletonSideInputView,\n-                        singletonSideInputView,\n-                        iterableSideInputView,\n-                        additionalOutput))\n-                .withSideInputs(\n-                    defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n-            encode(\"singletonValue\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n-            encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"X\"));\n-    mainInput.accept(valueInGlobalWindow(\"Y\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\"X:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"X:singletonValue\"),\n-            valueInGlobalWindow(\"X:iterableValue1\"),\n-            valueInGlobalWindow(\"X:iterableValue2\"),\n-            valueInGlobalWindow(\"X:iterableValue3\"),\n-            valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n-            valueInGlobalWindow(\"Y:singletonValue\"),\n-            valueInGlobalWindow(\"Y:iterableValue1\"),\n-            valueInGlobalWindow(\"Y:iterableValue2\"),\n-            valueInGlobalWindow(\"Y:iterableValue3\")));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n-    private final TupleTag<String> additionalOutput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n-      this.additionalOutput = additionalOutput;\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"value\", \"X\"), encode(\"X2\"))\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\"))\n+              .put(bagUserStateKey(\"combine\", \"X\"), encode(\"X0X1X2\"))\n+              .put(bagUserStateKey(\"value\", \"Y\"), encode(\"Y2\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\"))\n+              .put(bagUserStateKey(\"combine\", \"Y\"), encode(\"Y1Y2\"))\n+              .build(),\n+          fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      context.output(context.element() + \":main\");\n-      context.output(additionalOutput, context.element() + \":additional\");\n+    /** Produces a bag user {@link StateKey} for the test PTransform id in the global window. */\n+    private StateKey bagUserStateKey(String userStateId, String key) throws IOException {\n+      return StateKey.newBuilder()\n+          .setBagUserState(\n+              StateKey.BagUserState.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setUserStateId(userStateId)\n+                  .setKey(encode(key))\n+                  .setWindow(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE))))\n+          .build();\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\"))\n-            .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n-    TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n-    TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n-    PCollectionTuple outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n-                .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n-    String additionalPCollectionId =\n-        sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    consumers.register(\n-        additionalPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(\n-        consumers.keySet(),\n-        containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInWindows(\n-            \"X\",\n-            new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n-    mainInput.accept(\n-        valueInWindows(\n-            \"Y\",\n-            new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-            new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:main\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:main\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    assertThat(\n-        additionalOutputValues,\n-        contains(\n-            valueInWindows(\n-                \"X:additional\",\n-                new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n-            valueInWindows(\n-                \"Y:additional\",\n-                new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n-                new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n-    mainOutputValues.clear();\n+    private static class TestSideInputDoFn extends DoFn<String, String> {\n+      private final PCollectionView<String> defaultSingletonSideInput;\n+      private final PCollectionView<String> singletonSideInput;\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestSideInputDoFn(\n+          PCollectionView<String> defaultSingletonSideInput,\n+          PCollectionView<String> singletonSideInput,\n+          PCollectionView<Iterable<String>> iterableSideInput,\n+          TupleTag<String> additionalOutput) {\n+        this.defaultSingletonSideInput = defaultSingletonSideInput;\n+        this.singletonSideInput = singletonSideInput;\n+        this.iterableSideInput = iterableSideInput;\n+        this.additionalOutput = additionalOutput;\n+      }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":\" + context.sideInput(defaultSingletonSideInput));\n+        context.output(context.element() + \":\" + context.sideInput(singletonSideInput));\n+        for (String sideInputValue : context.sideInput(iterableSideInput)) {\n+          context.output(context.element() + \":\" + sideInputValue);\n+        }\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n+    }\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+    @Test\n+    public void testProcessElementWithSideInputsAndOutputs() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> defaultSingletonSideInputView =\n+          valuePCollection.apply(\n+              View.<String>asSingleton().withDefaultValue(\"defaultSingletonValue\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(\n+                      new TestSideInputDoFn(\n+                          defaultSingletonSideInputView,\n+                          singletonSideInputView,\n+                          iterableSideInputView,\n+                          additionalOutput))\n+                  .withSideInputs(\n+                      defaultSingletonSideInputView, singletonSideInputView, iterableSideInputView)\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(singletonSideInputView.getTagInternal().getId()),\n+              encode(\"singletonValue\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId()),\n+              encode(\"iterableValue1\", \"iterableValue2\", \"iterableValue3\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"X\"));\n+      mainInput.accept(valueInGlobalWindow(\"Y\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\"X:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"X:singletonValue\"),\n+              valueInGlobalWindow(\"X:iterableValue1\"),\n+              valueInGlobalWindow(\"X:iterableValue2\"),\n+              valueInGlobalWindow(\"X:iterableValue3\"),\n+              valueInGlobalWindow(\"Y:defaultSingletonValue\"),\n+              valueInGlobalWindow(\"Y:singletonValue\"),\n+              valueInGlobalWindow(\"Y:iterableValue1\"),\n+              valueInGlobalWindow(\"Y:iterableValue2\"),\n+              valueInGlobalWindow(\"Y:iterableValue3\")));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(valueInGlobalWindow(\"X:additional\"), valueInGlobalWindow(\"Y:additional\")));\n+      mainOutputValues.clear();\n \n-  private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n-      extends DoFn<String, Iterable<String>> {\n-    public static final String USER_COUNTER_NAME = \"userCountedElems\";\n-    private final Counter countedElements =\n-        Metrics.counter(TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private final PCollectionView<Iterable<String>> iterableSideInput;\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-    private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n-        PCollectionView<Iterable<String>> iterableSideInput) {\n-      this.iterableSideInput = iterableSideInput;\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n \n-    @ProcessElement\n-    public void processElement(ProcessContext context) {\n-      countedElements.inc();\n-      context.output(context.sideInput(iterableSideInput));\n+    private static class TestNonWindowObservingDoFn extends DoFn<String, String> {\n+      private final TupleTag<String> additionalOutput;\n+\n+      private TestNonWindowObservingDoFn(TupleTag<String> additionalOutput) {\n+        this.additionalOutput = additionalOutput;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        context.output(context.element() + \":main\");\n+        context.output(additionalOutput, context.element() + \":additional\");\n+      }\n     }\n-  }\n \n-  @Test\n-  public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    assertThat(mainOutputValues, hasSize(2));\n-    assertThat(\n-        mainOutputValues.get(0).getValue(),\n-        contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n-    assertThat(\n-        mainOutputValues.get(1).getValue(),\n-        contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+    @Test\n+    public void testProcessElementWithNonWindowObservingOptimization() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\"))\n+              .apply(Window.into(FixedWindows.of(Duration.standardMinutes(1))));\n+      TupleTag<String> mainOutput = new TupleTag<String>(\"main\") {};\n+      TupleTag<String> additionalOutput = new TupleTag<String>(\"additional\") {};\n+      PCollectionTuple outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestNonWindowObservingDoFn(additionalOutput))\n+                  .withOutputTags(mainOutput, TupleTagList.of(additionalOutput)));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(mainOutput));\n+      String additionalPCollectionId =\n+          sdkComponents.registerPCollection(outputPCollection.get(additionalOutput));\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      List<WindowedValue<String>> additionalOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      consumers.register(\n+          additionalPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) additionalOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /** @return a test MetricUpdate for expected metrics to compare against */\n-  public MetricUpdate create(String stepName, MetricName name, long value) {\n-    return MetricUpdate.create(MetricKey.create(stepName, name), value);\n-  }\n+      assertThat(\n+          consumers.keySet(),\n+          containsInAnyOrder(inputPCollectionId, outputPCollectionId, additionalPCollectionId));\n \n-  @Test\n-  public void testUsingMetrics() throws Exception {\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n-    Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n-    FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n-    IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n-    IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n-    ByteString encodedWindowA =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n-    ByteString encodedWindowB =\n-        ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection =\n-        p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n-    PCollectionView<Iterable<String>> iterableSideInputView =\n-        valuePCollection.apply(View.asIterable());\n-    PCollection<Iterable<String>> outputPCollection =\n-        valuePCollection.apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n-                .withSideInputs(iterableSideInputView));\n-\n-    SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0));\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n-            encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n-            iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n-            encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n-\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInWindows(\"X\", windowA));\n-    mainInput.accept(valueInWindows(\"Y\", windowB));\n-    mainOutputValues.clear();\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n-\n-    List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n-    SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n-    builder.setLabel(\n-        MonitoringInfoConstants.Labels.PCOLLECTION,\n-        \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    builder = new SimpleMonitoringInfoBuilder();\n-    builder\n-        .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAMESPACE,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n-        .setLabel(\n-            MonitoringInfoConstants.Labels.NAME,\n-            TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n-    builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-    builder.setInt64SumValue(2);\n-    expected.add(builder.build());\n-\n-    closeable.close();\n-    List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n-    for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n-      result.add(mi);\n-    }\n-    assertThat(result, containsInAnyOrder(expected.toArray()));\n-  }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(\n+          valueInWindows(\n+              \"X\",\n+              new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))));\n+      mainInput.accept(\n+          valueInWindows(\n+              \"Y\",\n+              new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+              new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1))));\n+      // Ensure that each output element is in all the windows and not one per window.\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:main\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:main\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      assertThat(\n+          additionalOutputValues,\n+          contains(\n+              valueInWindows(\n+                  \"X:additional\",\n+                  new IntervalWindow(new Instant(0L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(10L), Duration.standardMinutes(1))),\n+              valueInWindows(\n+                  \"Y:additional\",\n+                  new IntervalWindow(new Instant(1000L), Duration.standardMinutes(1)),\n+                  new IntervalWindow(new Instant(1010L), Duration.standardMinutes(1)))));\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testTimers() throws Exception {\n-    dateTimeProvider.setDateTimeFixed(10000L);\n-\n-    Pipeline p = Pipeline.create();\n-    PCollection<KV<String, String>> valuePCollection =\n-        p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n-    PCollection<String> outputPCollection =\n-        valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n-\n-    SdkComponents sdkComponents = SdkComponents.create();\n-    sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n-    RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n-    String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n-    String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n-\n-    RunnerApi.PTransform pTransform =\n-        pProto\n-            .getComponents()\n-            .getTransformsOrThrow(\n-                pProto.getComponents().getTransformsOrThrow(TEST_TRANSFORM_ID).getSubtransforms(0))\n-            .toBuilder()\n-            .build();\n-\n-    FakeBeamFnStateClient fakeStateClient =\n-        new FakeBeamFnStateClient(\n-            ImmutableMap.of(\n-                bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n-                bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n-                bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n-    FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeStateClient,\n-            fakeTimerClient,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n-    LogicalEndpoint processingTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n-    LogicalEndpoint eventFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n-    LogicalEndpoint processingFamilyTimer =\n-        LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n-    // Ensure that bag user state that is initially empty or populated works.\n-    // Ensure that the key order does not matter when we traverse over KV pairs.\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n-    mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n-    fakeTimerClient.sendTimer(\n-        eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n-    fakeTimerClient.sendTimer(\n-        processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n-    fakeTimerClient.sendTimer(\n-        eventFamilyTimer,\n-        dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n-    fakeTimerClient.sendTimer(\n-        processingFamilyTimer,\n-        dynamicTimerInGlobalWindow(\n-            \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n-            timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n-            timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n-            timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n-            timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n-            timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n-            timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n-            timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n-            timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n-            timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n-            timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n-            timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingTimer),\n-        contains(\n-            timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n-            timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n-            timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n-            timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n-            timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n-            timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n-            timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n-            timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n-            timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n-            timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(eventFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n-            dynamicTimerInGlobalWindow(\"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n-            dynamicTimerInGlobalWindow(\"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n-            dynamicTimerInGlobalWindow(\"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n-            dynamicTimerInGlobalWindow(\"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n-            dynamicTimerInGlobalWindow(\"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n-    assertThat(\n-        fakeTimerClient.getTimers(processingFamilyTimer),\n-        contains(\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n-            dynamicTimerInGlobalWindow(\n-                \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n-            dynamicTimerInGlobalWindow(\n-                \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n-            dynamicTimerInGlobalWindow(\n-                \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n-    mainOutputValues.clear();\n-\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-    fakeTimerClient.closeInbound(eventTimer);\n-    fakeTimerClient.closeInbound(processingTimer);\n-    fakeTimerClient.closeInbound(eventFamilyTimer);\n-    fakeTimerClient.closeInbound(processingFamilyTimer);\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n-    assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    assertEquals(\n-        ImmutableMap.<StateKey, ByteString>builder()\n-            .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n-            .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n-            .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n-            .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n-            .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n-            .build(),\n-        fakeStateClient.getData());\n-  }\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n-      K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n-    return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+    }\n \n-  private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n-      K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n-    return org.apache.beam.runners.core.construction.Timer.of(\n-        userKey,\n-        dynamicTimerTag,\n-        Collections.singletonList(GlobalWindow.INSTANCE),\n-        fireTimestamp,\n-        holdTimestamp,\n-        PaneInfo.NO_FIRING);\n-  }\n+    private static class TestSideInputIsAccessibleForDownstreamCallersDoFn\n+        extends DoFn<String, Iterable<String>> {\n+      public static final String USER_COUNTER_NAME = \"userCountedElems\";\n+      private final Counter countedElements =\n+          Metrics.counter(\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class, USER_COUNTER_NAME);\n \n-  private <T> WindowedValue<T> valueInWindows(\n-      T value, BoundedWindow window, BoundedWindow... windows) {\n-    return WindowedValue.of(\n-        value,\n-        window.maxTimestamp(),\n-        ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n-        PaneInfo.NO_FIRING);\n-  }\n+      private final PCollectionView<Iterable<String>> iterableSideInput;\n+\n+      private TestSideInputIsAccessibleForDownstreamCallersDoFn(\n+          PCollectionView<Iterable<String>> iterableSideInput) {\n+        this.iterableSideInput = iterableSideInput;\n+      }\n \n-  private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n-    @StateId(\"bag\")\n-    private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n-\n-    @TimerId(\"event\")\n-    private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n-\n-    @TimerId(\"processing\")\n-    private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n-\n-    @TimerFamily(\"event-family\")\n-    private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n-\n-    @TimerFamily(\"processing-family\")\n-    private final TimerSpec processingTimerFamilySpec =\n-        TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n-\n-    @ProcessElement\n-    public void processElement(\n-        ProcessContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n-      bagState.add(context.element().getValue());\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n-      processingTimeTimer.offset(Duration.millis(2L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(3L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n-    }\n-\n-    @OnTimer(\"event\")\n-    public void eventTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event\");\n-      eventTimeTimer\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(11L));\n-      processingTimeTimer.offset(Duration.millis(12L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.fireTimestamp().plus(13L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n-    }\n-\n-    @OnTimer(\"processing\")\n-    public void processingTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n-      processingTimeTimer.offset(Duration.millis(22L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(23L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"event-family\")\n-    public void eventFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"event-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"event-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n-      processingTimeTimer.offset(Duration.millis(32L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(33L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n-    }\n-\n-    @OnTimerFamily(\"processing-family\")\n-    public void processingFamilyOnTimer(\n-        OnTimerContext context,\n-        @StateId(\"bag\") BagState<String> bagState,\n-        @TimerId(\"event\") Timer eventTimeTimer,\n-        @TimerId(\"processing\") Timer processingTimeTimer,\n-        @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n-        @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n-      context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n-      bagState.add(\"processing-family\");\n-      eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n-      processingTimeTimer.offset(Duration.millis(42L));\n-      processingTimeTimer.setRelative();\n-      eventTimerFamily\n-          .get(\"event-timer1\")\n-          .withOutputTimestamp(context.timestamp())\n-          .set(context.timestamp().plus(43L));\n-      processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        countedElements.inc();\n+        context.output(context.sideInput(iterableSideInput));\n+      }\n     }\n-  }\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n-    return iterableSideInputKey(\n-        sideInputId,\n-        ByteString.copyFrom(\n-            CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n-  }\n+    @Test\n+    public void testSideInputIsAccessibleForDownstreamCallers() throws Exception {\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n \n-  /**\n-   * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n-   * window.\n-   */\n-  private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n-    return StateKey.newBuilder()\n-        .setIterableSideInput(\n-            StateKey.IterableSideInput.newBuilder()\n-                .setTransformId(TEST_TRANSFORM_ID)\n-                .setSideInputId(sideInputId)\n-                .setWindow(windowKey))\n-        .build();\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      assertThat(mainOutputValues, hasSize(2));\n+      assertThat(\n+          mainOutputValues.get(0).getValue(),\n+          contains(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"));\n+      assertThat(\n+          mainOutputValues.get(1).getValue(),\n+          contains(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private ByteString encode(String... values) throws IOException {\n-    ByteString.Output out = ByteString.newOutput();\n-    for (String value : values) {\n-      StringUtf8Coder.of().encode(value, out);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n     }\n-    return out.toByteString();\n-  }\n \n-  @Test\n-  public void testRegistration() {\n-    for (PTransformRunnerFactory.Registrar registrar :\n-        ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n-      if (registrar instanceof FnApiDoFnRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n-        return;\n-      }\n+    /** @return a test MetricUpdate for expected metrics to compare against */\n+    public MetricUpdate create(String stepName, MetricName name, long value) {\n+      return MetricUpdate.create(MetricKey.create(stepName, name), value);\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  /**\n-   * The trySplit testing of this splittable DoFn is done when processing the {@link\n-   * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n-   * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n-   *\n-   * <p>The expected thread flow is:\n-   *\n-   * <ul>\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n-   *   <li>process element thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n-   *   <li>splitting thread: perform try split\n-   *   <li>splitting thread: {@link\n-   *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n-   * </ul>\n-   */\n-  static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n-    private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n-        DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n-    private static final long SPLIT_ELEMENT = 3;\n-    private static final long CHECKPOINT_UPPER_BOUND = 8;\n-\n-    private KV<CountDownLatch, CountDownLatch> getLatches() {\n-      return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n-          this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n-    }\n-\n-    public void enableAndWaitForTrySplitToHappen() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getKey().countDown();\n-      if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for trySplit to occur.\");\n+    @Test\n+    public void testUsingMetrics() throws Exception {\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      MetricsContainerImpl metricsContainer = metricsContainerRegistry.getUnboundContainer();\n+      Closeable closeable = MetricsEnvironment.scopedMetricsContainer(metricsContainer);\n+      FixedWindows windowFn = FixedWindows.of(Duration.millis(1L));\n+      IntervalWindow windowA = windowFn.assignWindow(new Instant(1L));\n+      IntervalWindow windowB = windowFn.assignWindow(new Instant(2L));\n+      ByteString encodedWindowA =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowA));\n+      ByteString encodedWindowB =\n+          ByteString.copyFrom(CoderUtils.encodeToByteArray(windowFn.windowCoder(), windowB));\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection =\n+          p.apply(Create.of(\"unused\")).apply(Window.into(windowFn));\n+      PCollectionView<Iterable<String>> iterableSideInputView =\n+          valuePCollection.apply(View.asIterable());\n+      PCollection<Iterable<String>> outputPCollection =\n+          valuePCollection.apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new TestSideInputIsAccessibleForDownstreamCallersDoFn(iterableSideInputView))\n+                  .withSideInputs(iterableSideInputView));\n+\n+      SdkComponents sdkComponents = SdkComponents.create(p.getOptions());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents, true);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0));\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowA),\n+              encode(\"iterableValue1A\", \"iterableValue2A\", \"iterableValue3A\"),\n+              iterableSideInputKey(iterableSideInputView.getTagInternal().getId(), encodedWindowB),\n+              encode(\"iterableValue1B\", \"iterableValue2B\", \"iterableValue3B\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<Iterable<String>>> mainOutputValues = new ArrayList<>();\n+\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          Iterables.getOnlyElement(pTransform.getOutputsMap().values()),\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<Iterable<String>>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the bagUserStateKey order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInWindows(\"X\", windowA));\n+      mainInput.accept(valueInWindows(\"Y\", windowB));\n+      mainOutputValues.clear();\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      MetricsContainer mc = MetricsEnvironment.getCurrentContainer();\n+\n+      List<MonitoringInfo> expected = new ArrayList<MonitoringInfo>();\n+      SimpleMonitoringInfoBuilder builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION, \"Window.Into()/Window.Assign.out\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder.setUrn(MonitoringInfoConstants.Urns.ELEMENT_COUNT);\n+      builder.setLabel(\n+          MonitoringInfoConstants.Labels.PCOLLECTION,\n+          \"pTransformId/ParMultiDo(TestSideInputIsAccessibleForDownstreamCallers).output\");\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      builder = new SimpleMonitoringInfoBuilder();\n+      builder\n+          .setUrn(MonitoringInfoConstants.Urns.USER_SUM_INT64)\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAMESPACE,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.class.getName())\n+          .setLabel(\n+              MonitoringInfoConstants.Labels.NAME,\n+              TestSideInputIsAccessibleForDownstreamCallersDoFn.USER_COUNTER_NAME);\n+      builder.setLabel(MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+      builder.setInt64SumValue(2);\n+      expected.add(builder.build());\n+\n+      closeable.close();\n+      List<MonitoringInfo> result = new ArrayList<MonitoringInfo>();\n+      for (MonitoringInfo mi : metricsContainerRegistry.getMonitoringInfos()) {\n+        result.add(mi);\n       }\n+      assertThat(result, containsInAnyOrder(expected.toArray()));\n     }\n \n-    public void waitForSplitElementToBeProcessed() throws Exception {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n-        fail(\"Failed to wait for split element to be processed.\");\n-      }\n+    @Test\n+    public void testTimers() throws Exception {\n+      dateTimeProvider.setDateTimeFixed(10000L);\n+\n+      Pipeline p = Pipeline.create();\n+      PCollection<KV<String, String>> valuePCollection =\n+          p.apply(Create.of(KV.of(\"unused\", \"unused\")));\n+      PCollection<String> outputPCollection =\n+          valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new TestTimerfulDoFn()));\n+\n+      SdkComponents sdkComponents = SdkComponents.create();\n+      sdkComponents.registerEnvironment(Environment.getDefaultInstance());\n+      RunnerApi.Pipeline pProto = PipelineTranslation.toProto(p, sdkComponents);\n+      String inputPCollectionId = sdkComponents.registerPCollection(valuePCollection);\n+      String outputPCollectionId = sdkComponents.registerPCollection(outputPCollection);\n+\n+      RunnerApi.PTransform pTransform =\n+          pProto\n+              .getComponents()\n+              .getTransformsOrThrow(\n+                  pProto\n+                      .getComponents()\n+                      .getTransformsOrThrow(TEST_TRANSFORM_ID)\n+                      .getSubtransforms(0))\n+              .toBuilder()\n+              .build();\n+\n+      FakeBeamFnStateClient fakeStateClient =\n+          new FakeBeamFnStateClient(\n+              ImmutableMap.of(\n+                  bagUserStateKey(\"bag\", \"X\"), encode(\"X0\"),\n+                  bagUserStateKey(\"bag\", \"A\"), encode(\"A0\"),\n+                  bagUserStateKey(\"bag\", \"C\"), encode(\"C0\")));\n+      FakeBeamFnTimerClient fakeTimerClient = new FakeBeamFnTimerClient();\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeStateClient,\n+              fakeTimerClient,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      LogicalEndpoint eventTimer = LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-event\");\n+      LogicalEndpoint processingTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"ts-processing\");\n+      LogicalEndpoint eventFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-event-family\");\n+      LogicalEndpoint processingFamilyTimer =\n+          LogicalEndpoint.timer(\"57L\", TEST_TRANSFORM_ID, \"tfs-processing-family\");\n+      // Ensure that bag user state that is initially empty or populated works.\n+      // Ensure that the key order does not matter when we traverse over KV pairs.\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X1\"), new Instant(1000L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y1\"), new Instant(1100L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"X\", \"X2\"), new Instant(1200L)));\n+      mainInput.accept(timestampedValueInGlobalWindow(KV.of(\"Y\", \"Y2\"), new Instant(1300L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2400L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2500L)));\n+      fakeTimerClient.sendTimer(\n+          eventTimer, timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2600L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(2700L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(2800L)));\n+      fakeTimerClient.sendTimer(\n+          processingTimer, timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(2900L)));\n+      fakeTimerClient.sendTimer(\n+          eventFamilyTimer,\n+          dynamicTimerInGlobalWindow(\"B\", \"event-timer2\", new Instant(2000L), new Instant(3000L)));\n+      fakeTimerClient.sendTimer(\n+          processingFamilyTimer,\n+          dynamicTimerInGlobalWindow(\n+              \"Y\", \"processing-timer2\", new Instant(2100L), new Instant(3100L)));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              timestampedValueInGlobalWindow(\"mainX[X0]\", new Instant(1000L)),\n+              timestampedValueInGlobalWindow(\"mainY[]\", new Instant(1100L)),\n+              timestampedValueInGlobalWindow(\"mainX[X0, X1]\", new Instant(1200L)),\n+              timestampedValueInGlobalWindow(\"mainY[Y1]\", new Instant(1300L)),\n+              timestampedValueInGlobalWindow(\"event[A0]\", new Instant(1400L)),\n+              timestampedValueInGlobalWindow(\"event[]\", new Instant(1500L)),\n+              timestampedValueInGlobalWindow(\"event[A0, event]\", new Instant(1600L)),\n+              timestampedValueInGlobalWindow(\"processing[X0, X1, X2]\", new Instant(1700L)),\n+              timestampedValueInGlobalWindow(\"processing[C0]\", new Instant(1800L)),\n+              timestampedValueInGlobalWindow(\"processing[event]\", new Instant(1900L)),\n+              timestampedValueInGlobalWindow(\"event-family[event, processing]\", new Instant(2000L)),\n+              timestampedValueInGlobalWindow(\"processing-family[Y1, Y2]\", new Instant(2100L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(1001L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(1101L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(1201L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(1301L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(2411L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(2511L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(2611L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(1721L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(1821L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(1921L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(2031L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(2141L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingTimer),\n+          contains(\n+              timerInGlobalWindow(\"X\", new Instant(1000L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1100L), new Instant(10002L)),\n+              timerInGlobalWindow(\"X\", new Instant(1200L), new Instant(10002L)),\n+              timerInGlobalWindow(\"Y\", new Instant(1300L), new Instant(10002L)),\n+              timerInGlobalWindow(\"A\", new Instant(1400L), new Instant(10012L)),\n+              timerInGlobalWindow(\"B\", new Instant(1500L), new Instant(10012L)),\n+              timerInGlobalWindow(\"A\", new Instant(1600L), new Instant(10012L)),\n+              timerInGlobalWindow(\"X\", new Instant(1700L), new Instant(10022L)),\n+              timerInGlobalWindow(\"C\", new Instant(1800L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(1900L), new Instant(10022L)),\n+              timerInGlobalWindow(\"B\", new Instant(2000L), new Instant(10032L)),\n+              timerInGlobalWindow(\"Y\", new Instant(2100L), new Instant(10042L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(eventFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1000L), new Instant(1003L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1100L), new Instant(1103L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1200L), new Instant(1203L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(1300L), new Instant(1303L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1400L), new Instant(2413L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1500L), new Instant(2513L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"event-timer1\", new Instant(1600L), new Instant(2613L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"event-timer1\", new Instant(1700L), new Instant(1723L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"event-timer1\", new Instant(1800L), new Instant(1823L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(1900L), new Instant(1923L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"event-timer1\", new Instant(2000L), new Instant(2033L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"event-timer1\", new Instant(2100L), new Instant(2143L))));\n+      assertThat(\n+          fakeTimerClient.getTimers(processingFamilyTimer),\n+          contains(\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1000L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1100L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1200L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(1300L), new Instant(10004L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1400L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1500L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"A\", \"processing-timer1\", new Instant(1600L), new Instant(10014L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"X\", \"processing-timer1\", new Instant(1700L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"C\", \"processing-timer1\", new Instant(1800L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(1900L), new Instant(10024L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"B\", \"processing-timer1\", new Instant(2000L), new Instant(10034L)),\n+              dynamicTimerInGlobalWindow(\n+                  \"Y\", \"processing-timer1\", new Instant(2100L), new Instant(10044L))));\n+      mainOutputValues.clear();\n+\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertFalse(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+      fakeTimerClient.closeInbound(eventTimer);\n+      fakeTimerClient.closeInbound(processingTimer);\n+      fakeTimerClient.closeInbound(eventFamilyTimer);\n+      fakeTimerClient.closeInbound(processingFamilyTimer);\n+\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(eventFamilyTimer));\n+      assertTrue(fakeTimerClient.isOutboundClosed(processingFamilyTimer));\n+\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n+\n+      assertEquals(\n+          ImmutableMap.<StateKey, ByteString>builder()\n+              .put(bagUserStateKey(\"bag\", \"X\"), encode(\"X0\", \"X1\", \"X2\", \"processing\"))\n+              .put(bagUserStateKey(\"bag\", \"Y\"), encode(\"Y1\", \"Y2\", \"processing-family\"))\n+              .put(bagUserStateKey(\"bag\", \"A\"), encode(\"A0\", \"event\", \"event\"))\n+              .put(bagUserStateKey(\"bag\", \"B\"), encode(\"event\", \"processing\", \"event-family\"))\n+              .put(bagUserStateKey(\"bag\", \"C\"), encode(\"C0\", \"processing\"))\n+              .build(),\n+          fakeStateClient.getData());\n     }\n \n-    public void releaseWaitingProcessElementThread() {\n-      KV<CountDownLatch, CountDownLatch> latches = getLatches();\n-      latches.getValue().countDown();\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> timerInGlobalWindow(\n+        K userKey, Instant holdTimestamp, Instant fireTimestamp) {\n+      return dynamicTimerInGlobalWindow(userKey, \"\", holdTimestamp, fireTimestamp);\n     }\n \n-    private final String uuid;\n+    private <K> org.apache.beam.runners.core.construction.Timer<K> dynamicTimerInGlobalWindow(\n+        K userKey, String dynamicTimerTag, Instant holdTimestamp, Instant fireTimestamp) {\n+      return org.apache.beam.runners.core.construction.Timer.of(\n+          userKey,\n+          dynamicTimerTag,\n+          Collections.singletonList(GlobalWindow.INSTANCE),\n+          fireTimestamp,\n+          holdTimestamp,\n+          PaneInfo.NO_FIRING);\n+    }\n \n-    private NonWindowObservingTestSplittableDoFn() {\n-      this.uuid = UUID.randomUUID().toString();\n+    private <T> WindowedValue<T> valueInWindows(\n+        T value, BoundedWindow window, BoundedWindow... windows) {\n+      return WindowedValue.of(\n+          value,\n+          window.maxTimestamp(),\n+          ImmutableList.<BoundedWindow>builder().add(window).add(windows).build(),\n+          PaneInfo.NO_FIRING);\n     }\n \n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n-        }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n-        }\n+    private static class TestTimerfulDoFn extends DoFn<KV<String, String>, String> {\n+      @StateId(\"bag\")\n+      private final StateSpec<BagState<String>> bagStateSpec = StateSpecs.bag(StringUtf8Coder.of());\n+\n+      @TimerId(\"event\")\n+      private final TimerSpec eventTimerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+      @TimerId(\"processing\")\n+      private final TimerSpec processingTimerSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);\n+\n+      @TimerFamily(\"event-family\")\n+      private final TimerSpec eventTimerFamilySpec = TimerSpecs.timerMap(TimeDomain.EVENT_TIME);\n+\n+      @TimerFamily(\"processing-family\")\n+      private final TimerSpec processingTimerFamilySpec =\n+          TimerSpecs.timerMap(TimeDomain.PROCESSING_TIME);\n+\n+      @ProcessElement\n+      public void processElement(\n+          ProcessContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"main\" + context.element().getKey() + Iterables.toString(bagState.read()));\n+        bagState.add(context.element().getValue());\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(1L));\n+        processingTimeTimer.offset(Duration.millis(2L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(3L));\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(4L)).setRelative();\n+      }\n+\n+      @OnTimer(\"event\")\n+      public void eventTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event\");\n+        eventTimeTimer\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(11L));\n+        processingTimeTimer.offset(Duration.millis(12L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.fireTimestamp().plus(13L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(14L)).setRelative();\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @OnTimer(\"processing\")\n+      public void processingTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(21L));\n+        processingTimeTimer.offset(Duration.millis(22L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(23L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(24L)).setRelative();\n       }\n-    }\n \n-    @GetInitialRestriction\n-    public OffsetRange restriction(@Element String element) {\n-      return new OffsetRange(0, Integer.parseInt(element));\n-    }\n+      @OnTimerFamily(\"event-family\")\n+      public void eventFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"event-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"event-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(31L));\n+        processingTimeTimer.offset(Duration.millis(32L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(33L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(34L)).setRelative();\n+      }\n \n-    @NewTracker\n-    public RestrictionTracker<OffsetRange, Long> newTracker(@Restriction OffsetRange restriction) {\n-      return new OffsetRangeTracker(restriction);\n+      @OnTimerFamily(\"processing-family\")\n+      public void processingFamilyOnTimer(\n+          OnTimerContext context,\n+          @StateId(\"bag\") BagState<String> bagState,\n+          @TimerId(\"event\") Timer eventTimeTimer,\n+          @TimerId(\"processing\") Timer processingTimeTimer,\n+          @TimerFamily(\"event-family\") TimerMap eventTimerFamily,\n+          @TimerFamily(\"processing-family\") TimerMap processingTimerFamily) {\n+        context.output(\"processing-family\" + Iterables.toString(bagState.read()));\n+        bagState.add(\"processing-family\");\n+\n+        eventTimeTimer.withOutputTimestamp(context.timestamp()).set(context.timestamp().plus(41L));\n+        processingTimeTimer.offset(Duration.millis(42L));\n+        processingTimeTimer.setRelative();\n+        eventTimerFamily\n+            .get(\"event-timer1\")\n+            .withOutputTimestamp(context.timestamp())\n+            .set(context.timestamp().plus(43L));\n+\n+        processingTimerFamily.get(\"processing-timer1\").offset(Duration.millis(44L)).setRelative();\n+      }\n     }\n \n-    @SplitRestriction\n-    public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n-      receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n-      receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the global\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId) throws IOException {\n+      return iterableSideInputKey(\n+          sideInputId,\n+          ByteString.copyFrom(\n+              CoderUtils.encodeToByteArray(GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)));\n     }\n \n-    @TruncateRestriction\n-    public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range) {\n-      return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+    /**\n+     * Produces an iterable side input {@link StateKey} for the test PTransform id in the supplied\n+     * window.\n+     */\n+    private StateKey iterableSideInputKey(String sideInputId, ByteString windowKey) {\n+      return StateKey.newBuilder()\n+          .setIterableSideInput(\n+              StateKey.IterableSideInput.newBuilder()\n+                  .setTransformId(TEST_TRANSFORM_ID)\n+                  .setSideInputId(sideInputId)\n+                  .setWindow(windowKey))\n+          .build();\n     }\n \n-    @GetInitialWatermarkEstimatorState\n-    public Instant getInitialWatermarkEstimatorState() {\n-      return GlobalWindow.TIMESTAMP_MIN_VALUE;\n+    private ByteString encode(String... values) throws IOException {\n+      ByteString.Output out = ByteString.newOutput();\n+      for (String value : values) {\n+        StringUtf8Coder.of().encode(value, out);\n+      }\n+      return out.toByteString();\n     }\n \n-    @NewWatermarkEstimator\n-    public WatermarkEstimators.Manual newWatermarkEstimator(\n-        @WatermarkEstimatorState Instant watermark) {\n-      return new WatermarkEstimators.Manual(watermark);\n+    @Test\n+    public void testRegistration() {\n+      for (PTransformRunnerFactory.Registrar registrar :\n+          ServiceLoader.load(PTransformRunnerFactory.Registrar.class)) {\n+        if (registrar instanceof FnApiDoFnRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(PTransformTranslation.PAR_DO_TRANSFORM_URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n     }\n-  }\n \n-  /**\n-   * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the side\n-   * inputs to choose the checkpoint upper bound.\n-   */\n-  static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n+    /**\n+     * The trySplit testing of this splittable DoFn is done when processing the {@link\n+     * NonWindowObservingTestSplittableDoFn#SPLIT_ELEMENT}. Always checkpoints at element {@link\n+     * NonWindowObservingTestSplittableDoFn#CHECKPOINT_UPPER_BOUND}.\n+     *\n+     * <p>The expected thread flow is:\n+     *\n+     * <ul>\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#waitForSplitElementToBeProcessed()}\n+     *   <li>process element thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#enableAndWaitForTrySplitToHappen()}\n+     *   <li>splitting thread: perform try split\n+     *   <li>splitting thread: {@link\n+     *       NonWindowObservingTestSplittableDoFn#releaseWaitingProcessElementThread()}\n+     * </ul>\n+     */\n+    static class NonWindowObservingTestSplittableDoFn extends DoFn<String, String> {\n+      private static final ConcurrentMap<String, KV<CountDownLatch, CountDownLatch>>\n+          DOFN_INSTANCE_TO_LOCK = new ConcurrentHashMap<>();\n+      private static final long SPLIT_ELEMENT = 3;\n+      private static final long CHECKPOINT_UPPER_BOUND = 8;\n+\n+      private KV<CountDownLatch, CountDownLatch> getLatches() {\n+        return DOFN_INSTANCE_TO_LOCK.computeIfAbsent(\n+            this.uuid, (uuid) -> KV.of(new CountDownLatch(1), new CountDownLatch(1)));\n+      }\n \n-    private final PCollectionView<String> singletonSideInput;\n+      public void enableAndWaitForTrySplitToHappen() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getKey().countDown();\n+        if (!latches.getValue().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for trySplit to occur.\");\n+        }\n+      }\n \n-    private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n-      this.singletonSideInput = singletonSideInput;\n-    }\n+      public void waitForSplitElementToBeProcessed() throws Exception {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        if (!latches.getKey().await(30, TimeUnit.SECONDS)) {\n+          fail(\"Failed to wait for split element to be processed.\");\n+        }\n+      }\n \n-    @Override\n-    @ProcessElement\n-    public ProcessContinuation processElement(\n-        ProcessContext context,\n-        RestrictionTracker<OffsetRange, Long> tracker,\n-        ManualWatermarkEstimator<Instant> watermarkEstimator)\n-        throws Exception {\n-      long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n-      long position = tracker.currentRestriction().getFrom();\n-      boolean claimStatus;\n-      while (true) {\n-        claimStatus = (tracker.tryClaim(position));\n-        if (!claimStatus) {\n-          break;\n-        } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n-          enableAndWaitForTrySplitToHappen();\n+      public void releaseWaitingProcessElementThread() {\n+        KV<CountDownLatch, CountDownLatch> latches = getLatches();\n+        latches.getValue().countDown();\n+      }\n+\n+      private final String uuid;\n+\n+      private NonWindowObservingTestSplittableDoFn() {\n+        this.uuid = UUID.randomUUID().toString();\n+      }\n+\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = CHECKPOINT_UPPER_BOUND;\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n         }\n-        context.outputWithTimestamp(\n-            context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n-        position += 1L;\n-        if (position == checkpointUpperBound) {\n-          break;\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n         }\n       }\n-      if (!claimStatus) {\n-        return ProcessContinuation.stop();\n-      } else {\n-        return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+\n+      @GetInitialRestriction\n+      public OffsetRange restriction(@Element String element) {\n+        return new OffsetRange(0, Integer.parseInt(element));\n       }\n-    }\n-  }\n \n-  @Test\n-  public void testProcessElementForSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  5.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with\n-      // the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(splitListener.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      splitListener.clear();\n+      @NewTracker\n+      public RestrictionTracker<OffsetRange, Long> newTracker(\n+          @Restriction OffsetRange restriction) {\n+        return new OffsetRangeTracker(restriction);\n+      }\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      @SplitRestriction\n+      public void splitRange(@Restriction OffsetRange range, OutputReceiver<OffsetRange> receiver) {\n+        receiver.output(new OffsetRange(range.getFrom(), (range.getFrom() + range.getTo()) / 2));\n+        receiver.output(new OffsetRange((range.getFrom() + range.getTo()) / 2, range.getTo()));\n+      }\n \n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n-              timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n-              timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n-              timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+\n+      @GetInitialWatermarkEstimatorState\n+      public Instant getInitialWatermarkEstimatorState() {\n+        return GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+      }\n+\n+      @NewWatermarkEstimator\n+      public WatermarkEstimators.Manual newWatermarkEstimator(\n+          @WatermarkEstimatorState Instant watermark) {\n+        return new WatermarkEstimators.Manual(watermark);\n+      }\n     }\n \n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements.\n-                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+    /**\n+     * A window observing variant of {@link NonWindowObservingTestSplittableDoFn} which uses the\n+     * side inputs to choose the checkpoint upper bound.\n+     */\n+    static class WindowObservingTestSplittableDoFn extends NonWindowObservingTestSplittableDoFn {\n \n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n+      private final PCollectionView<String> singletonSideInput;\n+      private static final long PROCESSED_WINDOW = 1;\n+      private boolean splitAtTruncate = false;\n+      private long processedWindowCount = 0;\n \n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      mainInput.accept(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                  2.0)));\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+      private WindowObservingTestSplittableDoFn(PCollectionView<String> singletonSideInput) {\n+        this.singletonSideInput = singletonSideInput;\n+      }\n \n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      private static WindowObservingTestSplittableDoFn forSplitAtTruncate(\n+          PCollectionView<String> singletonSideInput) {\n+        WindowObservingTestSplittableDoFn doFn =\n+            new WindowObservingTestSplittableDoFn(singletonSideInput);\n+        doFn.splitAtTruncate = true;\n+        return doFn;\n+      }\n \n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n-              timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n-              timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n-              timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      DelayedBundleApplication residualRoot =\n-          Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0)),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInGlobalWindow(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0)),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n+      @Override\n+      @ProcessElement\n+      public ProcessContinuation processElement(\n+          ProcessContext context,\n+          RestrictionTracker<OffsetRange, Long> tracker,\n+          ManualWatermarkEstimator<Instant> watermarkEstimator)\n+          throws Exception {\n+        long checkpointUpperBound = Long.parseLong(context.sideInput(singletonSideInput));\n+        long position = tracker.currentRestriction().getFrom();\n+        boolean claimStatus;\n+        while (true) {\n+          claimStatus = (tracker.tryClaim(position));\n+          if (!claimStatus) {\n+            break;\n+          } else if (position == NonWindowObservingTestSplittableDoFn.SPLIT_ELEMENT) {\n+            enableAndWaitForTrySplitToHappen();\n+          }\n+          context.outputWithTimestamp(\n+              context.element() + \":\" + position, GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          watermarkEstimator.setWatermark(GlobalWindow.TIMESTAMP_MIN_VALUE.plus(position));\n+          position += 1L;\n+          if (position == checkpointUpperBound) {\n+            break;\n+          }\n+        }\n+        if (!claimStatus) {\n+          return ProcessContinuation.stop();\n+        } else {\n+          return ProcessContinuation.resume().withResumeDelay(Duration.millis(54321L));\n+        }\n+      }\n+\n+      @Override\n+      @TruncateRestriction\n+      public TruncateResult<OffsetRange> truncateRestriction(@Restriction OffsetRange range)\n+          throws Exception {\n+        // Waiting for split when we are on the second window.\n+        if (splitAtTruncate && processedWindowCount == PROCESSED_WINDOW) {\n+          enableAndWaitForTrySplitToHappen();\n+        }\n+        processedWindowCount += 1;\n+        return TruncateResult.of(new OffsetRange(range.getFrom(), range.getTo() / 2));\n+      }\n+    }\n+\n+    @Test\n+    public void testProcessElementForSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n           ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n       mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n \n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n \n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    5.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with\n+        // the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(splitListener.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    3.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                    2.0)),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        splitListener.clear();\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n+            valueInGlobalWindow(\n+                KV.of(\n+                    KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n-    // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n-    addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    WindowObservingTestSplittableDoFn doFn =\n-        new WindowObservingTestSplittableDoFn(singletonSideInputView);\n-\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation\n-                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    RunnerApi.PCollection inputPCollection =\n-        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n-    RehydratedComponents rehydratedComponents =\n-        RehydratedComponents.forComponents(pProto.getComponents());\n-    Coder<WindowedValue> inputCoder =\n-        WindowedValue.getFullCoder(\n-            CoderTranslation.fromProto(\n-                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n-                rehydratedComponents,\n-                TranslationContext.DEFAULT),\n-            (Coder)\n-                CoderTranslation.fromProto(\n-                    pProto\n-                        .getComponents()\n-                        .getCodersOrThrow(\n-                            pProto\n-                                .getComponents()\n-                                .getWindowingStrategiesOrThrow(\n-                                    inputPCollection.getWindowingStrategyId())\n-                                .getWindowCoderId()),\n-                    rehydratedComponents,\n-                    TranslationContext.DEFAULT));\n-    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n-\n-    ImmutableMap<StateKey, ByteString> stateData =\n-        ImmutableMap.of(\n-            iterableSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n-            encode(\"8\"));\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n-\n-    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n-    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            progressRequestCallbacks::add,\n-            splitListener,\n-            null /* bundleFinalizer */);\n-\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    {\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> firstValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              window1,\n-              window2);\n-      mainInput.accept(firstValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n-      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n-      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n-      // watermark.\n-      //\n-      // Since we were on the first window, we expect only a single primary root and two residual\n-      // roots (the split + the unprocessed window).\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n-      assertEquals(2, splitListener.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootForUnprocessedWindows =\n-          splitListener.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-              .setSeconds(54)\n-              .setNanos(321000000)\n-              .build(),\n-          residualRoot.getRequestedTimeDelay());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRootForUnprocessedWindows.getApplication().getInputId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-\n-      assertEquals(\n-          decode(inputCoder, primaryRoot.getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRoot.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\n-                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                  2.0),\n-              firstValue.getTimestamp(),\n-              window1,\n-              firstValue.getPane()));\n-      assertEquals(\n-          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              firstValue.getTimestamp(),\n-              window2,\n-              firstValue.getPane()));\n-      splitListener.clear();\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> secondValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(secondValue);\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n-              WindowedValue.of(\n-                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-    }\n-\n-    {\n-      // Setup and launch the trySplit thread.\n-      ExecutorService executorService = Executors.newSingleThreadExecutor();\n-      Future<HandlesSplits.SplitResult> trySplitFuture =\n-          executorService.submit(\n-              () -> {\n-                try {\n-                  doFn.waitForSplitElementToBeProcessed();\n-                  // Currently processing \"3\" out of range [0, 5) elements for the first window.\n-                  assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n-\n-                  // Check that during progressing of an element we report progress\n-                  List<MonitoringInfo> mis =\n-                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n-                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n-                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n-                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedCompleted.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedCompleted.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n-                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n-                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n-                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n-                  expectedRemaining.putLabels(\n-                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n-                  expectedRemaining.setPayload(\n-                      ByteString.copyFrom(\n-                          CoderUtils.encodeToByteArray(\n-                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(7.0))));\n-                  assertThat(\n-                      mis,\n-                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n-\n-                  return ((HandlesSplits) mainInput).trySplit(0);\n-                } finally {\n-                  doFn.releaseWaitingProcessElementThread();\n-                }\n-              });\n-\n-      // Check that before processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-      WindowedValue<?> splitValue =\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n-              window1,\n-              window2);\n-      mainInput.accept(splitValue);\n-      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n-\n-      // Check that after processing an element we don't report progress\n-      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n-\n-      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.\n-      // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n-      // has yet to be invoked for the split element and that the primary represents [0, 4) with\n-      // the original watermark while the residual represents [4, 5) with the new MIN + 2 watermark.\n-      //\n-      // We expect to see none of the output for the second window.\n-      assertThat(\n-          mainOutputValues,\n-          contains(\n-              WindowedValue.of(\n-                  \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n-              WindowedValue.of(\n-                  \"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3), window1, splitValue.getPane())));\n-\n-      BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n-      assertEquals(2, trySplitResult.getResidualRoots().size());\n-      DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n-      DelayedBundleApplication residualRootInUnprocessedWindows =\n-          trySplitResult.getResidualRoots().get(0);\n-      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-      assertEquals(\n-          ParDoTranslation.getMainInputName(pTransform),\n-          residualRoot.getApplication().getInputId());\n-      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-      assertEquals(\n-          TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n-      assertEquals(\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRootInUnprocessedWindows.getRequestedTimeDelay());\n-      assertTrue(\n-          residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)), 4.0),\n-              window1),\n-          inputCoder.decode(primaryRoot.getElement().newInput()));\n-      assertEquals(\n-          valueInWindows(\n-              KV.of(\n-                  KV.of(\n-                      \"7\", KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n-                  1.0),\n-              window1),\n-          inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n-      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n-      assertEquals(\n-          ImmutableMap.of(\n-              \"output\",\n-              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                  .build()),\n-          residualRoot.getApplication().getOutputWatermarksMap());\n-      assertEquals(\n-          WindowedValue.of(\n-              KV.of(\n-                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n-              splitValue.getTimestamp(),\n-              window2,\n-              splitValue.getPane()),\n-          inputCoder.decode(\n-              residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n-\n-      // We expect 0 resume delay.\n-      assertEquals(\n-          residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n-          residualRoot.getRequestedTimeDelay());\n-      // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n-      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n-      assertTrue(splitListener.getResidualRoots().isEmpty());\n-      mainOutputValues.clear();\n-      executorService.shutdown();\n-    }\n-\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-\n-    // Assert that state data did not change\n-    assertEquals(stateData, fakeClient.getData());\n-  }\n-\n-  private static <T> T decode(Coder<T> coder, ByteString value) {\n-    try {\n-      return coder.decode(value.newInput());\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5)),\n+                timestampedValueInGlobalWindow(\"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6)),\n+                timestampedValueInGlobalWindow(\"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7)),\n+                timestampedValueInGlobalWindow(\"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void testProcessElementForPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(valueInGlobalWindow(\"5\"));\n-    mainInput.accept(valueInGlobalWindow(\"2\"));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))),\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements.\n+                    assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(2.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        mainInput.accept(\n             valueInGlobalWindow(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)))));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window1,\n-                secondValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                window2,\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n-\n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n-\n-  @Test\n-  public void testProcessElementForWindowedPairWithRestrictionWithNonWindowObservingOptimization()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n-    WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                secondValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                secondValue.getPane())));\n-    mainOutputValues.clear();\n-\n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+                KV.of(\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    2.0)));\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-  @Test\n-  public void testProcessElementForSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE))));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                timestampedValueInGlobalWindow(\"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0)),\n+                timestampedValueInGlobalWindow(\"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)),\n+                timestampedValueInGlobalWindow(\"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2)),\n+                timestampedValueInGlobalWindow(\"7:3\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3))));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        DelayedBundleApplication residualRoot =\n+            Iterables.getOnlyElement(trySplitResult.getResidualRoots());\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0)),\n+                    KV.of(\"7\", KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    4.0)),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n             valueInGlobalWindow(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  @Test\n-  public void testProcessElementForWindowedSplitAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(\n-            TEST_TRANSFORM_ID,\n-            ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-                .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n+\n+    @Test\n+    public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"beam_fn_api\");\n+      // TODO(BEAM-10097): Remove experiment once all portable runners support this view type\n+      addExperiment(p.getOptions().as(ExperimentalOptions.class), \"use_runner_v2\");\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      WindowObservingTestSplittableDoFn doFn =\n+          new WindowObservingTestSplittableDoFn(singletonSideInputView);\n+\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(\n+                                  PTransformTranslation\n+                                      .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      RunnerApi.PCollection inputPCollection =\n+          pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+      RehydratedComponents rehydratedComponents =\n+          RehydratedComponents.forComponents(pProto.getComponents());\n+      Coder<WindowedValue> inputCoder =\n+          WindowedValue.getFullCoder(\n+              CoderTranslation.fromProto(\n+                  pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                  rehydratedComponents,\n+                  TranslationContext.DEFAULT),\n+              (Coder)\n+                  CoderTranslation.fromProto(\n+                      pProto\n+                          .getComponents()\n+                          .getCodersOrThrow(\n+                              pProto\n+                                  .getComponents()\n+                                  .getWindowingStrategiesOrThrow(\n+                                      inputPCollection.getWindowingStrategyId())\n+                                  .getWindowCoderId()),\n+                      rehydratedComponents,\n+                      TranslationContext.DEFAULT));\n+      String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+      ImmutableMap<StateKey, ByteString> stateData =\n+          ImmutableMap.of(\n+              iterableSideInputKey(\n+                  singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+              encode(\"8\"));\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+      List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(\n+          outputPCollectionId,\n+          TEST_TRANSFORM_ID,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+      List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+      BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              progressRequestCallbacks::add,\n+              splitListener,\n+              null /* bundleFinalizer */);\n+\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      mainOutputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+      BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      {\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> firstValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0),\n-                firstValue.getTimestamp(),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n                 window1,\n-                firstValue.getPane()),\n+                window2);\n+        mainInput.accept(firstValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+        // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+        // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+        // watermark.\n+        //\n+        // Since we were on the first window, we expect only a single primary root and two residual\n+        // roots (the split + the unprocessed window).\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n+        assertEquals(2, splitListener.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootForUnprocessedWindows =\n+            splitListener.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        Instant initialWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatmermarkMapForUnprocessedWindows =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(initialWatermark.getMillis() / 1000)\n+                        .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatmermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRootForUnprocessedWindows.getApplication().getInputId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+        assertEquals(\n+            expectedOutputWatmermarkMapForUnprocessedWindows,\n+            residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+\n+        assertEquals(\n+            decode(inputCoder, primaryRoot.getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n                     3.0),\n                 firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRoot.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n                     2.0),\n                 firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n                 window1,\n-                firstValue.getPane()),\n-            WindowedValue.of(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                window2,\n-                firstValue.getPane()),\n+                firstValue.getPane()));\n+        assertEquals(\n+            decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n+                    KV.of(\n+                        \"5\",\n+                        KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n                 firstValue.getTimestamp(),\n                 window2,\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                firstValue.getPane()));\n+        splitListener.clear();\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> secondValue =\n+            valueInWindows(\n+                KV.of(\n+                    KV.of(\n+                        \"2\",\n+                        KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    2.0),\n+                window1,\n+                window2);\n+        mainInput.accept(secondValue);\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+                WindowedValue.of(\n+                    \"2:1\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1),\n+                    window2,\n+                    firstValue.getPane())));\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+      }\n \n-  @Test\n-  public void\n-      testProcessElementForWindowedSplitAndSizeRestrictionWithNonWindowObservingOptimization()\n-          throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection\n-        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n-        .apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createSizedReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(\n-                                PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n-    IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n-    WindowedValue<?> firstValue =\n-        valueInWindows(\n-            KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    WindowedValue<?> secondValue =\n-        valueInWindows(\n-            KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-            window1,\n-            window2);\n-    mainInput.accept(firstValue);\n-    mainInput.accept(secondValue);\n-    // Ensure that each output element is in all the windows and not one per window.\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            WindowedValue.of(\n+      {\n+        // Setup and launch the trySplit thread.\n+        ExecutorService executorService = Executors.newSingleThreadExecutor();\n+        Future<HandlesSplits.SplitResult> trySplitFuture =\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    doFn.waitForSplitElementToBeProcessed();\n+                    // Currently processing \"3\" out of range [0, 5) elements for the first window.\n+                    assertEquals(0.3, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                    // Check that during progressing of an element we report progress\n+                    List<MonitoringInfo> mis =\n+                        Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                    MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                    expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                    expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedCompleted.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedCompleted.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(3.0))));\n+                    MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                    expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                    expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                    expectedRemaining.putLabels(\n+                        MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                    expectedRemaining.setPayload(\n+                        ByteString.copyFrom(\n+                            CoderUtils.encodeToByteArray(\n+                                IterableCoder.of(DoubleCoder.of()),\n+                                Collections.singletonList(7.0))));\n+                    assertThat(\n+                        mis,\n+                        containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                    return ((HandlesSplits) mainInput).trySplit(0);\n+                  } finally {\n+                    doFn.releaseWaitingProcessElementThread();\n+                  }\n+                });\n+\n+        // Check that before processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+        WindowedValue<?> splitValue =\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n                     2.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                window1,\n+                window2);\n+        mainInput.accept(splitValue);\n+        HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+        // Check that after processing an element we don't report progress\n+        assertThat(\n+            Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+        // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first\n+        // window.\n+        // We expect that the watermark advances to MIN + 2 since the manual watermark estimator\n+        // has yet to be invoked for the split element and that the primary represents [0, 4) with\n+        // the original watermark while the residual represents [4, 5) with the new MIN + 2\n+        // watermark.\n+        //\n+        // We expect to see none of the output for the second window.\n+        assertThat(\n+            mainOutputValues,\n+            contains(\n+                WindowedValue.of(\n+                    \"7:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:2\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2), window1, splitValue.getPane()),\n+                WindowedValue.of(\n+                    \"7:3\",\n+                    GlobalWindow.TIMESTAMP_MIN_VALUE.plus(3),\n+                    window1,\n+                    splitValue.getPane())));\n+\n+        BundleApplication primaryRoot = Iterables.getOnlyElement(trySplitResult.getPrimaryRoots());\n+        assertEquals(2, trySplitResult.getResidualRoots().size());\n+        DelayedBundleApplication residualRoot = trySplitResult.getResidualRoots().get(1);\n+        DelayedBundleApplication residualRootInUnprocessedWindows =\n+            trySplitResult.getResidualRoots().get(0);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        assertEquals(\n+            TEST_TRANSFORM_ID, residualRootInUnprocessedWindows.getApplication().getTransformId());\n+        assertEquals(\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRootInUnprocessedWindows.getRequestedTimeDelay());\n+        Instant initialWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1);\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2);\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMapInUnprocessedResiduals =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(initialWatermark.getMillis() / 1000)\n+                        .setNanos((int) (initialWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        Map<String, org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp>\n+            expectedOutputWatermarkMap =\n+                ImmutableMap.of(\n+                    \"output\",\n+                    org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                        .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                        .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                        .build());\n+        assertEquals(\n+            expectedOutputWatermarkMapInUnprocessedResiduals,\n+            residualRootInUnprocessedWindows.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(2, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    3.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n-            WindowedValue.of(\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 4), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    4.0),\n+                window1),\n+            inputCoder.decode(primaryRoot.getElement().newInput()));\n+        assertEquals(\n+            valueInWindows(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(4, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(2))),\n                     1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane()),\n+                window1),\n+            inputCoder.decode(residualRoot.getApplication().getElement().newInput()));\n+        assertEquals(\n+            expectedOutputWatermarkMap, residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n             WindowedValue.of(\n                 KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(1, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0),\n-                firstValue.getTimestamp(),\n-                ImmutableList.of(window1, window2),\n-                firstValue.getPane())));\n-    mainOutputValues.clear();\n+                    KV.of(\n+                        \"7\",\n+                        KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                    5.0),\n+                splitValue.getTimestamp(),\n+                window2,\n+                splitValue.getPane()),\n+            inputCoder.decode(\n+                residualRootInUnprocessedWindows.getApplication().getElement().newInput()));\n+\n+        // We expect 0 resume delay.\n+        assertEquals(\n+            residualRoot.getRequestedTimeDelay().getDefaultInstanceForType(),\n+            residualRoot.getRequestedTimeDelay());\n+        // We don't expect the outputs to goto the SDK initiated checkpointing listener.\n+        assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+        assertTrue(splitListener.getResidualRoots().isEmpty());\n+        mainOutputValues.clear();\n+        executorService.shutdown();\n+      }\n \n-    assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n-    assertThat(mainOutputValues, empty());\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+      assertThat(mainOutputValues, empty());\n \n-    Iterables.getOnlyElement(teardownFunctions).run();\n-    assertThat(mainOutputValues, empty());\n-  }\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n \n-  private static SplitResult createSplitResult(double fractionOfRemainder) {\n-    ByteString.Output primaryBytes = ByteString.newOutput();\n-    ByteString.Output residualBytes = ByteString.newOutput();\n-    try {\n-      DoubleCoder.of().encode(fractionOfRemainder, primaryBytes);\n-      DoubleCoder.of().encode(1 - fractionOfRemainder, residualBytes);\n-    } catch (Exception e) {\n-      // No-op.\n-    }\n-    return SplitResult.of(\n-        ImmutableList.of(\n-            BundleApplication.newBuilder().setElement(primaryBytes.toByteString()).build()),\n-        ImmutableList.of(\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(\n-                    BundleApplication.newBuilder().setElement(residualBytes.toByteString()).build())\n-                .build()));\n-  }\n+      // Assert that state data did not change\n+      assertEquals(stateData, fakeClient.getData());\n+    }\n \n-  private static class SplittableFnDataReceiver\n-      implements HandlesSplits, FnDataReceiver<WindowedValue> {\n-    SplittableFnDataReceiver(\n-        List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues) {\n-      this.mainOutputValues = mainOutputValues;\n+    private static <T> T decode(Coder<T> coder, ByteString value) {\n+      try {\n+        return coder.decode(value.newInput());\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n     }\n \n-    private final List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues;\n+    @Test\n+    public void testProcessElementForPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection.apply(\n+          TEST_TRANSFORM_ID,\n+          ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+              .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-    @Override\n-    public SplitResult trySplit(double fractionOfRemainder) {\n-      return createSplitResult(fractionOfRemainder);\n-    }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-    @Override\n-    public double getProgress() {\n-      return 0.7;\n-    }\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      mainInput.accept(valueInGlobalWindow(\"5\"));\n+      mainInput.accept(valueInGlobalWindow(\"2\"));\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      \"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1)))),\n+              valueInGlobalWindow(\n+                  KV.of(\n+                      \"2\",\n+                      KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))))));\n+      mainOutputValues.clear();\n+\n+      assertTrue(finishFunctionRegistry.getFunctions().isEmpty());\n+      assertThat(mainOutputValues, empty());\n \n-    @Override\n-    public void accept(WindowedValue input) throws Exception {\n-      mainOutputValues.add(input);\n+      Iterables.getOnlyElement(teardownFunctions).run();\n+      assertThat(mainOutputValues, empty());\n     }\n-  }\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertNull(((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+    @Test\n+    public void testProcessElementForWindowedPairWithRestriction() throws Exception {\n+      Pipeline p = Pipeline.create();\n+      PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+      PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+      valuePCollection\n+          .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+          .apply(\n+              TEST_TRANSFORM_ID,\n+              ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n+                  .withSideInputs(singletonSideInputView));\n+\n+      RunnerApi.Pipeline pProto =\n+          ProtoOverrides.updateTransform(\n+              PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+              PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+              SplittableParDoExpander.createSizedReplacement());\n+      String expandedTransformId =\n+          Iterables.find(\n+                  pProto.getComponents().getTransformsMap().entrySet(),\n+                  entry ->\n+                      entry\n+                              .getValue()\n+                              .getSpec()\n+                              .getUrn()\n+                              .equals(PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN)\n+                          && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+              .getKey();\n+      RunnerApi.PTransform pTransform =\n+          pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+      String inputPCollectionId =\n+          pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+      String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n+\n+      FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n+\n+      List<WindowedValue<KV<String, OffsetRange>>> mainOutputValues = new ArrayList<>();\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      consumers.register(outputPCollectionId, TEST_TRANSFORM_ID, ((List) mainOutputValues)::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      new FnApiDoFnRunner.Factory<>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              null /* beamFnDataClient */,\n+              fakeClient,\n+              null /* beamFnTimerClient */,\n+              TEST_TRANSFORM_ID,\n+              pTransform,\n+              Suppliers.ofInstance(\"57L\")::get,\n+              pProto.getComponents().getPcollectionsMap(),\n+              pProto.getComponents().getCodersMap(),\n+              pProto.getComponents().getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* bundleSplitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n+      mainOutputValues.clear();\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestrictionForwardSplitWhenoutObservingWindow()\n-      throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    valuePCollection.apply(TEST_TRANSFORM_ID, ParDo.of(new NonWindowObservingTestSplittableDoFn()));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    assertEquals(0.7, ((HandlesSplits) mainInput).getProgress(), 0.0);\n-    assertEquals(createSplitResult(0.4), ((HandlesSplits) mainInput).trySplit(0.4));\n-  }\n+      assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n \n-  @Test\n-  public void testProcessElementForTruncateAndSizeRestriction() throws Exception {\n-    Pipeline p = Pipeline.create();\n-    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n-    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n-    valuePCollection.apply(\n-        TEST_TRANSFORM_ID,\n-        ParDo.of(new WindowObservingTestSplittableDoFn(singletonSideInputView))\n-            .withSideInputs(singletonSideInputView));\n-\n-    RunnerApi.Pipeline pProto =\n-        ProtoOverrides.updateTransform(\n-            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n-            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n-            SplittableParDoExpander.createTruncateReplacement());\n-    String expandedTransformId =\n-        Iterables.find(\n-                pProto.getComponents().getTransformsMap().entrySet(),\n-                entry ->\n-                    entry\n-                            .getValue()\n-                            .getSpec()\n-                            .getUrn()\n-                            .equals(PTransformTranslation.SPLITTABLE_TRUNCATE_SIZED_RESTRICTION_URN)\n-                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n-            .getKey();\n-    RunnerApi.PTransform pTransform =\n-        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n-    String inputPCollectionId =\n-        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n-    String outputPCollectionId = Iterables.getOnlyElement(pTransform.getOutputsMap().values());\n-\n-    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(ImmutableMap.of());\n-\n-    List<WindowedValue<KV<KV<String, OffsetRange>, Double>>> mainOutputValues = new ArrayList<>();\n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    consumers.register(\n-        outputPCollectionId,\n-        TEST_TRANSFORM_ID,\n-        (FnDataReceiver) new SplittableFnDataReceiver(mainOutputValues));\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    new FnApiDoFnRunner.Factory<>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            null /* beamFnDataClient */,\n-            fakeClient,\n-            null /* beamFnTimerClient */,\n-            TEST_TRANSFORM_ID,\n-            pTransform,\n-            Suppliers.ofInstance(\"57L\")::get,\n-            pProto.getComponents().getPcollectionsMap(),\n-            pProto.getComponents().getCodersMap(),\n-            pProto.getComponents().getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* bundleSplitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertTrue(startFunctionRegistry.getFunctions().isEmpty());\n-    mainOutputValues.clear();\n-\n-    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n-\n-    FnDataReceiver<WindowedValue<?>> mainInput =\n-        consumers.getMultiplexingConsumer(inputPCollectionId);\n-    assertThat(mainInput, instanceOf(HandlesSplits.class));\n-\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0)));\n-    mainInput.accept(\n-        valueInGlobalWindow(\n-            KV.of(\n-                KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0)));\n-    assertThat(\n-        mainOutputValues,\n-        contains(\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"5\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    2.0)),\n-            valueInGlobalWindow(\n-                KV.of(\n-                    KV.of(\"2\", KV.of(new OffsetRange(0, 1), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                    1.0))));\n-    mainOutputValues.clear();\n+      FnDataReceiver<WindowedValue<?>> mainInput =\n+          consumers.getMultiplexingConsumer(inputPCollectionId);\n+      IntervalWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+      IntervalWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+      WindowedValue<?> firstValue = valueInWindows(\"5\", window1, window2);\n+      WindowedValue<?> secondValue = valueInWindows(\"2\", window1, window2);\n+      mainInput.accept(firstValue);\n+      mainInput.accept(secondValue);\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      \"5\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1))),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+", "originalCommit": "1753e9ec69ab3b623b42741ab404f799e8c3a338", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6473909fb600631455126a968eb5c86908c145e9", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 19425a5f4d..b388587410 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -138,7 +137,6 @@ import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableSet;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n import org.hamcrest.collection.IsMapContaining;\n import org.joda.time.Duration;\n"}}, {"oid": "6473909fb600631455126a968eb5c86908c145e9", "url": "https://github.com/apache/beam/commit/6473909fb600631455126a968eb5c86908c145e9", "message": "Handle split when truncate observes windows.", "committedDate": "2020-08-26T22:34:44Z", "type": "commit"}, {"oid": "6473909fb600631455126a968eb5c86908c145e9", "url": "https://github.com/apache/beam/commit/6473909fb600631455126a968eb5c86908c145e9", "message": "Handle split when truncate observes windows.", "committedDate": "2020-08-26T22:34:44Z", "type": "forcePushed"}]}