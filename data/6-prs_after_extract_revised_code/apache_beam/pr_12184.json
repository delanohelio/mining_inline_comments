{"pr_number": 12184, "pr_title": "[BEAM-10392] Make sure that messages that are unroutable are returned to the sender and redelivered.", "pr_createdAt": "2020-07-06T21:17:08Z", "pr_url": "https://github.com/apache/beam/pull/12184", "timeline": [{"oid": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d", "url": "https://github.com/apache/beam/commit/af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d", "message": "[BEAM-10392] Make sure that messages that are unroutable are returned to the sender and redelivered.", "committedDate": "2020-07-06T21:15:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTgwMA==", "url": "https://github.com/apache/beam/pull/12184#discussion_r450789800", "bodyText": "I think this has to be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                waitForExchangeToBeDeclared.countDown();\n          \n          \n            \n                waitForExchangeToBeDeclared.await();", "author": "mxm", "createdAt": "2020-07-07T11:18:12Z", "path": "sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java", "diffHunk": "@@ -196,59 +200,74 @@ private void doExchangeTest(ExchangeTestPlan testPlan, boolean simulateIncompati\n         exchangeType = \"fanout\";\n       }\n     }\n+    final String finalExchangeType = exchangeType;\n+    final CountDownLatch waitForExchangeToBeDeclared = new CountDownLatch(1);\n+    final BlockingQueue<byte[]> recordsToPublish = new LinkedBlockingQueue<>();\n+    recordsToPublish.addAll(RabbitMqTestUtils.generateRecords(testPlan.getNumRecordsToPublish()));\n+    Thread publisher =\n+        new Thread(\n+            () -> {\n+              Connection connection = null;\n+              Channel channel = null;\n+              try {\n+                ConnectionFactory connectionFactory = new ConnectionFactory();\n+                connectionFactory.setAutomaticRecoveryEnabled(false);\n+                connectionFactory.setUri(uri);\n+                connection = connectionFactory.newConnection();\n+                channel = connection.createChannel();\n+                channel.exchangeDeclare(exchange, finalExchangeType);\n+                // We are relying on the pipeline to declare the queue and messages that are\n+                // published without a queue being declared are \"unroutable\". Since there is a race\n+                // between when the pipeline declares and when we can start publishing, we add a\n+                // handler to republish messages that are returned to us.\n+                channel.addReturnListener(\n+                    (replyCode, replyText, exchange1, routingKey, properties, body) -> {\n+                      try {\n+                        recordsToPublish.put(body);\n+                      } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                      }\n+                    });\n+                waitForExchangeToBeDeclared.countDown();\n+                while (true) {\n+                  byte[] record = recordsToPublish.take();\n+                  if (record == terminalRecord) {\n+                    return;\n+                  }\n+                  channel.basicPublish(\n+                      exchange,\n+                      testPlan.publishRoutingKeyGen().get(),\n+                      true, // ensure that messages are returned to sender\n+                      testPlan.getPublishProperties(),\n+                      record);\n+                }\n \n-    ConnectionFactory connectionFactory = new ConnectionFactory();\n-    connectionFactory.setAutomaticRecoveryEnabled(false);\n-    connectionFactory.setUri(uri);\n-    Connection connection = null;\n-    Channel channel = null;\n-\n-    try {\n-      connection = connectionFactory.newConnection();\n-      channel = connection.createChannel();\n-      channel.exchangeDeclare(exchange, exchangeType);\n-      final Channel finalChannel = channel;\n-      Thread publisher =\n-          new Thread(\n-              () -> {\n-                try {\n-                  Thread.sleep(5000);\n-                } catch (Exception e) {\n-                  LOG.error(e.getMessage(), e);\n+              } catch (Exception e) {\n+                throw new RuntimeException(e);\n+              } finally {\n+                if (channel != null) {\n+                  // channel may have already been closed automatically due to protocol failure\n+                  try {\n+                    channel.close();\n+                  } catch (Exception e) {\n+                    /* ignored */\n+                  }\n                 }\n-                for (int i = 0; i < testPlan.getNumRecordsToPublish(); i++) {\n+                if (connection != null) {\n+                  // connection may have already been closed automatically due to protocol failure\n                   try {\n-                    finalChannel.basicPublish(\n-                        exchange,\n-                        testPlan.publishRoutingKeyGen().get(),\n-                        testPlan.getPublishProperties(),\n-                        RabbitMqTestUtils.generateRecord(i));\n+                    connection.close();\n                   } catch (Exception e) {\n-                    LOG.error(e.getMessage(), e);\n+                    /* ignored */\n                   }\n                 }\n-              });\n-      publisher.start();\n-      p.run();\n-      publisher.join();\n-    } finally {\n-      if (channel != null) {\n-        // channel may have already been closed automatically due to protocol failure\n-        try {\n-          channel.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-      if (connection != null) {\n-        // connection may have already been closed automatically due to protocol failure\n-        try {\n-          connection.close();\n-        } catch (Exception e) {\n-          /* ignored */\n-        }\n-      }\n-    }\n+              }\n+            });\n+    publisher.start();\n+    waitForExchangeToBeDeclared.countDown();", "originalCommit": "af1ce25cf9aaf99ae94a98a25fe8287c884d5f2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEyMzczOQ==", "url": "https://github.com/apache/beam/pull/12184#discussion_r451123739", "bodyText": "Your right.", "author": "lukecwik", "createdAt": "2020-07-07T20:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc4OTgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "b675acaf9093a1e0edf5c1ce181be95405227c09", "chunk": "diff --git a/sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java b/sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java\nindex 31b77f0f51..c7b3c0e679 100644\n--- a/sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java\n+++ b/sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java\n\n@@ -264,7 +264,7 @@ public class RabbitMqIOTest implements Serializable {\n               }\n             });\n     publisher.start();\n-    waitForExchangeToBeDeclared.countDown();\n+    waitForExchangeToBeDeclared.await();\n     p.run();\n     recordsToPublish.put(terminalRecord);\n     publisher.join();\n"}}, {"oid": "b675acaf9093a1e0edf5c1ce181be95405227c09", "url": "https://github.com/apache/beam/commit/b675acaf9093a1e0edf5c1ce181be95405227c09", "message": "Update sdks/java/io/rabbitmq/src/test/java/org/apache/beam/sdk/io/rabbitmq/RabbitMqIOTest.java\n\nCo-authored-by: Maximilian Michels <mxm@apache.org>", "committedDate": "2020-07-07T20:27:28Z", "type": "commit"}]}