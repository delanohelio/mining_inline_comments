{"pr_number": 11074, "pr_title": "Store logical type values in Row instead of base values", "pr_createdAt": "2020-03-09T04:30:35Z", "pr_url": "https://github.com/apache/beam/pull/11074", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0MTk4OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389641989", "bodyText": "There is similar code in cb3dce0#diff-7ed3da1c0f656d0645423b9dab4da881R31\nThere are a few differences that might make sense to incorporate:\n\ndon't use rawtypes for better typesafety\noverride structuralValue\nexplicitly override constentWithEquals\nI wish we could do something better for contentWithEquals, but out of my head it would be unexpected to add any of this information to LogicalType\nhaving registerByteSizeObserver, isRegisterByteSizeObserverCheap might make sense\ngetCoderArguments could return baseCoder", "author": "kanterov", "createdAt": "2020-03-09T12:56:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+public class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  public static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder extends Coder {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1MzU3OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391253578", "bodyText": "Made these changes.\nWe should probably update SchemaCoder as well to do this properly, but that can be in a different PR IMO.", "author": "reuvenlax", "createdAt": "2020-03-11T20:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0MTk4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\nindex 4944cbfce5..f24383057c 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\n\n@@ -43,11 +43,14 @@ import org.apache.beam.sdk.coders.VarLongCoder;\n import org.apache.beam.sdk.schemas.Schema.FieldType;\n import org.apache.beam.sdk.schemas.Schema.LogicalType;\n import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.sdk.util.common.ElementByteSizeObserver;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.joda.time.ReadableInstant;\n \n-public class SchemaCoderHelpers {\n+class SchemaCoderHelpers {\n   // This contains a map of primitive types to their coders.\n-  public static final Map<TypeName, Coder> CODER_MAP =\n+  private static final Map<TypeName, Coder> CODER_MAP =\n       ImmutableMap.<TypeName, Coder>builder()\n           .put(TypeName.BYTE, ByteCoder.of())\n           .put(TypeName.BYTES, ByteArrayCoder.of())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0Mjg0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389642843", "bodyText": "What about replacing default with an explicit switch? There is error-prone rule that checks that switch cases are exhaustive, and it would help if we would add new TypeName. If not, it might make sense to throw a more elaborate exception if coder is null.", "author": "kanterov", "createdAt": "2020-03-09T12:57:45Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+public class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  public static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder extends Coder {\n+    private final LogicalType logicalType;\n+    private final Coder baseTypeCoder;\n+\n+    public LogicalTypeCoder(LogicalType logicalType, Coder baseTypeCoder) {\n+      this.logicalType = logicalType;\n+      this.baseTypeCoder = baseTypeCoder;\n+    }\n+\n+    @Override\n+    public void encode(Object value, OutputStream outStream) throws CoderException, IOException {\n+      Object baseType = logicalType.toBaseType(value);\n+      baseTypeCoder.encode(baseType, outStream);\n+    }\n+\n+    @Override\n+    public Object decode(InputStream inStream) throws CoderException, IOException {\n+      Object baseType = baseTypeCoder.decode(inStream);\n+      return logicalType.toInputType(baseType);\n+    }\n+\n+    @Override\n+    public List<? extends Coder<?>> getCoderArguments() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void verifyDeterministic() throws NonDeterministicException {\n+      baseTypeCoder.verifyDeterministic();\n+    }\n+  }\n+\n+  /** Returns the coder used for a given primitive type. */\n+  public static <T> Coder<T> coderForFieldType(FieldType fieldType) {\n+    Coder<T> coder;\n+    switch (fieldType.getTypeName()) {\n+      case ROW:\n+        coder = (Coder<T>) SchemaCoder.of(fieldType.getRowSchema());\n+        break;\n+      case ARRAY:\n+        coder = (Coder<T>) ListCoder.of(coderForFieldType(fieldType.getCollectionElementType()));\n+        break;\n+      case ITERABLE:\n+        coder =\n+            (Coder<T>) IterableCoder.of(coderForFieldType(fieldType.getCollectionElementType()));\n+        break;\n+      case MAP:\n+        coder =\n+            (Coder<T>)\n+                MapCoder.of(\n+                    coderForFieldType(fieldType.getMapKeyType()),\n+                    coderForFieldType(fieldType.getMapValueType()));\n+        break;\n+      case LOGICAL_TYPE:\n+        coder =\n+            new LogicalTypeCoder(\n+                fieldType.getLogicalType(),\n+                coderForFieldType(fieldType.getLogicalType().getBaseType()));\n+        break;\n+      default:\n+        coder = (Coder<T>) CODER_MAP.get(fieldType.getTypeName());", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NDk5Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390764992", "bodyText": "Added  a null check.", "author": "reuvenlax", "createdAt": "2020-03-11T06:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0Mjg0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\nindex 4944cbfce5..f24383057c 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java\n\n@@ -43,11 +43,14 @@ import org.apache.beam.sdk.coders.VarLongCoder;\n import org.apache.beam.sdk.schemas.Schema.FieldType;\n import org.apache.beam.sdk.schemas.Schema.LogicalType;\n import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.sdk.util.common.ElementByteSizeObserver;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.joda.time.ReadableInstant;\n \n-public class SchemaCoderHelpers {\n+class SchemaCoderHelpers {\n   // This contains a map of primitive types to their coders.\n-  public static final Map<TypeName, Coder> CODER_MAP =\n+  private static final Map<TypeName, Coder> CODER_MAP =\n       ImmutableMap.<TypeName, Coder>builder()\n           .put(TypeName.BYTE, ByteCoder.of())\n           .put(TypeName.BYTES, ByteArrayCoder.of())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389644249", "bodyText": "This looks rather unexpected that Combiner accepts int as an argument instead of EnumerationType.Value", "author": "kanterov", "createdAt": "2020-03-09T13:00:39Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java", "diffHunk": "@@ -620,6 +531,88 @@ public void testGloballyWithSchemaAggregateFnNestedFields() {\n     pipeline.run();\n   }\n \n+  @DefaultSchema(AutoValueSchema.class)\n+  @AutoValue\n+  abstract static class BasicEnum {\n+    enum Test {\n+      ZERO,\n+      ONE,\n+      TWO\n+    };\n+\n+    abstract String getKey();\n+\n+    abstract Test getEnumeration();\n+\n+    static BasicEnum of(String key, Test value) {\n+      return new AutoValue_GroupTest_BasicEnum(key, value);\n+    }\n+  }\n+\n+  static final EnumerationType BASIC_ENUM_ENUMERATION =\n+      EnumerationType.create(\"ZERO\", \"ONE\", \"TWO\");\n+  static final Schema BASIC_ENUM_SCHEMA =\n+      Schema.builder()\n+          .addStringField(\"key\")\n+          .addLogicalTypeField(\"enumeration\", BASIC_ENUM_ENUMERATION)\n+          .build();\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateBaseValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    PCollection<Row> aggregate =\n+        pipeline\n+            .apply(Create.of(elements))\n+            .apply(\n+                Group.<BasicEnum>globally()\n+                    .aggregateFieldBaseValue(\"enumeration\", Sum.ofIntegers(), \"enum_sum\"));", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NTE2Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390765162", "bodyText": "it's because aggregateFieldBaseValue is called instead of aggregateField. Would a different name make it more clear?", "author": "reuvenlax", "createdAt": "2020-03-11T06:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5Mzg0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391093843", "bodyText": "I see I didn't get it in the beginning, but now it all makes sense.", "author": "kanterov", "createdAt": "2020-03-11T16:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\nindex 5adbd172bc..57c0301247 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\n\n@@ -584,7 +584,8 @@ public class GroupTest implements Serializable {\n         Lists.newArrayList(\n             BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n \n-    SampleAnyCombineFn<EnumerationType.Value> sampleAnyCombineFn = new SampleAnyCombineFn<>(100);\n+    CombineFn<EnumerationType.Value, ?, Iterable<EnumerationType.Value>> sampleAnyCombineFn =\n+        Sample.anyCombineFn(100);\n     Field aggField =\n         Field.of(\"sampleList\", FieldType.array(FieldType.logicalType(BASIC_ENUM_ENUMERATION)));\n     pipeline\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389645005", "bodyText": "Does it only work because of type erasure, or is it actually aggregating EnumerationType.Value (not Integer)?", "author": "kanterov", "createdAt": "2020-03-09T13:02:13Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java", "diffHunk": "@@ -620,6 +531,88 @@ public void testGloballyWithSchemaAggregateFnNestedFields() {\n     pipeline.run();\n   }\n \n+  @DefaultSchema(AutoValueSchema.class)\n+  @AutoValue\n+  abstract static class BasicEnum {\n+    enum Test {\n+      ZERO,\n+      ONE,\n+      TWO\n+    };\n+\n+    abstract String getKey();\n+\n+    abstract Test getEnumeration();\n+\n+    static BasicEnum of(String key, Test value) {\n+      return new AutoValue_GroupTest_BasicEnum(key, value);\n+    }\n+  }\n+\n+  static final EnumerationType BASIC_ENUM_ENUMERATION =\n+      EnumerationType.create(\"ZERO\", \"ONE\", \"TWO\");\n+  static final Schema BASIC_ENUM_SCHEMA =\n+      Schema.builder()\n+          .addStringField(\"key\")\n+          .addLogicalTypeField(\"enumeration\", BASIC_ENUM_ENUMERATION)\n+          .build();\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateBaseValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    PCollection<Row> aggregate =\n+        pipeline\n+            .apply(Create.of(elements))\n+            .apply(\n+                Group.<BasicEnum>globally()\n+                    .aggregateFieldBaseValue(\"enumeration\", Sum.ofIntegers(), \"enum_sum\"));\n+    Schema aggregateSchema = Schema.builder().addInt32Field(\"enum_sum\").build();\n+    Row expectedRow = Row.withSchema(aggregateSchema).addValues(3).build();\n+    PAssert.that(aggregate).containsInAnyOrder(expectedRow);\n+\n+    pipeline.run();\n+  }\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateLogicalValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    SampleAnyCombineFn<EnumerationType.Value> sampleAnyCombineFn = new SampleAnyCombineFn<>(100);", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NTM3OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390765378", "bodyText": "No, it's actually aggregation EnumerationType.Value", "author": "reuvenlax", "createdAt": "2020-03-11T06:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NDkwMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391094901", "bodyText": "I see, there are two methods: aggregateFieldBaseValue and aggregateField", "author": "kanterov", "createdAt": "2020-03-11T16:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\nindex 5adbd172bc..57c0301247 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java\n\n@@ -584,7 +584,8 @@ public class GroupTest implements Serializable {\n         Lists.newArrayList(\n             BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n \n-    SampleAnyCombineFn<EnumerationType.Value> sampleAnyCombineFn = new SampleAnyCombineFn<>(100);\n+    CombineFn<EnumerationType.Value, ?, Iterable<EnumerationType.Value>> sampleAnyCombineFn =\n+        Sample.anyCombineFn(100);\n     Field aggField =\n         Field.of(\"sampleList\", FieldType.array(FieldType.logicalType(BASIC_ENUM_ENUMERATION)));\n     pipeline\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTc5Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389645792", "bodyText": "nit: we probably don't want System.err.println in tests", "author": "kanterov", "createdAt": "2020-03-09T13:03:52Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java", "diffHunk": "@@ -592,41 +593,66 @@ public void testEnumFieldToRow() throws NoSuchSchemaException {\n     SchemaRegistry registry = SchemaRegistry.createDefault();\n     Schema schema = registry.getSchema(PojoWithEnum.class);\n     SchemaTestUtils.assertSchemaEquivalent(POJO_WITH_ENUM_SCHEMA, schema);\n-    EnumerationType enumerationType =\n-        POJO_WITH_ENUM_SCHEMA.getField(0).getType().getLogicalType(EnumerationType.class);\n+    EnumerationType enumerationType = ENUMERATION;\n \n+    List<EnumerationType.Value> allColors =\n+        Lists.newArrayList(\n+            enumerationType.valueOf(\"RED\"),\n+            enumerationType.valueOf(\"GREEN\"),\n+            enumerationType.valueOf(\"BLUE\"));\n     Row redRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"RED\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"RED\"), allColors)\n+            .build();\n     Row greenRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"GREEN\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"GREEN\"), allColors)\n+            .build();\n     Row blueRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"BLUE\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"BLUE\"), allColors)\n+            .build();\n+\n+    List<Color> allColorsJava = Lists.newArrayList(Color.RED, Color.GREEN, Color.BLUE);\n \n     SerializableFunction<PojoWithEnum, Row> toRow = registry.getToRowFunction(PojoWithEnum.class);\n-    assertEquals(redRow, toRow.apply(new PojoWithEnum(Color.RED)));\n-    assertEquals(greenRow, toRow.apply(new PojoWithEnum(Color.GREEN)));\n-    assertEquals(blueRow, toRow.apply(new PojoWithEnum(Color.BLUE)));\n+    System.err.println(\"CONVERTED \" + toRow.apply(new PojoWithEnum(Color.RED, allColorsJava)));", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java\nindex 0fa4dabda0..af3aae015b 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java\n\n@@ -616,7 +616,6 @@ public class JavaFieldSchemaTest {\n     List<Color> allColorsJava = Lists.newArrayList(Color.RED, Color.GREEN, Color.BLUE);\n \n     SerializableFunction<PojoWithEnum, Row> toRow = registry.getToRowFunction(PojoWithEnum.class);\n-    System.err.println(\"CONVERTED \" + toRow.apply(new PojoWithEnum(Color.RED, allColorsJava)));\n     assertEquals(redRow, toRow.apply(new PojoWithEnum(Color.RED, allColorsJava)));\n     assertEquals(greenRow, toRow.apply(new PojoWithEnum(Color.GREEN, allColorsJava)));\n     assertEquals(blueRow, toRow.apply(new PojoWithEnum(Color.BLUE, allColorsJava)));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzE0OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389647148", "bodyText": "nit: is it necessary to enforce? if yes, probably error message can be improved", "author": "kanterov", "createdAt": "2020-03-09T13:06:43Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -362,7 +371,24 @@ public Boolean getBoolean(int idx) {\n   @Nullable\n   public <T> T getLogicalTypeValue(int idx, Class<T> clazz) {\n     LogicalType logicalType = checkNotNull(getSchema().getField(idx).getType().getLogicalType());\n-    return (T) logicalType.toInputType(getValue(idx));\n+    return (T) getValue(idx);\n+  }\n+\n+  /**\n+   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n+   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n+   * schema doesn't match.\n+   */\n+  @Nullable\n+  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+    Object value = getValue(idx);\n+    FieldType fieldType = getSchema().getField(idx).getType();\n+    checkArgument(fieldType.getTypeName().isLogicalType());", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\nindex 3d84fa66fa..24d4291517 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\n\n@@ -375,22 +388,31 @@ public abstract class Row implements Serializable {\n   }\n \n   /**\n-   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n-   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n-   * schema doesn't match.\n+   * Returns the base type for this field. If this is a logical type, we convert to the base value.\n+   * Otherwise the field itself is returned.\n    */\n   @Nullable\n-  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+  public <T> T getBaseValue(int idx, Class<T> clazz) {\n     Object value = getValue(idx);\n     FieldType fieldType = getSchema().getField(idx).getType();\n-    checkArgument(fieldType.getTypeName().isLogicalType());\n-    while (fieldType.getTypeName().isLogicalType()) {\n-      value = fieldType.getLogicalType().toBaseType(value);\n-      fieldType = fieldType.getLogicalType().getBaseType();\n+    if (fieldType.getTypeName().isLogicalType() && value != null) {\n+      while (fieldType.getTypeName().isLogicalType()) {\n+        value = fieldType.getLogicalType().toBaseType(value);\n+        fieldType = fieldType.getLogicalType().getBaseType();\n+      }\n     }\n     return (T) value;\n   }\n \n+  /**\n+   * Returns the base type for this field. If this is a logical type, we convert to the base value.\n+   * Otherwise the field itself is returned.\n+   */\n+  @Nullable\n+  public Object getBaseValue(int idx) {\n+    return getBaseValue(idx, Object.class);\n+  }\n+\n   /**\n    * Get a {@link Row} value by field index, {@link IllegalStateException} is thrown if schema\n    * doesn't match.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzU3NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389647574", "bodyText": "Should toBaseType handle null values for nullable fields or not? Can we assume that toBaseType(null) == null?", "author": "kanterov", "createdAt": "2020-03-09T13:07:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -362,7 +371,24 @@ public Boolean getBoolean(int idx) {\n   @Nullable\n   public <T> T getLogicalTypeValue(int idx, Class<T> clazz) {\n     LogicalType logicalType = checkNotNull(getSchema().getField(idx).getType().getLogicalType());\n-    return (T) logicalType.toInputType(getValue(idx));\n+    return (T) getValue(idx);\n+  }\n+\n+  /**\n+   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n+   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n+   * schema doesn't match.\n+   */\n+  @Nullable\n+  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+    Object value = getValue(idx);\n+    FieldType fieldType = getSchema().getField(idx).getType();\n+    checkArgument(fieldType.getTypeName().isLogicalType());\n+    while (fieldType.getTypeName().isLogicalType()) {\n+      value = fieldType.getLogicalType().toBaseType(value);", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjA0NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766044", "bodyText": "good catch, we should.", "author": "reuvenlax", "createdAt": "2020-03-11T06:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\nindex 3d84fa66fa..24d4291517 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java\n\n@@ -375,22 +388,31 @@ public abstract class Row implements Serializable {\n   }\n \n   /**\n-   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n-   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n-   * schema doesn't match.\n+   * Returns the base type for this field. If this is a logical type, we convert to the base value.\n+   * Otherwise the field itself is returned.\n    */\n   @Nullable\n-  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+  public <T> T getBaseValue(int idx, Class<T> clazz) {\n     Object value = getValue(idx);\n     FieldType fieldType = getSchema().getField(idx).getType();\n-    checkArgument(fieldType.getTypeName().isLogicalType());\n-    while (fieldType.getTypeName().isLogicalType()) {\n-      value = fieldType.getLogicalType().toBaseType(value);\n-      fieldType = fieldType.getLogicalType().getBaseType();\n+    if (fieldType.getTypeName().isLogicalType() && value != null) {\n+      while (fieldType.getTypeName().isLogicalType()) {\n+        value = fieldType.getLogicalType().toBaseType(value);\n+        fieldType = fieldType.getLogicalType().getBaseType();\n+      }\n     }\n     return (T) value;\n   }\n \n+  /**\n+   * Returns the base type for this field. If this is a logical type, we convert to the base value.\n+   * Otherwise the field itself is returned.\n+   */\n+  @Nullable\n+  public Object getBaseValue(int idx) {\n+    return getBaseValue(idx, Object.class);\n+  }\n+\n   /**\n    * Get a {@link Row} value by field index, {@link IllegalStateException} is thrown if schema\n    * doesn't match.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0ODMyNw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389648327", "bodyText": "nit: doesn't look necessary, we can probably replicate this combiner in tests, instead of extending public API", "author": "kanterov", "createdAt": "2020-03-09T13:09:10Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java", "diffHunk": "@@ -202,10 +202,10 @@ public void populateDisplayData(DisplayData.Builder builder) {\n   }\n \n   /** A {@link CombineFn} that combines into a {@link List} of up to limit elements. */\n-  private static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {\n+  public static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjE0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766143", "bodyText": "Sample.anyCombineFn() exists, so I reverted this change", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0ODMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java\nindex 730e19f153..2594dee3f5 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java\n\n@@ -202,10 +202,10 @@ public class Sample {\n   }\n \n   /** A {@link CombineFn} that combines into a {@link List} of up to limit elements. */\n-  public static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {\n+  private static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {\n     private final long limit;\n \n-    public SampleAnyCombineFn(long limit) {\n+    private SampleAnyCombineFn(long limit) {\n       this.limit = limit;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MDE4Nw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389650187", "bodyText": "I find this was useful to have, and it was public. Instead, I would suggest SchemaCoderHelpers to be package-private, and this method to delegate to SchemaCoderHelpers.", "author": "kanterov", "createdAt": "2020-03-09T13:12:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoder.java", "diffHunk": "@@ -119,27 +86,6 @@ protected SchemaCoder(\n     return RowCoder.of(schema);\n   }\n \n-  /** Returns the coder used for a given primitive type. */\n-  public static <T> Coder<T> coderForFieldType(FieldType fieldType) {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjE5NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766194", "bodyText": "done", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MDE4Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MjIwMg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389652202", "bodyText": "nit: not directly relevant to this PR, but I guess this field should be final, and name should follow convention", "author": "kanterov", "createdAt": "2020-03-09T13:16:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java", "diffHunk": "@@ -99,37 +97,14 @@\n @Experimental(Kind.SCHEMAS)\n public abstract class RowCoderGenerator {\n   private static final ByteBuddy BYTE_BUDDY = new ByteBuddy();\n-  private static final ForLoadedType CODER_TYPE = new ForLoadedType(Coder.class);\n-  private static final ForLoadedType LIST_CODER_TYPE = new ForLoadedType(ListCoder.class);\n-  private static final ForLoadedType ITERABLE_CODER_TYPE = new ForLoadedType(IterableCoder.class);\n-  private static final ForLoadedType MAP_CODER_TYPE = new ForLoadedType(MapCoder.class);\n   private static final BitSetCoder NULL_LIST_CODER = BitSetCoder.of();\n   private static final VarIntCoder VAR_INT_CODER = VarIntCoder.of();\n-  private static final ForLoadedType NULLABLE_CODER = new ForLoadedType(NullableCoder.class);\n \n   private static final String CODERS_FIELD_NAME = \"FIELD_CODERS\";\n \n-  // A map of primitive types -> StackManipulations to create their coders.\n-  private static final Map<TypeName, StackManipulation> CODER_MAP;\n-\n   // Cache for Coder class that are already generated.\n   private static Map<UUID, Coder<Row>> generatedCoders = Maps.newConcurrentMap();", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjIxMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766211", "bodyText": "done", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MjIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "71ea5fc58a929dde6debf768f52bca89c472587e", "chunk": "diff --git a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java\nindex 1af1b171a1..15bfe6400b 100644\n--- a/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java\n+++ b/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java\n\n@@ -103,13 +103,13 @@ public abstract class RowCoderGenerator {\n   private static final String CODERS_FIELD_NAME = \"FIELD_CODERS\";\n \n   // Cache for Coder class that are already generated.\n-  private static Map<UUID, Coder<Row>> generatedCoders = Maps.newConcurrentMap();\n+  private static final Map<UUID, Coder<Row>> GENERATED_CODERS = Maps.newConcurrentMap();\n \n   @SuppressWarnings(\"unchecked\")\n   public static Coder<Row> generate(Schema schema) {\n     // Using ConcurrentHashMap::computeIfAbsent here would deadlock in case of nested\n     // coders. Using HashMap::computeIfAbsent generates ConcurrentModificationExceptions in Java 11.\n-    Coder<Row> rowCoder = generatedCoders.get(schema.getUUID());\n+    Coder<Row> rowCoder = GENERATED_CODERS.get(schema.getUUID());\n     if (rowCoder == null) {\n       TypeDescription.Generic coderType =\n           TypeDescription.Generic.Builder.parameterizedType(Coder.class, Row.class).build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MzQ1OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389653458", "bodyText": "Probably I need to look into the code more. Why is OneOfType is a special case, while there is a generic branch for other logical types?", "author": "kanterov", "createdAt": "2020-03-09T13:19:03Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/FromRowUsingCreator.java", "diffHunk": "@@ -126,21 +127,25 @@ public T apply(Row row) {\n               valueType,\n               typeFactory);\n     } else {\n-      if (type.getTypeName().isLogicalType()\n-          && OneOfType.IDENTIFIER.equals(type.getLogicalType().getIdentifier())) {\n+      if (type.isLogicalType(OneOfType.IDENTIFIER)) {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjQzMg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766432", "bodyText": "because the actual conversion type changes depending on the oneOf case type. there might be a better way to handle this, but I'm not sure what it is yet.", "author": "reuvenlax", "createdAt": "2020-03-11T06:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MzQ1OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "71ea5fc58a929dde6debf768f52bca89c472587e", "url": "https://github.com/apache/beam/commit/71ea5fc58a929dde6debf768f52bca89c472587e", "message": "store logical type values in Row instead of base values", "committedDate": "2020-03-19T22:45:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3NDUyMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396074521", "bodyText": "Remove comment", "author": "alexvanboxel", "createdAt": "2020-03-22T09:54:51Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java", "diffHunk": "@@ -396,8 +396,8 @@ public void testLogicalTypes() {\n \n     PCollection<Row> outputRow =\n         pipeline\n-            .apply(Create.of(row))\n-            .setRowSchema(outputRowSchema)\n+            .apply(Create.of(row).withRowSchema(inputRowSchema))\n+            //  .setRowSchema(outputRowSchema)", "originalCommit": "71ea5fc58a929dde6debf768f52bca89c472587e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d271736c5f88f3652fa7c80bd2c3e77c26fe27f", "chunk": "diff --git a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java\nindex 3db68116f2..ce46c17c29 100644\n--- a/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java\n+++ b/sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java\n\n@@ -397,7 +397,6 @@ public class BeamComplexTypeTest {\n     PCollection<Row> outputRow =\n         pipeline\n             .apply(Create.of(row).withRowSchema(inputRowSchema))\n-            //  .setRowSchema(outputRowSchema)\n             .apply(\n                 SqlTransform.query(\n                     \"SELECT timeTypeField, dateTypeField FROM PCOLLECTION GROUP BY timeTypeField, dateTypeField\"));\n"}}, {"oid": "4d271736c5f88f3652fa7c80bd2c3e77c26fe27f", "url": "https://github.com/apache/beam/commit/4d271736c5f88f3652fa7c80bd2c3e77c26fe27f", "message": "fix spotbugs", "committedDate": "2020-03-23T05:42:36Z", "type": "forcePushed"}, {"oid": "f11a6b87aecb208656a9626253c7469d360b8df9", "url": "https://github.com/apache/beam/commit/f11a6b87aecb208656a9626253c7469d360b8df9", "message": "store logical type values in Row instead of base values", "committedDate": "2020-03-23T05:46:22Z", "type": "commit"}, {"oid": "6e77596a1d48a22ff8157faf76b90525bb05b445", "url": "https://github.com/apache/beam/commit/6e77596a1d48a22ff8157faf76b90525bb05b445", "message": "fix spotbugs", "committedDate": "2020-03-23T05:46:22Z", "type": "commit"}, {"oid": "6e77596a1d48a22ff8157faf76b90525bb05b445", "url": "https://github.com/apache/beam/commit/6e77596a1d48a22ff8157faf76b90525bb05b445", "message": "fix spotbugs", "committedDate": "2020-03-23T05:46:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396411943", "bodyText": "Why is this check needed?", "author": "kanterov", "createdAt": "2020-03-23T12:25:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.sdk.util.common.ElementByteSizeObserver;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.joda.time.ReadableInstant;\n+\n+class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  private static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder<InputT, BaseT> extends Coder<InputT> {\n+    private final LogicalType<InputT, BaseT> logicalType;\n+    private final Coder<BaseT> baseTypeCoder;\n+    private final boolean isDateTime;\n+\n+    LogicalTypeCoder(LogicalType<InputT, BaseT> logicalType, Coder baseTypeCoder) {\n+      this.logicalType = logicalType;\n+      this.baseTypeCoder = baseTypeCoder;\n+      this.isDateTime = logicalType.getBaseType().equals(FieldType.DATETIME);\n+    }\n+\n+    @Override\n+    public void encode(InputT value, OutputStream outStream) throws CoderException, IOException {\n+      BaseT baseType = logicalType.toBaseType(value);\n+      if (isDateTime) {\n+        baseType = (BaseT) ((ReadableInstant) baseType).toInstant();", "originalCommit": "6e77596a1d48a22ff8157faf76b90525bb05b445", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NjY2OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396586669", "bodyText": "It's to maintain the current invariant that any ReadableInstant can be passed in, while the current InstantCoder requires an Instant. This used to be enforced in the Row builder because we would call toBaseType there.\nWe need to redo DateTime types I think (really we have a timestamp type, not a datetime type), but until then I wanted to maintain the existing behavior.", "author": "reuvenlax", "createdAt": "2020-03-23T16:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4ODQzNg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396588436", "bodyText": "Thanks. Makes sense. Agree that DateTime types need to be redone.", "author": "kanterov", "createdAt": "2020-03-23T16:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw=="}], "type": "inlineReview", "revised_code": null}]}