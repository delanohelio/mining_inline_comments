{"pr_number": 12062, "pr_title": "[BEAM-10305] Let InMemoryBagUserStateFactory only use a single cache token", "pr_createdAt": "2020-06-23T08:40:43Z", "pr_url": "https://github.com/apache/beam/pull/12062", "timeline": [{"oid": "18e5df392987e073ff9a2158f3791d6e0e718ee3", "url": "https://github.com/apache/beam/commit/18e5df392987e073ff9a2158f3791d6e0e718ee3", "message": "[BEAM-10305] Let InMemoryBagUserStateFactory only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-23T09:09:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyNTcwMg==", "url": "https://github.com/apache/beam/pull/12062#discussion_r444325702", "bodyText": "You should update the comment related to error handling to make sure that users discard the factory every time they want a new cache token.", "author": "lukecwik", "createdAt": "2020-06-23T15:46:43Z", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java", "diffHunk": "@@ -41,9 +41,12 @@\n public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>", "originalCommit": "18e5df392987e073ff9a2158f3791d6e0e718ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NDkwOA==", "url": "https://github.com/apache/beam/pull/12062#discussion_r444774908", "bodyText": "Sure, good idea to clarify that.", "author": "mxm", "createdAt": "2020-06-24T09:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyNTcwMg=="}], "type": "inlineReview", "revised_code": {"commit": "be7b5f2221e003adc99ab911b2413e9b75764141", "chunk": "diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\nindex 8759dc1dd5..79559a66d5 100644\n--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\n+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\n\n@@ -41,12 +37,9 @@ import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;\n public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>\n     implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {\n \n-  private final ByteString cacheToken;\n-\n-  private List<InMemorySingleKeyBagState> handlers;\n+  private final List<InMemorySingleKeyBagState> handlers;\n \n   public InMemoryBagUserStateFactory() {\n-    cacheToken = ByteString.copyFrom(UUID.randomUUID().toString().getBytes(Charsets.UTF_8));\n     handlers = new ArrayList<>();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDY3OQ==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445074679", "bodyText": "I think we'll want to move the cache token generation up higher to the ByteStringStateRequestHandlerToBagUserStateHandlerFactoryAdapter or the factory has to own the cache token or we add a method which is a supplier to the StateRequestHandlers#forBagUserState. The comment added for this class should be moved appropriately.", "author": "lukecwik", "createdAt": "2020-06-24T18:01:32Z", "path": "runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java", "diffHunk": "@@ -37,13 +37,19 @@\n /**\n  * Holds user state in memory. Only one key is active at a time due to the GroupReduceFunction being\n  * called once per key. Needs to be reset via {@code resetForNewKey()} before processing a new key.\n+ *\n+ * <p>In case of any failures, this factory must be discarded. Otherwise, the contained state cache\n+ * token would be reused which would corrupt the state cache.\n  */\n public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>\n     implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {\n \n+  private final ByteString cacheToken;\n+\n   private List<InMemorySingleKeyBagState> handlers;\n \n   public InMemoryBagUserStateFactory() {\n+    cacheToken = ByteString.copyFrom(UUID.randomUUID().toString().getBytes(Charsets.UTF_8));", "originalCommit": "9847976462b8540d398a8296a6b6e8a347e3d8fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4MDUzMQ==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445080531", "bodyText": "Could you add a reason for moving this up the stack? State handlers should implement their own cache token handling.", "author": "mxm", "createdAt": "2020-06-24T18:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4MzI2NA==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445083264", "bodyText": "I'll have another look later.", "author": "mxm", "createdAt": "2020-06-24T18:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4MzMzMw==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445083333", "bodyText": "ByteStringStateRequestHandlerToBagUserStateHandlerFactoryAdapter#getCacheTokens is going to add N copies of the cache token to the ProcessBundleRequest\nFor user state, it makes sense to have a caching handler that does the delegation to other handlers. This caching handler is the one that should be responsible for supplying the single cache token.", "author": "lukecwik", "createdAt": "2020-06-24T18:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzMTkwNA==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445131904", "bodyText": "I see, makes sense. Let me update the PR.", "author": "mxm", "createdAt": "2020-06-24T19:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NDY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "be7b5f2221e003adc99ab911b2413e9b75764141", "chunk": "diff --git a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\nindex 23f3702ee8..79559a66d5 100644\n--- a/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\n+++ b/runners/java-fn-execution/src/main/java/org/apache/beam/runners/fnexecution/state/InMemoryBagUserStateFactory.java\n\n@@ -31,25 +29,17 @@ import org.apache.beam.runners.core.StateTags;\n import org.apache.beam.sdk.coders.Coder;\n import org.apache.beam.sdk.state.BagState;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n-import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.ByteString;\n-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Charsets;\n \n /**\n  * Holds user state in memory. Only one key is active at a time due to the GroupReduceFunction being\n  * called once per key. Needs to be reset via {@code resetForNewKey()} before processing a new key.\n- *\n- * <p>In case of any failures, this factory must be discarded. Otherwise, the contained state cache\n- * token would be reused which would corrupt the state cache.\n  */\n public class InMemoryBagUserStateFactory<K, V, W extends BoundedWindow>\n     implements StateRequestHandlers.BagUserStateHandlerFactory<K, V, W> {\n \n-  private final ByteString cacheToken;\n-\n-  private List<InMemorySingleKeyBagState> handlers;\n+  private final List<InMemorySingleKeyBagState> handlers;\n \n   public InMemoryBagUserStateFactory() {\n-    cacheToken = ByteString.copyFrom(UUID.randomUUID().toString().getBytes(Charsets.UTF_8));\n     handlers = new ArrayList<>();\n   }\n \n"}}, {"oid": "be7b5f2221e003adc99ab911b2413e9b75764141", "url": "https://github.com/apache/beam/commit/be7b5f2221e003adc99ab911b2413e9b75764141", "message": "[BEAM-10305] Let InMemoryBagUserStateFactory only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-24T20:12:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NzY1Mg==", "url": "https://github.com/apache/beam/pull/12062#discussion_r445147652", "bodyText": "Looks like this should be using the StateRequestHandler instead, will update.", "author": "mxm", "createdAt": "2020-06-24T20:19:09Z", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java", "diffHunk": "@@ -59,4 +68,46 @@ public void testDelegatingStateHandlerThrowsWhenNotFound() throws Exception {\n     StateRequestHandlers.delegateBasedUponType(new EnumMap<>(StateKey.TypeCase.class))\n         .handle(StateRequest.getDefaultInstance());\n   }\n+\n+  @Test\n+  public void testUserStateCacheTokenGeneration() {\n+    ProcessBundleDescriptors.ExecutableProcessBundleDescriptor processBundleDescriptor =\n+        Mockito.mock(ProcessBundleDescriptors.ExecutableProcessBundleDescriptor.class);\n+    InMemoryBagUserStateFactory inMemoryBagUserStateFactory = new InMemoryBagUserStateFactory<>();\n+    StateRequestHandler stateRequestHandler =\n+        StateRequestHandlers.forBagUserStateHandlerFactory(\n+            processBundleDescriptor, inMemoryBagUserStateFactory);\n+\n+    Iterable<BeamFnApi.ProcessBundleRequest.CacheToken> cacheTokens =\n+        stateRequestHandler.getCacheTokens();\n+    assertThat(Iterables.size(cacheTokens), is(1));\n+\n+    BeamFnApi.ProcessBundleRequest.CacheToken cacheToken = Iterables.getOnlyElement(cacheTokens);\n+    assertThat(\n+        cacheToken.getUserState(),\n+        is(BeamFnApi.ProcessBundleRequest.CacheToken.UserState.getDefaultInstance()));\n+    assertThat(cacheToken.getToken(), is(notNullValue()));\n+\n+    inMemoryBagUserStateFactory.forUserState(", "originalCommit": "be7b5f2221e003adc99ab911b2413e9b75764141", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae80434c3a7eb70c1112d0377a2df34e5627438", "chunk": "diff --git a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java\nindex 1d77b860e4..46a3d874ce 100644\n--- a/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java\n+++ b/runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/state/StateRequestHandlersTest.java\n\n@@ -70,44 +75,122 @@ public class StateRequestHandlersTest {\n   }\n \n   @Test\n-  public void testUserStateCacheTokenGeneration() {\n-    ProcessBundleDescriptors.ExecutableProcessBundleDescriptor processBundleDescriptor =\n-        Mockito.mock(ProcessBundleDescriptors.ExecutableProcessBundleDescriptor.class);\n+  public void testUserStateCacheTokenGeneration() throws Exception {\n+    ExecutableStage stage = buildExecutableStage(\"state1\", \"state2\");\n+    ProcessBundleDescriptors.ExecutableProcessBundleDescriptor descriptor =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+            \"id\", stage, Endpoints.ApiServiceDescriptor.getDefaultInstance());\n+\n     InMemoryBagUserStateFactory inMemoryBagUserStateFactory = new InMemoryBagUserStateFactory<>();\n+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(0));\n+\n     StateRequestHandler stateRequestHandler =\n-        StateRequestHandlers.forBagUserStateHandlerFactory(\n-            processBundleDescriptor, inMemoryBagUserStateFactory);\n+        StateRequestHandlers.forBagUserStateHandlerFactory(descriptor, inMemoryBagUserStateFactory);\n+    final BeamFnApi.ProcessBundleRequest.CacheToken cacheToken =\n+        assertSingleCacheToken(stateRequestHandler);\n+\n+    sendGetRequest(stateRequestHandler, \"state1\");\n+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(1));\n+    assertThat(assertSingleCacheToken(stateRequestHandler), is(cacheToken));\n \n+    sendGetRequest(stateRequestHandler, \"state2\");\n+    assertThat(inMemoryBagUserStateFactory.handlers.size(), is(2));\n+    assertThat(assertSingleCacheToken(stateRequestHandler), is(cacheToken));\n+  }\n+\n+  private static BeamFnApi.ProcessBundleRequest.CacheToken assertSingleCacheToken(\n+      StateRequestHandler stateRequestHandler) {\n     Iterable<BeamFnApi.ProcessBundleRequest.CacheToken> cacheTokens =\n         stateRequestHandler.getCacheTokens();\n     assertThat(Iterables.size(cacheTokens), is(1));\n \n     BeamFnApi.ProcessBundleRequest.CacheToken cacheToken = Iterables.getOnlyElement(cacheTokens);\n+    assertThat(cacheToken.getToken(), is(notNullValue()));\n     assertThat(\n         cacheToken.getUserState(),\n         is(BeamFnApi.ProcessBundleRequest.CacheToken.UserState.getDefaultInstance()));\n-    assertThat(cacheToken.getToken(), is(notNullValue()));\n+    return cacheToken;\n+  }\n \n-    inMemoryBagUserStateFactory.forUserState(\n-        \"transform\",\n-        \"userState1\",\n-        StringUtf8Coder.of(),\n-        VoidCoder.of(),\n-        GlobalWindow.Coder.INSTANCE);\n+  private static void sendGetRequest(StateRequestHandler stateRequestHandler, String userStateName)\n+      throws Exception {\n+    stateRequestHandler\n+        .handle(\n+            StateRequest.newBuilder()\n+                .setGet(BeamFnApi.StateGetRequest.getDefaultInstance())\n+                .setStateKey(\n+                    StateKey.newBuilder()\n+                        .setBagUserState(\n+                            StateKey.BagUserState.newBuilder()\n+                                .setKey(ByteString.copyFromUtf8(\"key\"))\n+                                .setWindow(\n+                                    ByteString.copyFrom(\n+                                        CoderUtils.encodeToByteArray(\n+                                            GlobalWindow.Coder.INSTANCE, GlobalWindow.INSTANCE)))\n+                                .setTransformId(\"transform\")\n+                                .setUserStateId(userStateName))\n+                        .build())\n+                .build())\n+        .toCompletableFuture()\n+        .get();\n+  }\n \n-    cacheTokens = stateRequestHandler.getCacheTokens();\n-    assertThat(Iterables.size(cacheTokens), is(1));\n-    assertThat(Iterables.getOnlyElement(cacheTokens), is(cacheToken));\n+  private static ExecutableStage buildExecutableStage(String... userStateNames) {\n+    RunnerApi.ExecutableStagePayload.Builder builder =\n+        RunnerApi.ExecutableStagePayload.newBuilder()\n+            .setInput(\"input\")\n+            .setComponents(\n+                RunnerApi.Components.newBuilder()\n+                    .putWindowingStrategies(\n+                        \"window\",\n+                        RunnerApi.WindowingStrategy.newBuilder()\n+                            .setWindowCoderId(\"windowCoder\")\n+                            .build())\n+                    .putPcollections(\n+                        \"input\",\n+                        RunnerApi.PCollection.newBuilder()\n+                            .setWindowingStrategyId(\"window\")\n+                            .setCoderId(\"coder\")\n+                            .build())\n+                    .putCoders(\n+                        \"windowCoder\",\n+                        RunnerApi.Coder.newBuilder()\n+                            .setSpec(\n+                                RunnerApi.FunctionSpec.newBuilder()\n+                                    .setUrn(ModelCoders.GLOBAL_WINDOW_CODER_URN)\n+                                    .build())\n+                            .build())\n+                    .putCoders(\n+                        \"coder\",\n+                        RunnerApi.Coder.newBuilder()\n+                            .setSpec(\n+                                RunnerApi.FunctionSpec.newBuilder()\n+                                    .setUrn(ModelCoders.KV_CODER_URN)\n+                                    .build())\n+                            .addComponentCoderIds(\"keyCoder\")\n+                            .addComponentCoderIds(\"valueCoder\")\n+                            .build())\n+                    .putCoders(\"keyCoder\", RunnerApi.Coder.getDefaultInstance())\n+                    .putCoders(\"valueCoder\", RunnerApi.Coder.getDefaultInstance())\n+                    .putTransforms(\n+                        \"transform\",\n+                        RunnerApi.PTransform.newBuilder()\n+                            .setSpec(\n+                                RunnerApi.FunctionSpec.newBuilder()\n+                                    .setUrn(PAR_DO_TRANSFORM_URN)\n+                                    .build())\n+                            .putInputs(\"input\", \"input\")\n+                            .build())\n+                    .build());\n \n-    inMemoryBagUserStateFactory.forUserState(\n-        \"transform\",\n-        \"userState2\",\n-        StringUtf8Coder.of(),\n-        VoidCoder.of(),\n-        GlobalWindow.Coder.INSTANCE);\n+    for (String userStateName : userStateNames) {\n+      builder.addUserStates(\n+          RunnerApi.ExecutableStagePayload.UserStateId.newBuilder()\n+              .setTransformId(\"transform\")\n+              .setLocalName(userStateName)\n+              .build());\n+    }\n \n-    cacheTokens = stateRequestHandler.getCacheTokens();\n-    assertThat(Iterables.size(cacheTokens), is(1));\n-    assertThat(Iterables.getOnlyElement(cacheTokens), is(cacheToken));\n+    return ExecutableStage.fromPayload(builder.build());\n   }\n }\n"}}, {"oid": "8ae80434c3a7eb70c1112d0377a2df34e5627438", "url": "https://github.com/apache/beam/commit/8ae80434c3a7eb70c1112d0377a2df34e5627438", "message": "[BEAM-10305] Let StateRequestHandler for user state only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-25T08:47:25Z", "type": "forcePushed"}, {"oid": "6817c19636d0ff82947f3526bb68c78a1af6f862", "url": "https://github.com/apache/beam/commit/6817c19636d0ff82947f3526bb68c78a1af6f862", "message": "[BEAM-10305] Let StateRequestHandler for user state only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-25T09:19:53Z", "type": "forcePushed"}, {"oid": "5d65ed6d44b41165126ba7533057200ed8abbebb", "url": "https://github.com/apache/beam/commit/5d65ed6d44b41165126ba7533057200ed8abbebb", "message": "[BEAM-10305] Let StateRequestHandler for user state only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-25T09:24:11Z", "type": "commit"}, {"oid": "5d65ed6d44b41165126ba7533057200ed8abbebb", "url": "https://github.com/apache/beam/commit/5d65ed6d44b41165126ba7533057200ed8abbebb", "message": "[BEAM-10305] Let StateRequestHandler for user state only use a single cache token\n\nWhen the state cache is enabled in the Python SDK, the batch mode of the Flink\nRunner currently only allows a single user state cell because a new cache token\nis generated for each state cell; the caching code in the Python SDK Harness\nonly supports one cache token per user state handler.\n\nTheoretically multiple cache tokens would work but would just be adding to the\npayload. We should make sure to just send a single cache token in batch\nmode (which is already the case in streaming)", "committedDate": "2020-06-25T09:24:11Z", "type": "forcePushed"}]}