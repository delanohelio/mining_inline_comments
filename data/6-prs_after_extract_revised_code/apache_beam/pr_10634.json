{"pr_number": 10634, "pr_title": "[BEAM-9178] Support all ZetaSQL TIMESTAMP functions", "pr_createdAt": "2020-01-17T23:40:36Z", "pr_url": "https://github.com/apache/beam/pull/10634", "timeline": [{"oid": "37b9890d40266eba7d5fb3ad20791a9c4b071fc2", "url": "https://github.com/apache/beam/commit/37b9890d40266eba7d5fb3ad20791a9c4b071fc2", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:34:23Z", "type": "forcePushed"}, {"oid": "5f3c2923de0bbaaf4c48a9f6a009d39c17bd3d37", "url": "https://github.com/apache/beam/commit/5f3c2923de0bbaaf4c48a9f6a009d39c17bd3d37", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:41:58Z", "type": "forcePushed"}, {"oid": "c6b36a0414c9489832f0f87cc4da20413341ea09", "url": "https://github.com/apache/beam/commit/c6b36a0414c9489832f0f87cc4da20413341ea09", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:44:57Z", "type": "forcePushed"}, {"oid": "d8300dea9d9c6c22614791433365897b54db9b8a", "url": "https://github.com/apache/beam/commit/d8300dea9d9c6c22614791433365897b54db9b8a", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T21:43:37Z", "type": "forcePushed"}, {"oid": "43524190dc6e6d7101351902e98c8fd3402d743f", "url": "https://github.com/apache/beam/commit/43524190dc6e6d7101351902e98c8fd3402d743f", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-03T19:00:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwODU0Mw==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374408543", "bodyText": "s/parse/unparse/", "author": "apilloud", "createdAt": "2020-02-03T23:56:50Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -302,6 +316,38 @@ private void unparseTrim(SqlWriter writer, SqlCall call, int leftPrec, int right\n     writer.endFunCall(trimFrame);\n   }\n \n+  /**\n+   * For usage of INTERVAL, see <a\n+   * href=\"https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#timestamp_add\">\n+   * BQ TIMESTAMP_ADD function</a> for example.\n+   */\n+  private void unparseFunctionsUsingInterval(\n+      SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {\n+    // e.g. TIMESTAMP_ADD syntax:\n+    // TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)\n+    int operandCount = call.operandCount();\n+    if (operandCount == 2) {\n+      // operand0: timestamp_expression\n+      // operand1: SqlIntervalLiteral (INTERVAL int64_expression date_part)\n+      super.unparseCall(writer, call, leftPrec, rightPrec);\n+    } else if (operandCount == 3) {\n+      // operand0: timestamp_expression\n+      // operand1: int64_expression\n+      // operand2: date_part\n+      final SqlWriter.Frame frame = writer.startFunCall(call.getOperator().getName());\n+      call.operand(0).unparse(writer, leftPrec, rightPrec);\n+      writer.literal(\",\");\n+      writer.literal(\"INTERVAL\");\n+      call.operand(1).unparse(writer, leftPrec, rightPrec);\n+      call.operand(2).unparse(writer, leftPrec, rightPrec);\n+      writer.endFunCall(frame);\n+    } else {\n+      throw new IllegalArgumentException(\n+          String.format(\n+              \"Unable to parse %s with %d operands.\", call.getOperator().getName(), operandCount));", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjM2MA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374842360", "bodyText": "Fixed.", "author": "robinyqiu", "createdAt": "2020-02-04T18:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwODU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "acb046004dc3a828ee5fbb896741084d5690720d", "chunk": "diff --git a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java\nindex d9eedb1f61..0cf97a8e16 100644\n--- a/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java\n+++ b/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java\n\n@@ -344,7 +344,8 @@ public class BeamBigQuerySqlDialect extends BigQuerySqlDialect {\n     } else {\n       throw new IllegalArgumentException(\n           String.format(\n-              \"Unable to parse %s with %d operands.\", call.getOperator().getName(), operandCount));\n+              \"Unable to unparse %s with %d operands.\",\n+              call.getOperator().getName(), operandCount));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTAzMA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374409030", "bodyText": "\ud83d\udc4d Thanks. This actually adds quite a bit of complexity elsewhere.", "author": "apilloud", "createdAt": "2020-02-03T23:58:39Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -52,7 +51,6 @@\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedOrderByScan;\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedParameter;\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedProjectScan;\n-import io.grpc.Status;", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMDAzMw==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374410033", "bodyText": "Manually maintaining this list seems like no fun. What about using functionCall.getSignature().getResultType().getType()?", "author": "apilloud", "createdAt": "2020-02-04T00:02:14Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -770,88 +765,34 @@ private RexNode convertResolvedFunctionCall(\n           throw new UnsupportedOperationException(\n               \"Only support TUMBLE, HOP AND SESSION functions right now.\");\n       }\n-    } else if (functionCall.getFunction().getGroup().equals(\"ZetaSQL\")) {\n-      op =\n-          SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR.get(\n-              functionCall.getFunction().getName());\n-\n+    } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        throw new UnsupportedOperationException(\n-            \"Does not support ZetaSQL function: \" + functionCall.getFunction().getName());\n+        TypeKind returnType =\n+            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjkwMA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374842900", "bodyText": "Great suggestion! Removing the manual map simplifies the code quite a lot.", "author": "robinyqiu", "createdAt": "2020-02-04T18:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "acb046004dc3a828ee5fbb896741084d5690720d", "chunk": "diff --git a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\nindex 5e8d951747..feef354688 100644\n--- a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\n+++ b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\n\n@@ -767,12 +767,11 @@ public class ExpressionConverter {\n       }\n     } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        TypeKind returnType =\n-            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);\n+        Type returnType = functionCall.getSignature().getResultType().getType();\n         if (returnType != null) {\n           op =\n               SqlOperators.createSimpleSqlFunction(\n-                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType));\n+                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType.getKind()));\n         } else {\n           throw new UnsupportedOperationException(\"Does not support ZetaSQL function: \" + funName);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjAyNQ==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374412025", "bodyText": "This 'works' now but it is still not supported in our type system, so it might work inconsistently. (Microseconds will be dropped once we are out of ZetaSQLCalc.) Should we be making sure ZetaSQLCalc has the correct hooks to error if the user interacts with microsecond precision values?\ncc: @kennknowles", "author": "apilloud", "createdAt": "2020-02-04T00:09:21Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -770,88 +765,34 @@ private RexNode convertResolvedFunctionCall(\n           throw new UnsupportedOperationException(\n               \"Only support TUMBLE, HOP AND SESSION functions right now.\");\n       }\n-    } else if (functionCall.getFunction().getGroup().equals(\"ZetaSQL\")) {\n-      op =\n-          SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR.get(\n-              functionCall.getFunction().getName());\n-\n+    } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        throw new UnsupportedOperationException(\n-            \"Does not support ZetaSQL function: \" + functionCall.getFunction().getName());\n+        TypeKind returnType =\n+            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);\n+        if (returnType != null) {\n+          op =\n+              SqlOperators.createSimpleSqlFunction(\n+                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType));\n+        } else {\n+          throw new UnsupportedOperationException(\"Does not support ZetaSQL function: \" + funName);\n+        }\n       }\n \n-      // There are different processes to handle argument conversion because INTERVAL is not a\n-      // type in ZetaSQL.\n-      if (FUNCTION_FAMILY_DATE_ADD.contains(functionCall.getFunction().getName())) {\n-        return convertTimestampAddFunction(functionCall, columnList, fieldList);\n-      } else {\n-        for (ResolvedExpr expr : functionCall.getArgumentList()) {\n-          operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n-        }\n+      for (ResolvedExpr expr : functionCall.getArgumentList()) {\n+        operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Does not support function group: \" + functionCall.getFunction().getGroup());\n+      throw new UnsupportedOperationException(\"Does not support function group: \" + funGroup);\n     }\n \n     SqlOperatorRewriter rewriter =\n-        SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR_REWRITER.get(\n-            functionCall.getFunction().getName());\n+        SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR_REWRITER.get(funName);\n \n     if (rewriter != null) {\n-      ret = rewriter.apply(rexBuilder(), operands);\n+      return rewriter.apply(rexBuilder(), operands);\n     } else {\n-      ret = rexBuilder().makeCall(op, operands);\n-    }\n-    return ret;\n-  }\n-\n-  private RexNode convertTimestampAddFunction(\n-      ResolvedFunctionCall functionCall,\n-      List<ResolvedColumn> columnList,\n-      List<RelDataTypeField> fieldList) {\n-\n-    TimeUnit unit =\n-        TIME_UNIT_CASTING_MAP.get(\n-            ((ResolvedLiteral) functionCall.getArgumentList().get(2)).getValue().getEnumValue());\n-\n-    if ((unit == TimeUnit.MICROSECOND) || (unit == TimeUnit.NANOSECOND)) {", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NjE1MA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374846150", "bodyText": "Yeah right now it might work inconsistently. We can throw an exception during timestamp value conversion (here) if we see microsecond precision used, but I am not sure if we should do that. One  down side of that is we might break functions unnecessarily (e.g. CURRENT_TIMESTAMP). Or maybe we can leave it as it is and see if we can fully fix the precision problem? WDYT?", "author": "robinyqiu", "createdAt": "2020-02-04T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "acb046004dc3a828ee5fbb896741084d5690720d", "chunk": "diff --git a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\nindex 5e8d951747..feef354688 100644\n--- a/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\n+++ b/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java\n\n@@ -767,12 +767,11 @@ public class ExpressionConverter {\n       }\n     } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        TypeKind returnType =\n-            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);\n+        Type returnType = functionCall.getSignature().getResultType().getType();\n         if (returnType != null) {\n           op =\n               SqlOperators.createSimpleSqlFunction(\n-                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType));\n+                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType.getKind()));\n         } else {\n           throw new UnsupportedOperationException(\"Does not support ZetaSQL function: \" + funName);\n         }\n"}}, {"oid": "acb046004dc3a828ee5fbb896741084d5690720d", "url": "https://github.com/apache/beam/commit/acb046004dc3a828ee5fbb896741084d5690720d", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-04T18:08:33Z", "type": "commit"}, {"oid": "acb046004dc3a828ee5fbb896741084d5690720d", "url": "https://github.com/apache/beam/commit/acb046004dc3a828ee5fbb896741084d5690720d", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-04T18:08:33Z", "type": "forcePushed"}]}