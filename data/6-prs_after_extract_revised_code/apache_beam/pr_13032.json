{"pr_number": 13032, "pr_title": "[BEAM-11034] Avoid build-up of stateful garbage collection timers for\u2026", "pr_createdAt": "2020-10-07T10:52:25Z", "pr_url": "https://github.com/apache/beam/pull/13032", "timeline": [{"oid": "d9ff30b7f2a9a00e8c9d327c21711cb9960da15e", "url": "https://github.com/apache/beam/commit/d9ff30b7f2a9a00e8c9d327c21711cb9960da15e", "message": "[BEAM-11034] Avoid build-up of stateful garbage collection timers for GlobalWindow.\n\nSuch cleanup timers are not needed on the GlobalWindow for DoFn without\n@onWindowExpiration. It is a common pattern for users to use the global\nwindow for stateful processing for full control using state and timers.\nHowever if this is done for stages with unbounded keyspaces, the gc\ntimers build up indefinitely.", "committedDate": "2020-10-07T11:01:32Z", "type": "commit"}, {"oid": "d9ff30b7f2a9a00e8c9d327c21711cb9960da15e", "url": "https://github.com/apache/beam/commit/d9ff30b7f2a9a00e8c9d327c21711cb9960da15e", "message": "[BEAM-11034] Avoid build-up of stateful garbage collection timers for GlobalWindow.\n\nSuch cleanup timers are not needed on the GlobalWindow for DoFn without\n@onWindowExpiration. It is a common pattern for users to use the global\nwindow for stateful processing for full control using state and timers.\nHowever if this is done for stages with unbounded keyspaces, the gc\ntimers build up indefinitely.", "committedDate": "2020-10-07T11:01:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDEzMw==", "url": "https://github.com/apache/beam/pull/13032#discussion_r503400133", "bodyText": "Re-reading the bug and thinking about your comments, can we eliminate this condition and invoke from some onDrain method?", "author": "kennknowles", "createdAt": "2020-10-12T16:16:21Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/SimpleParDoFn.java", "diffHunk": "@@ -486,14 +487,23 @@ private void processTimers(\n     for (W window : windowsToCleanup) {\n       // The stepContext is the thing that know if it is batch or streaming, hence\n       // whether state needs to be cleaned up or will simply be discarded so the\n-      // timer can be ignored\n-\n+      // timer can be ignored.\n       Instant cleanupTime = earliestAllowableCleanupTime(window, windowingStrategy);\n-      // if DoFn has OnWindowExpiration then set holds for system timer.\n-      Instant cleanupOutputTimestamp =\n-          fnSignature.onWindowExpiration() == null ? cleanupTime : cleanupTime.minus(1L);\n-      stepContext.setStateCleanupTimer(\n-          CLEANUP_TIMER_ID, window, windowCoder, cleanupTime, cleanupOutputTimestamp);\n+      // Set a cleanup timer for state at the end of the window to trigger onWindowExpiration and\n+      // garbage collect state. We avoid doing this for the global window if there is no window\n+      // expiration set as the state will be up when the pipeline terminates. Setting the timer\n+      // leads to a unbounded growth of timers for pipelines with many unique keys in the global\n+      // window.\n+      if (cleanupTime.isBefore(GlobalWindow.INSTANCE.maxTimestamp())", "originalCommit": "d9ff30b7f2a9a00e8c9d327c21711cb9960da15e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MDMyNg==", "url": "https://github.com/apache/beam/pull/13032#discussion_r503470326", "bodyText": "I'm not sure I understand your suggestion.\nIf we eliminate this condition, we are back to always setting timers which ends up accumulating timers for the global window.  If we eliminate setting the timer if the user did not specify onWindowExpiration, we are removing the automatic cleanup of windowed user-state for the non global window.\nAre you are concerned about setting the timers if onWindowExpiration was requested for the global window? That is true, but at least the user can work around that by removing the onWindowExpiration annotation and modifying their code. Currently there is no mechanism in the dataflow streaming backend to scan and delivering an onDrain notification for all keys with user state, though that would be possible to add.  Any onDrain mechanism currently would have to be powered by timers set for the end of time, which would have the same issues as the cleanup timer.", "author": "scwhittle", "createdAt": "2020-10-12T18:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyNDA2MA==", "url": "https://github.com/apache/beam/pull/13032#discussion_r503524060", "bodyText": "I meant the latter - concerned about setting timers if onWindowExpiration was requested for the global window.\nI meant to imply us implementing some internal onDrain callback just for ParDoFn to receive. The backend would have to store all the keys & windows that need a callback, indeed. Perhaps just loudly warning that they have submitted a pipeline that could be trouble is best.\nAt some point we probably do want a user-facing onDrain rather than having them inspect the PaneInfo but that is a bigger conversation than this change.", "author": "kennknowles", "createdAt": "2020-10-12T20:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQwMDEzMw=="}], "type": "inlineReview", "revised_code": null}]}