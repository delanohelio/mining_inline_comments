{"pr_number": 11924, "pr_title": "[BEAM-8543] Dataflow streaming timers are not strictly time ordered when set earlier mid-bundle", "pr_createdAt": "2020-06-04T19:58:45Z", "pr_url": "https://github.com/apache/beam/pull/11924", "timeline": [{"oid": "9c1dd6a5e11eff6b450025ef1b82069f66d616a2", "url": "https://github.com/apache/beam/commit/9c1dd6a5e11eff6b450025ef1b82069f66d616a2", "message": "validated timer ordering", "committedDate": "2020-06-04T19:52:18Z", "type": "commit"}, {"oid": "b73c77003945073d69485692dc6df05ac570b063", "url": "https://github.com/apache/beam/commit/b73c77003945073d69485692dc6df05ac570b063", "message": "update changes.md", "committedDate": "2020-06-04T20:04:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NzI2NQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r436147265", "bodyText": "@kennknowles for comment. This doesn't look right to me, as I don't think we should be modifying the WindmillTimerInternals here. I think we just want to merge the timer modifications from processing the workitem into this priority queue; note that if timers are deleted, we need to detect that as well and remove from the priority queue.", "author": "reuvenlax", "createdAt": "2020-06-05T20:24:25Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -577,12 +583,21 @@ public void flushState() {\n                         WindmillTimerInternals.windmillTimerToTimerData(\n                             WindmillNamespacePrefix.USER_NAMESPACE_PREFIX, timer, windowCoder))\n                 .iterator();\n+\n+        cachedFiredUserTimers.forEachRemaining(toBeFiredTimersOrdered::add);\n+      }\n+\n+      Instant currentInputWatermark = userTimerInternals.currentInputWatermarkTime();\n+      if (userTimerInternals.hasTimerBefore(currentInputWatermark)) {\n+        while (!toBeFiredTimersOrdered.isEmpty()) {\n+          userTimerInternals.setTimer(toBeFiredTimersOrdered.poll());\n+        }\n       }", "originalCommit": "b73c77003945073d69485692dc6df05ac570b063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MzIyMA==", "url": "https://github.com/apache/beam/pull/11924#discussion_r436173220", "bodyText": "Yea I don't actually understand what this block is for.\nFWIW to do timer deletion/reset cheaply without building a bespoke data structure just keep a map from id to firing time or tombstone. This way, whenever a timer comes up in the prio queue you pull out the actual time for it from the map. If it is actually set for another time, don't fire it. If it is obsolete, don't fire it.", "author": "kennknowles", "createdAt": "2020-06-05T21:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NzI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNjk2OQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r438306969", "bodyText": "@reuvenlax  done", "author": "rehmanmuradali", "createdAt": "2020-06-10T17:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NzI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fba4c3d90302eede9a9741938de06b6260f158fc", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\nindex 42e7639030..2fe183243a 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n\n@@ -582,22 +576,72 @@ public class StreamingModeExecutionContext extends DataflowExecutionContext<Step\n                     timer ->\n                         WindmillTimerInternals.windmillTimerToTimerData(\n                             WindmillNamespacePrefix.USER_NAMESPACE_PREFIX, timer, windowCoder))\n-                .iterator();\n-\n-        cachedFiredUserTimers.forEachRemaining(toBeFiredTimersOrdered::add);\n+                .iterator()\n+                .forEachRemaining(toBeFiredTimersOrdered::add);\n       }\n \n+      LOG.info(\"Queue content: \" + Arrays.toString(toBeFiredTimersOrdered.toArray()));\n+\n+      LOG.info(\"timer Internals timers: \" + userTimerInternals.timers);\n+\n       Instant currentInputWatermark = userTimerInternals.currentInputWatermarkTime();\n       if (userTimerInternals.hasTimerBefore(currentInputWatermark)) {\n-        while (!toBeFiredTimersOrdered.isEmpty()) {\n-          userTimerInternals.setTimer(toBeFiredTimersOrdered.poll());\n+        LOG.info(\"Yaya!! timer contains updates \");\n+\n+        for (Table.Cell<String, StateNamespace, Boolean> cell : userTimerInternals.timerStillPresent.cellSet()) {\n+          TimerData timerData = userTimerInternals.timers.get(cell.getRowKey(), cell.getColumnKey());\n+          if (cell.getValue()) {\n+            LOG.info(\"Adding timer in queue:  \" + timerData);\n+            //firedTimer.put(timerData.getTimerId() + '+' + timerData.getTimerFamilyId(), timerData.getTimestamp());\n+            toBeFiredTimersOrdered.add(timerData);\n+\n+          }\n         }\n+\n       }\n \n+\n+\n+      /*\n+      TimerData nextTimer = null;\n+      while (!toBeFiredTimersOrdered.isEmpty()){\n+        nextTimer = toBeFiredTimersOrdered.poll();\n+        if(firedTimer.containsKey(nextTimer.getTimerId())){\n+          LOG.info(\"Timer Already fired betaa\" + nextTimer);\n+          userTimerInternals.deleteTimer(nextTimer);\n+          nextTimer = null;\n+        }\n+        else {\n+          break;\n+        }\n+      }\n+\n+      if (nextTimer == null) {\n+        return null;\n+      }\n+*/\n+\n       if (toBeFiredTimersOrdered.isEmpty()) {\n         return null;\n       }\n+\n       TimerData nextTimer = toBeFiredTimersOrdered.poll();\n+      LOG.info(\n+          \"Polled timer: Id: \"\n+              + nextTimer.getTimerId()\n+              + \" timestamp: \"\n+              + nextTimer.getTimestamp());\n+      LOG.info(\"Queue content after timer poll : \" + Arrays.toString(toBeFiredTimersOrdered.toArray()));\n+\n+      String timerUniqueId = nextTimer.getTimerId() +  '+' + nextTimer.getTimerFamilyId();\n+      if(firedTimer.containsKey(timerUniqueId)){\n+        Instant instant = firedTimer.get(timerUniqueId);\n+        LOG.info(\"Timer \" + timerUniqueId +\" already fired with timestamp: \"  +  instant);\n+      }\n+\n+\n+      firedTimer.put(nextTimer.getTimerId() + '+' + nextTimer.getTimerFamilyId(), nextTimer.getTimestamp());\n+\n       // User timers must be explicitly deleted when delivered, to release the implied hold\n       userTimerInternals.deleteTimer(nextTimer);\n       return nextTimer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MTc4Nw==", "url": "https://github.com/apache/beam/pull/11924#discussion_r436171787", "bodyText": "Do we even need cachedFiredUserTimers? It seems obsolete if we populate the priority queue. The name is also wrong - even before this PR it wasn't a cache. It is a lazily initialized iterator. Instead, we should have a lazily initialized priority queue (like you do) and just a flag to say whether the incoming timers have been loaded yet.", "author": "kennknowles", "createdAt": "2020-06-05T21:27:10Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -577,12 +583,21 @@ public void flushState() {\n                         WindmillTimerInternals.windmillTimerToTimerData(\n                             WindmillNamespacePrefix.USER_NAMESPACE_PREFIX, timer, windowCoder))\n                 .iterator();\n+\n+        cachedFiredUserTimers.forEachRemaining(toBeFiredTimersOrdered::add);", "originalCommit": "b73c77003945073d69485692dc6df05ac570b063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNzYyMQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r438307621", "bodyText": "done", "author": "rehmanmuradali", "createdAt": "2020-06-10T17:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MTc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fba4c3d90302eede9a9741938de06b6260f158fc", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\nindex 42e7639030..2fe183243a 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n\n@@ -582,22 +576,72 @@ public class StreamingModeExecutionContext extends DataflowExecutionContext<Step\n                     timer ->\n                         WindmillTimerInternals.windmillTimerToTimerData(\n                             WindmillNamespacePrefix.USER_NAMESPACE_PREFIX, timer, windowCoder))\n-                .iterator();\n-\n-        cachedFiredUserTimers.forEachRemaining(toBeFiredTimersOrdered::add);\n+                .iterator()\n+                .forEachRemaining(toBeFiredTimersOrdered::add);\n       }\n \n+      LOG.info(\"Queue content: \" + Arrays.toString(toBeFiredTimersOrdered.toArray()));\n+\n+      LOG.info(\"timer Internals timers: \" + userTimerInternals.timers);\n+\n       Instant currentInputWatermark = userTimerInternals.currentInputWatermarkTime();\n       if (userTimerInternals.hasTimerBefore(currentInputWatermark)) {\n-        while (!toBeFiredTimersOrdered.isEmpty()) {\n-          userTimerInternals.setTimer(toBeFiredTimersOrdered.poll());\n+        LOG.info(\"Yaya!! timer contains updates \");\n+\n+        for (Table.Cell<String, StateNamespace, Boolean> cell : userTimerInternals.timerStillPresent.cellSet()) {\n+          TimerData timerData = userTimerInternals.timers.get(cell.getRowKey(), cell.getColumnKey());\n+          if (cell.getValue()) {\n+            LOG.info(\"Adding timer in queue:  \" + timerData);\n+            //firedTimer.put(timerData.getTimerId() + '+' + timerData.getTimerFamilyId(), timerData.getTimestamp());\n+            toBeFiredTimersOrdered.add(timerData);\n+\n+          }\n         }\n+\n       }\n \n+\n+\n+      /*\n+      TimerData nextTimer = null;\n+      while (!toBeFiredTimersOrdered.isEmpty()){\n+        nextTimer = toBeFiredTimersOrdered.poll();\n+        if(firedTimer.containsKey(nextTimer.getTimerId())){\n+          LOG.info(\"Timer Already fired betaa\" + nextTimer);\n+          userTimerInternals.deleteTimer(nextTimer);\n+          nextTimer = null;\n+        }\n+        else {\n+          break;\n+        }\n+      }\n+\n+      if (nextTimer == null) {\n+        return null;\n+      }\n+*/\n+\n       if (toBeFiredTimersOrdered.isEmpty()) {\n         return null;\n       }\n+\n       TimerData nextTimer = toBeFiredTimersOrdered.poll();\n+      LOG.info(\n+          \"Polled timer: Id: \"\n+              + nextTimer.getTimerId()\n+              + \" timestamp: \"\n+              + nextTimer.getTimestamp());\n+      LOG.info(\"Queue content after timer poll : \" + Arrays.toString(toBeFiredTimersOrdered.toArray()));\n+\n+      String timerUniqueId = nextTimer.getTimerId() +  '+' + nextTimer.getTimerFamilyId();\n+      if(firedTimer.containsKey(timerUniqueId)){\n+        Instant instant = firedTimer.get(timerUniqueId);\n+        LOG.info(\"Timer \" + timerUniqueId +\" already fired with timestamp: \"  +  instant);\n+      }\n+\n+\n+      firedTimer.put(nextTimer.getTimerId() + '+' + nextTimer.getTimerFamilyId(), nextTimer.getTimestamp());\n+\n       // User timers must be explicitly deleted when delivered, to release the implied hold\n       userTimerInternals.deleteTimer(nextTimer);\n       return nextTimer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3Mzc3OQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r436173779", "bodyText": "Why shrink it? Does the test get really slow? Is this going to be a perf problem overall?", "author": "kennknowles", "createdAt": "2020-06-05T21:33:03Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3938,10 +3939,11 @@ public void testEventTimeTimerOrdering() throws Exception {\n       ValidatesRunner.class,\n       UsesTimersInParDo.class,\n       UsesStatefulParDo.class,\n+      UsesUnboundedPCollections.class,\n       UsesStrictTimerOrdering.class\n     })\n     public void testEventTimeTimerOrderingWithCreate() throws Exception {\n-      final int numTestElements = 100;\n+      final int numTestElements = 5;", "originalCommit": "b73c77003945073d69485692dc6df05ac570b063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNzI4MQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r438307281", "bodyText": "reverted.", "author": "rehmanmuradali", "createdAt": "2020-06-10T17:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3Mzc3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fba4c3d90302eede9a9741938de06b6260f158fc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex 34d0d0b40f..412380fa40 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -3930,11 +3932,35 @@ public class ParDoTest implements Serializable {\n       }\n \n       testEventTimeTimerOrderingWithInputPTransform(\n-          now, numTestElements, builder.advanceWatermarkToInfinity());\n+          now, numTestElements, builder.advanceWatermarkToInfinity(), false);\n     }\n \n     /** A test makes sure that an event time timers are correctly ordered using Create transform. */\n     @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesTimersInParDo.class,\n+      UsesStatefulParDo.class,\n+      UsesStrictTimerOrdering.class\n+    })\n+    public void testEventTimeTimerOrderingWithCreateBounded() throws Exception {\n+      final int numTestElements = 100;\n+      final Instant now = new Instant(1500000000000L);\n+\n+      List<TimestampedValue<KV<String, String>>> elements = new ArrayList<>();\n+      for (int i = 0; i < numTestElements; i++) {\n+        elements.add(TimestampedValue.of(KV.of(\"dummy\", \"\" + i), now.plus(i)));\n+      }\n+\n+      testEventTimeTimerOrderingWithInputPTransform(\n+          now, numTestElements, Create.timestamped(elements), false);\n+    }\n+\n+    /**\n+     * A test makes sure that an event time timers are correctly ordered using Create transform\n+     * unbounded.\n+     */\n+    @Test\n     @Category({\n       ValidatesRunner.class,\n       UsesTimersInParDo.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDI5NQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r436174295", "bodyText": "Should not be calling setIsBoundedInternal here. Is this just to force streaming mode? We need to just create a separate run of ValidatesRunner that forces streaming mode.", "author": "kennknowles", "createdAt": "2020-06-05T21:34:40Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -4040,7 +4043,8 @@ public void onTimer(\n             }\n           };\n \n-      PCollection<String> output = pipeline.apply(transform).apply(ParDo.of(fn));\n+      PCollection<String> output =\n+          pipeline.apply(transform).setIsBoundedInternal(IsBounded.UNBOUNDED).apply(ParDo.of(fn));", "originalCommit": "b73c77003945073d69485692dc6df05ac570b063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNzQzNw==", "url": "https://github.com/apache/beam/pull/11924#discussion_r438307437", "bodyText": "Added a new test case", "author": "rehmanmuradali", "createdAt": "2020-06-10T17:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDI5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fba4c3d90302eede9a9741938de06b6260f158fc", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex 34d0d0b40f..412380fa40 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -4044,7 +4076,10 @@ public class ParDoTest implements Serializable {\n           };\n \n       PCollection<String> output =\n-          pipeline.apply(transform).setIsBoundedInternal(IsBounded.UNBOUNDED).apply(ParDo.of(fn));\n+          pipeline\n+              .apply(transform)\n+              .setIsBoundedInternal(isStreaming ? IsBounded.UNBOUNDED : IsBounded.BOUNDED)\n+              .apply(ParDo.of(fn));\n       List<String> expected =\n           IntStream.rangeClosed(0, numTestElements)\n               .mapToObj(expandFn(numTestElements))\n"}}, {"oid": "fba4c3d90302eede9a9741938de06b6260f158fc", "url": "https://github.com/apache/beam/commit/fba4c3d90302eede9a9741938de06b6260f158fc", "message": "Strict timer ordering without resetting timer", "committedDate": "2020-06-09T13:53:55Z", "type": "commit"}, {"oid": "032bde5a107c2ba0327eff426047b0ac083715ec", "url": "https://github.com/apache/beam/commit/032bde5a107c2ba0327eff426047b0ac083715ec", "message": "maintain strict ordering + timer reset", "committedDate": "2020-06-09T18:51:21Z", "type": "commit"}, {"oid": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "url": "https://github.com/apache/beam/commit/abd93ecde23701e0d0c63bfaaf10785ca0be332a", "message": "adding comments", "committedDate": "2020-06-10T16:14:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyOTc2Nw==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459729767", "bodyText": "Please keep the imports all explicit.", "author": "kennknowles", "createdAt": "2020-07-23T21:09:50Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -24,18 +24,11 @@\n import com.google.api.services.dataflow.model.SideInputInfo;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dc7b614d452e370d719f1b1198622717a450bbbb", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\nindex 90263f5d6e..83361f6ff9 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n\n@@ -24,11 +24,17 @@ import com.google.api.services.dataflow.model.CounterUpdate;\n import com.google.api.services.dataflow.model.SideInputInfo;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.atomic.AtomicLong;\n-import javax.annotation.Nullable;\n-import org.apache.beam.runners.core.*;\n+import org.apache.beam.runners.core.SideInputReader;\n+import org.apache.beam.runners.core.StateInternals;\n+import org.apache.beam.runners.core.StateNamespaces;\n+import org.apache.beam.runners.core.TimerInternals;\n import org.apache.beam.runners.core.TimerInternals.TimerData;\n import org.apache.beam.runners.core.metrics.ExecutionStateTracker;\n import org.apache.beam.runners.core.metrics.ExecutionStateTracker.ExecutionState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDM0OQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459730349", "bodyText": "Can you add a comment about what are the keys and values of this map?", "author": "kennknowles", "createdAt": "2020-07-23T21:11:06Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java", "diffHunk": "@@ -561,28 +554,64 @@ public void flushState() {\n       return nextTimer;\n     }\n \n-    // Lazily initialized\n-    private Iterator<TimerData> cachedFiredUserTimers = null;\n+    private PriorityQueue<TimerData> toBeFiredTimersOrdered = null;\n+\n+    // to track if timer is reset earlier mid-bundle.", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyNzI3Ng==", "url": "https://github.com/apache/beam/pull/11924#discussion_r462327276", "bodyText": "Added", "author": "rehmanmuradali", "createdAt": "2020-07-29T14:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMDM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "10487f0a4097bc51a55bf26256fed61f7ae25532", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\nindex 90263f5d6e..334f145d5e 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n\n@@ -557,6 +564,8 @@ public class StreamingModeExecutionContext extends DataflowExecutionContext<Step\n     private PriorityQueue<TimerData> toBeFiredTimersOrdered = null;\n \n     // to track if timer is reset earlier mid-bundle.\n+    // Map of timer's id to timer's firing time to check\n+    // the actual firing time of a timer.\n     private Map<String, Instant> firedTimer = new HashMap<>();\n \n     public <W extends BoundedWindow> TimerData getNextFiredUserTimer(Coder<W> windowCoder) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzI1NQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459733255", "bodyText": "This doesn't depend on streaming or not, but just controls whether the pcollection should be bounded or unbounded. For clarity, you can just make this parameter IsBounded isBounded", "author": "kennknowles", "createdAt": "2020-07-23T21:17:33Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -3950,13 +3950,39 @@ public void testEventTimeTimerOrderingWithCreate() throws Exception {\n       }\n \n       testEventTimeTimerOrderingWithInputPTransform(\n-          now, numTestElements, Create.timestamped(elements));\n+          now, numTestElements, Create.timestamped(elements), false);\n+    }\n+\n+    /**\n+     * A test makes sure that an event time timers are correctly ordered using Create transform\n+     * unbounded.\n+     */\n+    @Test\n+    @Category({\n+      ValidatesRunner.class,\n+      UsesTimersInParDo.class,\n+      UsesStatefulParDo.class,\n+      UsesUnboundedPCollections.class,\n+      UsesStrictTimerOrdering.class\n+    })\n+    public void testEventTimeTimerOrderingWithCreateUnbounded() throws Exception {\n+      final int numTestElements = 100;\n+      final Instant now = new Instant(1500000000000L);\n+\n+      List<TimestampedValue<KV<String, String>>> elements = new ArrayList<>();\n+      for (int i = 0; i < numTestElements; i++) {\n+        elements.add(TimestampedValue.of(KV.of(\"dummy\", \"\" + i), now.plus(i)));\n+      }\n+\n+      testEventTimeTimerOrderingWithInputPTransform(\n+          now, numTestElements, Create.timestamped(elements), true);\n     }\n \n     private void testEventTimeTimerOrderingWithInputPTransform(\n         Instant now,\n         int numTestElements,\n-        PTransform<PBegin, PCollection<KV<String, String>>> transform)\n+        PTransform<PBegin, PCollection<KV<String, String>>> transform,\n+        boolean isStreaming)", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyNzQ3Ng==", "url": "https://github.com/apache/beam/pull/11924#discussion_r462327476", "bodyText": "Changed to IsBounded", "author": "rehmanmuradali", "createdAt": "2020-07-29T14:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "dc7b614d452e370d719f1b1198622717a450bbbb", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex ac04c9ca45..6823cfadcd 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -3946,7 +3976,7 @@ public class ParDoTest implements Serializable {\n \n       List<TimestampedValue<KV<String, String>>> elements = new ArrayList<>();\n       for (int i = 0; i < numTestElements; i++) {\n-        elements.add(TimestampedValue.of(KV.of(\"dummy\", \"\" + i), now.plus(i)));\n+        elements.add(TimestampedValue.of(KV.of(\"dummy\", \"\" + i), now.plus(i * 1000)));\n       }\n \n       testEventTimeTimerOrderingWithInputPTransform(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzM4MA==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459733380", "bodyText": "same here", "author": "kennknowles", "createdAt": "2020-07-23T21:17:49Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -4307,18 +4346,26 @@ public void onTimer(\n     private static class TwoTimerTest extends PTransform<PBegin, PDone> {\n \n       private static PTransform<PBegin, PDone> of(\n-          Instant start, Instant end, PTransform<PBegin, PCollection<KV<Void, Void>>> input) {\n-        return new TwoTimerTest(start, end, input);\n+          Instant start,\n+          Instant end,\n+          PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n+          boolean isStreaming) {", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10487f0a4097bc51a55bf26256fed61f7ae25532", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex ac04c9ca45..776fd3e262 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -4349,23 +4376,23 @@ public class ParDoTest implements Serializable {\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n-        return new TwoTimerTest(start, end, input, isStreaming);\n+          IsBounded isBounded) {\n+        return new TwoTimerTest(start, end, input, isBounded);\n       }\n \n       private final Instant start;\n       private final Instant end;\n-      private final boolean isStreaming;\n+      private final IsBounded isBounded;\n       private final transient PTransform<PBegin, PCollection<KV<Void, Void>>> inputPTransform;\n \n       public TwoTimerTest(\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n+          IsBounded isBounded) {\n         this.start = start;\n         this.end = end;\n-        this.isStreaming = isStreaming;\n+        this.isBounded = isBounded;\n         this.inputPTransform = input;\n       }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzUwOA==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459733508", "bodyText": "same here", "author": "kennknowles", "createdAt": "2020-07-23T21:18:04Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -4307,18 +4346,26 @@ public void onTimer(\n     private static class TwoTimerTest extends PTransform<PBegin, PDone> {\n \n       private static PTransform<PBegin, PDone> of(\n-          Instant start, Instant end, PTransform<PBegin, PCollection<KV<Void, Void>>> input) {\n-        return new TwoTimerTest(start, end, input);\n+          Instant start,\n+          Instant end,\n+          PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n+          boolean isStreaming) {\n+        return new TwoTimerTest(start, end, input, isStreaming);\n       }\n \n       private final Instant start;\n       private final Instant end;\n+      private final boolean isStreaming;", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyNzc4OQ==", "url": "https://github.com/apache/beam/pull/11924#discussion_r462327789", "bodyText": "done", "author": "rehmanmuradali", "createdAt": "2020-07-29T14:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "10487f0a4097bc51a55bf26256fed61f7ae25532", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex ac04c9ca45..776fd3e262 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -4349,23 +4376,23 @@ public class ParDoTest implements Serializable {\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n-        return new TwoTimerTest(start, end, input, isStreaming);\n+          IsBounded isBounded) {\n+        return new TwoTimerTest(start, end, input, isBounded);\n       }\n \n       private final Instant start;\n       private final Instant end;\n-      private final boolean isStreaming;\n+      private final IsBounded isBounded;\n       private final transient PTransform<PBegin, PCollection<KV<Void, Void>>> inputPTransform;\n \n       public TwoTimerTest(\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n+          IsBounded isBounded) {\n         this.start = start;\n         this.end = end;\n-        this.isStreaming = isStreaming;\n+        this.isBounded = isBounded;\n         this.inputPTransform = input;\n       }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzU1Ng==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459733556", "bodyText": "same here", "author": "kennknowles", "createdAt": "2020-07-23T21:18:11Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -4307,18 +4346,26 @@ public void onTimer(\n     private static class TwoTimerTest extends PTransform<PBegin, PDone> {\n \n       private static PTransform<PBegin, PDone> of(\n-          Instant start, Instant end, PTransform<PBegin, PCollection<KV<Void, Void>>> input) {\n-        return new TwoTimerTest(start, end, input);\n+          Instant start,\n+          Instant end,\n+          PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n+          boolean isStreaming) {\n+        return new TwoTimerTest(start, end, input, isStreaming);\n       }\n \n       private final Instant start;\n       private final Instant end;\n+      private final boolean isStreaming;\n       private final transient PTransform<PBegin, PCollection<KV<Void, Void>>> inputPTransform;\n \n       public TwoTimerTest(\n-          Instant start, Instant end, PTransform<PBegin, PCollection<KV<Void, Void>>> input) {\n+          Instant start,\n+          Instant end,\n+          PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n+          boolean isStreaming) {", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyNzcxMA==", "url": "https://github.com/apache/beam/pull/11924#discussion_r462327710", "bodyText": "done", "author": "rehmanmuradali", "createdAt": "2020-07-29T14:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "10487f0a4097bc51a55bf26256fed61f7ae25532", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex ac04c9ca45..776fd3e262 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -4349,23 +4376,23 @@ public class ParDoTest implements Serializable {\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n-        return new TwoTimerTest(start, end, input, isStreaming);\n+          IsBounded isBounded) {\n+        return new TwoTimerTest(start, end, input, isBounded);\n       }\n \n       private final Instant start;\n       private final Instant end;\n-      private final boolean isStreaming;\n+      private final IsBounded isBounded;\n       private final transient PTransform<PBegin, PCollection<KV<Void, Void>>> inputPTransform;\n \n       public TwoTimerTest(\n           Instant start,\n           Instant end,\n           PTransform<PBegin, PCollection<KV<Void, Void>>> input,\n-          boolean isStreaming) {\n+          IsBounded isBounded) {\n         this.start = start;\n         this.end = end;\n-        this.isStreaming = isStreaming;\n+        this.isBounded = isBounded;\n         this.inputPTransform = input;\n       }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNDE5Ng==", "url": "https://github.com/apache/beam/pull/11924#discussion_r459734196", "bodyText": "Another way to do this that might be better is to use TestStream in the unbounded case. This will probably give best coverage. Even for an unbounded PCollection the watermark might instantly move to infinity.", "author": "kennknowles", "createdAt": "2020-07-23T21:19:37Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java", "diffHunk": "@@ -4331,6 +4378,7 @@ public PDone expand(PBegin input) {\n         PCollection<String> result =\n             input\n                 .apply(inputPTransform)\n+                .setIsBoundedInternal(isStreaming ? IsBounded.UNBOUNDED : IsBounded.BOUNDED)", "originalCommit": "abd93ecde23701e0d0c63bfaaf10785ca0be332a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10487f0a4097bc51a55bf26256fed61f7ae25532", "chunk": "diff --git a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\nindex ac04c9ca45..776fd3e262 100644\n--- a/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n+++ b/sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/ParDoTest.java\n\n@@ -4378,7 +4405,7 @@ public class ParDoTest implements Serializable {\n         PCollection<String> result =\n             input\n                 .apply(inputPTransform)\n-                .setIsBoundedInternal(isStreaming ? IsBounded.UNBOUNDED : IsBounded.BOUNDED)\n+                .setIsBoundedInternal(isBounded)\n                 .apply(\n                     ParDo.of(\n                         new DoFn<KV<Void, Void>, String>() {\n"}}, {"oid": "dc7b614d452e370d719f1b1198622717a450bbbb", "url": "https://github.com/apache/beam/commit/dc7b614d452e370d719f1b1198622717a450bbbb", "message": "Merge branch 'master' into feature/BEAM-8543\n\n# Conflicts:\n#\trunners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/StreamingModeExecutionContext.java\n#\trunners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/WindmillTimerInternals.java", "committedDate": "2020-07-27T08:47:45Z", "type": "commit"}, {"oid": "10487f0a4097bc51a55bf26256fed61f7ae25532", "url": "https://github.com/apache/beam/commit/10487f0a4097bc51a55bf26256fed61f7ae25532", "message": "Replace isStreaming with isBounded", "committedDate": "2020-07-29T13:49:22Z", "type": "commit"}]}