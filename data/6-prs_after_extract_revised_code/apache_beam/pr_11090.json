{"pr_number": 11090, "pr_title": "[BEAM-9470] :sdks:java:io:kinesis:test is flaky", "pr_createdAt": "2020-03-10T03:00:25Z", "pr_url": "https://github.com/apache/beam/pull/11090", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ==", "url": "https://github.com/apache/beam/pull/11090#discussion_r390376749", "bodyText": "Would you share your thought on in why customRateLimitPolicy did not take [d] even when it took [a, b] and [c]?\nI'd like to know more about the problem in \"the order of concurrent operations\" in this test case.\nhttps://builds.apache.org/job/beam_PreCommit_Java_Commit/10277/testReport/junit/org.apache.beam.sdk.io.kinesis/ShardReadersPoolTest/shouldCallRateLimitPolicy/\n\nArgument(s) are different! Wanted:\ncustomRateLimitPolicy.onSuccess(\n[d]\n);\n-> at org.apache.beam.sdk.io.kinesis.ShardReadersPoolTest.shouldCallRateLimitPolicy(ShardReadersPoolTest.java:330)", "author": "suztomo", "createdAt": "2020-03-10T14:56:39Z", "path": "sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java", "diffHunk": "@@ -324,10 +325,15 @@ public void shouldCallRateLimitPolicy()\n       }\n     }\n \n+    ArgumentCaptor<List<KinesisRecord>> recordsCaptor = ArgumentCaptor.forClass(List.class);\n+    verify(customRateLimitPolicy, atLeastOnce()).onSuccess(recordsCaptor.capture());\n+    List<List<KinesisRecord>> capturedRecords = recordsCaptor.getAllValues();\n+    assertThat(capturedRecords).contains(\n+        ImmutableList.of(a, b),\n+        singletonList(c),\n+        singletonList(d),\n+        Collections.emptyList()\n+    );\n     verify(customRateLimitPolicy).onThrottle(same(e));\n-    verify(customRateLimitPolicy).onSuccess(eq(ImmutableList.of(a, b)));\n-    verify(customRateLimitPolicy).onSuccess(eq(singletonList(c)));\n-    verify(customRateLimitPolicy).onSuccess(eq(singletonList(d)));", "originalCommit": "a600145bd91e6fc5f09f6e2967d80fb833e3611d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMDk3Mg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r390700972", "bodyText": "@suztomo My thought is that Mockito is expecting to see these parameters in this order, which may not always be the case due to the 2 ShardReadersPool worker threads. My suggested fix is to rewrite the Mockito verifications so that they are definitely not dependent on order.", "author": "jfarr", "createdAt": "2020-03-11T01:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNjQ1Nw==", "url": "https://github.com/apache/beam/pull/11090#discussion_r390736457", "bodyText": "Thank you for response. I still need your help here. Mockito is not supposed to check the order of the method calls (unless configured to use inOrder). I checked its behavior with the following code:\n\nDo you know something special in this test case that makes mockito's verify order sensitive?", "author": "suztomo", "createdAt": "2020-03-11T04:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2MjYzNQ==", "url": "https://github.com/apache/beam/pull/11090#discussion_r390762635", "bodyText": "Thanks, that's how I thought Mockito.verify() worked too but this made me doubt it. I didn't do any detailed testing, though, so thanks for taking the time to validate. I'm honestly at a loss for what could be causing intermittent failures then. All I can say is this version of the test is semantically equivalent and might not be subject to the same failure mode. I have not been able to reproduce the failure myself.", "author": "jfarr", "createdAt": "2020-03-11T06:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwMjUzOA==", "url": "https://github.com/apache/beam/pull/11090#discussion_r390902538", "bodyText": "How about writing one-off code that invokes this problematic test case, say, 100 times and count test failures?  We can verify whether your version fixes the flakiness.\nI don\u2019t expect that one-off code to be checked in, but attaching the observation and the code snippet to PR is helpful.", "author": "suztomo", "createdAt": "2020-03-11T11:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1MTI5Ng==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391151296", "bodyText": "I did run this test thousands of times locally (with @RepeatedTest(10000) and some hacks to run it on Junit5) and I've managed to reproduce it only twice with the similar but a bit different error as it was on Jenkins.\nJenkins error: https://gist.github.com/aromanenko-dev/f9714c3dd5a47a9439b9245f3ef7b04b\nMy local error (old test version): https://gist.github.com/aromanenko-dev/9a8acf265b96e010ad0ad1d09bb3ab92\nThe common thing there is that it starts to emit empty records list after it returned a list with c value.\nAlso, I did the same thing for new version of test and it's also reproducible (2 fails over 1000 runs):\nMy local error (new test version) 1st fail: https://gist.github.com/aromanenko-dev/faa4229a486117d7504e486282503009\nMy local error (new test version) 2nd fail: https://gist.github.com/aromanenko-dev/751cd007bb89a4f6e67f1ce9f9ef3d25\nAs you can see actually the errors with old and new versions of tests are similar. So, it seems that it's not related to verify using and more related to how every mock ShardRecordsIterator returns the records. For some reasons it starts to return just empty list.", "author": "aromanenko-dev", "createdAt": "2020-03-11T17:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyODgzMg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391228832", "bodyText": "@aromanenko-dev Thank you for sharing your result.", "author": "suztomo", "createdAt": "2020-03-11T19:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MTUwNg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391291506", "bodyText": "Yes, thanks Alexey. I was just working on something similar. Maybe the test is just overspecified then. I propose we change the validations to just:\nverify(customRateLimitPolicy).onThrottle(any(KinesisClientThrottledException.class));\nverify(customRateLimitPolicy, atLeastOnce()).onSuccess(any(List.class));\n\nIf you both agree I'll make that change.", "author": "jfarr", "createdAt": "2020-03-11T21:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMDM4Nw==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391300387", "bodyText": "I disagree (I\u2019m not a committer). We just revealed a bug, which is very hard to reproduce.\n@aromanenko-dev\n\n@RepeatedTest(10000) and some hacks to run it on Junit5\n\nWould you share this?", "author": "suztomo", "createdAt": "2020-03-11T22:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTgzMA==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391341830", "bodyText": "Would you share this?\n\n+1, please\n@suztomo What bug are you suggesting this exposes?", "author": "jfarr", "createdAt": "2020-03-12T00:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM2NTcxNg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391365716", "bodyText": "bug: sometimes customRateLimitPolicy does not receive items, \"[d]\" in the test case.", "author": "suztomo", "createdAt": "2020-03-12T02:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM4OTUzOA==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391389538", "bodyText": "@suztomo You have a good point. The intention of this test is to validate that every time readNextBatch() returns a list of records onSuccess() gets called and every time it throws KinesisClientThrottledException onThrottle() gets called. I can see a couple of code paths where readNextBatch() could return records without onSuccess() getting called, namely if any exceptions are thrown along in here: \n  \n    \n      beam/sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java\n    \n    \n        Lines 146 to 149\n      in\n      d62521f\n    \n    \n    \n    \n\n        \n          \n           for (KinesisRecord kinesisRecord : kinesisRecords) { \n        \n\n        \n          \n             recordsQueue.put(kinesisRecord); \n        \n\n        \n          \n             numberOfRecordsInAQueueByShard.get(kinesisRecord.getShardId()).incrementAndGet(); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI haven't seen evidence that this is what's happening, but let's try my latest changes in ShardReadersPool and see if that fixes it. With this change it should not be possible for readNextBatch() to return without onSuccess() being called.", "author": "jfarr", "createdAt": "2020-03-12T03:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5MDI5OQ==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391390299", "bodyText": "@aromanenko-dev If you could share with us how you got @RepeatedTest working I'd be happy to retest.", "author": "jfarr", "createdAt": "2020-03-12T04:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ4NDIzOQ==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391484239", "bodyText": "Sure, this patch is enough to run only this test shouldCallRateLimitPolicy() with Junit 5:\nhttps://gist.github.com/aromanenko-dev/02c4b206bd7c64bec3ee7a4e3588a5b6\nI know it's a not perfect solution, very hacky, but it allowed to run this test as much time as I need. I didn't test other tests, so plz don't blame me if something doesn't work =)\nSorry for delay, I guess I'm in a different time zone with you.", "author": "aromanenko-dev", "createdAt": "2020-03-12T09:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NTMyOQ==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391685329", "bodyText": "@aromanenko-dev Thank you very much. I can now reproduce the problem.\n\nEveryone is in different time zones.", "author": "suztomo", "createdAt": "2020-03-12T15:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MjA4Mg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391692082", "bodyText": "What I can guess for now is that firstIterator and secondIterator are executed in different threads (since readLoop() is called for every topic shard in the separate thread) and for some reasons sometimes one thread takes more priority over the second while running and the secondIterator doesn't have a chance to return \"d\" record since shardReadersPool got closed.\nPS: Interesting that on Jenkins it's much easier reproducible than locally.", "author": "aromanenko-dev", "createdAt": "2020-03-12T15:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3OTU1Ng==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391779556", "bodyText": "I did some testing on my side and I think that the problem is with using the same mock of RateLimitPolicy for both ShardRecordsIterators calling in different threads. For example, when failed assertion says that \"d\" record is absent in capturedRecords, actually I see (using debug output) that it was read with shardRecordsIterator.readNextBatch() in readLoop().\nSince, in case of using the real RateLimitPolicy in normal code, the instances of them will be created per every readLoop() thread (right?). So, we need to test it in the same way with mock policies.", "author": "aromanenko-dev", "createdAt": "2020-03-12T17:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNDI4NA==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391914284", "bodyText": "OK, I see what's happening here. It's basically a race condition. This loop will exit as soon as nextRecord() returns the last record:\n\n  \n    \n      beam/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java\n    \n    \n        Lines 320 to 325\n      in\n      b0e7afb\n    \n    \n    \n    \n\n        \n          \n           while (fetchedRecords.size() < 4) { \n        \n\n        \n          \n             CustomOptional<KinesisRecord> nextRecord = shardReadersPool.nextRecord(); \n        \n\n        \n          \n             if (nextRecord.isPresent()) { \n        \n\n        \n          \n               fetchedRecords.add(nextRecord.get()); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI believe that sometimes the test is hitting the verify() call for that last record in the split second between shardReadersPool putting the record into the blocking queue and calling onSuccess(). The fix is to use Mockito's timeout() to ensure that we wait long enough for that last onSuccess() call. It took me about 30,000 iterations to reproduce with the original code but I have run the new test code over 100,000 times without a failure.\nI do still think it's a good idea to make these changes to ShardReadersPool to ensure that onSuccess() always gets called (as long as the thread wasn't interrupted).", "author": "jfarr", "createdAt": "2020-03-12T21:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNzgxMw==", "url": "https://github.com/apache/beam/pull/11090#discussion_r391917813", "bodyText": "Since, in case of using the real RateLimitPolicy in normal code, the instances of them will be created per every readLoop() thread (right?). So, we need to test it in the same way with mock policies.\n\nIt's possible for a custom RateLimitPolicyFactory to return a singleton instance of RateLimitPolicy, and I think that should be fine (as long as it's thread-safe). So maybe we shouldn't assume that they will always be different instances.", "author": "jfarr", "createdAt": "2020-03-12T21:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3Njc0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a5c1521ecb61b9b365ed26d0c3d856f6591ee52e", "chunk": "diff --git a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java\nindex 2aa14192f2..db17bf7973 100644\n--- a/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java\n+++ b/sdks/java/io/kinesis/src/test/java/org/apache/beam/sdk/io/kinesis/ShardReadersPoolTest.java\n\n@@ -328,12 +328,9 @@ public class ShardReadersPoolTest {\n     ArgumentCaptor<List<KinesisRecord>> recordsCaptor = ArgumentCaptor.forClass(List.class);\n     verify(customRateLimitPolicy, atLeastOnce()).onSuccess(recordsCaptor.capture());\n     List<List<KinesisRecord>> capturedRecords = recordsCaptor.getAllValues();\n-    assertThat(capturedRecords).contains(\n-        ImmutableList.of(a, b),\n-        singletonList(c),\n-        singletonList(d),\n-        Collections.emptyList()\n-    );\n+    assertThat(capturedRecords)\n+        .contains(\n+            ImmutableList.of(a, b), singletonList(c), singletonList(d), Collections.emptyList());\n     verify(customRateLimitPolicy).onThrottle(same(e));\n   }\n }\n"}}, {"oid": "a5c1521ecb61b9b365ed26d0c3d856f6591ee52e", "url": "https://github.com/apache/beam/commit/a5c1521ecb61b9b365ed26d0c3d856f6591ee52e", "message": "fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-11T01:27:55Z", "type": "forcePushed"}, {"oid": "9df4e258ffb21160e511c7234ed75bf0ce2c1ed5", "url": "https://github.com/apache/beam/commit/9df4e258ffb21160e511c7234ed75bf0ce2c1ed5", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-11T01:36:46Z", "type": "forcePushed"}, {"oid": "3da0d2d32d7d472e3b1dac18ecd1f914cb905afd", "url": "https://github.com/apache/beam/commit/3da0d2d32d7d472e3b1dac18ecd1f914cb905afd", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-12T03:54:19Z", "type": "forcePushed"}, {"oid": "2d5d83b21c2931c817b569567aa651ca02be14a8", "url": "https://github.com/apache/beam/commit/2d5d83b21c2931c817b569567aa651ca02be14a8", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-12T21:31:30Z", "type": "forcePushed"}, {"oid": "570243d2debec1cc52ad2f3f7ebafccc58ca1f9f", "url": "https://github.com/apache/beam/commit/570243d2debec1cc52ad2f3f7ebafccc58ca1f9f", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-12T21:54:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NTU3NA==", "url": "https://github.com/apache/beam/pull/11090#discussion_r393165574", "bodyText": "Do we really need to pass an empty list of records if it's happen to receive from shardRecordsIterator.readNextBatch()?", "author": "aromanenko-dev", "createdAt": "2020-03-16T16:49:26Z", "path": "sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java", "diffHunk": "@@ -126,9 +126,21 @@ void startReadingShards(Iterable<ShardRecordsIterator> shardRecordsIterators) {\n   private void readLoop(ShardRecordsIterator shardRecordsIterator, RateLimitPolicy rateLimiter) {\n     while (poolOpened.get()) {\n       try {\n-        List<KinesisRecord> kinesisRecords;\n         try {\n-          kinesisRecords = shardRecordsIterator.readNextBatch();\n+          List<KinesisRecord> kinesisRecords = shardRecordsIterator.readNextBatch();\n+          try {\n+            for (KinesisRecord kinesisRecord : kinesisRecords) {\n+              recordsQueue.put(kinesisRecord);\n+              numberOfRecordsInAQueueByShard.get(kinesisRecord.getShardId()).incrementAndGet();\n+            }\n+          } finally {\n+            // One of the paths into this finally block is recordsQueue.put() throwing\n+            // InterruptedException so we should check the thread's interrupted status before\n+            // calling onSuccess().\n+            if (!Thread.currentThread().isInterrupted()) {\n+              rateLimiter.onSuccess(kinesisRecords);", "originalCommit": "570243d2debec1cc52ad2f3f7ebafccc58ca1f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNjc0Mw==", "url": "https://github.com/apache/beam/pull/11090#discussion_r393216743", "bodyText": "Yes, in order to rate limit correctly onSuccess() needs to be called after every successful getRecords() call even if it returned no records. Otherwise we would be right back to exceeding our API rate limit when the shard has no more records to process.", "author": "jfarr", "createdAt": "2020-03-16T18:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NTU3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzE2Mg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r393167162", "bodyText": "Don't you think that rateLimiter should not be shared across different reader threads?", "author": "aromanenko-dev", "createdAt": "2020-03-16T16:51:47Z", "path": "sdks/java/io/kinesis/src/main/java/org/apache/beam/sdk/io/kinesis/ShardReadersPool.java", "diffHunk": "@@ -126,9 +126,21 @@ void startReadingShards(Iterable<ShardRecordsIterator> shardRecordsIterators) {\n   private void readLoop(ShardRecordsIterator shardRecordsIterator, RateLimitPolicy rateLimiter) {", "originalCommit": "570243d2debec1cc52ad2f3f7ebafccc58ca1f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMjY1Mg==", "url": "https://github.com/apache/beam/pull/11090#discussion_r393222652", "bodyText": "I don't see an inherent problem with it, as long as the rate limiter is thread-safe it can be shared. If you want I could add a note in the Javadoc for RateLimitPolicyFactory to indicate that it will be used from multiple threads, so if it returns a singleton instance of RateLimitPolicy then that instance should be thread-safe, otherwise it should return separate RateLimitPolicy instances.", "author": "jfarr", "createdAt": "2020-03-16T18:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5NjgyMw==", "url": "https://github.com/apache/beam/pull/11090#discussion_r393796823", "bodyText": "Yes, please add this into Javadoc to make it clear for users. Other than that we are fine, I think.", "author": "aromanenko-dev", "createdAt": "2020-03-17T16:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzE2Mg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9110f3126889e6d000e8cd2df9ab594358d4394d", "url": "https://github.com/apache/beam/commit/9110f3126889e6d000e8cd2df9ab594358d4394d", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-19T02:08:45Z", "type": "commit"}, {"oid": "9110f3126889e6d000e8cd2df9ab594358d4394d", "url": "https://github.com/apache/beam/commit/9110f3126889e6d000e8cd2df9ab594358d4394d", "message": "[BEAM-9470] fix flaky unit test in :sdks:java:io:kinesis", "committedDate": "2020-03-19T02:08:45Z", "type": "forcePushed"}]}