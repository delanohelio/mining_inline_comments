{"pr_number": 11688, "pr_title": "[BEAM-9935, BEAM-3836] Respect allowed split points in Java", "pr_createdAt": "2020-05-12T21:53:59Z", "pr_url": "https://github.com/apache/beam/pull/11688", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDc0Ng==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424084746", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n          \n          \n            \n                // 8 should be the split but it's not in the allowedSplitPoints list. 9 is the closest one.", "author": "lukecwik", "createdAt": "2020-05-12T23:10:00Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 10a6a2b0d4..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -284,220 +325,357 @@ public class BeamFnDataReadRunnerTest {\n \n     readRunner.blockTillReadFinishes();\n     future.get();\n+    assertEquals(\n+        createReadIndexMonitoringInfoAt(2),\n+        Iterables.getOnlyElement(Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));\n     assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n       }\n+      fail(\"Expected registrar not found.\");\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(readRunner, PTRANSFORM_ID, -1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    // The split should happen at 5 since the allowedSplitPoints is empty.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(readRunner, PTRANSFORM_ID, 1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"1\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"2\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"3\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"4\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"5\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"-1\"),\n+              valueInGlobalWindow(\"0\"),\n+              valueInGlobalWindow(\"1\"),\n+              valueInGlobalWindow(\"2\"),\n+              valueInGlobalWindow(\"3\"),\n+              valueInGlobalWindow(\"4\")));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-\n-    assertEquals(\n-        channelSplitResult(6),\n-        executeSplit(\n-            readRunner, pTransformId, 10, ImmutableList.of(\"A\", \"B\"), 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0, 16L})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.24, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.25, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.26, 16L})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 0L, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(9L), 2, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(11L), 6L, 0, 0.5, 16L})\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0.9, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0.1, 0.25, 4L})\n+          .build();\n+    }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            10,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.05,\n-            Collections.EMPTY_LIST));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n-\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-    // 16 is the desired split point.\n-    assertEquals(\n-        channelSplitResult(16),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            32,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(10L, 13L, 16L, 20L)));\n-\n-    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n-    assertEquals(\n-        channelSplitResult(9),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            16,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(5L, 7L, 9L, 10L)));\n-\n-    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 5L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 6L)})\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(5L, 6L, 7L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(1L, 2L, 3L)})\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                5L,\n+                0.25,\n+                16L,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    // The desired split point is not in the range of the allowed list.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(3)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n+  }\n \n-    assertEquals(\n-        channelSplitResult(2),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.51, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.49, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.26, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.25, 4L})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L, 0.8), 0L, 0, 0.2, 4L})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L, 0.5), 0L, 0, 0.125, 4L})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.2, 4L})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 2L, 0, 0.6, 4L})\n+          .add(new Object[] {channelSplitResult(4L), 2L, 0.9, 0.6, 4L})\n+          .add(new Object[] {elementSplitResult(2L, 0.6), 2L, 0.5, 0.2, 4L})\n+          .build();\n+    }\n \n-    // All possible split points have been passed. So there is no split.\n-    assertEquals(\n-        ProcessBundleSplitResponse.getDefaultInstance(),\n-        executeSplit(\n-            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.0);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.2,\n-            ImmutableList.of(1L, 2L, 5L)));\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 4L, 5L)));\n-    // The ideal split should at 2(\"C\") but 2 is not a split point. So the closet split is 3.\n-    assertEquals(\n-        channelSplitResult(3),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 3L, 4L, 5L)));\n-    // This time both 2 and 3 is a valid split point. Spilt at 2.\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 3L, 4L, 5L)));\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L, 0.6), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 3L, 4L, 5L)\n+              })\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 4L, 5L)\n+              })\n+          // We can't even split element at index 4 as above, because 4 is also not a split point.\n+          .add(new Object[] {channelSplitResult(5L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 5L)})\n+          // We can't split element at index 2, because 2 is not a split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 3L, 4L, 5L)\n+              })\n+          .build();\n+    }\n+\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(5)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n   }\n \n   private abstract static class SplittingReceiver\n-      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {}\n+      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {\n+    @Override\n+    public SplitResult trySplit(double fractionOfRemainder) {\n+      return SplitResult.of(\n+          BundleApplication.newBuilder()\n+              .setInputId(String.format(\"primary%.1f\", fractionOfRemainder))\n+              .build(),\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setInputId(String.format(\"residual%.1f\", 1 - fractionOfRemainder))\n+                      .build())\n+              .build());\n+    }\n+  }\n \n-  private BeamFnDataReadRunner<String> createReadRunner(\n-      FnDataReceiver<WindowedValue<String>> consumer, String pTransformId) throws Exception {\n+  private static BeamFnDataReadRunner<String> createReadRunner(\n+      FnDataReceiver<WindowedValue<String>> consumer,\n+      String pTransformId,\n+      BeamFnDataClient dataClient)\n+      throws Exception {\n     String bundleId = \"57\";\n \n     MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDgzMw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424084833", "bodyText": "Suggested change", "author": "lukecwik", "createdAt": "2020-05-12T23:10:10Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 10a6a2b0d4..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -284,220 +325,357 @@ public class BeamFnDataReadRunnerTest {\n \n     readRunner.blockTillReadFinishes();\n     future.get();\n+    assertEquals(\n+        createReadIndexMonitoringInfoAt(2),\n+        Iterables.getOnlyElement(Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));\n     assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n       }\n+      fail(\"Expected registrar not found.\");\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(readRunner, PTRANSFORM_ID, -1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    // The split should happen at 5 since the allowedSplitPoints is empty.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(readRunner, PTRANSFORM_ID, 1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"1\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"2\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"3\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"4\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"5\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"-1\"),\n+              valueInGlobalWindow(\"0\"),\n+              valueInGlobalWindow(\"1\"),\n+              valueInGlobalWindow(\"2\"),\n+              valueInGlobalWindow(\"3\"),\n+              valueInGlobalWindow(\"4\")));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-\n-    assertEquals(\n-        channelSplitResult(6),\n-        executeSplit(\n-            readRunner, pTransformId, 10, ImmutableList.of(\"A\", \"B\"), 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0, 16L})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.24, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.25, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.26, 16L})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 0L, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(9L), 2, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(11L), 6L, 0, 0.5, 16L})\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0.9, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0.1, 0.25, 4L})\n+          .build();\n+    }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            10,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.05,\n-            Collections.EMPTY_LIST));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n-\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-    // 16 is the desired split point.\n-    assertEquals(\n-        channelSplitResult(16),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            32,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(10L, 13L, 16L, 20L)));\n-\n-    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n-    assertEquals(\n-        channelSplitResult(9),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            16,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(5L, 7L, 9L, 10L)));\n-\n-    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 5L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 6L)})\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(5L, 6L, 7L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(1L, 2L, 3L)})\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                5L,\n+                0.25,\n+                16L,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    // The desired split point is not in the range of the allowed list.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(3)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n+  }\n \n-    assertEquals(\n-        channelSplitResult(2),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.51, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.49, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.26, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.25, 4L})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L, 0.8), 0L, 0, 0.2, 4L})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L, 0.5), 0L, 0, 0.125, 4L})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.2, 4L})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 2L, 0, 0.6, 4L})\n+          .add(new Object[] {channelSplitResult(4L), 2L, 0.9, 0.6, 4L})\n+          .add(new Object[] {elementSplitResult(2L, 0.6), 2L, 0.5, 0.2, 4L})\n+          .build();\n+    }\n \n-    // All possible split points have been passed. So there is no split.\n-    assertEquals(\n-        ProcessBundleSplitResponse.getDefaultInstance(),\n-        executeSplit(\n-            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.0);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.2,\n-            ImmutableList.of(1L, 2L, 5L)));\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 4L, 5L)));\n-    // The ideal split should at 2(\"C\") but 2 is not a split point. So the closet split is 3.\n-    assertEquals(\n-        channelSplitResult(3),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 3L, 4L, 5L)));\n-    // This time both 2 and 3 is a valid split point. Spilt at 2.\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 3L, 4L, 5L)));\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L, 0.6), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 3L, 4L, 5L)\n+              })\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 4L, 5L)\n+              })\n+          // We can't even split element at index 4 as above, because 4 is also not a split point.\n+          .add(new Object[] {channelSplitResult(5L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 5L)})\n+          // We can't split element at index 2, because 2 is not a split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 3L, 4L, 5L)\n+              })\n+          .build();\n+    }\n+\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(5)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n   }\n \n   private abstract static class SplittingReceiver\n-      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {}\n+      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {\n+    @Override\n+    public SplitResult trySplit(double fractionOfRemainder) {\n+      return SplitResult.of(\n+          BundleApplication.newBuilder()\n+              .setInputId(String.format(\"primary%.1f\", fractionOfRemainder))\n+              .build(),\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setInputId(String.format(\"residual%.1f\", 1 - fractionOfRemainder))\n+                      .build())\n+              .build());\n+    }\n+  }\n \n-  private BeamFnDataReadRunner<String> createReadRunner(\n-      FnDataReceiver<WindowedValue<String>> consumer, String pTransformId) throws Exception {\n+  private static BeamFnDataReadRunner<String> createReadRunner(\n+      FnDataReceiver<WindowedValue<String>> consumer,\n+      String pTransformId,\n+      BeamFnDataClient dataClient)\n+      throws Exception {\n     String bundleId = \"57\";\n \n     MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTgxMA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424085810", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n          \n          \n            \n                // The ideal split should at 2(\"C\") but 3 is not a split point. So the closest split is 4.", "author": "lukecwik", "createdAt": "2020-05-12T23:13:11Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n+    assertEquals(\n+        channelSplitResult(9),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            16,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(5L, 7L, 9L, 10L)));\n+\n+    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n+    assertEquals(\n+        channelSplitResult(5),\n+        executeSplit(\n+            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+\n+    // The desired split point is not in the range of the allowed list.\n+    assertEquals(\n+        channelSplitResult(4),\n+        executeSplit(\n+            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+\n+    assertEquals(\n+        channelSplitResult(2),\n+        executeSplit(\n+            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+\n+    // All possible split points have been passed. So there is no split.\n+    assertEquals(\n+        ProcessBundleSplitResponse.getDefaultInstance(),\n+        executeSplit(\n+            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+  }\n+\n+  @Test\n+  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+    SplitResult splitResult =\n+        SplitResult.of(\n+            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n+            DelayedBundleApplication.newBuilder()\n+                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n+                .build());\n+    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+    when(splittingReceiver.getProgress()).thenReturn(0.0);\n+    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n+    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n+    assertEquals(\n+        channelSplitResult(5),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            5,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.2,\n+            ImmutableList.of(1L, 2L, 5L)));\n+    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 10a6a2b0d4..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -284,220 +325,357 @@ public class BeamFnDataReadRunnerTest {\n \n     readRunner.blockTillReadFinishes();\n     future.get();\n+    assertEquals(\n+        createReadIndexMonitoringInfoAt(2),\n+        Iterables.getOnlyElement(Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));\n     assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n       }\n+      fail(\"Expected registrar not found.\");\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(readRunner, PTRANSFORM_ID, -1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    // The split should happen at 5 since the allowedSplitPoints is empty.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(readRunner, PTRANSFORM_ID, 1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"1\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"2\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"3\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"4\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"5\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"-1\"),\n+              valueInGlobalWindow(\"0\"),\n+              valueInGlobalWindow(\"1\"),\n+              valueInGlobalWindow(\"2\"),\n+              valueInGlobalWindow(\"3\"),\n+              valueInGlobalWindow(\"4\")));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-\n-    assertEquals(\n-        channelSplitResult(6),\n-        executeSplit(\n-            readRunner, pTransformId, 10, ImmutableList.of(\"A\", \"B\"), 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0, 16L})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.24, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.25, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.26, 16L})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 0L, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(9L), 2, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(11L), 6L, 0, 0.5, 16L})\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0.9, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0.1, 0.25, 4L})\n+          .build();\n+    }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            10,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.05,\n-            Collections.EMPTY_LIST));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n-\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-    // 16 is the desired split point.\n-    assertEquals(\n-        channelSplitResult(16),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            32,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(10L, 13L, 16L, 20L)));\n-\n-    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n-    assertEquals(\n-        channelSplitResult(9),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            16,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(5L, 7L, 9L, 10L)));\n-\n-    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 5L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 6L)})\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(5L, 6L, 7L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(1L, 2L, 3L)})\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                5L,\n+                0.25,\n+                16L,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    // The desired split point is not in the range of the allowed list.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(3)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n+  }\n \n-    assertEquals(\n-        channelSplitResult(2),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.51, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.49, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.26, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.25, 4L})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L, 0.8), 0L, 0, 0.2, 4L})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L, 0.5), 0L, 0, 0.125, 4L})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.2, 4L})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 2L, 0, 0.6, 4L})\n+          .add(new Object[] {channelSplitResult(4L), 2L, 0.9, 0.6, 4L})\n+          .add(new Object[] {elementSplitResult(2L, 0.6), 2L, 0.5, 0.2, 4L})\n+          .build();\n+    }\n \n-    // All possible split points have been passed. So there is no split.\n-    assertEquals(\n-        ProcessBundleSplitResponse.getDefaultInstance(),\n-        executeSplit(\n-            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.0);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.2,\n-            ImmutableList.of(1L, 2L, 5L)));\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 4L, 5L)));\n-    // The ideal split should at 2(\"C\") but 2 is not a split point. So the closet split is 3.\n-    assertEquals(\n-        channelSplitResult(3),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 3L, 4L, 5L)));\n-    // This time both 2 and 3 is a valid split point. Spilt at 2.\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 3L, 4L, 5L)));\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L, 0.6), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 3L, 4L, 5L)\n+              })\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 4L, 5L)\n+              })\n+          // We can't even split element at index 4 as above, because 4 is also not a split point.\n+          .add(new Object[] {channelSplitResult(5L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 5L)})\n+          // We can't split element at index 2, because 2 is not a split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 3L, 4L, 5L)\n+              })\n+          .build();\n+    }\n+\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(5)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n   }\n \n   private abstract static class SplittingReceiver\n-      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {}\n+      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {\n+    @Override\n+    public SplitResult trySplit(double fractionOfRemainder) {\n+      return SplitResult.of(\n+          BundleApplication.newBuilder()\n+              .setInputId(String.format(\"primary%.1f\", fractionOfRemainder))\n+              .build(),\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setInputId(String.format(\"residual%.1f\", 1 - fractionOfRemainder))\n+                      .build())\n+              .build());\n+    }\n+  }\n \n-  private BeamFnDataReadRunner<String> createReadRunner(\n-      FnDataReceiver<WindowedValue<String>> consumer, String pTransformId) throws Exception {\n+  private static BeamFnDataReadRunner<String> createReadRunner(\n+      FnDataReceiver<WindowedValue<String>> consumer,\n+      String pTransformId,\n+      BeamFnDataClient dataClient)\n+      throws Exception {\n     String bundleId = \"57\";\n \n     MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjgzMg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424086832", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long newStopIndex =\n          \n          \n            \n                      Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n          \n          \n            \n                  long newStopIndex = index + Math.max(1, Math.round(currentElementProgress + keep));", "author": "lukecwik", "createdAt": "2020-05-12T23:16:41Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\nindex 79901f108b..eedb42c2a0 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n\n@@ -259,19 +287,19 @@ public class BeamFnDataReadRunner<OutputT> {\n       }\n \n       // Otherwise, split at the closest allowed element boundary.\n-      long newStopIndex =\n-          Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n+      long newStopIndex = index + Math.max(1, Math.round(currentElementProgress + keep));\n       if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        // Choose the closest allowed split point.\n         Collections.sort(allowedSplitPoints);\n-        int closetSplitPointIndex =\n+        int closestSplitPointIndex =\n             -(Collections.binarySearch(allowedSplitPoints, newStopIndex) + 1);\n-        if (closetSplitPointIndex == 0) {\n+        if (closestSplitPointIndex == 0) {\n           newStopIndex = allowedSplitPoints.get(0);\n-        } else if (closetSplitPointIndex == allowedSplitPoints.size()) {\n-          newStopIndex = allowedSplitPoints.get(closetSplitPointIndex - 1);\n+        } else if (closestSplitPointIndex == allowedSplitPoints.size()) {\n+          newStopIndex = allowedSplitPoints.get(closestSplitPointIndex - 1);\n         } else {\n-          long prevPoint = allowedSplitPoints.get(closetSplitPointIndex - 1);\n-          long nextPoint = allowedSplitPoints.get(closetSplitPointIndex);\n+          long prevPoint = allowedSplitPoints.get(closestSplitPointIndex - 1);\n+          long nextPoint = allowedSplitPoints.get(closestSplitPointIndex);\n           if (index < prevPoint && newStopIndex - prevPoint < nextPoint - newStopIndex) {\n             newStopIndex = prevPoint;\n           } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzUwMw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424087503", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collections.sort(allowedSplitPoints);\n          \n          \n            \n                    // Choose the closest allowed split point.\n          \n          \n            \n                    Collections.sort(allowedSplitPoints);", "author": "lukecwik", "createdAt": "2020-05-12T23:19:01Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n-      if (newStopIndex < stopIndex) {\n+      if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        Collections.sort(allowedSplitPoints);", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\nindex 79901f108b..eedb42c2a0 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n\n@@ -259,19 +287,19 @@ public class BeamFnDataReadRunner<OutputT> {\n       }\n \n       // Otherwise, split at the closest allowed element boundary.\n-      long newStopIndex =\n-          Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n+      long newStopIndex = index + Math.max(1, Math.round(currentElementProgress + keep));\n       if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        // Choose the closest allowed split point.\n         Collections.sort(allowedSplitPoints);\n-        int closetSplitPointIndex =\n+        int closestSplitPointIndex =\n             -(Collections.binarySearch(allowedSplitPoints, newStopIndex) + 1);\n-        if (closetSplitPointIndex == 0) {\n+        if (closestSplitPointIndex == 0) {\n           newStopIndex = allowedSplitPoints.get(0);\n-        } else if (closetSplitPointIndex == allowedSplitPoints.size()) {\n-          newStopIndex = allowedSplitPoints.get(closetSplitPointIndex - 1);\n+        } else if (closestSplitPointIndex == allowedSplitPoints.size()) {\n+          newStopIndex = allowedSplitPoints.get(closestSplitPointIndex - 1);\n         } else {\n-          long prevPoint = allowedSplitPoints.get(closetSplitPointIndex - 1);\n-          long nextPoint = allowedSplitPoints.get(closetSplitPointIndex);\n+          long prevPoint = allowedSplitPoints.get(closestSplitPointIndex - 1);\n+          long nextPoint = allowedSplitPoints.get(closestSplitPointIndex);\n           if (index < prevPoint && newStopIndex - prevPoint < nextPoint - newStopIndex) {\n             newStopIndex = prevPoint;\n           } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzU4OA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424087588", "bodyText": "nit: closetSplitPointIndex -> closestSplitPointIndex", "author": "lukecwik", "createdAt": "2020-05-12T23:19:17Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n-      if (newStopIndex < stopIndex) {\n+      if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        Collections.sort(allowedSplitPoints);\n+        int closetSplitPointIndex =", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\nindex 79901f108b..eedb42c2a0 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java\n\n@@ -259,19 +287,19 @@ public class BeamFnDataReadRunner<OutputT> {\n       }\n \n       // Otherwise, split at the closest allowed element boundary.\n-      long newStopIndex =\n-          Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n+      long newStopIndex = index + Math.max(1, Math.round(currentElementProgress + keep));\n       if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        // Choose the closest allowed split point.\n         Collections.sort(allowedSplitPoints);\n-        int closetSplitPointIndex =\n+        int closestSplitPointIndex =\n             -(Collections.binarySearch(allowedSplitPoints, newStopIndex) + 1);\n-        if (closetSplitPointIndex == 0) {\n+        if (closestSplitPointIndex == 0) {\n           newStopIndex = allowedSplitPoints.get(0);\n-        } else if (closetSplitPointIndex == allowedSplitPoints.size()) {\n-          newStopIndex = allowedSplitPoints.get(closetSplitPointIndex - 1);\n+        } else if (closestSplitPointIndex == allowedSplitPoints.size()) {\n+          newStopIndex = allowedSplitPoints.get(closestSplitPointIndex - 1);\n         } else {\n-          long prevPoint = allowedSplitPoints.get(closetSplitPointIndex - 1);\n-          long nextPoint = allowedSplitPoints.get(closetSplitPointIndex);\n+          long prevPoint = allowedSplitPoints.get(closestSplitPointIndex - 1);\n+          long nextPoint = allowedSplitPoints.get(closestSplitPointIndex);\n           if (index < prevPoint && newStopIndex - prevPoint < nextPoint - newStopIndex) {\n             newStopIndex = prevPoint;\n           } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4OTg5Mg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424089892", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n          \n          \n            \n                // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closest one.", "author": "lukecwik", "createdAt": "2020-05-12T23:26:28Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n+    assertEquals(\n+        channelSplitResult(9),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            16,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(5L, 7L, 9L, 10L)));\n+\n+    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 10a6a2b0d4..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -284,220 +325,357 @@ public class BeamFnDataReadRunnerTest {\n \n     readRunner.blockTillReadFinishes();\n     future.get();\n+    assertEquals(\n+        createReadIndexMonitoringInfoAt(2),\n+        Iterables.getOnlyElement(Iterables.getOnlyElement(progressCallbacks).getMonitoringInfos()));\n     assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n       }\n+      fail(\"Expected registrar not found.\");\n     }\n-    fail(\"Expected registrar not found.\");\n-  }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(readRunner, PTRANSFORM_ID, -1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    // The split should happen at 5 since the allowedSplitPoints is empty.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(readRunner, PTRANSFORM_ID, 1L, 0.5, 10, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"1\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"2\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"3\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"4\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"5\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"-1\"),\n+              valueInGlobalWindow(\"0\"),\n+              valueInGlobalWindow(\"1\"),\n+              valueInGlobalWindow(\"2\"),\n+              valueInGlobalWindow(\"3\"),\n+              valueInGlobalWindow(\"4\")));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-\n-    assertEquals(\n-        channelSplitResult(6),\n-        executeSplit(\n-            readRunner, pTransformId, 10, ImmutableList.of(\"A\", \"B\"), 0.5, Collections.EMPTY_LIST));\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0, 16L})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.24, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.25, 16L})\n+          .add(new Object[] {channelSplitResult(4L), 0L, 0, 0.26, 16L})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 0L, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(9L), 2, 0, 0.5, 16L})\n+          .add(new Object[] {channelSplitResult(11L), 6L, 0, 0.5, 16L})\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0.9, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0, 0.25, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 1L, 0.1, 0.25, 4L})\n+          .build();\n+    }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            10,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.05,\n-            Collections.EMPTY_LIST));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n-\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n-    // 16 is the desired split point.\n-    assertEquals(\n-        channelSplitResult(16),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            32,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(10L, 13L, 16L, 20L)));\n-\n-    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n-    assertEquals(\n-        channelSplitResult(9),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            16,\n-            Collections.EMPTY_LIST,\n-            0.5,\n-            ImmutableList.of(5L, 7L, 9L, 10L)));\n-\n-    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 5L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(2L, 3L, 6L)})\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(new Object[] {channelSplitResult(5L), 0L, 0.25, 16L, ImmutableList.of(5L, 6L, 7L)})\n+          .add(new Object[] {channelSplitResult(3L), 0L, 0.25, 16L, ImmutableList.of(1L, 2L, 3L)})\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                5L,\n+                0.25,\n+                16L,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    // The desired split point is not in the range of the allowed list.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(3)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n+  }\n \n-    assertEquals(\n-        channelSplitResult(2),\n-        executeSplit(\n-            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.51, 4L})\n+          .add(new Object[] {channelSplitResult(2L), 0L, 0, 0.49, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.26, 4L})\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0, 0.25, 4L})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L, 0.8), 0L, 0, 0.2, 4L})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L, 0.5), 0L, 0, 0.125, 4L})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 0L, 0.5, 0.2, 4L})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 2L, 0, 0.6, 4L})\n+          .add(new Object[] {channelSplitResult(4L), 2L, 0.9, 0.6, 4L})\n+          .add(new Object[] {elementSplitResult(2L, 0.6), 2L, 0.5, 0.2, 4L})\n+          .build();\n+    }\n \n-    // All possible split points have been passed. So there is no split.\n-    assertEquals(\n-        ProcessBundleSplitResponse.getDefaultInstance(),\n-        executeSplit(\n-            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.0);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    String pTransformId = \"pTransformId\";\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n-    assertEquals(\n-        channelSplitResult(5),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            ImmutableList.of(\"A\", \"B\", \"C\"),\n-            0.2,\n-            ImmutableList.of(1L, 2L, 5L)));\n-    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n-    assertEquals(\n-        channelSplitResult(4),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 4L, 5L)));\n-    // The ideal split should at 2(\"C\") but 2 is not a split point. So the closet split is 3.\n-    assertEquals(\n-        channelSplitResult(3),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 3L, 4L, 5L)));\n-    // This time both 2 and 3 is a valid split point. Spilt at 2.\n-    assertEquals(\n-        elementSplitResult(2, splitResult),\n-        executeSplit(\n-            readRunner,\n-            pTransformId,\n-            5,\n-            Collections.EMPTY_LIST,\n-            0.2,\n-            ImmutableList.of(1L, 2L, 3L, 4L, 5L)));\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L, 0.6), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 3L, 4L, 5L)\n+              })\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 4L, 5L)\n+              })\n+          // We can't even split element at index 4 as above, because 4 is also not a split point.\n+          .add(new Object[] {channelSplitResult(5L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 2L, 5L)})\n+          // We can't split element at index 2, because 2 is not a split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L), 2L, 0, 0.2, 5L, ImmutableList.of(1L, 3L, 4L, 5L)\n+              })\n+          .build();\n+    }\n+\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long index;\n+\n+    @Parameterized.Parameter(2)\n+    public double elementProgress;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public long bufferSize;\n+\n+    @Parameterized.Parameter(5)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenCallRealMethod();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+      readRunner.registerInputLocation();\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              index,\n+              fractionOfRemainder,\n+              bufferSize,\n+              allowedSplitPoints));\n+    }\n   }\n \n   private abstract static class SplittingReceiver\n-      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {}\n+      implements FnDataReceiver<WindowedValue<String>>, HandlesSplits {\n+    @Override\n+    public SplitResult trySplit(double fractionOfRemainder) {\n+      return SplitResult.of(\n+          BundleApplication.newBuilder()\n+              .setInputId(String.format(\"primary%.1f\", fractionOfRemainder))\n+              .build(),\n+          DelayedBundleApplication.newBuilder()\n+              .setApplication(\n+                  BundleApplication.newBuilder()\n+                      .setInputId(String.format(\"residual%.1f\", 1 - fractionOfRemainder))\n+                      .build())\n+              .build());\n+    }\n+  }\n \n-  private BeamFnDataReadRunner<String> createReadRunner(\n-      FnDataReceiver<WindowedValue<String>> consumer, String pTransformId) throws Exception {\n+  private static BeamFnDataReadRunner<String> createReadRunner(\n+      FnDataReceiver<WindowedValue<String>> consumer,\n+      String pTransformId,\n+      BeamFnDataClient dataClient)\n+      throws Exception {\n     String bundleId = \"57\";\n \n     MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzY0MQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424187641", "bodyText": "This test is the same to test_simple_split + test_split_with_element_progress", "author": "boyuanzz", "createdAt": "2020-05-13T05:52:49Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzgxNw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424187817", "bodyText": "The same to test_split_with_element_allowed_splits", "author": "boyuanzz", "createdAt": "2020-05-13T05:53:25Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA3OA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424188078", "bodyText": "The same to test_sdf_split", "author": "boyuanzz", "createdAt": "2020-05-13T05:54:16Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODIyMQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424188221", "bodyText": "The same to test_sdf_split_with_allowed_splits", "author": "boyuanzz", "createdAt": "2020-05-13T05:54:47Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.125, 0})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.2, 0.5})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0})\n+          .add(new Object[] {channelSplitResult(4L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0.9})\n+          .add(new Object[] {elementSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.2, 0.5})\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(5)\n-                    .setFirstResidualElement(6)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenReturn(mockSplitResult);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5MTM3Mw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424491373", "bodyText": "nit: mockSplitResult -> TEST_SPLIT_RESULT\nmock in a variable name usually means that it isn't a real instance of something.", "author": "lukecwik", "createdAt": "2020-05-13T14:39:55Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -103,6 +104,12 @@\n           .setApiServiceDescriptor(Endpoints.ApiServiceDescriptor.getDefaultInstance())\n           .setCoderId(CODER_SPEC_ID)\n           .build();\n+  private static final SplitResult mockSplitResult =", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -104,12 +109,6 @@ public class BeamFnDataReadRunnerTest {\n           .setApiServiceDescriptor(Endpoints.ApiServiceDescriptor.getDefaultInstance())\n           .setCoderId(CODER_SPEC_ID)\n           .build();\n-  private static final SplitResult mockSplitResult =\n-      SplitResult.of(\n-          BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-          DelayedBundleApplication.newBuilder()\n-              .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-              .build());\n \n   static {\n     try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5MzgwMA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424493800", "bodyText": "This should be @RunWith(Enclosed.class) to prevent an issue from junit not detecting inner classes for test execution.", "author": "lukecwik", "createdAt": "2020-05-13T14:42:57Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -82,15 +84,14 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.junit.runners.Parameterized;\n import org.mockito.ArgumentCaptor;\n import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /** Tests for {@link BeamFnDataReadRunner}. */\n-@RunWith(JUnit4.class)", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -82,6 +85,7 @@ import org.hamcrest.collection.IsMapContaining;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n import org.junit.runners.Parameterized;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTA3Mg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424499072", "bodyText": "It would be nice if the fraction did make it through into the split result allowing us to validate correctly computing the fraction.", "author": "lukecwik", "createdAt": "2020-05-13T14:49:44Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwMTE5NQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424501195", "bodyText": "nit: If you want to better mirror the python version of the test, you could generate the list of elements in testElementSplittingWithAllowedSplitPoints based upon the \"index\"  you pass in instead of explicitly listing them (here and in the other parameterized versions)\nnit: ordering the parameters the same way also makes for easier maintenance in the future (here and in the other parameterized versions)", "author": "lukecwik", "createdAt": "2020-05-13T14:52:23Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.125, 0})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.2, 0.5})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0})\n+          .add(new Object[] {channelSplitResult(4L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0.9})\n+          .add(new Object[] {elementSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.2, 0.5})\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(5)\n-                    .setFirstResidualElement(6)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenReturn(mockSplitResult);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L),\n+                5L,\n+                ImmutableList.of(\"A\", \"B\", \"C\"),", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\nindex 584d042d3d..785af506c3 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java\n\n@@ -170,27 +169,27 @@ public class BeamFnDataReadRunnerTest {\n       RunnerApi.PTransform pTransform =\n           RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n \n-      new BeamFnDataReadRunner.Factory<String>()\n-          .createRunnerForPTransform(\n-              PipelineOptionsFactory.create(),\n-              mockBeamFnDataClient,\n-              null /* beamFnStateClient */,\n-              null /* beamFnTimerClient */,\n-              pTransformId,\n-              pTransform,\n-              Suppliers.ofInstance(bundleId)::get,\n-              ImmutableMap.of(\n-                  localOutputId,\n-                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-              COMPONENTS.getCodersMap(),\n-              COMPONENTS.getWindowingStrategiesMap(),\n-              consumers,\n-              startFunctionRegistry,\n-              finishFunctionRegistry,\n-              teardownFunctions::add,\n-              null /* addProgressRequestCallback */,\n-              null /* splitListener */,\n-              null /* bundleFinalizer */);\n+    new BeamFnDataReadRunner.Factory<String>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            mockBeamFnDataClient,\n+            null /* beamFnStateClient */,\n+            null /* beamFnTimerClient */,\n+            pTransformId,\n+            pTransform,\n+            Suppliers.ofInstance(bundleId)::get,\n+            ImmutableMap.of(\n+                localOutputId,\n+                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+            COMPONENTS.getCodersMap(),\n+            COMPONENTS.getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            (PTransformRunnerFactory.ProgressRequestCallback callback) -> {},\n+            null /* splitListener */,\n+            null /* bundleFinalizer */);\n \n       assertThat(teardownFunctions, empty());\n \n"}}, {"oid": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "url": "https://github.com/apache/beam/commit/efdee96f04d339445298b4a4dc44f8aa75e6aa67", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:26:05Z", "type": "forcePushed"}, {"oid": "216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "url": "https://github.com/apache/beam/commit/216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:28:26Z", "type": "commit"}, {"oid": "216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "url": "https://github.com/apache/beam/commit/216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:28:26Z", "type": "forcePushed"}]}