{"pr_number": 12994, "pr_title": "[BEAM-11044] Add support for gracefully aborting workers.", "pr_createdAt": "2020-10-01T23:19:00Z", "pr_url": "https://github.com/apache/beam/pull/12994", "timeline": [{"oid": "19ff0451b09f48903b85b1103d0982ae6b378ac3", "url": "https://github.com/apache/beam/commit/19ff0451b09f48903b85b1103d0982ae6b378ac3", "message": "Add support for gracefully aborting workers. On complete_work_status received (by the work progress updater thread), abort the corresponding map task executor thread.  This relies on Thread.interrupt() to unblock the worker thread if blocked and raise an exception -- the exception is actually ignored by the backend since the backend already decided to abort this thread.  Must also check the current thread for interrupts in the valuesiterator when it consumes a stream of values behind the same key, else control does not return to the runReadLoop() to check the interruption.", "committedDate": "2020-10-01T20:55:00Z", "type": "commit"}, {"oid": "42a4957793a9d49d50c6da4ab9ea05a2a4fdbdf9", "url": "https://github.com/apache/beam/commit/42a4957793a9d49d50c6da4ab9ea05a2a4fdbdf9", "message": ".", "committedDate": "2020-10-01T20:55:01Z", "type": "commit"}, {"oid": "09802834b9cee636818124ce130f4d805fc74b4d", "url": "https://github.com/apache/beam/commit/09802834b9cee636818124ce130f4d805fc74b4d", "message": ".", "committedDate": "2020-10-01T23:08:27Z", "type": "commit"}, {"oid": "c14d176c89aef682c6efff51cc764a9d436a4574", "url": "https://github.com/apache/beam/commit/c14d176c89aef682c6efff51cc764a9d436a4574", "message": "spotlessApply", "committedDate": "2020-10-01T23:26:54Z", "type": "commit"}, {"oid": "c14d176c89aef682c6efff51cc764a9d436a4574", "url": "https://github.com/apache/beam/commit/c14d176c89aef682c6efff51cc764a9d436a4574", "message": "spotlessApply", "committedDate": "2020-10-01T23:26:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5NTYxOA==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498595618", "bodyText": "It would be nice for the next person if there is a diagnostic error message attached to this failure, lest we get a failure that says \"false is not true\".", "author": "kennknowles", "createdAt": "2020-10-02T02:32:16Z", "path": "runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java", "diffHunk": "@@ -483,4 +483,29 @@ public void testExceptionInAbortSuppressed() throws Exception {\n       assertThat(e.getSuppressed()[0].getMessage(), equalTo(\"suppressed in abort\"));\n     }\n   }\n+\n+  @Test\n+  public void testAbort() throws Exception {\n+    // Operation must be an instance of ReadOperation or ReceivingOperation per preconditions\n+    // in MapTaskExecutor.\n+    Operation o = Mockito.mock(ReadOperation.class);\n+\n+    ExecutionStateTracker stateTracker = ExecutionStateTracker.newForTest();\n+    try (MapTaskExecutor executor =\n+        new MapTaskExecutor(Arrays.<Operation>asList(o), counterSet, stateTracker)) {\n+      Mockito.doAnswer(\n+              invocation -> {\n+                executor.abort();\n+                return null;\n+              })\n+          .when(o)\n+          .start();\n+      executor.execute();\n+      fail(\"Should have aborted\");\n+    } catch (Exception e) {\n+      Assert.assertTrue(e instanceof InterruptedException);", "originalCommit": "c14d176c89aef682c6efff51cc764a9d436a4574", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5ODk5Mg==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498598992", "bodyText": "Done.", "author": "tudorm", "createdAt": "2020-10-02T02:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5NTYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c543663d8d646d8190ce93c46d9efba836f31cd7", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\nindex 074653159a..6e51d70f9c 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\n\n@@ -503,9 +503,13 @@ public class MapTaskExecutorTest {\n       executor.execute();\n       fail(\"Should have aborted\");\n     } catch (Exception e) {\n-      Assert.assertTrue(e instanceof InterruptedException);\n+      Assert.assertTrue(\n+          \"Aborting the executor interrupts the worker thread running execute() which then throws an InterruptedException\",\n+          e instanceof InterruptedException);\n       Mockito.verify(o).abort();\n     }\n-    Assert.assertTrue(Thread.currentThread().isInterrupted());\n+    Assert.assertTrue(\n+        \"Aborting the executor interrupts the worker thread running execute()\",\n+        Thread.currentThread().isInterrupted());\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5NTYzNQ==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498595635", "bodyText": "Same", "author": "kennknowles", "createdAt": "2020-10-02T02:32:22Z", "path": "runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java", "diffHunk": "@@ -483,4 +483,29 @@ public void testExceptionInAbortSuppressed() throws Exception {\n       assertThat(e.getSuppressed()[0].getMessage(), equalTo(\"suppressed in abort\"));\n     }\n   }\n+\n+  @Test\n+  public void testAbort() throws Exception {\n+    // Operation must be an instance of ReadOperation or ReceivingOperation per preconditions\n+    // in MapTaskExecutor.\n+    Operation o = Mockito.mock(ReadOperation.class);\n+\n+    ExecutionStateTracker stateTracker = ExecutionStateTracker.newForTest();\n+    try (MapTaskExecutor executor =\n+        new MapTaskExecutor(Arrays.<Operation>asList(o), counterSet, stateTracker)) {\n+      Mockito.doAnswer(\n+              invocation -> {\n+                executor.abort();\n+                return null;\n+              })\n+          .when(o)\n+          .start();\n+      executor.execute();\n+      fail(\"Should have aborted\");\n+    } catch (Exception e) {\n+      Assert.assertTrue(e instanceof InterruptedException);\n+      Mockito.verify(o).abort();\n+    }\n+    Assert.assertTrue(Thread.currentThread().isInterrupted());", "originalCommit": "c14d176c89aef682c6efff51cc764a9d436a4574", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5ODk5Ng==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498598996", "bodyText": "Done", "author": "tudorm", "createdAt": "2020-10-02T02:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5NTYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c543663d8d646d8190ce93c46d9efba836f31cd7", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\nindex 074653159a..6e51d70f9c 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutorTest.java\n\n@@ -503,9 +503,13 @@ public class MapTaskExecutorTest {\n       executor.execute();\n       fail(\"Should have aborted\");\n     } catch (Exception e) {\n-      Assert.assertTrue(e instanceof InterruptedException);\n+      Assert.assertTrue(\n+          \"Aborting the executor interrupts the worker thread running execute() which then throws an InterruptedException\",\n+          e instanceof InterruptedException);\n       Mockito.verify(o).abort();\n     }\n-    Assert.assertTrue(Thread.currentThread().isInterrupted());\n+    Assert.assertTrue(\n+        \"Aborting the executor interrupts the worker thread running execute()\",\n+        Thread.currentThread().isInterrupted());\n   }\n }\n"}}, {"oid": "c543663d8d646d8190ce93c46d9efba836f31cd7", "url": "https://github.com/apache/beam/commit/c543663d8d646d8190ce93c46d9efba836f31cd7", "message": ".", "committedDate": "2020-10-02T02:50:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498894067", "bodyText": "There is no requirement for user code to handle being interrupted arbitrarily and there are enough instances that I have seen where this would not be handled gracefully by the user.", "author": "lukecwik", "createdAt": "2020-10-02T15:30:03Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutor.java", "diffHunk": "@@ -146,13 +165,17 @@ public boolean supportsRestart() {\n   @Override\n   public void abort() {\n     // Signal the read loop to abort on the next record.\n-    // TODO: Also interrupt the execution thread.\n     for (Operation op : operations) {\n       Preconditions.checkState(op instanceof ReadOperation || op instanceof ReceivingOperation);\n       if (op instanceof ReadOperation) {\n         ((ReadOperation) op).abortReadLoop();\n       }\n     }\n+    synchronized (this) {\n+      if (currentExecutorThread != null) {\n+        currentExecutorThread.interrupt();", "originalCommit": "c543663d8d646d8190ce93c46d9efba836f31cd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzMzQ2Nw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498933467", "bodyText": "Can you give an example to consider here?", "author": "kennknowles", "createdAt": "2020-10-02T16:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNDkzMw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498934933", "bodyText": "My understanding of this change is that user code will typically finish a callback and the abort will occur when control returns to the worker. To a user it should be transparently like other failures. Is that not the case?", "author": "kennknowles", "createdAt": "2020-10-02T16:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTc3OQ==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498935779", "bodyText": "Interrupting the GCS writer has caused issues with how the pipe that is used to transfer data is not gracefully shutdown leaving a blocked thread sitting around indefinitely.", "author": "lukecwik", "createdAt": "2020-10-02T16:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzM1Mw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498937353", "bodyText": "Internally within Flume we saw with the C++ worker where user code didn't handle thread::cancel correctly and were relying on process crash to not get stuck.\nI would generally love for us to be able to interrupt random code arbitrarily as it would be the best and cleanest way to do this and if we want to do this we should really have a way for users to opt-out incase it doesn't work for them. We can watch how many people opt-out and find out why and possibly make this the default forever or choose to make this the default in portable execution as that will require a migration.", "author": "lukecwik", "createdAt": "2020-10-02T16:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDc3Ng==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498944776", "bodyText": "I may be misunderstanding, but this is a cooperative interrupt. The interrupt only happens when the user code return control.", "author": "kennknowles", "createdAt": "2020-10-02T17:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODQ4Mw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r498998483", "bodyText": "Discussed offline: \"user\" code can mean many things, and there are some common Java errors that this change could trigger:\n\nUser's (who usually won't check the bit) doing catch-all error handling without separating out InterruptedException.\nIO libraries (which may often check the bit) doing incomplete or incorrect cleanup and being left in an inconsistent state or leaking resources.\n\nThese would ideally both be noticed and handled by higher-level mechanisms since in both cases something should be notably unhealthy about the thread, process, or VM. For now just aborting without interrupting the thread is safer.", "author": "kennknowles", "createdAt": "2020-10-02T18:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ce47d21fd772b7d760b3d3d36515c386f4919bdd", "chunk": "diff --git a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutor.java b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutor.java\nindex 13f8b7d96b..a23b6be61a 100644\n--- a/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutor.java\n+++ b/runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/util/common/worker/MapTaskExecutor.java\n\n@@ -164,18 +164,14 @@ public class MapTaskExecutor implements WorkExecutor {\n \n   @Override\n   public void abort() {\n-    // Signal the read loop to abort on the next record.\n+    // Signal the read loop to abort on the next record and async abort any iterators.\n+    // TODO: Also interrupt the execution thread.\n     for (Operation op : operations) {\n       Preconditions.checkState(op instanceof ReadOperation || op instanceof ReceivingOperation);\n       if (op instanceof ReadOperation) {\n         ((ReadOperation) op).abortReadLoop();\n       }\n     }\n-    synchronized (this) {\n-      if (currentExecutorThread != null) {\n-        currentExecutorThread.interrupt();\n-      }\n-    }\n   }\n \n   @Override\n"}}, {"oid": "ce47d21fd772b7d760b3d3d36515c386f4919bdd", "url": "https://github.com/apache/beam/commit/ce47d21fd772b7d760b3d3d36515c386f4919bdd", "message": "Added async abort signaling up to the GroupingShuffleReader's (values) iterator", "committedDate": "2020-10-06T03:13:35Z", "type": "commit"}, {"oid": "c1b61acd19e16b25e16f7df509a72563e9d7ab25", "url": "https://github.com/apache/beam/commit/c1b61acd19e16b25e16f7df509a72563e9d7ab25", "message": "Update abort message and add async abort signaling up to the GroupingShuffleReader's (values) iterator", "committedDate": "2020-10-06T16:25:07Z", "type": "commit"}, {"oid": "cba6498d3e6dad52bb0a1ef099471c20b32d2dbd", "url": "https://github.com/apache/beam/commit/cba6498d3e6dad52bb0a1ef099471c20b32d2dbd", "message": "When aborting the work item, log the status received from the backend", "committedDate": "2020-10-06T17:32:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NTcxMw==", "url": "https://github.com/apache/beam/pull/12994#discussion_r501855713", "bodyText": "Checking atFirstValue and aborted will likely perform worse then just checking aborted all the time. It may seem redundant but the abort happens asynchronously so we may have gotten past the check in the ReadOperation already.", "author": "lukecwik", "createdAt": "2020-10-08T16:31:34Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/GroupingShuffleReader.java", "diffHunk": "@@ -402,6 +432,14 @@ public boolean hasNext() {\n \n       @Override\n       public V next() {\n+        // Given that the underlying ReadOperation already checks the abort status after every\n+        // record it advances over (i.e., for every distinct key), we skip the check when at\n+        // the first value as that is redundant. Signal by thread interruption may be better, but\n+        // it may also have unintended side-effects.\n+        if (!atFirstValue && aborted.get()) {", "originalCommit": "cba6498d3e6dad52bb0a1ef099471c20b32d2dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}