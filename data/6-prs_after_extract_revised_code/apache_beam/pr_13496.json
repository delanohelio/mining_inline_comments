{"pr_number": 13496, "pr_title": "[BEAM-11408] Integrate BigQuery sink streaming inserts with GroupIntoBatches", "pr_createdAt": "2020-12-07T19:11:26Z", "pr_url": "https://github.com/apache/beam/pull/13496", "timeline": [{"oid": "d187951af8fc016fc8e2adf2d10054d94bfe9b63", "url": "https://github.com/apache/beam/commit/d187951af8fc016fc8e2adf2d10054d94bfe9b63", "message": "Integrate BQ streaming inserts with GroupIntoBatches", "committedDate": "2020-12-07T21:07:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg==", "url": "https://github.com/apache/beam/pull/13496#discussion_r537860362", "bodyText": "Didn't add a global window around here as the existing implementation:\n\n  \n    \n      beam/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\n    \n    \n         Line 281\n      in\n      2462fe9\n    \n    \n    \n    \n\n        \n          \n           \"GlobalWindow\", \n        \n    \n  \n\n\nAccording to the documentation the global window is for correct access to side inputs but it seems to me that up to this point the dynamic destination has been read. @reuvenlax I might be missing something but let me know if I should keep the global window (and if so where?).", "author": "nehsyc", "createdAt": "2020-12-07T21:53:12Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input", "originalCommit": "d187951af8fc016fc8e2adf2d10054d94bfe9b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NjU3MQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396571", "bodyText": "Hmm good question. I wonder if someone refactored the code at some point to change things? I'm not entirely sure about the global window here.", "author": "reuvenlax", "createdAt": "2021-01-06T06:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5Njk4Ng==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552396986", "bodyText": "However we probably want to put in global window here anyway as the GroupIntoBatches should logically be in hte global window, right? If the user had tiny windows, we don't want that to result in tiny grouping.", "author": "reuvenlax", "createdAt": "2021-01-06T06:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDExNQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774115", "bodyText": "Good point! I added a global window right before GroupIntoBatches.", "author": "nehsyc", "createdAt": "2021-01-08T06:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg2MDM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex 90cc08a046..a8e3bc73fb 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -274,7 +274,7 @@ class BatchedStreamingWrite<ErrorT, ElementT>\n \n   private class ViaStateful\n       extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n-    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.standardSeconds(10);\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n \n     @Override\n     public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n"}}, {"oid": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "url": "https://github.com/apache/beam/commit/3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "message": "Integrate BQ streaming inserts with GroupIntoBatches", "committedDate": "2020-12-28T18:57:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw==", "url": "https://github.com/apache/beam/pull/13496#discussion_r549453687", "bodyText": "Not sure about this limit. What would be a proper value? Should we make it configurable?", "author": "nehsyc", "createdAt": "2020-12-28T18:58:58Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY0NjQ5MQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r565646491", "bodyText": "to be hones, I am not sure what's a good duration either. I think this is acceptable for now, until we find out more. Thoughts?", "author": "pabloem", "createdAt": "2021-01-27T21:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4ODEzMA==", "url": "https://github.com/apache/beam/pull/13496#discussion_r565688130", "bodyText": "Yeah sounds reasonable to proceed with this for now.", "author": "nehsyc", "createdAt": "2021-01-27T22:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MzY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDA4Mw==", "url": "https://github.com/apache/beam/pull/13496#discussion_r537890083", "bodyText": "I would make this specified in the BigQueryIO builder instead.", "author": "reuvenlax", "createdAt": "2020-12-07T22:44:09Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java", "diffHunk": "@@ -243,61 +243,108 @@ public WriteResult expand(PCollection<KV<TableDestination, ElementT>> input) {\n       AtomicCoder<T> coder,\n       ErrorContainer<T> errorContainer) {\n     BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n-    int numShards = options.getNumStreamingKeys();\n \n     // A naive implementation would be to simply stream data directly to BigQuery.\n     // However, this could occasionally lead to duplicated data, e.g., when\n     // a VM that runs this code is restarted and the code is re-run.\n \n     // The above risk is mitigated in this implementation by relying on\n     // BigQuery built-in best effort de-dup mechanism.\n-\n     // To use this mechanism, each input TableRow is tagged with a generated\n-    // unique id, which is then passed to BigQuery and used to ignore duplicates\n-    // We create 50 keys per BigQuery table to generate output on. This is few enough that we\n-    // get good batching into BigQuery's insert calls, and enough that we can max out the\n-    // streaming insert quota.\n-    PCollection<KV<ShardedKey<String>, TableRowInfo<ElementT>>> tagged =\n-        input\n-            .apply(\"ShardTableWrites\", ParDo.of(new GenerateShardedTable<>(numShards)))\n-            .setCoder(KvCoder.of(ShardedKeyCoder.of(StringUtf8Coder.of()), elementCoder))\n-            .apply(\"TagWithUniqueIds\", ParDo.of(new TagWithUniqueIds<>()))\n-            .setCoder(\n-                KvCoder.of(\n-                    ShardedKeyCoder.of(StringUtf8Coder.of()), TableRowInfoCoder.of(elementCoder)));\n-\n-    TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+    // unique id, which is then passed to BigQuery and used to ignore duplicates.\n \n     // To prevent having the same TableRow processed more than once with regenerated\n     // different unique ids, this implementation relies on \"checkpointing\", which is\n-    // achieved as a side effect of having StreamingWriteFn immediately follow a GBK,\n-    // performed by Reshuffle.\n-    PCollectionTuple tuple =\n-        tagged\n-            .apply(Reshuffle.of())\n-            // Put in the global window to ensure that DynamicDestinations side inputs are accessed\n-            // correctly.\n-            .apply(\n-                \"GlobalWindow\",\n-                Window.<KV<ShardedKey<String>, TableRowInfo<ElementT>>>into(new GlobalWindows())\n-                    .triggering(DefaultTrigger.of())\n-                    .discardingFiredPanes())\n-            .apply(\n-                \"StreamingWrite\",\n-                ParDo.of(\n-                        new StreamingWriteFn<>(\n-                            bigQueryServices,\n-                            retryPolicy,\n-                            failedInsertsTag,\n-                            errorContainer,\n-                            skipInvalidRows,\n-                            ignoreUnknownValues,\n-                            ignoreInsertIds,\n-                            toTableRow,\n-                            toFailsafeTableRow))\n-                    .withOutputTags(mainOutputTag, TupleTagList.of(failedInsertsTag)));\n-    PCollection<T> failedInserts = tuple.get(failedInsertsTag);\n-    failedInserts.setCoder(coder);\n-    return failedInserts;\n+    // achieved as a side effect of having BigQuery insertion immediately follow a GBK.\n+\n+    if (options.getEnableStreamingAutoSharding()) {", "originalCommit": "d187951af8fc016fc8e2adf2d10054d94bfe9b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDE2MQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774161", "bodyText": "Done.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MDA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\nindex d28a544f0f..9bfe3d2197 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/StreamingWriteTables.java\n\n@@ -257,7 +284,7 @@ public class StreamingWriteTables<ElementT>\n     // different unique ids, this implementation relies on \"checkpointing\", which is\n     // achieved as a side effect of having BigQuery insertion immediately follow a GBK.\n \n-    if (options.getEnableStreamingAutoSharding()) {\n+    if (autoSharding) {\n       // If runner determined dynamic sharding is enabled, group TableRows on table destinations\n       // that may be sharded during the runtime. Otherwise, we choose a fixed number of shards per\n       // table destination following the logic below in the other branch.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552377340", "bodyText": "I think this should be an option on BigQueryIO.", "author": "reuvenlax", "createdAt": "2021-01-06T05:28:49Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java", "diffHunk": "@@ -78,4 +79,11 @@\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n+\n+  @Experimental\n+  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n+  @Default.Boolean(false)\n+  Boolean getEnableStreamingAutoSharding();", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDE4Ng==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774186", "bodyText": "Done.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEyMzQ0Mg==", "url": "https://github.com/apache/beam/pull/13496#discussion_r554123442", "bodyText": "I was thinking that adding the option to BigQueryOptions might be easier for the users to switch on/off the feature. If it is an option of BigQueryIO users would need to update their code (vs. adding a flag) right? It might not be a concern...", "author": "nehsyc", "createdAt": "2021-01-08T18:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3NzM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java\nindex 9e317137bf..8944f9c5ce 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BigQueryOptions.java\n\n@@ -79,11 +78,4 @@ public interface BigQueryOptions\n   Integer getLatencyLoggingFrequency();\n \n   void setLatencyLoggingFrequency(Integer value);\n-\n-  @Experimental\n-  @Description(\"Whether dynamic sharding is enabled for writing to BigQuery in streaming.\")\n-  @Default.Boolean(false)\n-  Boolean getEnableStreamingAutoSharding();\n-\n-  void setEnableStreamingAutoSharding(Boolean value);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDEwNA==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384104", "bodyText": "add space", "author": "reuvenlax", "createdAt": "2021-01-06T05:54:56Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDIxNQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774215", "bodyText": "Done.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDk2OA==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552384968", "bodyText": "seems more direct to just call tableRows.computeIfAbsent(tableSpec, ...)", "author": "reuvenlax", "createdAt": "2021-01-06T05:57:52Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI0NQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774245", "bodyText": "Done.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NDk2OA=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MDU4OQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552390589", "bodyText": "instead add an OutputReceiver parameter to finishBundle.", "author": "reuvenlax", "createdAt": "2021-01-06T06:18:22Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI3MA==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774270", "bodyText": "finishBundle doesn't seems to accept parameters other than FinishBundleContext.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MDU4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTAyNg==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552391026", "bodyText": "Why is this \"stateful\"?", "author": "reuvenlax", "createdAt": "2021-01-06T06:19:47Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDI4OQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774289", "bodyText": "Because input is batched through a stateful DoFn, GroupIntoBatches. Any suggestion on the name?", "author": "nehsyc", "createdAt": "2021-01-08T07:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzQ0MQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552397441", "bodyText": "We are relying on the fact that the GroupIntoBatches produces stable output. Really we should tag this with RequiresStableInput. Can you find out if this is safe to do in Dataflow?", "author": "reuvenlax", "createdAt": "2021-01-06T06:42:19Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDMyMg==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774322", "bodyText": "There is a transform override in Dataflow to add a preceding Reshuffle to DoFns marked with RequiresStableInput.\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/RequiresStableInputParDoOverrides.java\n    \n    \n         Line 73\n      in\n      74ec609\n    \n    \n    \n    \n\n        \n          \n           .apply(\"Materialize input\", Reshuffle.viaRandomKey()) \n        \n    \n  \n\n\nThe override is disabled though. So I guess currently Dataflow does nothing for this tag.\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/DataflowRunner.java\n    \n    \n         Line 601\n      in\n      df74d74\n    \n    \n    \n    \n\n        \n          \n           /* TODO[Beam-4684]: Support @RequiresStableInput on Dataflow in a more intelligent way \n        \n    \n  \n\n\nAlso my understanding is that dding a Reshuffle before GroupIntoBatches will introduce an extra shuffle as Reshuffle is essentially a GBK + value expansion in Dataflow.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzQ0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNjkxOQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r552406919", "bodyText": "use a MultiOutputReceiver instead", "author": "reuvenlax", "createdAt": "2021-01-06T07:15:22Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.bigquery;\n+\n+import com.google.api.services.bigquery.model.TableReference;\n+import com.google.api.services.bigquery.model.TableRow;\n+import java.io.IOException;\n+import java.math.RoundingMode;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.AtomicCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.SinkMetrics;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.GroupIntoBatches;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.util.Histogram;\n+import org.apache.beam.sdk.util.ShardedKey;\n+import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.sdk.values.TupleTagList;\n+import org.apache.beam.sdk.values.ValueInSingleWindow;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.math.DoubleMath;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** PTransform to perform batched streaming BigQuery write. */\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})\n+class BatchedStreamingWrite<ErrorT, ElementT>\n+    extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+  private static final TupleTag<Void> mainOutputTag = new TupleTag<>(\"mainOutput\");\n+\n+  private final BigQueryServices bqServices;\n+  private final InsertRetryPolicy retryPolicy;\n+  private final TupleTag<ErrorT> failedOutputTag;\n+  private final AtomicCoder<ErrorT> failedOutputCoder;\n+  private final ErrorContainer<ErrorT> errorContainer;\n+  private final boolean skipInvalidRows;\n+  private final boolean ignoreUnknownValues;\n+  private final boolean ignoreInsertIds;\n+  private final SerializableFunction<ElementT, TableRow> toTableRow;\n+  private final SerializableFunction<ElementT, TableRow> toFailsafeTableRow;\n+\n+  /** Tracks histogram of bytes written. Reset at the start of every bundle. */\n+  private transient Histogram histogram = Histogram.linear(0, 20, 3000);\n+\n+  private transient Long lastReportedSystemClockMillis = System.currentTimeMillis();\n+\n+  private final Logger LOG = LoggerFactory.getLogger(BatchedStreamingWrite.class);\n+\n+  /** Tracks bytes written, exposed as \"ByteCount\" Counter. */\n+  private Counter byteCounter = SinkMetrics.bytesWritten();\n+\n+  /** Switches the method of batching. */\n+  private final boolean batchViaStateful;\n+\n+  public BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = false;\n+  }\n+\n+  private BatchedStreamingWrite(\n+      BigQueryServices bqServices,\n+      InsertRetryPolicy retryPolicy,\n+      TupleTag<ErrorT> failedOutputTag,\n+      AtomicCoder<ErrorT> failedOutputCoder,\n+      ErrorContainer<ErrorT> errorContainer,\n+      boolean skipInvalidRows,\n+      boolean ignoreUnknownValues,\n+      boolean ignoreInsertIds,\n+      SerializableFunction<ElementT, TableRow> toTableRow,\n+      SerializableFunction<ElementT, TableRow> toFailsafeTableRow,\n+      boolean batchViaStateful) {\n+    this.bqServices = bqServices;\n+    this.retryPolicy = retryPolicy;\n+    this.failedOutputTag = failedOutputTag;\n+    this.failedOutputCoder = failedOutputCoder;\n+    this.errorContainer = errorContainer;\n+    this.skipInvalidRows = skipInvalidRows;\n+    this.ignoreUnknownValues = ignoreUnknownValues;\n+    this.ignoreInsertIds = ignoreInsertIds;\n+    this.toTableRow = toTableRow;\n+    this.toFailsafeTableRow = toFailsafeTableRow;\n+    this.batchViaStateful = batchViaStateful;\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are batched and\n+   * flushed upon bundle finalization.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaDoFnFinalization() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        false);\n+  }\n+\n+  /**\n+   * A transform that performs batched streaming BigQuery write; input elements are grouped on table\n+   * destinations and batched via a stateful DoFn. This also enables dynamic sharding during\n+   * grouping to parallelize writes.\n+   */\n+  public BatchedStreamingWrite<ErrorT, ElementT> viaStateful() {\n+    return new BatchedStreamingWrite<>(\n+        bqServices,\n+        retryPolicy,\n+        failedOutputTag,\n+        failedOutputCoder,\n+        errorContainer,\n+        skipInvalidRows,\n+        ignoreUnknownValues,\n+        ignoreInsertIds,\n+        toTableRow,\n+        toFailsafeTableRow,\n+        true);\n+  }\n+\n+  @Override\n+  public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+    return batchViaStateful\n+        ? input.apply(new ViaStateful())\n+        : input.apply(new ViaBundleFinalization());\n+  }\n+\n+  private class ViaBundleFinalization\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      PCollectionTuple result =\n+          input.apply(\n+              ParDo.of(new BatchAndInsertElements())\n+                  .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  private class BatchAndInsertElements extends DoFn<KV<String, TableRowInfo<ElementT>>, Void> {\n+\n+    /** JsonTableRows to accumulate BigQuery rows in order to batch writes. */\n+    private transient Map<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> tableRows;\n+\n+    /** The list of unique ids for each BigQuery table row. */\n+    private transient Map<String, List<String>> uniqueIdsForTableRows;\n+\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    /** Prepares a target BigQuery table. */\n+    @StartBundle\n+    public void startBundle() {\n+      tableRows = new HashMap<>();\n+      uniqueIdsForTableRows = new HashMap<>();\n+    }\n+\n+    /** Accumulates the input into JsonTableRows and uniqueIdsForTableRows. */\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<String, TableRowInfo<ElementT>> element,\n+        @Timestamp Instant timestamp,\n+        BoundedWindow window,\n+        PaneInfo pane) {\n+      String tableSpec = element.getKey();\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> rows =\n+          BigQueryHelpers.getOrCreateMapListValue(tableRows, tableSpec);\n+      List<String> uniqueIds =\n+          BigQueryHelpers.getOrCreateMapListValue(uniqueIdsForTableRows, tableSpec);\n+\n+      TableRow tableRow = toTableRow.apply(element.getValue().tableRow);\n+      TableRow failsafeTableRow = toFailsafeTableRow.apply(element.getValue().tableRow);\n+      rows.add(FailsafeValueInSingleWindow.of(tableRow, timestamp, window, pane, failsafeTableRow));\n+      uniqueIds.add(element.getValue().uniqueId);\n+    }\n+\n+    /** Writes the accumulated rows into BigQuery with streaming API. */\n+    @FinishBundle\n+    public void finishBundle(FinishBundleContext context) throws Exception {\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      for (Map.Entry<String, List<FailsafeValueInSingleWindow<TableRow, TableRow>>> entry :\n+          tableRows.entrySet()) {\n+        TableReference tableReference = BigQueryHelpers.parseTableSpec(entry.getKey());\n+        flushRows(\n+            tableReference,\n+            entry.getValue(),\n+            uniqueIdsForTableRows.get(entry.getKey()),\n+            options,\n+            failedInserts);\n+      }\n+      tableRows.clear();\n+      uniqueIdsForTableRows.clear();\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue(), row.getTimestamp(), row.getWindow());\n+      }\n+\n+      updateAndLogHistogram(options);\n+    }\n+  }\n+\n+  private class ViaStateful\n+      extends PTransform<PCollection<KV<String, TableRowInfo<ElementT>>>, PCollection<ErrorT>> {\n+    private final Duration BATCH_MAX_BUFFERING_DURATION = Duration.millis(200);\n+\n+    @Override\n+    public PCollection<ErrorT> expand(PCollection<KV<String, TableRowInfo<ElementT>>> input) {\n+      BigQueryOptions options = input.getPipeline().getOptions().as(BigQueryOptions.class);\n+      KvCoder<String, TableRowInfo<ElementT>> inputCoder = (KvCoder) input.getCoder();\n+      TableRowInfoCoder<ElementT> valueCoder =\n+          (TableRowInfoCoder) inputCoder.getCoderArguments().get(1);\n+      PCollectionTuple result =\n+          input\n+              // Group and batch table rows such that each batch has no more than\n+              // getMaxStreamingRowsToBatch rows. Also set a buffering time limit to avoid being\n+              // stuck at a partial batch forever, especially in a global window.\n+              .apply(\n+                  GroupIntoBatches.<String, TableRowInfo<ElementT>>ofSize(\n+                          options.getMaxStreamingRowsToBatch())\n+                      .withMaxBufferingDuration(BATCH_MAX_BUFFERING_DURATION)\n+                      .withShardedKey())\n+              .setCoder(\n+                  KvCoder.of(\n+                      ShardedKey.Coder.of(StringUtf8Coder.of()), IterableCoder.of(valueCoder)))\n+              .apply(\n+                  ParDo.of(new InsertBatchedElements())\n+                      .withOutputTags(mainOutputTag, TupleTagList.of(failedOutputTag)));\n+      PCollection<ErrorT> failedInserts = result.get(failedOutputTag);\n+      failedInserts.setCoder(failedOutputCoder);\n+      return failedInserts;\n+    }\n+  }\n+\n+  private class InsertBatchedElements\n+      extends DoFn<KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>>, Void> {\n+    @Setup\n+    public void setup() {\n+      // record latency upto 60 seconds in the resolution of 20ms\n+      histogram = Histogram.linear(0, 20, 3000);\n+      lastReportedSystemClockMillis = System.currentTimeMillis();\n+    }\n+\n+    @Teardown\n+    public void teardown() {\n+      if (histogram.getTotalCount() > 0) {\n+        logPercentiles();\n+        histogram.clear();\n+      }\n+    }\n+\n+    @ProcessElement\n+    public void processElement(\n+        @Element KV<ShardedKey<String>, Iterable<TableRowInfo<ElementT>>> input,\n+        BoundedWindow window,\n+        ProcessContext context)\n+        throws InterruptedException {\n+      List<FailsafeValueInSingleWindow<TableRow, TableRow>> tableRows = new ArrayList<>();\n+      List<String> uniqueIds = new ArrayList<>();\n+      for (TableRowInfo<ElementT> row : input.getValue()) {\n+        TableRow tableRow = toTableRow.apply(row.tableRow);\n+        TableRow failsafeTableRow = toFailsafeTableRow.apply(row.tableRow);\n+        tableRows.add(\n+            FailsafeValueInSingleWindow.of(\n+                tableRow, context.timestamp(), window, context.pane(), failsafeTableRow));\n+        uniqueIds.add(row.uniqueId);\n+      }\n+      BigQueryOptions options = context.getPipelineOptions().as(BigQueryOptions.class);\n+      TableReference tableReference = BigQueryHelpers.parseTableSpec(input.getKey().getKey());\n+      List<ValueInSingleWindow<ErrorT>> failedInserts = Lists.newArrayList();\n+      flushRows(tableReference, tableRows, uniqueIds, options, failedInserts);\n+\n+      for (ValueInSingleWindow<ErrorT> row : failedInserts) {\n+        context.output(failedOutputTag, row.getValue());", "originalCommit": "3b0992c68a0e639bc10d59e83f17739d83bcbbb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NDM0NQ==", "url": "https://github.com/apache/beam/pull/13496#discussion_r553774345", "bodyText": "Done.", "author": "nehsyc", "createdAt": "2021-01-08T07:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNjkxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "chunk": "diff --git a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\nindex a8e3bc73fb..19f4c33441 100644\n--- a/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n+++ b/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/bigquery/BatchedStreamingWrite.java\n\n@@ -37,7 +37,10 @@ import org.apache.beam.sdk.transforms.PTransform;\n import org.apache.beam.sdk.transforms.ParDo;\n import org.apache.beam.sdk.transforms.SerializableFunction;\n import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.DefaultTrigger;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindows;\n import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n import org.apache.beam.sdk.util.Histogram;\n import org.apache.beam.sdk.util.ShardedKey;\n import org.apache.beam.sdk.values.FailsafeValueInSingleWindow;\n"}}, {"oid": "f8790e344c022b4d299c3f7f71cbabeb398b0c21", "url": "https://github.com/apache/beam/commit/f8790e344c022b4d299c3f7f71cbabeb398b0c21", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments.", "committedDate": "2021-01-08T06:59:29Z", "type": "forcePushed"}, {"oid": "0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "url": "https://github.com/apache/beam/commit/0ab05d9a934a7d4ad22b070c77fb2f3857ea1b10", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments.", "committedDate": "2021-01-09T00:52:30Z", "type": "forcePushed"}, {"oid": "b16f518d20953b3d373a52a60148e71180ef9fd0", "url": "https://github.com/apache/beam/commit/b16f518d20953b3d373a52a60148e71180ef9fd0", "message": "Integrate BQ streaming inserts with GroupIntoBatches", "committedDate": "2021-01-27T22:27:53Z", "type": "commit"}, {"oid": "129176a8ff1eb1171ebdc950931a670babe690d8", "url": "https://github.com/apache/beam/commit/129176a8ff1eb1171ebdc950931a670babe690d8", "message": "Moved autosharding option from BigQueryOption to BigQueryIOBuilder; addressed comments.", "committedDate": "2021-01-27T22:28:27Z", "type": "commit"}, {"oid": "c033215c5cebc923652db018aaf034bcef8376c8", "url": "https://github.com/apache/beam/commit/c033215c5cebc923652db018aaf034bcef8376c8", "message": "fix checkstyle error", "committedDate": "2021-01-27T22:29:21Z", "type": "commit"}, {"oid": "c033215c5cebc923652db018aaf034bcef8376c8", "url": "https://github.com/apache/beam/commit/c033215c5cebc923652db018aaf034bcef8376c8", "message": "fix checkstyle error", "committedDate": "2021-01-27T22:29:21Z", "type": "forcePushed"}, {"oid": "3deba1de69098cbf58753831a50bf9583a87af55", "url": "https://github.com/apache/beam/commit/3deba1de69098cbf58753831a50bf9583a87af55", "message": "Revert the logic that was dropped during merge", "committedDate": "2021-01-27T23:29:53Z", "type": "commit"}, {"oid": "1b97e7c90a92f65df9faba5e531726ddc128c55a", "url": "https://github.com/apache/beam/commit/1b97e7c90a92f65df9faba5e531726ddc128c55a", "message": "Add comments for RequiresStableInput", "committedDate": "2021-01-28T00:51:18Z", "type": "commit"}]}