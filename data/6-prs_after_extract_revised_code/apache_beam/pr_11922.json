{"pr_number": 11922, "pr_title": "[BEAM-2939] Fix FnApiDoFnRunner to ensure that we output within the correct window when processing a splittable dofn", "pr_createdAt": "2020-06-04T18:15:14Z", "pr_url": "https://github.com/apache/beam/pull/11922", "timeline": [{"oid": "0beec6a9f21b139d0a65dfa699c9509513404710", "url": "https://github.com/apache/beam/commit/0beec6a9f21b139d0a65dfa699c9509513404710", "message": "[BEAM-2939] Fix FnApiDoFnRunner to ensure that we output within the correct window.\n\nThis fixes a bug where we would output within all the windows instead of just the current window.\nThis would not impact any SDF that used only a single window while processing.", "committedDate": "2020-06-04T18:14:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTY1Nw==", "url": "https://github.com/apache/beam/pull/11922#discussion_r435521657", "bodyText": "I'm wondering why the split is on the first window?", "author": "boyuanzz", "createdAt": "2020-06-04T20:12:08Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java", "diffHunk": "@@ -1593,6 +1601,391 @@ public void testProcessElementForSizedElementAndRestriction() throws Exception {\n     assertEquals(stateData, fakeClient.getData());\n   }\n \n+  @Test\n+  public void testProcessElementForWindowedSizedElementAndRestriction() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    PCollection<String> valuePCollection = p.apply(Create.of(\"unused\"));\n+    PCollectionView<String> singletonSideInputView = valuePCollection.apply(View.asSingleton());\n+    TestSplittableDoFn doFn = new TestSplittableDoFn(singletonSideInputView);\n+\n+    valuePCollection\n+        .apply(Window.into(SlidingWindows.of(Duration.standardSeconds(1))))\n+        .apply(TEST_TRANSFORM_ID, ParDo.of(doFn).withSideInputs(singletonSideInputView));\n+\n+    RunnerApi.Pipeline pProto =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            PipelineTranslation.toProto(p, SdkComponents.create(p.getOptions()), true),\n+            SplittableParDoExpander.createSizedReplacement());\n+    String expandedTransformId =\n+        Iterables.find(\n+                pProto.getComponents().getTransformsMap().entrySet(),\n+                entry ->\n+                    entry\n+                            .getValue()\n+                            .getSpec()\n+                            .getUrn()\n+                            .equals(\n+                                PTransformTranslation\n+                                    .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN)\n+                        && entry.getValue().getUniqueName().contains(TEST_TRANSFORM_ID))\n+            .getKey();\n+    RunnerApi.PTransform pTransform =\n+        pProto.getComponents().getTransformsOrThrow(expandedTransformId);\n+    String inputPCollectionId =\n+        pTransform.getInputsOrThrow(ParDoTranslation.getMainInputName(pTransform));\n+    RunnerApi.PCollection inputPCollection =\n+        pProto.getComponents().getPcollectionsOrThrow(inputPCollectionId);\n+    RehydratedComponents rehydratedComponents =\n+        RehydratedComponents.forComponents(pProto.getComponents());\n+    Coder<WindowedValue> inputCoder =\n+        WindowedValue.getFullCoder(\n+            CoderTranslation.fromProto(\n+                pProto.getComponents().getCodersOrThrow(inputPCollection.getCoderId()),\n+                rehydratedComponents,\n+                TranslationContext.DEFAULT),\n+            (Coder)\n+                CoderTranslation.fromProto(\n+                    pProto\n+                        .getComponents()\n+                        .getCodersOrThrow(\n+                            pProto\n+                                .getComponents()\n+                                .getWindowingStrategiesOrThrow(\n+                                    inputPCollection.getWindowingStrategyId())\n+                                .getWindowCoderId()),\n+                    rehydratedComponents,\n+                    TranslationContext.DEFAULT));\n+    String outputPCollectionId = pTransform.getOutputsOrThrow(\"output\");\n+\n+    ImmutableMap<StateKey, ByteString> stateData =\n+        ImmutableMap.of(\n+            multimapSideInputKey(singletonSideInputView.getTagInternal().getId(), ByteString.EMPTY),\n+            encode(\"8\"));\n+\n+    FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient(stateData);\n+\n+    List<WindowedValue<String>> mainOutputValues = new ArrayList<>();\n+    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+    PCollectionConsumerRegistry consumers =\n+        new PCollectionConsumerRegistry(\n+            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+    consumers.register(\n+        outputPCollectionId,\n+        TEST_TRANSFORM_ID,\n+        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) mainOutputValues::add);\n+    PTransformFunctionRegistry startFunctionRegistry =\n+        new PTransformFunctionRegistry(\n+            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+    PTransformFunctionRegistry finishFunctionRegistry =\n+        new PTransformFunctionRegistry(\n+            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+    List<ProgressRequestCallback> progressRequestCallbacks = new ArrayList<>();\n+    BundleSplitListener.InMemory splitListener = BundleSplitListener.InMemory.create();\n+\n+    new FnApiDoFnRunner.Factory<>()\n+        .createRunnerForPTransform(\n+            PipelineOptionsFactory.create(),\n+            null /* beamFnDataClient */,\n+            fakeClient,\n+            null /* beamFnTimerClient */,\n+            TEST_TRANSFORM_ID,\n+            pTransform,\n+            Suppliers.ofInstance(\"57L\")::get,\n+            pProto.getComponents().getPcollectionsMap(),\n+            pProto.getComponents().getCodersMap(),\n+            pProto.getComponents().getWindowingStrategiesMap(),\n+            consumers,\n+            startFunctionRegistry,\n+            finishFunctionRegistry,\n+            teardownFunctions::add,\n+            progressRequestCallbacks::add,\n+            splitListener,\n+            null /* bundleFinalizer */);\n+\n+    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+    mainOutputValues.clear();\n+\n+    assertThat(consumers.keySet(), containsInAnyOrder(inputPCollectionId, outputPCollectionId));\n+\n+    FnDataReceiver<WindowedValue<?>> mainInput =\n+        consumers.getMultiplexingConsumer(inputPCollectionId);\n+    assertThat(mainInput, instanceOf(HandlesSplits.class));\n+\n+    BoundedWindow window1 = new IntervalWindow(new Instant(5), new Instant(10));\n+    BoundedWindow window2 = new IntervalWindow(new Instant(6), new Instant(11));\n+    {\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> firstValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              window1,\n+              window2);\n+      mainInput.accept(firstValue);\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      // Since the side input upperBound is 8 we will process 5, 6, and 7 then checkpoint.\n+      // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n+      // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n+      // watermark.\n+      assertEquals(2, splitListener.getPrimaryRoots().size());\n+      assertEquals(2, splitListener.getResidualRoots().size());\n+      for (int i = 0; i < splitListener.getPrimaryRoots().size(); ++i) {\n+        BundleApplication primaryRoot = splitListener.getPrimaryRoots().get(i);\n+        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(i);\n+        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+        assertEquals(\n+            ParDoTranslation.getMainInputName(pTransform),\n+            residualRoot.getApplication().getInputId());\n+        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+        assertEquals(\n+            ImmutableMap.of(\n+                \"output\",\n+                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                    .build()),\n+            residualRoot.getApplication().getOutputWatermarksMap());\n+        assertEquals(\n+            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+                .setSeconds(54)\n+                .setNanos(321000000)\n+                .build(),\n+            residualRoot.getRequestedTimeDelay());\n+      }\n+      assertThat(\n+          Collections2.transform(\n+              splitListener.getPrimaryRoots(), (root) -> decode(inputCoder, root.getElement())),\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n+                      3.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      assertThat(\n+          Collections2.transform(\n+              splitListener.getResidualRoots(),\n+              (root) -> decode(inputCoder, root.getApplication().getElement())),\n+          contains(\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          \"5\",\n+                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window1,\n+                  firstValue.getPane()),\n+              WindowedValue.of(\n+                  KV.of(\n+                      KV.of(\n+                          \"5\",\n+                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                      2.0),\n+                  firstValue.getTimestamp(),\n+                  window2,\n+                  firstValue.getPane())));\n+      splitListener.clear();\n+\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> secondValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"2\", KV.of(new OffsetRange(0, 2), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(secondValue);\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      assertThat(\n+          mainOutputValues,\n+          contains(\n+              WindowedValue.of(\n+                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:5\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(5), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:6\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(6), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"5:7\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window1, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:0\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(0), window2, firstValue.getPane()),\n+              WindowedValue.of(\n+                  \"2:1\", GlobalWindow.TIMESTAMP_MIN_VALUE.plus(1), window2, firstValue.getPane())));\n+      assertTrue(splitListener.getPrimaryRoots().isEmpty());\n+      assertTrue(splitListener.getResidualRoots().isEmpty());\n+      mainOutputValues.clear();\n+    }\n+\n+    {\n+      // Setup and launch the trySplit thread.\n+      ExecutorService executorService = Executors.newSingleThreadExecutor();\n+      Future<HandlesSplits.SplitResult> trySplitFuture =\n+          executorService.submit(\n+              () -> {\n+                try {\n+                  doFn.waitForSplitElementToBeProcessed();\n+                  // Currently processing \"3\" out of range [0, 5) elements.\n+                  assertEquals(0.6, ((HandlesSplits) mainInput).getProgress(), 0.01);\n+\n+                  // Check that during progressing of an element we report progress\n+                  List<MonitoringInfo> mis =\n+                      Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos();\n+                  MonitoringInfo.Builder expectedCompleted = MonitoringInfo.newBuilder();\n+                  expectedCompleted.setUrn(MonitoringInfoConstants.Urns.WORK_COMPLETED);\n+                  expectedCompleted.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                  expectedCompleted.putLabels(\n+                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                  expectedCompleted.setPayload(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(3.0))));\n+                  MonitoringInfo.Builder expectedRemaining = MonitoringInfo.newBuilder();\n+                  expectedRemaining.setUrn(MonitoringInfoConstants.Urns.WORK_REMAINING);\n+                  expectedRemaining.setType(MonitoringInfoConstants.TypeUrns.PROGRESS_TYPE);\n+                  expectedRemaining.putLabels(\n+                      MonitoringInfoConstants.Labels.PTRANSFORM, TEST_TRANSFORM_ID);\n+                  expectedRemaining.setPayload(\n+                      ByteString.copyFrom(\n+                          CoderUtils.encodeToByteArray(\n+                              IterableCoder.of(DoubleCoder.of()), Collections.singletonList(2.0))));\n+                  assertThat(\n+                      mis,\n+                      containsInAnyOrder(expectedCompleted.build(), expectedRemaining.build()));\n+\n+                  return ((HandlesSplits) mainInput).trySplit(0);\n+                } finally {\n+                  doFn.releaseWaitingProcessElementThread();\n+                }\n+              });\n+\n+      // Check that before processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+      WindowedValue<?> splitValue =\n+          valueInWindows(\n+              KV.of(\n+                  KV.of(\"7\", KV.of(new OffsetRange(0, 5), GlobalWindow.TIMESTAMP_MIN_VALUE)), 2.0),\n+              window1,\n+              window2);\n+      mainInput.accept(splitValue);\n+      HandlesSplits.SplitResult trySplitResult = trySplitFuture.get();\n+\n+      // Check that after processing an element we don't report progress\n+      assertThat(Iterables.getOnlyElement(progressRequestCallbacks).getMonitoringInfos(), empty());\n+\n+      // Since the SPLIT_ELEMENT is 3 we will process 0, 1, 2, 3 then be split on the first window.", "originalCommit": "0beec6a9f21b139d0a65dfa699c9509513404710", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NjgzMg==", "url": "https://github.com/apache/beam/pull/11922#discussion_r435546832", "bodyText": "If the window is observed we need to process the element for each window independently. You do point out an issue though that the split's primary and residual roots need to account for what windows were processed and which are still remaining.", "author": "lukecwik", "createdAt": "2020-06-04T21:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTY1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f58af70504e4cfc12212d56c576bec87c2599d38", "chunk": "diff --git a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\nindex 6a5415005f..f9eec08dda 100644\n--- a/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n+++ b/sdks/java/harness/src/test/java/org/apache/beam/fn/harness/FnApiDoFnRunnerTest.java\n\n@@ -1732,74 +1732,72 @@ public class FnApiDoFnRunnerTest implements Serializable {\n       // We expect that the watermark advances to MIN + 7 and that the primary represents [5, 8)\n       // with the original watermark while the residual represents [8, 10) with the new MIN + 7\n       // watermark.\n-      assertEquals(2, splitListener.getPrimaryRoots().size());\n+      //\n+      // Since we were on the first window, we expect only a single primary root and two residual\n+      // roots (the split + the unprocessed window).\n+      BundleApplication primaryRoot = Iterables.getOnlyElement(splitListener.getPrimaryRoots());\n       assertEquals(2, splitListener.getResidualRoots().size());\n-      for (int i = 0; i < splitListener.getPrimaryRoots().size(); ++i) {\n-        BundleApplication primaryRoot = splitListener.getPrimaryRoots().get(i);\n-        DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(i);\n-        assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n-        assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n-        assertEquals(\n-            ParDoTranslation.getMainInputName(pTransform),\n-            residualRoot.getApplication().getInputId());\n-        assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n-        Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n-        assertEquals(\n-            ImmutableMap.of(\n-                \"output\",\n-                org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n-                    .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n-                    .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n-                    .build()),\n-            residualRoot.getApplication().getOutputWatermarksMap());\n-        assertEquals(\n-            org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n-                .setSeconds(54)\n-                .setNanos(321000000)\n-                .build(),\n-            residualRoot.getRequestedTimeDelay());\n-      }\n-      assertThat(\n-          Collections2.transform(\n-              splitListener.getPrimaryRoots(), (root) -> decode(inputCoder, root.getElement())),\n-          contains(\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                      3.0),\n-                  firstValue.getTimestamp(),\n-                  window1,\n-                  firstValue.getPane()),\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)),\n-                      3.0),\n-                  firstValue.getTimestamp(),\n-                  window2,\n-                  firstValue.getPane())));\n-      assertThat(\n-          Collections2.transform(\n-              splitListener.getResidualRoots(),\n-              (root) -> decode(inputCoder, root.getApplication().getElement())),\n-          contains(\n-              WindowedValue.of(\n-                  KV.of(\n-                      KV.of(\n-                          \"5\",\n-                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                      2.0),\n-                  firstValue.getTimestamp(),\n-                  window1,\n-                  firstValue.getPane()),\n-              WindowedValue.of(\n+      DelayedBundleApplication residualRoot = splitListener.getResidualRoots().get(1);\n+      DelayedBundleApplication residualRootForUnprocessedWindows =\n+          splitListener.getResidualRoots().get(0);\n+      assertEquals(ParDoTranslation.getMainInputName(pTransform), primaryRoot.getInputId());\n+      assertEquals(TEST_TRANSFORM_ID, primaryRoot.getTransformId());\n+      assertEquals(\n+          ParDoTranslation.getMainInputName(pTransform),\n+          residualRoot.getApplication().getInputId());\n+      assertEquals(TEST_TRANSFORM_ID, residualRoot.getApplication().getTransformId());\n+      Instant expectedOutputWatermark = GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7);\n+      assertEquals(\n+          ImmutableMap.of(\n+              \"output\",\n+              org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Timestamp.newBuilder()\n+                  .setSeconds(expectedOutputWatermark.getMillis() / 1000)\n+                  .setNanos((int) (expectedOutputWatermark.getMillis() % 1000) * 1000000)\n+                  .build()),\n+          residualRoot.getApplication().getOutputWatermarksMap());\n+      assertEquals(\n+          org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.Duration.newBuilder()\n+              .setSeconds(54)\n+              .setNanos(321000000)\n+              .build(),\n+          residualRoot.getRequestedTimeDelay());\n+      assertEquals(\n+          ParDoTranslation.getMainInputName(pTransform),\n+          residualRootForUnprocessedWindows.getApplication().getInputId());\n+      assertEquals(\n+          TEST_TRANSFORM_ID, residualRootForUnprocessedWindows.getApplication().getTransformId());\n+      assertEquals(\n+          residualRootForUnprocessedWindows.getRequestedTimeDelay().getDefaultInstanceForType(),\n+          residualRootForUnprocessedWindows.getRequestedTimeDelay());\n+      assertTrue(\n+          residualRootForUnprocessedWindows.getApplication().getOutputWatermarksMap().isEmpty());\n+\n+      assertEquals(\n+          decode(inputCoder, primaryRoot.getElement()),\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(5, 8), GlobalWindow.TIMESTAMP_MIN_VALUE)), 3.0),\n+              firstValue.getTimestamp(),\n+              window1,\n+              firstValue.getPane()));\n+      assertEquals(\n+          decode(inputCoder, residualRoot.getApplication().getElement()),\n+          WindowedValue.of(\n+              KV.of(\n                   KV.of(\n-                      KV.of(\n-                          \"5\",\n-                          KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n-                      2.0),\n-                  firstValue.getTimestamp(),\n-                  window2,\n-                  firstValue.getPane())));\n+                      \"5\", KV.of(new OffsetRange(8, 10), GlobalWindow.TIMESTAMP_MIN_VALUE.plus(7))),\n+                  2.0),\n+              firstValue.getTimestamp(),\n+              window1,\n+              firstValue.getPane()));\n+      assertEquals(\n+          decode(inputCoder, residualRootForUnprocessedWindows.getApplication().getElement()),\n+          WindowedValue.of(\n+              KV.of(\n+                  KV.of(\"5\", KV.of(new OffsetRange(5, 10), GlobalWindow.TIMESTAMP_MIN_VALUE)), 5.0),\n+              firstValue.getTimestamp(),\n+              window2,\n+              firstValue.getPane()));\n       splitListener.clear();\n \n       // Check that before processing an element we don't report progress\n"}}, {"oid": "f58af70504e4cfc12212d56c576bec87c2599d38", "url": "https://github.com/apache/beam/commit/f58af70504e4cfc12212d56c576bec87c2599d38", "message": "Make sure that splitting/checkpointing is window aware.", "committedDate": "2020-06-04T23:17:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjU0OA==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436072548", "bodyText": "Duplicated {@link #processElementForSizedElementAndRestriction}?", "author": "boyuanzz", "createdAt": "2020-06-05T17:49:45Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -296,6 +299,12 @@ public void accept(WindowedValue input) throws Exception {\n   /** Only valid during {@code processElement...} methods, null otherwise. */\n   private WindowedValue<InputT> currentElement;\n \n+  /**\n+   * Only valid during {@link #processElementForSizedElementAndRestriction} and {@link\n+   * #processElementForSizedElementAndRestriction}.", "originalCommit": "f58af70504e4cfc12212d56c576bec87c2599d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMzA5Nw==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436113097", "bodyText": "Fixed.", "author": "lukecwik", "createdAt": "2020-06-05T19:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjU0OA=="}], "type": "inlineReview", "revised_code": {"commit": "16d4619eb8fb312347a3ab73c7efadcee7f75a5d", "chunk": "diff --git a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\nindex c756889c8a..1c8ba3217b 100644\n--- a/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n+++ b/sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java\n\n@@ -300,7 +300,7 @@ public class FnApiDoFnRunner<InputT, RestrictionT, PositionT, WatermarkEstimator\n   private WindowedValue<InputT> currentElement;\n \n   /**\n-   * Only valid during {@link #processElementForSizedElementAndRestriction} and {@link\n+   * Only valid during {@link #processElementForElementAndRestriction} and {@link\n    * #processElementForSizedElementAndRestriction}.\n    */\n   private ListIterator<BoundedWindow> currentWindowIterator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTIwNA==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436085204", "bodyText": "currentWindowIterator .next()?", "author": "boyuanzz", "createdAt": "2020-06-05T18:12:09Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -577,26 +586,83 @@ public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n     switch (pTransform.getSpec().getUrn()) {\n       case PTransformTranslation.SPLITTABLE_PROCESS_ELEMENTS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n-            (splitResult, watermarkEstimatorState) ->\n-                WindowedSplitResult.forRoots(\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()),\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()));\n+            (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);", "originalCommit": "f58af70504e4cfc12212d56c576bec87c2599d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTE4Ng==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436111186", "bodyText": "ImmutableList.copyOf(iterator) drains all the remaining elements from iterator. It is effectively:\nwhile (iterator.hasNext()) {\n  list.add(iterator.next());\n}", "author": "lukecwik", "createdAt": "2020-06-05T19:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNjk3Mg==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436116972", "bodyText": "Ah I see. It's different from what I know about an Iterator. Thanks!", "author": "boyuanzz", "createdAt": "2020-06-05T19:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTIwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTQ4OA==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436085488", "bodyText": "currentWindowIterator.next()?", "author": "boyuanzz", "createdAt": "2020-06-05T18:12:33Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -577,26 +586,83 @@ public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n     switch (pTransform.getSpec().getUrn()) {\n       case PTransformTranslation.SPLITTABLE_PROCESS_ELEMENTS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n-            (splitResult, watermarkEstimatorState) ->\n-                WindowedSplitResult.forRoots(\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()),\n-                    WindowedValue.of(\n-                        KV.of(\n-                            currentElement.getValue(),\n-                            KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n-                        currentElement.getTimestamp(),\n-                        currentWindow,\n-                        currentElement.getPane()));\n+            (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);\n+              return WindowedSplitResult.forRoots(\n+                  primaryFullyProcessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              currentElement.getValue(),\n+                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                          currentElement.getTimestamp(),\n+                          primaryFullyProcessedWindows,\n+                          currentElement.getPane()),\n+                  WindowedValue.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(splitResult.getPrimary(), currentWatermarkEstimatorState)),\n+                      currentElement.getTimestamp(),\n+                      currentWindow,\n+                      currentElement.getPane()),\n+                  WindowedValue.of(\n+                      KV.of(\n+                          currentElement.getValue(),\n+                          KV.of(splitResult.getResidual(), watermarkEstimatorState)),\n+                      currentElement.getTimestamp(),\n+                      currentWindow,\n+                      currentElement.getPane()),\n+                  residualUnprocessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              currentElement.getValue(),\n+                              KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                          currentElement.getTimestamp(),\n+                          residualUnprocessedWindows,\n+                          currentElement.getPane()));\n+            };\n         break;\n       case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n         this.convertSplitResultToWindowedSplitResult =\n             (splitResult, watermarkEstimatorState) -> {\n+              List<BoundedWindow> primaryFullyProcessedWindows =\n+                  ImmutableList.copyOf(\n+                      Iterables.limit(\n+                          currentElement.getWindows(), currentWindowIterator.previousIndex()));\n+              // Advances the iterator consuming the remaining windows.\n+              List<BoundedWindow> residualUnprocessedWindows =\n+                  ImmutableList.copyOf(currentWindowIterator);", "originalCommit": "f58af70504e4cfc12212d56c576bec87c2599d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTI5Ng==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436111296", "bodyText": "ImmutableList.copyOf(iterator) drains all the remaining elements from iterator. It is effectively:\nwhile (iterator.hasNext()) {\n  list.add(iterator.next());\n}", "author": "lukecwik", "createdAt": "2020-06-05T19:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTQ4OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5MzA0OA==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436093048", "bodyText": "I'm wondering should the size be fullSize * num of windows?", "author": "boyuanzz", "createdAt": "2020-06-05T18:26:02Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -632,6 +698,17 @@ public Object restriction() {\n                         }\n                       });\n               return WindowedSplitResult.forRoots(\n+                  primaryFullyProcessedWindows.isEmpty()\n+                      ? null\n+                      : WindowedValue.of(\n+                          KV.of(\n+                              KV.of(\n+                                  currentElement.getValue(),\n+                                  KV.of(currentRestriction, currentWatermarkEstimatorState)),\n+                              fullSize),", "originalCommit": "f58af70504e4cfc12212d56c576bec87c2599d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTgzOA==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436111838", "bodyText": "I don't think so but this warrants a larger discussion about what does an element+restriction in multiple windows mean and how that it impacts splitting/sizing.\nI would like to leave it as is until we can build that consensus.", "author": "lukecwik", "createdAt": "2020-06-05T19:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5MzA0OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NzU0Mw==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436097543", "bodyText": "This also takes care of self checkpoint, right?", "author": "boyuanzz", "createdAt": "2020-06-05T18:35:04Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -941,20 +1047,59 @@ private Progress getProgress() {\n           convertSplitResultToWindowedSplitResult.apply(result, watermarkAndState.getValue());\n     }\n \n+    List<BundleApplication> primaryRoots = new ArrayList<>();", "originalCommit": "f58af70504e4cfc12212d56c576bec87c2599d38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjI0MQ==", "url": "https://github.com/apache/beam/pull/11922#discussion_r436112241", "bodyText": "Yes. As shown in the test the self checkpoint will checkpoint for the \"remaining\" windows as well.\nI would like to leave it as is until we can build consensus around what we should do in these use cases.", "author": "lukecwik", "createdAt": "2020-06-05T19:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5NzU0Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "16d4619eb8fb312347a3ab73c7efadcee7f75a5d", "url": "https://github.com/apache/beam/commit/16d4619eb8fb312347a3ab73c7efadcee7f75a5d", "message": "fixup! Address PR comments.", "committedDate": "2020-06-05T19:08:13Z", "type": "commit"}]}