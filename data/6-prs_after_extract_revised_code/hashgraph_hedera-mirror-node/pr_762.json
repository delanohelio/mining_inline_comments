{"pr_number": 762, "pr_title": "Add consensus_start and consensus_end to t_record_files", "pr_createdAt": "2020-05-15T17:03:14Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/762", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2NTAyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/762#discussion_r425965029", "bodyText": "With the change that went in today, we can simply use first and last RecordItem to calculate start and end timestamps.", "author": "apeksharma", "createdAt": "2020-05-15T18:05:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -193,13 +200,20 @@ public void loadRecordFile(StreamFileData streamFileData) throws IOException {\n                         dis.readFully(recordRawBytes);\n                         RecordItem recordItem = new RecordItem(transactionRawBytes, recordRawBytes);\n \n+                        long consensusTimestamp = Utility", "originalCommit": "a62e5ea51a8d77c1736fc78d2267e65662bc389c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjA2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/762#discussion_r426096062", "bodyText": "Done", "author": "steven-sheehy", "createdAt": "2020-05-16T00:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2NTAyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "291554146a7df5544350a71210cb9e1c06e05b3e", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\nindex 8894f11c..7f6a7a1f 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n\n@@ -98,166 +93,70 @@ public class RecordFileParser implements FileParser {\n                         \"processed the transaction\");\n     }\n \n-    /**\n-     * Given a service record name, read its prevFileHash\n-     *\n-     * @param fileName the name of record file to read\n-     * @return return previous file hash's Hex String\n-     */\n-    public static String readPrevFileHash(String fileName) {\n-        File file = new File(fileName);\n-        if (file.exists() == false) {\n-            log.warn(\"File does not exist {}\", fileName);\n-            return null;\n-        }\n-        byte[] prevFileHash = new byte[48];\n-        try (DataInputStream dis = new DataInputStream(new FileInputStream(file))) {\n-            // record_format_version\n-            dis.readInt();\n-            // version\n-            dis.readInt();\n-\n-            byte typeDelimiter = dis.readByte();\n-\n-            if (typeDelimiter == FileDelimiter.RECORD_TYPE_PREV_HASH) {\n-                dis.read(prevFileHash);\n-                String hexString = Hex.encodeHexString(prevFileHash);\n-                log.trace(\"Read previous file hash {} for file {}\", hexString, fileName);\n-                return hexString;\n-            } else {\n-                log.error(\"Expecting previous file hash, but found file delimiter {} for file {}\", typeDelimiter,\n-                        fileName);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Error reading previous file hash {}\", fileName, e);\n-        }\n-\n-        return null;\n-    }\n-\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n      * @param streamFileData containing information about file to be processed\n      */\n-    public void loadRecordFile(StreamFileData streamFileData) throws IOException {\n+    public void loadRecordFile(StreamFileData streamFileData) {\n+        Instant startTime = Instant.now();\n         recordStreamFileListener.onStart(streamFileData);\n+        RecordFile recordFile = Utility.parseRecordFile(streamFileData.getFilename(), true);\n+        String fileName = Utility.getFileName(streamFileData.getFilename());\n+        int counter = 0;\n+        boolean success = false;\n \n-        long counter = 0;\n-        Integer recordFileVersion = 0;\n-        Boolean success = false;\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        String currentHash = Hex.encodeHexString(Utility.getRecordFileHash(streamFileData.getFilename()));\n-        log.trace(\"Calculated file hash for the current file {}\", currentHash);\n-\n-        RecordFile recordFile = new RecordFile();\n-        recordFile.setFileHash(currentHash);\n-        recordFile.setLoadStart(Instant.now().getEpochSecond());\n-        recordFile.setName(streamFileData.getFilename());\n-\n-        try (DataInputStream dis = new DataInputStream(streamFileData.getInputStream())) {\n-            recordFileVersion = dis.readInt();\n-            int version = dis.readInt();\n-            log.info(\"Loading version {} record file: {}\", recordFileVersion, recordFile.getName());\n-            while (dis.available() != 0) {\n-                byte typeDelimiter = dis.readByte();\n-\n-                switch (typeDelimiter) {\n-                    case FileDelimiter.RECORD_TYPE_PREV_HASH:\n-                        byte[] readFileHash = new byte[48];\n-                        dis.read(readFileHash);\n-                        String actualPrevFileHash = Hex.encodeHexString(readFileHash);\n-                        recordFile.setPreviousHash(actualPrevFileHash);\n-                        String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(\n-                                ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH);\n-                        if (Utility.hashIsEmpty(expectedPrevFileHash)) {\n-                            log.error(\"Previous file hash not available\");\n-                            expectedPrevFileHash = actualPrevFileHash;\n-                        }\n-                        log.trace(\"actual file hash = {}, expected file hash = {}\", actualPrevFileHash,\n-                                expectedPrevFileHash);\n-                        if (!actualPrevFileHash.contentEquals(expectedPrevFileHash)) {\n-                            if (applicationStatusRepository\n-                                    .findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER)\n-                                    .compareTo(Utility.getFileName(recordFile.getName())) < 0) {\n-                                // last file for which mismatch is allowed is in the past\n-                                throw new ParserException(String.format(\n-                                        \"Hash mismatch for file %s. Expected = %s, Actual = %s\",\n-                                        recordFile.getName(), expectedPrevFileHash, actualPrevFileHash));\n-                            }\n-                        }\n-                        break;\n-                    case FileDelimiter.RECORD_TYPE_RECORD:\n-                        counter++;\n-\n-                        int byteLength = dis.readInt();\n-                        byte[] transactionRawBytes = new byte[byteLength];\n-                        dis.readFully(transactionRawBytes);\n-\n-                        byteLength = dis.readInt();\n-                        byte[] recordRawBytes = new byte[byteLength];\n-                        dis.readFully(recordRawBytes);\n-                        RecordItem recordItem = new RecordItem(transactionRawBytes, recordRawBytes);\n-\n-                        long consensusTimestamp = Utility\n-                                .timeStampInNanos(recordItem.getRecord().getConsensusTimestamp());\n-                        recordFile.setConsensusEnd(consensusTimestamp);\n-\n-                        if (recordFile.getConsensusStart() == null) {\n-                            recordFile.setConsensusStart(consensusTimestamp);\n-                        }\n-\n-                        if (log.isTraceEnabled()) {\n-                            log.trace(\"Transaction = {}, Record = {}\",\n-                                    Utility.printProtoMessage(recordItem.getTransaction()),\n-                                    Utility.printProtoMessage(recordItem.getRecord()));\n-                        } else {\n-                            log.debug(\"Storing transaction with consensus timestamp {}\", consensusTimestamp);\n-                        }\n-                        recordItemListener.onItem(recordItem);\n-\n-                        String type = TransactionTypeEnum.of(recordItem.getTransactionType()).toString();\n-                        transactionSizeMetric.tag(\"type\", type)\n-                                .register(meterRegistry)\n-                                .record(transactionRawBytes.length);\n+        try {\n+            if (!Utility.verifyHashChain(recordFile.getPreviousHash(),\n+                    applicationStatusRepository.findByStatusCode(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH),\n+                    parserProperties.getMirrorProperties().getVerifyHashAfter(), fileName)) {\n+                throw new ParserException(\"Hash mismatch for file \" + fileName);\n+            }\n \n-                        Instant consensusInstant = Instant.ofEpochSecond(0, consensusTimestamp);\n-                        transactionLatencyMetric.tag(\"type\", type)\n-                                .register(meterRegistry)\n-                                .record(Duration.between(consensusInstant, Instant.now()));\n-                        break;\n-                    case FileDelimiter.RECORD_TYPE_SIGNATURE:\n-                        int sigLength = dis.readInt();\n-                        byte[] sigBytes = new byte[sigLength];\n-                        dis.readFully(sigBytes);\n-                        log.trace(\"File {} has signature {}\", recordFile.getName(), Hex.encodeHexString(sigBytes));\n-                        break;\n+            for (var recordItem : recordFile.getRecordItems()) {\n+                counter++;\n \n-                    default:\n-                        throw new ParserException(String.format(\n-                                \"Unknown record file delimiter %s for file %s\", typeDelimiter, recordFile.getName()));\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"Transaction = {}, Record = {}\",\n+                            Utility.printProtoMessage(recordItem.getTransaction()),\n+                            Utility.printProtoMessage(recordItem.getRecord()));\n+                } else {\n+                    log.debug(\"Storing transaction with consensus timestamp {}\", () ->\n+                            Utility.printProtoMessage(recordItem.getRecord().getConsensusTimestamp()));\n                 }\n+                recordItemListener.onItem(recordItem);\n+\n+                String type = TransactionTypeEnum.of(recordItem.getTransactionType()).toString();\n+                transactionSizeMetric.tag(\"type\", type)\n+                        .register(meterRegistry)\n+                        .record(recordItem.getTransactionBytes().length);\n+\n+                Instant consensusTimestamp = Utility.convertToInstant(\n+                        recordItem.getRecord().getConsensusTimestamp());\n+                transactionLatencyMetric.tag(\"type\", type)\n+                        .register(meterRegistry)\n+                        .record(Duration.between(consensusTimestamp, Instant.now()));\n             }\n \n+            List<RecordItem> items = recordFile.getRecordItems();\n+            if (!items.isEmpty()) {\n+                recordFile.setConsensusStart(items.get(0).getConsensusTimestamp());\n+                recordFile.setConsensusEnd(items.get(items.size() - 1).getConsensusTimestamp());\n+            }\n             recordFile.setLoadEnd(Instant.now().getEpochSecond());\n             recordStreamFileListener.onEnd(recordFile);\n-\n-            if (!Utility.hashIsEmpty(recordFile.getFileHash())) {\n-                applicationStatusRepository\n-                        .updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, recordFile.getFileHash());\n-            }\n-\n+            applicationStatusRepository.updateStatusValue(\n+                    ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, recordFile.getFileHash());\n             success = true;\n         } finally {\n-            var elapsed = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n-            var rate = elapsed > 0 ? (int) (1000.0 * counter / elapsed) : 0;\n-            log.info(\"Finished parsing {} transactions from record file {} in {} ({}/s)\",\n-                    counter, recordFile.getName(), stopwatch, rate);\n-            parseDurationMetric.tag(\"success\", success.toString())\n-                    .tag(\"version\", recordFileVersion.toString())\n+            var elapsedTimeMillis = Duration.between(startTime, Instant.now()).toMillis();\n+            var rate = elapsedTimeMillis > 0 ? (int) (1000.0 * counter / elapsedTimeMillis) : 0;\n+            log.info(\"Finished parsing {} transactions from record file {} in {}ms ({}/s)\",\n+                    counter, fileName, elapsedTimeMillis, rate);\n+            parseDurationMetric.tag(\"success\", String.valueOf(success))\n+                    .tag(\"version\", String.valueOf(recordFile.getRecordFormatVersion()))\n                     .register(meterRegistry)\n-                    .record(stopwatch.elapsed());\n+                    .record(elapsedTimeMillis, TimeUnit.MILLISECONDS);\n         }\n     }\n \n"}}, {"oid": "291554146a7df5544350a71210cb9e1c06e05b3e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/291554146a7df5544350a71210cb9e1c06e05b3e", "message": "Add consensus_start and consensus_end to t_record_files\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-05-15T21:30:06Z", "type": "commit"}, {"oid": "2e7f2a6dc1bfb922176094ebf2be42343012fb10", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2e7f2a6dc1bfb922176094ebf2be42343012fb10", "message": "Fix merge conflicts\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-05-15T21:57:43Z", "type": "commit"}, {"oid": "2e7f2a6dc1bfb922176094ebf2be42343012fb10", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2e7f2a6dc1bfb922176094ebf2be42343012fb10", "message": "Fix merge conflicts\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-05-15T21:57:43Z", "type": "forcePushed"}, {"oid": "bacba60b457cc7638ee8a13dbfcb8368a81d5921", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/bacba60b457cc7638ee8a13dbfcb8368a81d5921", "message": "Merge issue\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-05-15T22:05:19Z", "type": "commit"}]}