{"pr_number": 543, "pr_title": "Fix subscribe topic with end time not completing", "pr_createdAt": "2020-02-18T22:08:35Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/543", "timeline": [{"oid": "ff46993fde46b800d3d0430388a4590662b51c95", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ff46993fde46b800d3d0430388a4590662b51c95", "message": "Fix subscribe topic with end time not completing\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-02-18T22:04:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjg5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r381012890", "bodyText": "This kills historical queries that are still running (polling every 2 sec). lastTopicMessage is the last one processed, not last one in the system.\nIf you send a subscription request with endTime=now() with very old startTime on a big topic, it dies 30 seconds in regardless of if there is more data.", "author": "mike-burrage-hedera", "createdAt": "2020-02-19T00:22:57Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java", "diffHunk": "@@ -148,15 +155,23 @@ void onNext(TopicMessage topicMessage) {\n             log.trace(\"[{}] Topic {} received message #{}: {}\", filter.getSubscriberId(), topicId, count, topicMessage);\n         }\n \n-        boolean shouldListen() {\n-            return filter.getEndTime() == null || filter.getEndTime().isAfter(startTime);\n-        }\n-\n         boolean isNext(TopicMessage topicMessage) {\n             return lastTopicMessage == null || topicMessage.getSequenceNumber() == lastTopicMessage\n                     .getSequenceNumber() + 1;\n         }\n \n+        /**\n+         * Checks whether the end time is after the current time and we haven't seen any new messages in more than the\n+         * interval check.\n+         *\n+         * @return if the end time is after the current time\n+         */\n+        boolean isPastEndTime() {\n+            Instant now = Instant.now();\n+            return filter.getEndTime().isAfter(now) && (lastTopicMessage == null ||\n+                    lastTopicMessage.getConsensusTimestamp().plus(grpcProperties.getEndTimeInterval()).isBefore(now));", "originalCommit": "ff46993fde46b800d3d0430388a4590662b51c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDM3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r381044372", "bodyText": "Nice catch. I can't think of another solution (without introducing another query as you mention) to address this until we have separated historical and incoming in #542. When that occurs, we can just complete it once historical flow is complete and then run my current logic with some slight modification. Will keep this as is until that PR is complete", "author": "steven-sheehy", "createdAt": "2020-02-19T02:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NjkxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r381046918", "bodyText": "If we know the last query for this subscription (has to be at least 1 completed query) definitely returned 0 records I think we can do something with that.\nCould assume the \"effective\" timestamp processed so far was now() - 10 seconds (or 30 seconds or something like that), and if that timestamp > endTime we can complete the subscription. And if we received any messages > endTime we can complete.\nMight be a pretty decent simple solution, and wouldn't require the additional query. It's an option.\nStill edge cases it's not perfect on, but possibly better than the current situation.", "author": "mike-burrage-hedera", "createdAt": "2020-02-19T02:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMTAzMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r385411031", "bodyText": "This is fixed now. With the split of historical and incoming, we can simply check if endTime is before time request was received after historical is complete.\nAdditionally, we check if incoming is complete by waiting for endTime to be after now, but with some buffer in between to ensure all messages are received.", "author": "steven-sheehy", "createdAt": "2020-02-27T22:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAxMjg5MA=="}], "type": "inlineReview", "revised_code": {"commit": "e77a7d75c7722b5e7e163e7ff2bce665e72efa06", "chunk": "diff --git a/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java b/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\nindex 94f7e43b..2847536e 100644\n--- a/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\n+++ b/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\n\n@@ -160,24 +158,31 @@ public class TopicMessageServiceImpl implements TopicMessageService {\n                     .getSequenceNumber() + 1;\n         }\n \n-        /**\n-         * Checks whether the end time is after the current time and we haven't seen any new messages in more than the\n-         * interval check.\n-         *\n-         * @return if the end time is after the current time\n-         */\n-        boolean isPastEndTime() {\n-            Instant now = Instant.now();\n-            return filter.getEndTime().isAfter(now) && (lastTopicMessage == null ||\n-                    lastTopicMessage.getConsensusTimestamp().plus(grpcProperties.getEndTimeInterval()).isBefore(now));\n+        boolean isComplete() {\n+            if (filter.getEndTime() == null) {\n+                return false;\n+            }\n+\n+            if (filter.getEndTime().isBefore(startTime)) {\n+                return true;\n+            }\n+\n+            return filter.getEndTime().plus(grpcProperties.getEndTimeInterval()).isBefore(Instant.now());\n         }\n \n-        void onComplete() {\n+        private int rate() {\n             var elapsed = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n-            var rate = elapsed > 0 ? (int) (1000.0 * count.get() / elapsed) : 0;\n-            log.info(\"[{}] Topic {} {} complete with {} messages in {} ({}/s)\", filter\n-                    .getSubscriberId(), topicId, mode, count, stopwatch, rate);\n-            mode = mode.next();\n+            return elapsed > 0 ? (int) (1000.0 * count.get() / elapsed) : 0;\n+        }\n+\n+        void onCancel() {\n+            log.info(\"[{}] Topic {} cancelled with {} messages in {} ({}/s)\",\n+                    filter.getSubscriberId(), topicId, count, stopwatch, rate());\n+        }\n+\n+        void onComplete() {\n+            log.info(\"[{}] Topic {} completed with {} messages in {} ({}/s)\",\n+                    filter.getSubscriberId(), topicId, count, stopwatch, rate());\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDAzNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r381044034", "bodyText": "Deciding based on now and endTimeInterval is susceptible to\n\nrelative time skews between grpc server and nodes\ndelay in ingestion\n\nOne of the way to do this accurately would be - using latest consensus timestamp from t_timestamp table.\nIf latest consensus ts > filter's end time, then we know for sure that no new messages are arriving.", "author": "apeksharma", "createdAt": "2020-02-19T02:20:06Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java", "diffHunk": "@@ -148,15 +155,23 @@ void onNext(TopicMessage topicMessage) {\n             log.trace(\"[{}] Topic {} received message #{}: {}\", filter.getSubscriberId(), topicId, count, topicMessage);\n         }\n \n-        boolean shouldListen() {\n-            return filter.getEndTime() == null || filter.getEndTime().isAfter(startTime);\n-        }\n-\n         boolean isNext(TopicMessage topicMessage) {\n             return lastTopicMessage == null || topicMessage.getSequenceNumber() == lastTopicMessage\n                     .getSequenceNumber() + 1;\n         }\n \n+        /**\n+         * Checks whether the end time is after the current time and we haven't seen any new messages in more than the\n+         * interval check.\n+         *\n+         * @return if the end time is after the current time\n+         */\n+        boolean isPastEndTime() {\n+            Instant now = Instant.now();\n+            return filter.getEndTime().isAfter(now) && (lastTopicMessage == null ||\n+                    lastTopicMessage.getConsensusTimestamp().plus(grpcProperties.getEndTimeInterval()).isBefore(now));\n+        }", "originalCommit": "ff46993fde46b800d3d0430388a4590662b51c95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4NDE3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r381384177", "bodyText": "Executing a separate query is\n\nSlow\nWon't work if there's no messages after endTime\nDoesn't address completing incoming messages", "author": "steven-sheehy", "createdAt": "2020-02-19T16:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA0NDAzNA=="}], "type": "inlineReview", "revised_code": {"commit": "e77a7d75c7722b5e7e163e7ff2bce665e72efa06", "chunk": "diff --git a/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java b/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\nindex 94f7e43b..2847536e 100644\n--- a/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\n+++ b/hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/service/TopicMessageServiceImpl.java\n\n@@ -160,24 +158,31 @@ public class TopicMessageServiceImpl implements TopicMessageService {\n                     .getSequenceNumber() + 1;\n         }\n \n-        /**\n-         * Checks whether the end time is after the current time and we haven't seen any new messages in more than the\n-         * interval check.\n-         *\n-         * @return if the end time is after the current time\n-         */\n-        boolean isPastEndTime() {\n-            Instant now = Instant.now();\n-            return filter.getEndTime().isAfter(now) && (lastTopicMessage == null ||\n-                    lastTopicMessage.getConsensusTimestamp().plus(grpcProperties.getEndTimeInterval()).isBefore(now));\n+        boolean isComplete() {\n+            if (filter.getEndTime() == null) {\n+                return false;\n+            }\n+\n+            if (filter.getEndTime().isBefore(startTime)) {\n+                return true;\n+            }\n+\n+            return filter.getEndTime().plus(grpcProperties.getEndTimeInterval()).isBefore(Instant.now());\n         }\n \n-        void onComplete() {\n+        private int rate() {\n             var elapsed = stopwatch.elapsed(TimeUnit.MILLISECONDS);\n-            var rate = elapsed > 0 ? (int) (1000.0 * count.get() / elapsed) : 0;\n-            log.info(\"[{}] Topic {} {} complete with {} messages in {} ({}/s)\", filter\n-                    .getSubscriberId(), topicId, mode, count, stopwatch, rate);\n-            mode = mode.next();\n+            return elapsed > 0 ? (int) (1000.0 * count.get() / elapsed) : 0;\n+        }\n+\n+        void onCancel() {\n+            log.info(\"[{}] Topic {} cancelled with {} messages in {} ({}/s)\",\n+                    filter.getSubscriberId(), topicId, count, stopwatch, rate());\n+        }\n+\n+        void onComplete() {\n+            log.info(\"[{}] Topic {} completed with {} messages in {} ({}/s)\",\n+                    filter.getSubscriberId(), topicId, count, stopwatch, rate());\n         }\n     }\n }\n"}}, {"oid": "e1ca7272903c444b19b18815ecd3c9267ad0dc1f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e1ca7272903c444b19b18815ecd3c9267ad0dc1f", "message": "Merge remote-tracking branch 'origin/master' into complete-end-time", "committedDate": "2020-02-25T22:35:03Z", "type": "commit"}, {"oid": "e77a7d75c7722b5e7e163e7ff2bce665e72efa06", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e77a7d75c7722b5e7e163e7ff2bce665e72efa06", "message": "Address review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-02-27T20:58:33Z", "type": "commit"}, {"oid": "43cd07d5e884f66f3a07768359af4c584f86ddcd", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/43cd07d5e884f66f3a07768359af4c584f86ddcd", "message": "Revert to 30s\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-02-27T22:37:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMTQ1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r385421456", "bodyText": "q: why the preference for  replay and auto connect after 1 subscriber instead of just cache()", "author": "Nana-EC", "createdAt": "2020-02-27T23:03:03Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedPollingTopicListener.java", "diffHunk": "@@ -84,9 +84,10 @@ public void init() {\n                 .doOnComplete(() -> log.info(\"Completed polling\"))\n                 .doOnNext(context::onNext)\n                 .doOnSubscribe(context::onStart)\n-                .cache(listenerProperties.getBufferSize());\n+                .replay(listenerProperties.getBufferSize())", "originalCommit": "43cd07d5e884f66f3a07768359af4c584f86ddcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQzMTAyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r385431021", "bodyText": "There's zero difference behind the scenes except that autoConnect gives you an overload to store the cancellation callback. Without that cancellation there were multiple shared pollers running concurrently during tests.", "author": "steven-sheehy", "createdAt": "2020-02-27T23:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMTQ1Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzE4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/543#discussion_r385477181", "bodyText": "in listen,  we should be just replaying the messages with timestamp after last seen timestamp of that particular subscriber.\nReturning possible duplicates from one layer and filtering them in another layer doesn't seem right.\nWe should be building a system with stronger invariants than that.", "author": "apeksharma", "createdAt": "2020-02-28T02:22:07Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedPollingTopicListener.java", "diffHunk": "@@ -84,9 +84,10 @@ public void init() {\n                 .doOnComplete(() -> log.info(\"Completed polling\"))\n                 .doOnNext(context::onNext)\n                 .doOnSubscribe(context::onStart)\n-                .cache(listenerProperties.getBufferSize());\n+                .replay(listenerProperties.getBufferSize())", "originalCommit": "43cd07d5e884f66f3a07768359af4c584f86ddcd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}