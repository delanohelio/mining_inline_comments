{"pr_number": 1089, "pr_title": "HTS: Add support for token transactions to Importer", "pr_createdAt": "2020-09-30T00:02:20Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTcyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497789723", "bodyText": "Removing this so as not to conflict w Ian's PR", "author": "Nana-EC", "createdAt": "2020-09-30T20:46:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@AllArgsConstructor\n+@NoArgsConstructor\n+@Entity\n+\n+public class TokenBalance implements Persistable<TokenBalance.Id> {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java\nindex 3f6f41d6..c02a0a9e 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java\n\n@@ -3,9 +3,9 @@ package com.hedera.mirror.importer.domain;\n /*-\n  * \u200c\n  * Hedera Mirror Node\n- * \u200b\n+ *\n  * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTQ4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497791480", "bodyText": "Add a tokenUpdate tests in EntityRecordItemListenerTokenTest.java", "author": "Nana-EC", "createdAt": "2020-09-30T20:49:21Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +190,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);\n+            } else if (body.hasTokenBurn()) {\n+                insertTokenBurn(consensusNs, body);\n+            } else if (body.hasTokenCreation()) {\n+                insertTokenCreate(consensusNs, txRecord, body);\n+            } else if (body.hasTokenDeletion()) {\n+                insertTokenDelete(consensusNs, body);\n+            } else if (body.hasTokenDissociate()) {\n+                insertTokenDissociate(consensusNs, body);\n+            } else if (body.hasTokenFreeze()) {\n+                insertTokenAccountFreezeBody(consensusNs, body);\n+            } else if (body.hasTokenGrantKyc()) {\n+                insertTokenAccountGrantKyc(consensusNs, body);\n+            } else if (body.hasTokenMint()) {\n+                insertTokenMint(consensusNs, body);\n+            } else if (body.hasTokenRevokeKyc()) {\n+                insertTokenAccountRevokeKyc(consensusNs, body);\n+            } else if (body.hasTokenTransfers()) {\n+                insertTokenTransfers(consensusNs, txRecord);\n+            } else if (body.hasTokenUnfreeze()) {\n+                insertTokenAccountUnfreeze(consensusNs, body);\n+            } else if (body.hasTokenUpdate()) {\n+                insertTokenUpdate(consensusNs, body);", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 651d04d4..f6abe238 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -190,32 +187,34 @@ public class EntityRecordItemListener implements RecordItemListener {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n-            } else if (body.hasTokenAssociate()) {\n-                insertTokenAssociate(consensusNs, body);\n-            } else if (body.hasTokenBurn()) {\n-                insertTokenBurn(consensusNs, body);\n-            } else if (body.hasTokenCreation()) {\n+            }\n+//            else if (body.hasTokenAssociate()) {\n+//                insertTokenAssociate(body);\n+//            }\n+            else if (body.hasTokenCreation()) {\n                 insertTokenCreate(consensusNs, txRecord, body);\n             } else if (body.hasTokenDeletion()) {\n-                insertTokenDelete(consensusNs, body);\n-            } else if (body.hasTokenDissociate()) {\n-                insertTokenDissociate(consensusNs, body);\n-            } else if (body.hasTokenFreeze()) {\n-                insertTokenAccountFreezeBody(consensusNs, body);\n+\n+            } else if (body.hasTokenDeletion()) {\n+                insertTokenDelete(body);\n+            }\n+//            else if (body.hasTokenDissociate()) {\n+//                insertTokenDissociate(body);\n+//            }\n+            else if (body.hasTokenFreeze()) {\n+                insertTokenAccountFreezeBody(body);\n             } else if (body.hasTokenGrantKyc()) {\n-                insertTokenAccountGrantKyc(consensusNs, body);\n-            } else if (body.hasTokenMint()) {\n-                insertTokenMint(consensusNs, body);\n+                insertTokenGrantKyc(body);\n             } else if (body.hasTokenRevokeKyc()) {\n-                insertTokenAccountRevokeKyc(consensusNs, body);\n+                insertTokenRevokeKyc(body);\n             } else if (body.hasTokenTransfers()) {\n                 insertTokenTransfers(consensusNs, txRecord);\n             } else if (body.hasTokenUnfreeze()) {\n-                insertTokenAccountUnfreeze(consensusNs, body);\n+                insertTokenUnfreeze(body);\n             } else if (body.hasTokenUpdate()) {\n                 insertTokenUpdate(consensusNs, body);\n             } else if (body.hasTokenWipe()) {\n-                insertTokenAccountWipe(consensusNs, body);\n+                insertTokenWipe(body);\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwNzI0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497807244", "bodyText": "remove and use enum. Here and below", "author": "Nana-EC", "createdAt": "2020-09-30T21:20:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +430,262 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 651d04d4..f6abe238 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -431,155 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n-                tokenAccount.setFreezeStatus(1);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                // KycNotApplicable = 0, Granted = 1, Revoked = 2\n-                tokenAccount.setKycStatus(1);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                // KycNotApplicable = 0, Granted = 1, Revoked = 2\n-                tokenAccount.setKycStatus(2);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMzA4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497813088", "bodyText": "remove tokens and tokenAccounts lists for now as we save immediately", "author": "Nana-EC", "createdAt": "2020-09-30T21:32:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -124,6 +139,9 @@ public SqlEntityListener(SqlProperties sqlProperties, DataSource dataSource,\n         liveHashes = new ArrayList<>();\n         entityIds = new HashSet<>();\n         topicMessages = new ArrayList<>();\n+        tokens = new ArrayList<>();", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4923866fa05ab8dd6cd479f3ae2edee59d29b866", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\nindex 03e63dad..03dc924b 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\n\n@@ -139,8 +137,6 @@ public class SqlEntityListener implements EntityListener, RecordStreamFileListen\n         liveHashes = new ArrayList<>();\n         entityIds = new HashSet<>();\n         topicMessages = new ArrayList<>();\n-        tokens = new ArrayList<>();\n-        tokenAccounts = new ArrayList<>();\n         tokenTransfers = new ArrayList<>();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDU1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497814554", "bodyText": "Add conditional check and add expiry set", "author": "Nana-EC", "createdAt": "2020-09-30T21:35:47Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\nindex 52ce8ddd..7dbc4d3c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenCreation;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTMwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (txMessage.getExpiry() != 0) {\n          \n          \n            \n                    if (txMessage.getAutoRenewPeriod() != 0) {", "author": "Nana-EC", "createdAt": "2020-09-30T21:37:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\nindex a52e96b0..cc81c328 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenManagement;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTUyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815523", "bodyText": "Delete to not conflict with Ian", "author": "Nana-EC", "createdAt": "2020-09-30T21:38:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.TokenBalance;\n+\n+public interface TokenBalanceRepository extends CrudRepository<TokenBalance, TokenBalance.Id> {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4923866fa05ab8dd6cd479f3ae2edee59d29b866", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\nsimilarity index 72%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\nindex 7c26500b..0a7f0c02 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\n\n@@ -1,4 +1,4 @@\n-package com.hedera.mirror.importer.repository;\n+package com.hedera.mirror.importer.parser.record.entity;\n \n /*-\n  * \u200c\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498374705", "bodyText": "Should exclude the hex form as well as it will be quite large. Might be simpler to put the @ToString.Exclude annotation on the fields with this many.", "author": "steven-sheehy", "createdAt": "2020-10-01T16:31:36Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDMyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094326", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzYxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498393614", "bodyText": "Since both clients that use this catch and return null, let's just change the Utility implementation to do so. Then you can use utility directly and don't need wrapper convertByteKeyToHex", "author": "steven-sheehy", "createdAt": "2020-10-01T17:05:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDMzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094338", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498394289", "bodyText": "We don't need an embedded id if it's not a composite key. Just use EntityId directly.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:07:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);\n+        } catch (Exception e) {\n+            log.error(\"Invalid ED25519 key could not be translated to hex text for entity {}. Field \" +\n+                    \"will be nulled\", tokenId, e);\n+            return null;\n+        }\n+    }\n+\n+    @Data\n+    @Embeddable\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    public static class Id implements Serializable {\n+\n+        private static final long serialVersionUID = -4595724698253758379L;\n+\n+        @Convert(converter = TokenIdConverter.class)\n+        @JsonSerialize(using = EntityIdSerializer.class)\n+        private EntityId tokenId;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjgwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498996808", "bodyText": "Left over logic, meant to change", "author": "Nana-EC", "createdAt": "2020-10-02T18:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDM2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094362", "bodyText": "Remembered now, hit the issue last week where the Converter wasn't getting honored for @id.\nLeaving as is as discussed offline since as you noted it's not possible with JPA spec - eclipse-ee4j/jpa-api#207", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTE1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498395153", "bodyText": "We shouldn't import protobuf classes into domain classes. We should create our own enum for kyc status and  freeze status and make the domain classes use those.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:08:42Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQwMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094401", "bodyText": "Done. Created our own TokenFreezeStatusEnum and TokenKycStatusEnum", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTIyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421222", "bodyText": "We should use primitives for non-null numbers like initialSupply and totalSupply.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:56:17Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094419", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTM1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421353", "bodyText": "Would prefer fields sorted by name.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:56:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094437", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421814", "bodyText": "This is a bigint in the schema. Should the schema be changed or this changed to long?", "author": "steven-sheehy", "createdAt": "2020-10-01T17:57:22Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzUzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498953538", "bodyText": "This should be a long, schema is right", "author": "Nana-EC", "createdAt": "2020-10-02T17:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094458", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498422561", "bodyText": "Should we rename as wipe_key_ed_25519_hex so we don't have to manually map?", "author": "steven-sheehy", "createdAt": "2020-10-01T17:58:46Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mzg4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498953889", "bodyText": "Yes, that would be cleaner", "author": "Nana-EC", "createdAt": "2020-10-02T17:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5Mjg4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498992883", "bodyText": "wipe_key_ed_25519_hex would actually still require a mapping as hibernate translates wipeKeyEd25519Hex to wipe_key_ed25519hex.\nIf we want to avoid manual mapping we either set the schema to wipe_key_ed25519hex or rename the member to be wipeKeyHexEd25519 and schema to be wipe_key_hex_ed25519", "author": "Nana-EC", "createdAt": "2020-10-02T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\nindex 6b2a334b7..94a684e7c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java\n\n@@ -20,38 +20,31 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n-import com.hederahashgraph.api.proto.java.TokenKycStatus;\n-import java.io.Serializable;\n-import javax.persistence.Column;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.ToString;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n import com.hedera.mirror.importer.util.Utility;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n @ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n public class Token {\n-    @EmbeddedId\n-    private Token.Id tokenId;\n+    @Id\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n     private long createdTimestamp;\n \n-    private int decimals;\n+    private boolean deleted;\n+\n+    private int divisibility;\n \n     private boolean freezeDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTYxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498531619", "bodyText": "Should use enums for status", "author": "steven-sheehy", "createdAt": "2020-10-01T21:52:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId accountId;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    private int freezeStatus;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDUxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094516", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\nindex 5ac276d46..8c22f0610 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n\n@@ -46,12 +46,14 @@ public class TokenAccount {\n \n     private long createdTimestamp;\n \n-    private int freezeStatus;\n+    private boolean frozen;\n \n-    private int kycStatus;\n+    private boolean kyc;\n \n     private long modifiedTimestamp;\n \n     @Convert(converter = TokenIdConverter.class)\n     private EntityId tokenId;\n+\n+    private boolean wiped;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzODU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498538576", "bodyText": "We should avoid doing conditional logic based upon nulls. Would prefer taking advantage of the optional returned by the repo and chaining to ifPresent().", "author": "steven-sheehy", "createdAt": "2020-10-01T22:14:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094565", "bodyText": "Can do", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzODU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498913518", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:05:31Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenAssociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDYxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498954614", "bodyText": "Can't return one account Id since TokenAssociate can be applied to multiple accounts at a time", "author": "Nana-EC", "createdAt": "2020-10-02T17:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTU1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498961553", "bodyText": "Actually, it's the opposite. 1 Account -> Many tokens.\nWill return the Account entity in this case then.", "author": "Nana-EC", "createdAt": "2020-10-02T17:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094578", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java\nindex 123ffc149..1498fa03d 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java\n\n@@ -1,36 +1,4 @@\n package com.hedera.mirror.importer.parser.record.transactionhandler;\n \n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-\n-import com.hedera.mirror.importer.domain.EntityId;\n-import com.hedera.mirror.importer.parser.domain.RecordItem;\n-\n-@Named\n-@AllArgsConstructor\n-public class TokenAssociateTransactionsHandler implements TransactionHandler {\n-    @Override\n-    public EntityId getEntity(RecordItem recordItem) {\n-        return null;\n-    }\n+public class TokenAssociateTransactionsHandler {\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498914353", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:07:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenDissociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDkyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498954929", "bodyText": "Can't return one account Id since TokenDissociate can be applied to multiple accounts at a time", "author": "Nana-EC", "createdAt": "2020-10-02T17:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498961624", "bodyText": "Actually, it's the opposite. 1 Account -> Many tokens.\nWill return the Account entity in this case then.", "author": "Nana-EC", "createdAt": "2020-10-02T17:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU4NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094584", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java\nindex 3b6189ba4..f2badb958 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java\n\n@@ -1,37 +1,4 @@\n package com.hedera.mirror.importer.parser.record.transactionhandler;\n \n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-\n-import com.hedera.mirror.importer.domain.EntityId;\n-import com.hedera.mirror.importer.parser.domain.RecordItem;\n-\n-@Named\n-@AllArgsConstructor\n-public class TokenDissociateTransactionsHandler implements TransactionHandler {\n-    @Override\n-    public EntityId getEntity(RecordItem recordItem) {\n-        return null;\n-    }\n+public class TokenDissociateTransactionsHandler {\n }\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNTA0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498915045", "bodyText": "nit: Would prefer a variable name that represents the thing it's holding. e.g. tokenCreateTransactionBody, transactionBody, body.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:08:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDYwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094602", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNTA0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\nindex d9c571b45..7dbc4d3ca 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenCreation;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjcyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498916728", "bodyText": "Not an issue with your code, but autoRenewPeriod is modeled as a Duration in ConsensusCreateTopic and a uint64 here. Can we ask Michael if this can be switched to Duration?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:11:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxMzQ3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499913472", "bodyText": "Requested", "author": "Nana-EC", "createdAt": "2020-10-05T22:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\nindex d9c571b45..7dbc4d3ca 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenCreation;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498917727", "bodyText": "Should we ask services to model this as a Timestamp?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:13:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {\n+            entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1ODU2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498958562", "bodyText": "Yeah, probably better for consistency across entities to just do Timestamp.\nI also need to change this to pull ns as looks like expiry is in epoch seconds", "author": "Nana-EC", "createdAt": "2020-10-02T17:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxMzUxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499913514", "bodyText": "Requested", "author": "Nana-EC", "createdAt": "2020-10-05T22:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\nindex d9c571b45..7dbc4d3ca 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenCreation;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498918536", "bodyText": "Should this be the token or the account? We're not freezing the token we're freezing the account's use of this token. Or more generically, this action is modifying the account not the token.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:15:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenFreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenFreeze().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2Nzg3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498967878", "bodyText": "Yeah, I think the confusion comes from the fact that the real thing being modified is the TokenAccount not the Account or the Token in the Freeze/Kyc cases. That's the info that should be extracted on a getEntity.\nNeither Account nor Token are modified by these cases and so it's a toss up in terms of which one to return.\nEither ways you'd need the other for full visibility.\nI think the right thing in a future refactor would be to return the appropriate entity of TokenAccount.", "author": "Nana-EC", "createdAt": "2020-10-02T17:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDYzMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094631", "bodyText": "Went ahead and returned Account type", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java\nindex c33f19abe..cb520282f 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java\n\n@@ -31,6 +31,6 @@ import com.hedera.mirror.importer.parser.domain.RecordItem;\n public class TokenFreezeTransactionsHandler implements TransactionHandler {\n     @Override\n     public EntityId getEntity(RecordItem recordItem) {\n-        return EntityId.of(recordItem.getTransactionBody().getTokenFreeze().getToken());\n+        return EntityId.of(recordItem.getTransactionBody().getTokenFreeze().getToken().getTokenId());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxOTM5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498919399", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:17:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenGrantKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenGrantKyc().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDY5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094695", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxOTM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java\nindex 2740cc6a2..e0a159385 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java\n\n@@ -31,6 +31,6 @@ import com.hedera.mirror.importer.parser.domain.RecordItem;\n public class TokenGrantKycTransactionsHandler implements TransactionHandler {\n     @Override\n     public EntityId getEntity(RecordItem recordItem) {\n-        return EntityId.of(recordItem.getTransactionBody().getTokenGrantKyc().getToken());\n+        return EntityId.of(recordItem.getTransactionBody().getTokenGrantKyc().getToken().getTokenId());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTQyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498921422", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:20:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenRevokeKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenRevokeKyc().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDcwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094709", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java\nindex e8e816ede..992c1491a 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java\n\n@@ -31,6 +31,6 @@ import com.hedera.mirror.importer.parser.domain.RecordItem;\n public class TokenRevokeKycTransactionsHandler implements TransactionHandler {\n     @Override\n     public EntityId getEntity(RecordItem recordItem) {\n-        return EntityId.of(recordItem.getTransactionBody().getTokenRevokeKyc().getToken());\n+        return EntityId.of(recordItem.getTransactionBody().getTokenRevokeKyc().getToken().getTokenId());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjI0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922247", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:22:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUnfreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUnfreeze().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDcyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094722", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjI0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java\nindex 5058797ab..a8c7f56ac 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java\n\n@@ -31,6 +31,6 @@ import com.hedera.mirror.importer.parser.domain.RecordItem;\n public class TokenUnfreezeTransactionsHandler implements TransactionHandler {\n     @Override\n     public EntityId getEntity(RecordItem recordItem) {\n-        return EntityId.of(recordItem.getTransactionBody().getTokenUnfreeze().getToken());\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUnfreeze().getToken().getTokenId());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjc4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922781", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "author": "steven-sheehy", "createdAt": "2020-10-02T16:23:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDczNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094735", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjc4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\nindex db0d3138c..cc81c3281 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenManagement;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjg2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922865", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "author": "steven-sheehy", "createdAt": "2020-10-02T16:23:51Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDc0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094744", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\nindex d9c571b45..7dbc4d3ca 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java\n\n@@ -20,7 +20,7 @@ package com.hedera.mirror.importer.parser.record.transactionhandler;\n  * \u200d\n  */\n \n-import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import com.hederahashgraph.api.proto.java.TokenCreation;\n import javax.inject.Named;\n import lombok.AllArgsConstructor;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498923351", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:24:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenWipeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenWipe().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5Mzk1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499093956", "bodyText": "This one is honestly both. So not sure.\nWipe will burn the number of tokens an account has but also deplore the totalSupply of the actual Token", "author": "Nana-EC", "createdAt": "2020-10-03T00:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NTYxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499775619", "bodyText": "Left this as token", "author": "Nana-EC", "createdAt": "2020-10-05T17:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java\nindex a1b72e656..f1b80429b 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java\n\n@@ -31,6 +31,6 @@ import com.hedera.mirror.importer.parser.domain.RecordItem;\n public class TokenWipeTransactionsHandler implements TransactionHandler {\n     @Override\n     public EntityId getEntity(RecordItem recordItem) {\n-        return EntityId.of(recordItem.getTransactionBody().getTokenWipe().getToken());\n+        return EntityId.of(recordItem.getTransactionBody().getTokenWipe().getToken().getTokenId());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498926023", "bodyText": "We don't make use of this id, right? To save space and time it might be better to switch to a composite primary key.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:30:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODU4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498968583", "bodyText": "Yeah, it's unused. Composite would be more appropriate.", "author": "Nana-EC", "createdAt": "2020-10-02T17:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDc1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094758", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\nindex 5ac276d46..8c22f0610 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n\n@@ -46,12 +46,14 @@ public class TokenAccount {\n \n     private long createdTimestamp;\n \n-    private int freezeStatus;\n+    private boolean frozen;\n \n-    private int kycStatus;\n+    private boolean kyc;\n \n     private long modifiedTimestamp;\n \n     @Convert(converter = TokenIdConverter.class)\n     private EntityId tokenId;\n+\n+    private boolean wiped;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzcxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498937716", "bodyText": "This is brittle. What's wrong with using assertThat(expected).isEqualTo(actual) and using ignoringGivenFields if needed?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:53:57Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package com.hedera.mirror.importer.repository;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.google.protobuf.ByteString;\n+import com.hederahashgraph.api.proto.java.Key;\n+import javax.annotation.Resource;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.binary.Hex;\n+import org.junit.jupiter.api.Test;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Token;\n+\n+public class TokenRepositoryTest extends AbstractRepositoryTest {\n+    @Resource\n+    protected TokenRepository tokenRepository;\n+\n+    private final EntityId FOO_COIN_ID = EntityId.of(\"0.0.101\", EntityTypeEnum.TOKEN);\n+    String key = \"0011223344556677889900aabbccddeeff0011223344556677889900aabbccddeeff\";\n+    private final EntityId treasuryAccount = EntityId.of(\"0.0.102\", EntityTypeEnum.ACCOUNT);\n+\n+    @Test\n+    void save() throws DecoderException {\n+        Token token = tokenRepository.save(token(1));\n+        tokenMatch(token, tokenRepository.findById(token.getTokenId())\n+                .get());\n+    }\n+\n+    private Token token(long consensusTimestamp) throws DecoderException {\n+        var hexKey = Key.newBuilder().setEd25519(ByteString.copyFrom(Hex.decodeHex(key))).build().toByteArray();\n+        Token token = new Token();\n+        token.setCreatedTimestamp(1L);\n+        token.setDecimals(1000);\n+        token.setFreezeDefault(false);\n+        token.setFreezeKey(hexKey);\n+        token.setInitialSupply(1_000_000_000L);\n+        token.setKycKey(hexKey);\n+        token.setModifiedTimestamp(3L);\n+        token.setName(\"FOO COIN TOKEN\");\n+        token.setSupplyKey(hexKey);\n+        token.setSymbol(\"FOOTOK\");\n+        token.setTokenId(new Token.Id(FOO_COIN_ID));\n+        token.setTreasuryAccountId(treasuryAccount);\n+        token.setWipeKey(hexKey);\n+        return token;\n+    }\n+\n+    private void tokenMatch(Token expected, Token actual) {\n+        assertAll(\n+                () -> assertNotNull(actual),", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NTU5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499095591", "bodyText": "Actually can just do a isEqualTo without ignoring anything", "author": "Nana-EC", "createdAt": "2020-10-03T00:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java\ndeleted file mode 100644\nindex f3d3fec42..000000000\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java\n+++ /dev/null\n\n@@ -1,69 +0,0 @@\n-package com.hedera.mirror.importer.repository;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-import com.google.protobuf.ByteString;\n-import com.hederahashgraph.api.proto.java.Key;\n-import javax.annotation.Resource;\n-import org.apache.commons.codec.DecoderException;\n-import org.apache.commons.codec.binary.Hex;\n-import org.junit.jupiter.api.Test;\n-\n-import com.hedera.mirror.importer.domain.EntityId;\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.Token;\n-\n-public class TokenRepositoryTest extends AbstractRepositoryTest {\n-    @Resource\n-    protected TokenRepository tokenRepository;\n-\n-    private final EntityId FOO_COIN_ID = EntityId.of(\"0.0.101\", EntityTypeEnum.TOKEN);\n-    String key = \"0011223344556677889900aabbccddeeff0011223344556677889900aabbccddeeff\";\n-    private final EntityId treasuryAccount = EntityId.of(\"0.0.102\", EntityTypeEnum.ACCOUNT);\n-\n-    @Test\n-    void save() throws DecoderException {\n-        Token token = tokenRepository.save(token(1));\n-        tokenMatch(token, tokenRepository.findById(token.getTokenId())\n-                .get());\n-    }\n-\n-    private Token token(long consensusTimestamp) throws DecoderException {\n-        var hexKey = Key.newBuilder().setEd25519(ByteString.copyFrom(Hex.decodeHex(key))).build().toByteArray();\n-        Token token = new Token();\n-        token.setCreatedTimestamp(1L);\n-        token.setDecimals(1000);\n-        token.setFreezeDefault(false);\n-        token.setFreezeKey(hexKey);\n-        token.setInitialSupply(1_000_000_000L);\n-        token.setKycKey(hexKey);\n-        token.setModifiedTimestamp(3L);\n-        token.setName(\"FOO COIN TOKEN\");\n-        token.setSupplyKey(hexKey);\n-        token.setSymbol(\"FOOTOK\");\n-        token.setTokenId(new Token.Id(FOO_COIN_ID));\n-        token.setTreasuryAccountId(treasuryAccount);\n-        token.setWipeKey(hexKey);\n-        return token;\n-    }\n-\n-    private void tokenMatch(Token expected, Token actual) {\n-        assertAll(\n-                () -> assertNotNull(actual),\n-                () -> assertEquals(expected.getCreatedTimestamp(), actual.getCreatedTimestamp()),\n-                () -> assertEquals(expected.getDecimals(), actual.getDecimals()),\n-                () -> assertArrayEquals(expected.getFreezeKey(), actual.getFreezeKey()),\n-                () -> assertEquals(expected.getInitialSupply(), actual.getInitialSupply()),\n-                () -> assertArrayEquals(expected.getKycKey(), actual.getKycKey()),\n-                () -> assertEquals(expected.getModifiedTimestamp(), actual.getModifiedTimestamp()),\n-                () -> assertEquals(expected.getName(), actual.getName()),\n-                () -> assertArrayEquals(expected.getSupplyKey(), actual.getSupplyKey()),\n-                () -> assertEquals(expected.getSymbol(), actual.getSymbol()),\n-                () -> assertArrayEquals(expected.getWipeKey(), actual.getWipeKey()),\n-                () -> assertEquals(expected.getFreezeKeyEd25519Hex(), actual.getFreezeKeyEd25519Hex()),\n-                () -> assertEquals(expected.getKycKeyEd25519Hex(), actual.getKycKeyEd25519Hex()),\n-                () -> assertEquals(expected.getSupplyKeyEd25519Hex(), actual.getSupplyKeyEd25519Hex()),\n-                () -> assertEquals(expected.getWipeKeyEd25519Hex(), actual.getWipeKeyEd25519Hex())\n-        );\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTg1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498945853", "bodyText": "These two repository calls will definitely slow things down. I haven't had time to verify if multiple calls to save will be internally batched. This might be fine for now but we'll need to revisit this next sprint.", "author": "steven-sheehy", "createdAt": "2020-10-02T17:10:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -239,6 +255,21 @@ public void onLiveHash(LiveHash liveHash) throws ImporterException {\n         liveHashes.add(liveHash);\n     }\n \n+    @Override\n+    public void onToken(Token token) throws ImporterException {\n+        tokenRepository.save(token);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODQ5Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499098492", "bodyText": "Agreed. This is best path to get the ball rolling but we definitely need to scale.\nChallenge is each update needs to ensure it has the correct information  from current state before updating.\ne.g. A token gets created with a freeze and Kyc settings to default to FROZEN and REVOKED.\nAn account then Associates itself with the token, it will be frozen and revoked.\nSay accounts it gets Unfrozen and then soon after gets GrantedKyc.\nWe need to make sure the persistence for the KycGrant picks the fact that it was unfrozen and doesn't accidentally revert the freeze state change.\nThat's why for now I'm just saving immediately, just like Entity updates do.\nCurrently using Spring cache so this should give us some breathing room to explore the right solution for Accounts and Tokens", "author": "Nana-EC", "createdAt": "2020-10-03T00:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTg1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\nindex 03dc924b1..6ea295c2f 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java\n\n@@ -257,12 +265,12 @@ public class SqlEntityListener implements EntityListener, RecordStreamFileListen\n \n     @Override\n     public void onToken(Token token) throws ImporterException {\n-        tokenRepository.save(token);\n+        tokens.add(token);\n     }\n \n     @Override\n     public void onTokenAccount(TokenAccount tokenAccount) throws ImporterException {\n-        tokenAccountRepository.save(tokenAccount);\n+        tokenAccounts.add(tokenAccount);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498960148", "bodyText": "Would be cleaner to pass only RecordItem to all methods as it already contains the necessary fields and will be more encapsulated for future refactoring. I was tempted to do that for existing methods at one point but didn't want the code churn at the time, but since this is new it might make more sense to start here.", "author": "steven-sheehy", "createdAt": "2020-10-02T17:40:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +192,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTQwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099409", "bodyText": "Was trying to stick to the best practice of passing only the necessary objects in and not redoing conversion work that was already done e.g consensus time extraction.\nRecordItem contains SignatureMap, and not all transactions need the TransactionRecord.\nThough making it more uniform does set the ground work for encapsulating these methods in the appropriate classes later on.\nHow about a shared signature of the below?\nprivate void insertTransactionType(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {", "author": "Nana-EC", "createdAt": "2020-10-03T00:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExMjI1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499112253", "bodyText": "All the methods in RecordItem are already converted at this point as it's an immutable object. There's no penalty to pay for calling any of its getters. The getConsensusTimestamp() is a lazy getter and the protos are parsed.\nThere's a slight difference in that consensusNs = Utility.timeStampInNanos(txRecord.getConsensusTimestamp()) and recordItem.getConsensusTimestamp() is Utility.timestampInNanosMax(record.getConsensusTimestamp()), but either approach is equivalent for consensus timestamp in records.", "author": "steven-sheehy", "createdAt": "2020-10-03T03:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTA4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499189083", "bodyText": "Works for me. Will update them to all to take in RecordItem.", "author": "Nana-EC", "createdAt": "2020-10-03T23:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -192,32 +187,34 @@ public class EntityRecordItemListener implements RecordItemListener {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n-            } else if (body.hasTokenAssociate()) {\n-                insertTokenAssociate(consensusNs, body);\n-            } else if (body.hasTokenBurn()) {\n-                insertTokenBurn(consensusNs, body);\n-            } else if (body.hasTokenCreation()) {\n+            }\n+//            else if (body.hasTokenAssociate()) {\n+//                insertTokenAssociate(body);\n+//            }\n+            else if (body.hasTokenCreation()) {\n                 insertTokenCreate(consensusNs, txRecord, body);\n             } else if (body.hasTokenDeletion()) {\n-                insertTokenDelete(consensusNs, body);\n-            } else if (body.hasTokenDissociate()) {\n-                insertTokenDissociate(consensusNs, body);\n-            } else if (body.hasTokenFreeze()) {\n-                insertTokenAccountFreezeBody(consensusNs, body);\n+\n+            } else if (body.hasTokenDeletion()) {\n+                insertTokenDelete(body);\n+            }\n+//            else if (body.hasTokenDissociate()) {\n+//                insertTokenDissociate(body);\n+//            }\n+            else if (body.hasTokenFreeze()) {\n+                insertTokenAccountFreezeBody(body);\n             } else if (body.hasTokenGrantKyc()) {\n-                insertTokenAccountGrantKyc(consensusNs, body);\n-            } else if (body.hasTokenMint()) {\n-                insertTokenMint(consensusNs, body);\n+                insertTokenGrantKyc(body);\n             } else if (body.hasTokenRevokeKyc()) {\n-                insertTokenAccountRevokeKyc(consensusNs, body);\n+                insertTokenRevokeKyc(body);\n             } else if (body.hasTokenTransfers()) {\n                 insertTokenTransfers(consensusNs, txRecord);\n             } else if (body.hasTokenUnfreeze()) {\n-                insertTokenAccountUnfreeze(consensusNs, body);\n+                insertTokenUnfreeze(body);\n             } else if (body.hasTokenUpdate()) {\n                 insertTokenUpdate(consensusNs, body);\n             } else if (body.hasTokenWipe()) {\n-                insertTokenAccountWipe(consensusNs, body);\n+                insertTokenWipe(body);\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499063065", "bodyText": "All token Ids need to be passed to onEntityId(). All accounts do as well but that should be taken care of by generic handler.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:43:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTYzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099636", "bodyText": "They already are by the OnItem(). That's how the Entity is added to t_entities.\nSo far as the TransactionHandler implements the getEntity() method then it's covered in that sense", "author": "Nana-EC", "createdAt": "2020-10-03T00:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMzI3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499103270", "bodyText": "So with my original configuration all these transaction handlers would have had the Token Entity passed to the OnEntityId in the OnItem().\nMy guess is you're going off of your previous suggestions to change some of them to return the Account not Token. In which case I would now have to explicitly  can OnEntityId for which ever of the 2 wasn't covered.", "author": "Nana-EC", "createdAt": "2020-10-03T01:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMzYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499103624", "bodyText": "This makes me think TransactionHandler interfaces getEntity(RecordItem recordItem) should be swapped/updated to either return all applicable entities or return an entity of a requested type for a given RecordItem. i.e.\nList<EntityId> getEntities(RecordItem recordItem);\n\nor\nEntityId getEntity(RecordItem recordItem, EntityTypeEnum entityTypeEnum);", "author": "Nana-EC", "createdAt": "2020-10-03T01:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExMjU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499112586", "bodyText": "While the current approach is not ideal, I don't think that is a good approach either since it's a Ask Don't Tell. What we eventually want is for the transaction handlers to extract the domain objects and call EntityListener for each one.", "author": "steven-sheehy", "createdAt": "2020-10-03T03:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTMwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771307", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065167", "bodyText": "I don't think we should waste performance updating a timestamp when no other fields on that tokenaccount changed. We should treat the timestamp as audit info that only gets updated when a field on it changes.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:51:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTgxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099812", "bodyText": "Fair enough. In that case Wipe operations will be a no-op for TokenAccounts", "author": "Nana-EC", "createdAt": "2020-10-03T00:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4NjY2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499886660", "bodyText": "Actually wipe has an amount which currently needs to be deducted from the token totalSupply. Updating that.", "author": "Nana-EC", "createdAt": "2020-10-05T21:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065522", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:52:22Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMDAyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499100023", "bodyText": "Token is already passed through in OnItem.\nWe shouldn't need to repass Account because it will always be a valid already create account and no Token transactions affect the actual Hedera account", "author": "Nana-EC", "createdAt": "2020-10-03T00:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTY4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771681", "bodyText": "Updating to have all TokenId's/AccountId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066010", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:54:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMDA4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499100088", "bodyText": "Token is already passed through in OnItem.\nWe shouldn't need to repass Account because it will always be a valid already create account and no Token transactions affect the actual Hedera account", "author": "Nana-EC", "createdAt": "2020-10-03T00:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTc3OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771779", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066655", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a freeze/grant/revoke/unfreeze without an associate first, but if we have a stream reset like at OA it is possible.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:56:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTY0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101640", "bodyText": "Hmm, as is we won't have sufficient information to create an appropriate TokenAccount.\nfreeze/grant/revoke/unfreeze/burn only have the tokenId.\nThis would result in unexpected kyc & freeze behavior for accounts as initial freeze and kyc statuses after this shallow creation will likely be wrong for many cases.", "author": "Nana-EC", "createdAt": "2020-10-03T01:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4OTQwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499889409", "bodyText": "Per internal discussions we'll go with logging in these cases to avoid unexpected issues. Expectation is 3rd party should have a mirror node start time that covers the creation of desired tokens.", "author": "Nana-EC", "createdAt": "2020-10-05T21:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066782", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a update/delete/etc without a create first, but if we have a stream reset like at OA it is possible.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:56:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);\n+    }\n+\n+    private Token retrieveToken(TokenID tokenID) {\n+        return tokenRepository\n+                .findById(new Token.Id(EntityId.of(tokenID)))\n+                .orElse(null);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTMzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101338", "bodyText": "Hmm, as is we won't have sufficient information to create an appropriate Token.\nUpdate has the largest amount of info but doesn't have initialSupply, decimals etc.\ndelete/wipe/mint/burn only have the tokenId.\nThis would result in unexpected kyc & freeze behavior for accounts onboarded after this shallow creation.", "author": "Nana-EC", "createdAt": "2020-10-03T01:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4OTQ2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499889469", "bodyText": "Per internal discussions we'll go with logging in these cases to avoid unexpected issues. Expectation is 3rd party should have a mirror node start time that covers the creation of desired tokens.", "author": "Nana-EC", "createdAt": "2020-10-05T21:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067226", "bodyText": "Token and treasury should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:58:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101860", "bodyText": "Token is. Treasury will be an already created account.\nI'm guessing this is also the Pre OA case that we need to cover", "author": "Nana-EC", "createdAt": "2020-10-03T01:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MjAwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499772004", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzY2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067669", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:59:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3Njk4NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499776984", "bodyText": "Will add for token, missed on last commit", "author": "Nana-EC", "createdAt": "2020-10-05T18:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzY2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzgzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067838", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:00:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzIxMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773213", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzgzOA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODM2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068360", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzI5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773291", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODQwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068405", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzMzOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773339", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODUxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068514", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzQwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773402", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODY5NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068694", "bodyText": "Should we also have a delete flag on token?", "author": "steven-sheehy", "createdAt": "2020-10-02T22:03:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMjAwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499102002", "bodyText": "This already exists on the Entities object.\nThe assumption is any API call filtering on deleted will do the necessary join to pull that info.\nOtherwise it'll be a duplication of data between the tables.", "author": "Nana-EC", "createdAt": "2020-10-03T01:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODY5NA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODk2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068963", "bodyText": "Treasury and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:04:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMyMDA2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499320068", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-05T02:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODk2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex b5a5b9b3a..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -433,154 +430,97 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n-            AccountID accountID = tokenAssociate.getAccount();\n-            tokenAssociate.getTokensList().forEach(token -> {\n-                if (retrieveTokenAccount(token, accountID) == null) {\n-                    Token storedToken = retrieveToken(token);\n-                    TokenAccount tokenAccount = new TokenAccount();\n-                    tokenAccount.setAssociated(true);\n-                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n-                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    tokenAccount.setAccountId(EntityId.of(accountID));\n-                    tokenAccount.setTokenId(EntityId.of(token));\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n-            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n     private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n             token.setCreatedTimestamp(consensusTimestamp);\n-            token.setDecimals(tokenCreation.getDecimals());\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n             token.setFreezeDefault(tokenCreation.getFreezeDefault());\n-            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n             token.setModifiedTimestamp(consensusTimestamp);\n-            token.setName(tokenCreation.getName());\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n             token.setSymbol(tokenCreation.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n-\n-            if (tokenCreation.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasKycKey()) {\n-                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreation.hasTreasury()) {\n-                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n-            }\n-\n-            if (tokenCreation.hasWipeKey()) {\n-                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n-            }\n-\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n-            Token token = retrieveToken(tokenDeletion.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n-            AccountID accountID = tokenDissociate.getAccount();\n-            tokenDissociate.getTokensList().forEach(token -> {\n-                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n-                if (tokenAccount != null) {\n-                    tokenAccount.setAssociated(false);\n-                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-                    entityListener.onTokenAccount(tokenAccount);\n-                }\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n-            TokenID tokenID = tokenFreeze.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setFrozen(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n-            TokenID tokenID = tokenGrantKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(true);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n-            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (token != null) {\n-                token.setModifiedTimestamp(consensusTimestamp);\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n-            TokenID tokenID = tokenRevokeKyc.getToken();\n-\n-            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n             if (tokenAccount != null) {\n-                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n-                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                tokenAccount.setKyc(false);\n                 entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499755586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // if not onboarded create create TokenAccount based off of Token details\n          \n          \n            \n                                // if not onboarded create TokenAccount based on Token details", "author": "Nana-EC", "createdAt": "2020-10-05T17:22:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDEwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760107", "bodyText": "Remove a already handled in OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "author": "Nana-EC", "createdAt": "2020-10-05T17:30:55Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDk3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760970", "bodyText": "Remove since covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "author": "Nana-EC", "createdAt": "2020-10-05T17:32:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTQ4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499761487", "bodyText": "Add OnEntityId for every Token\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n          \n          \n            \n                            entityListener.onEntityId(EntityId.of(token));\n          \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "author": "Nana-EC", "createdAt": "2020-10-05T17:33:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mjc4Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499762782", "bodyText": "Swap to do for Token since Account is covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);\n          \n          \n            \n            TokenID tokenID = tokenFreezeAccountTransactionBody.getToken();\n          \n          \n            \n            EntityId.of(tokenID)", "author": "Nana-EC", "createdAt": "2020-10-05T17:35:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mzg5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499763895", "bodyText": "Swap to do token", "author": "Nana-EC", "createdAt": "2020-10-05T17:38:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), accountID, false, true, false);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 494e81a85..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -432,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n-                TokenAccount tokenAccount = null;\n-                if (retrieveTokenAccount(token, accountID).isPresent()) {\n-                    tokenAccount = optionalTokenAccount.get();\n-                } else {\n-                    // if not onboarded create create TokenAccount based off of Token details\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                    }\n-                }\n-\n-                tokenAccount.setAssociated(true);\n-                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                entityListener.onTokenAccount(tokenAccount);\n-            });\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenBurn(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n-                entityListener.onToken(token);\n-            }\n-        }\n-    }\n-\n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n-            });\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), accountID, false, true, false);\n-        }\n-    }\n-\n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            Optional<Token> optionalToken = retrieveToken(tokenMintTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-            AccountID accountID = tokenRevokeKycTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), accountID, false, false, true);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            Optional<Token> optionalToken = retrieveToken(tokenUpdateTransactionBody.getToken());\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n             }\n         }\n     }\n \n-    private void insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                          boolean toggleAssociate, boolean toggleFreeze, boolean toggleKyc) {\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        if (optionalTokenAccount.isPresent()) {\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (toggleAssociate) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (toggleFreeze) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (toggleKyc) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-            AccountID accountID = tokenUnfreezeAccountTransactionBody.getAccount();\n-            EntityId accountEntityId = EntityId.of(accountID);\n-            entityListener.onEntityId(accountEntityId);\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), false, true, false);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n-\n-            // update token total supply similar to TokenBurn transaction\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n-                entityListener.onToken(token);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n             }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMjcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499922705", "bodyText": "nit: Generally enum values are named like static constants in upper snake case, so NOT_APPLICABLE.", "author": "steven-sheehy", "createdAt": "2020-10-05T23:18:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public enum TokenKycStatusEnum {\n+\n+    NOTAPPLICABLE(0),", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Mjk0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500472947", "bodyText": "Changing to NOT_APPLICABLE", "author": "Nana-EC", "createdAt": "2020-10-06T17:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMjcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\nsimilarity index 72%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\nindex 0d135793e..0a7f0c020 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/BatchEntityListener.java\n\n@@ -1,4 +1,4 @@\n-package com.hedera.mirror.importer.domain;\n+package com.hedera.mirror.importer.parser.record.entity;\n \n /*-\n  * \u200c\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNTEyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499925128", "bodyText": "I'm not a fan of these toggle methods. If we get two freeze accounts transactions back to back (not sure if possible), then it would be unfrozen. Would prefer simpler setters to avoid this even if platform makes this impossible.", "author": "steven-sheehy", "createdAt": "2020-10-05T23:26:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+public class TokenAccount {\n+    @EmbeddedId\n+    @JsonUnwrapped\n+    private TokenAccount.Id id;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenFreezeStatusEnum freezeStatus;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenKycStatusEnum kycStatus;\n+\n+    private long modifiedTimestamp;\n+\n+    public TokenAccount(EntityId tokenId, EntityId accountId) {\n+        id = new TokenAccount.Id(tokenId, accountId);\n+    }\n+\n+    public void toggleAssociatedStatus() {\n+        associated = !associated;", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMzIxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500433218", "bodyText": "That's a good point. Can change it back to simple sets", "author": "Nana-EC", "createdAt": "2020-10-06T16:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNTEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\nindex 4b3ad7fa8..8c22f0610 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java\n\n@@ -20,86 +20,40 @@ package com.hedera.mirror.importer.domain;\n  * \u200d\n  */\n \n-import com.fasterxml.jackson.annotation.JsonUnwrapped;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.io.Serializable;\n import javax.persistence.Convert;\n-import javax.persistence.Embeddable;\n-import javax.persistence.EmbeddedId;\n import javax.persistence.Entity;\n-import javax.persistence.EnumType;\n-import javax.persistence.Enumerated;\n-import lombok.AllArgsConstructor;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n import lombok.Data;\n-import lombok.NoArgsConstructor;\n import lombok.extern.log4j.Log4j2;\n \n import com.hedera.mirror.importer.converter.AccountIdConverter;\n-import com.hedera.mirror.importer.converter.EntityIdSerializer;\n import com.hedera.mirror.importer.converter.TokenIdConverter;\n \n @Data\n @Entity\n @Log4j2\n-@NoArgsConstructor\n public class TokenAccount {\n-    @EmbeddedId\n-    @JsonUnwrapped\n-    private TokenAccount.Id id;\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId accountId;\n \n     private boolean associated;\n \n     private long createdTimestamp;\n \n-    @Enumerated(EnumType.ORDINAL)\n-    private TokenFreezeStatusEnum freezeStatus;\n+    private boolean frozen;\n \n-    @Enumerated(EnumType.ORDINAL)\n-    private TokenKycStatusEnum kycStatus;\n+    private boolean kyc;\n \n     private long modifiedTimestamp;\n \n-    public TokenAccount(EntityId tokenId, EntityId accountId) {\n-        id = new TokenAccount.Id(tokenId, accountId);\n-    }\n-\n-    public void toggleAssociatedStatus() {\n-        associated = !associated;\n-    }\n-\n-    public void toggleFreezeStatus() {\n-        // only toggle applicable states\n-        if (freezeStatus == TokenFreezeStatusEnum.NOTAPPLICABLE) {\n-            return;\n-        }\n-\n-        freezeStatus = freezeStatus == TokenFreezeStatusEnum.FROZEN ? TokenFreezeStatusEnum.UNFROZEN :\n-                TokenFreezeStatusEnum.FROZEN;\n-    }\n-\n-    public void toggleKycStatus() {\n-        // only toggle applicable states\n-        if (kycStatus == TokenKycStatusEnum.NOTAPPLICABLE) {\n-            return;\n-        }\n-\n-        kycStatus = kycStatus == TokenKycStatusEnum.GRANTED ? TokenKycStatusEnum.REVOKED :\n-                TokenKycStatusEnum.GRANTED;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    @Embeddable\n-    public static class Id implements Serializable {\n-        private static final long serialVersionUID = -4069569824910871771L;\n-\n-        @Convert(converter = TokenIdConverter.class)\n-        @JsonSerialize(using = EntityIdSerializer.class)\n-        private EntityId tokenId;\n+    @Convert(converter = TokenIdConverter.class)\n+    private EntityId tokenId;\n \n-        @Convert(converter = AccountIdConverter.class)\n-        @JsonSerialize(using = EntityIdSerializer.class)\n-        private EntityId accountId;\n-    }\n+    private boolean wiped;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500408741", "bodyText": "Not a fan of these generic methods that then have transaction specific checks within them. Also not ideal because it denormalizes the token account object into a bunch of parameters, which is less maintainable when those change. Code reuse should not be done at the expense of maintainability and encapsulation.\nTransaction specific logic should be contained within the insertToken... methods.  This encapsulates the logic and will allow us to lift and shift it to the transaction handlers later. You can achieve something similar without this by pushing most of this common logic into the retrieve method.\nWe can always change this in a follow up or when we move to transaction handlers, though.", "author": "steven-sheehy", "createdAt": "2020-10-06T15:49:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                        tokenAccount.setAssociated(true);\n+                        tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                        entityListener.onTokenAccount(tokenAccount);\n+                    } else {\n+                        log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENASSOCIATE,\n+                                consensusTimeStamp);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenBurnTransactionBody\n+                    .getToken(), tokenBurnTransactionBody.getAmount(), TransactionTypeEnum.TOKENBURN);\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenDeleteTransactionBody\n+                    .getToken(), 0, TransactionTypeEnum.TOKENDELETION);\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem\n+                        .getConsensusTimestamp(), token, accountID, TransactionTypeEnum.TOKENDISSOCIATE);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), tokenFreezeAccountTransactionBody.getAccount(), TransactionTypeEnum.TOKENFREEZE);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n+                    .getToken(), tokenGrantKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENGRANTKYC);\n+        }\n+    }\n+\n+    private void insertTokenMint(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenMintTransactionBody\n+                    .getToken(), tokenMintTransactionBody.getAmount(), TransactionTypeEnum.TOKENMINT);\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenRevokeKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n+                    .getToken(), tokenRevokeKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENREVOKEKYC);\n+        }\n+    }\n+\n+    private void insertTokenTransfers(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                entityListener.onEntityId(tokenId);\n+\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+                    entityListener.onEntityId(accountId);\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n+            TokenID tokenID = tokenUpdateTransactionBody.getToken();\n+\n+            Optional<Token> optionalToken = retrieveToken(tokenID);\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n+                    entityListener.onEntityId(treasuryEntityId);\n+                    token.setTreasuryAccountId(treasuryEntityId);\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            } else {\n+                log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENDELETION, recordItem\n+                        .getConsensusTimestamp());\n+            }\n+        }\n+    }\n+\n+    private boolean insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n+                                             TransactionTypeEnum transactionTypeEnum) {\n+        entityListener.onEntityId(EntityId.of(tokenID));\n+\n+        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n+        boolean tokenAccountFound = optionalTokenAccount.isPresent();\n+        if (tokenAccountFound) {\n+\n+            TokenAccount tokenAccount = optionalTokenAccount.get();\n+            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+\n+            if (transactionTypeEnum == TransactionTypeEnum.TOKENASSOCIATE || transactionTypeEnum == TransactionTypeEnum.TOKENDISSOCIATE) {", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMjU3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500432571", "bodyText": "Yeah my hope was this would leave mostly boiler plate code to copy and paste into the transaction handlers when we made that move", "author": "Nana-EC", "createdAt": "2020-10-06T16:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1Nzc4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500457788", "bodyText": "Changing now", "author": "Nana-EC", "createdAt": "2020-10-06T17:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3ODQ2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500478462", "bodyText": "Moved logic back into insertToken...\nMoved missing Token or TokenAccount to retrieveMethod, but had to pass current transactionType and timestamp to make long informational", "author": "Nana-EC", "createdAt": "2020-10-06T17:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 3eb45972e..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -436,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-\n-                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n-                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n-                        TransactionTypeEnum.TOKENASSOCIATE)) {\n-                    // if not onboarded create TokenAccount based on Token details\n-                    EntityId tokenID = EntityId.of(token);\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                        tokenAccount.setAssociated(true);\n-                        tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                        entityListener.onTokenAccount(tokenAccount);\n-                    } else {\n-                        log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENASSOCIATE,\n-                                consensusTimeStamp);\n-                    }\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenBurnTransactionBody\n-                    .getToken(), tokenBurnTransactionBody.getAmount(), TransactionTypeEnum.TOKENBURN);\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenDeleteTransactionBody\n-                    .getToken(), 0, TransactionTypeEnum.TOKENDELETION);\n-        }\n-    }\n-\n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem\n-                        .getConsensusTimestamp(), token, accountID, TransactionTypeEnum.TOKENDISSOCIATE);\n-            });\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n+                entityListener.onToken(token);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), tokenFreezeAccountTransactionBody.getAccount(), TransactionTypeEnum.TOKENFREEZE);\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), tokenGrantKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENGRANTKYC);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenMintTransactionBody\n-                    .getToken(), tokenMintTransactionBody.getAmount(), TransactionTypeEnum.TOKENMINT);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), tokenRevokeKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENREVOKEKYC);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n-                entityListener.onEntityId(tokenId);\n-\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            TokenID tokenID = tokenUpdateTransactionBody.getToken();\n-\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n-            } else {\n-                log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENDELETION, recordItem\n-                        .getConsensusTimestamp());\n             }\n         }\n     }\n \n-    private boolean insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                             TransactionTypeEnum transactionTypeEnum) {\n-        entityListener.onEntityId(EntityId.of(tokenID));\n-\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        boolean tokenAccountFound = optionalTokenAccount.isPresent();\n-        if (tokenAccountFound) {\n-\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENASSOCIATE || transactionTypeEnum == TransactionTypeEnum.TOKENDISSOCIATE) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENFREEZE || transactionTypeEnum == TransactionTypeEnum.TOKENUNFREEZE) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENGRANTKYC || transactionTypeEnum == TransactionTypeEnum.TOKENREVOKEKYC) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        } else {\n-            log.warn(MISSING_TOKEN_ACCOUNT_MESSAGE, tokenID, accountID, transactionTypeEnum, consensusTimestamp);\n-        }\n-\n-        return tokenAccountFound;\n-    }\n-\n-    private void insertSingleTokenPropertyUpdate(long consensusTimestamp, TokenID tokenID, long amount,\n-                                                 TransactionTypeEnum transactionTypeEnum) {\n-        Optional<Token> optionalToken = retrieveToken(tokenID);\n-        if (optionalToken.isPresent()) {\n-            Token token = optionalToken.get();\n-            token.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENMINT) {\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + amount);\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENBURN || transactionTypeEnum == TransactionTypeEnum.TOKENWIPE) {\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - amount);\n-            }\n-\n-            entityListener.onToken(token);\n-        } else {\n-            log.warn(MISSING_TOKEN_MESSAGE, tokenID, transactionTypeEnum, consensusTimestamp);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), TransactionTypeEnum.TOKENUNFREEZE);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenWipeAccountTransactionBody\n-                    .getToken(), tokenWipeAccountTransactionBody.getAmount(), TransactionTypeEnum.TOKENWIPE);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMTYyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500411629", "bodyText": "nit: Already have consensusTimeStamp variable extracted that you can use for both timestamps.", "author": "steven-sheehy", "createdAt": "2020-10-06T15:53:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3NzcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500477705", "bodyText": "Picking this up and other places", "author": "Nana-EC", "createdAt": "2020-10-06T17:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMTYyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "462dad70ae7386a570bca26efaff4a8246c9952c", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\nindex 3eb45972e..f6abe238c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java\n\n@@ -436,291 +430,160 @@ public class EntityRecordItemListener implements RecordItemListener {\n         entityRepository.save(entity);\n     }\n \n-    private void insertTokenAssociate(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenAssociate();\n-            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n-\n-            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n-\n-                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n-                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n-                        TransactionTypeEnum.TOKENASSOCIATE)) {\n-                    // if not onboarded create TokenAccount based on Token details\n-                    EntityId tokenID = EntityId.of(token);\n-                    Optional<Token> optionalToken = retrieveToken(token);\n-                    if (optionalToken.isPresent()) {\n-                        Token storedToken = optionalToken.get();\n-                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n-                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n-                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n-                        tokenAccount.setAssociated(true);\n-                        tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-                        entityListener.onTokenAccount(tokenAccount);\n-                    } else {\n-                        log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENASSOCIATE,\n-                                consensusTimeStamp);\n-                    }\n-                }\n-            });\n-        }\n-    }\n-\n-    private void insertTokenBurn(RecordItem recordItem) {\n+    private void insertTokenAssociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenBurnTransactionBody\n-                    .getToken(), tokenBurnTransactionBody.getAmount(), TransactionTypeEnum.TOKENBURN);\n+//            TokenAssociate tokenAssociate = txBody.getTokenAssociate();\n+//            tokenAssociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenAssociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(true);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenCreate(RecordItem recordItem) {\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n             // pull token details from TokenCreation body and TokenId from receipt\n-            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            TokenCreation tokenCreation = txBody.getTokenCreation();\n             Token token = new Token();\n-            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n-            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n-            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n-            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-            token.setName(tokenCreateTransactionBody.getName());\n-            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n-            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n-\n-            if (tokenCreateTransactionBody.hasFreezeKey()) {\n-                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasKycKey()) {\n-                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasSupplyKey()) {\n-                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n-            }\n-\n-            if (tokenCreateTransactionBody.hasTreasury()) {\n-                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n-                entityListener.onEntityId(treasuryEntityId);\n-                token.setTreasuryAccountId(treasuryEntityId);\n-            }\n-\n-            if (tokenCreateTransactionBody.hasWipeKey()) {\n-                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n-            }\n-\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDeleted(false);\n+            token.setDivisibility(tokenCreation.getDivisibility());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            token.setInitialSupply(tokenCreation.getFloat());\n+            token.setKycDefault(tokenCreation.getKycDefault());\n+            token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+//            token.setName(tokenCreation.getName());\n+            token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(EntityId.of(txRecord.getReceipt().getTokenId()));\n+            token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n             entityListener.onToken(token);\n         }\n     }\n \n-    private void insertTokenDelete(RecordItem recordItem) {\n-        if (entityProperties.getPersist().isTokens()) {\n-            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenDeleteTransactionBody\n-                    .getToken(), 0, TransactionTypeEnum.TOKENDELETION);\n-        }\n-    }\n-\n-    private void insertTokenDissociate(RecordItem recordItem) {\n+    private void insertTokenDelete(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenDissociate();\n-            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n-\n-            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n-                insertTokenAccountUpdate(recordItem\n-                        .getConsensusTimestamp(), token, accountID, TransactionTypeEnum.TOKENDISSOCIATE);\n-            });\n+            TokenDeletion tokenDeletion = txBody.getTokenDeletion();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenDeletion.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setDeleted(true);\n+                entityListener.onToken(token);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+    private void insertTokenDissociate(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenFreeze();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n-                    .getToken(), tokenFreezeAccountTransactionBody.getAccount(), TransactionTypeEnum.TOKENFREEZE);\n+//            TokenDissociate tokenDissociate = txBody.getTokenDissociate();\n+//            tokenDissociate.getTokens().forEach(tokenRef -> {\n+//                TokenAccount tokenAccount = retrieveTokenAccount(tokenRef.getToken(), tokenDissociate.getAccount());\n+//                if (tokenAccount != null) {\n+//                    tokenAccount.setAssociated(false);\n+//                    entityListener.onTokenAccount(tokenAccount);\n+//                }\n+//            });\n         }\n     }\n \n-    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+    private void insertTokenAccountFreezeBody(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenGrantKyc();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n-                    .getToken(), tokenGrantKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENGRANTKYC);\n+            TokenFreeze tokenFreeze = txBody.getTokenFreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenFreeze.getToken(), tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenMint(RecordItem recordItem) {\n+    private void insertTokenGrantKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenMintTransactionBody\n-                    .getToken(), tokenMintTransactionBody.getAmount(), TransactionTypeEnum.TOKENMINT);\n+            TokenGrantKyc tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenGrantKyc.getToken(), tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+    private void insertTokenRevokeKyc(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenRevokeKyc();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n-                    .getToken(), tokenRevokeKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENREVOKEKYC);\n+            TokenRevokeKyc tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenRevokeKyc.getToken(), tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKyc(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenTransfers(RecordItem recordItem) {\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n         if (entityProperties.getPersist().isTokens()) {\n-            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n                 EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n-                entityListener.onEntityId(tokenId);\n-\n                 tokenTransferList.getTransfersList().forEach(accountAmount -> {\n                     EntityId accountId = EntityId.of(accountAmount.getAccountID());\n-                    entityListener.onEntityId(accountId);\n-\n-                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n                             .getAmount(), tokenId, accountId));\n                 });\n             });\n         }\n     }\n \n-    private void insertTokenUpdate(RecordItem recordItem) {\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n-            TokenID tokenID = tokenUpdateTransactionBody.getToken();\n-\n-            Optional<Token> optionalToken = retrieveToken(tokenID);\n-            if (optionalToken.isPresent()) {\n-                Token token = optionalToken.get();\n-                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n-\n-                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n-                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasKycKey()) {\n-                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n-                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasTreasury()) {\n-                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n-                    entityListener.onEntityId(treasuryEntityId);\n-                    token.setTreasuryAccountId(treasuryEntityId);\n-                }\n-\n-                if (tokenUpdateTransactionBody.hasWipeKey()) {\n-                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n-                    token.setName(tokenUpdateTransactionBody.getName());\n-                }\n-\n-                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n-                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n-                }\n-\n+            TokenManagement tokenManagement = txBody.getTokenUpdate();\n+            Optional<Token> tokenOptional = tokenRepository\n+                    .findById(EntityId.of(tokenManagement.getToken().getTokenId()));\n+            if (tokenOptional.isPresent()) {\n+                Token token = tokenOptional.get();\n+                token.setFreezeKey(tokenManagement.getFreezeKey().toByteArray());\n+                token.setKycKey(tokenManagement.getKycKey().toByteArray());\n+                token.setModifiedTimestamp(consensusTimestamp);\n+//                token.setName(tokenManagement.getName());\n+                token.setSupplyKey(tokenManagement.getSupplyKey().toByteArray());\n+                token.setSymbol(tokenManagement.getSymbol());\n+                token.setTreasuryAccountId(EntityId.of(tokenManagement.getTreasury()));\n+                token.setWipeKey(tokenManagement.getWipeKey().toByteArray());\n                 entityListener.onToken(token);\n-            } else {\n-                log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENDELETION, recordItem\n-                        .getConsensusTimestamp());\n             }\n         }\n     }\n \n-    private boolean insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n-                                             TransactionTypeEnum transactionTypeEnum) {\n-        entityListener.onEntityId(EntityId.of(tokenID));\n-\n-        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n-        boolean tokenAccountFound = optionalTokenAccount.isPresent();\n-        if (tokenAccountFound) {\n-\n-            TokenAccount tokenAccount = optionalTokenAccount.get();\n-            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENASSOCIATE || transactionTypeEnum == TransactionTypeEnum.TOKENDISSOCIATE) {\n-                tokenAccount.toggleAssociatedStatus();\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENFREEZE || transactionTypeEnum == TransactionTypeEnum.TOKENUNFREEZE) {\n-                tokenAccount.toggleFreezeStatus();\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENGRANTKYC || transactionTypeEnum == TransactionTypeEnum.TOKENREVOKEKYC) {\n-                tokenAccount.toggleKycStatus();\n-            }\n-\n-            entityListener.onTokenAccount(tokenAccount);\n-        } else {\n-            log.warn(MISSING_TOKEN_ACCOUNT_MESSAGE, tokenID, accountID, transactionTypeEnum, consensusTimestamp);\n-        }\n-\n-        return tokenAccountFound;\n-    }\n-\n-    private void insertSingleTokenPropertyUpdate(long consensusTimestamp, TokenID tokenID, long amount,\n-                                                 TransactionTypeEnum transactionTypeEnum) {\n-        Optional<Token> optionalToken = retrieveToken(tokenID);\n-        if (optionalToken.isPresent()) {\n-            Token token = optionalToken.get();\n-            token.setModifiedTimestamp(consensusTimestamp);\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENMINT) {\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() + amount);\n-            }\n-\n-            if (transactionTypeEnum == TransactionTypeEnum.TOKENBURN || transactionTypeEnum == TransactionTypeEnum.TOKENWIPE) {\n-                // mirror will calculate new totalSupply as an interim solution until network returns it\n-                token.setTotalSupply(token.getTotalSupply() - amount);\n-            }\n-\n-            entityListener.onToken(token);\n-        } else {\n-            log.warn(MISSING_TOKEN_MESSAGE, tokenID, transactionTypeEnum, consensusTimestamp);\n-        }\n-    }\n-\n-    private void insertTokenAccountUnfreeze(RecordItem recordItem) {\n+    private void insertTokenUnfreeze(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenUnfreeze();\n-\n-            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenUnfreezeAccountTransactionBody\n-                    .getToken(), tokenUnfreezeAccountTransactionBody\n-                    .getAccount(), TransactionTypeEnum.TOKENUNFREEZE);\n+            TokenUnfreeze tokenUnfreeze = txBody.getTokenUnfreeze();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenUnfreeze.getToken(), tokenUnfreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFrozen(false);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private void insertTokenAccountWipe(RecordItem recordItem) {\n+    private void insertTokenWipe(TransactionBody txBody) {\n         if (entityProperties.getPersist().isTokens()) {\n-            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = recordItem.getTransactionBody()\n-                    .getTokenWipe();\n-            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenWipeAccountTransactionBody\n-                    .getToken(), tokenWipeAccountTransactionBody.getAmount(), TransactionTypeEnum.TOKENWIPE);\n+            TokenWipeAccount tokenWipe = txBody.getTokenWipe();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenWipe.getToken(), tokenWipe.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setWiped(true);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n         }\n     }\n \n-    private Optional<TokenAccount> retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+    private TokenAccount retrieveTokenAccount(TokenRef tokenRef, AccountID accountID) {\n         return tokenAccountRepository\n-                .findByTokenIdAndAccountId(EntityId.of(tokenID).getId(), EntityId.of(accountID).getId());\n-    }\n-\n-    private Optional<Token> retrieveToken(TokenID tokenID) {\n-        return tokenRepository\n-                .findById(new Token.Id(EntityId.of(tokenID)));\n+                .findByTokenIdAndAccountId(EntityId.of(tokenRef.getTokenId()).getId(), EntityId.of(accountID).getId())\n+                .orElse(null);\n     }\n }\n"}}, {"oid": "462dad70ae7386a570bca26efaff4a8246c9952c", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/462dad70ae7386a570bca26efaff4a8246c9952c", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "d1d6863fcbc487d35cd94f10523608f55f872086", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1d6863fcbc487d35cd94f10523608f55f872086", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "c9b9afd3b98119183404d1ba2935334479e4aa28", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c9b9afd3b98119183404d1ba2935334479e4aa28", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "fb322f88d90f8442fd8063bb9d4653416b2b02e0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb322f88d90f8442fd8063bb9d4653416b2b02e0", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "68db9fe273bf04ab9d8d4214484493adcc913013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/68db9fe273bf04ab9d8d4214484493adcc913013", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "4923866fa05ab8dd6cd479f3ae2edee59d29b866", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4923866fa05ab8dd6cd479f3ae2edee59d29b866", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "6ec96df9ed8aa4d7a428399ef725c508839cedc4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6ec96df9ed8aa4d7a428399ef725c508839cedc4", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "327505df3664012ca17684df155a3cb47ac9615e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/327505df3664012ca17684df155a3cb47ac9615e", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "message": "Updating to have all TokenId's and AccountId's be passed to OnEntityId\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "67738e1ff0c53481b5fba389d226f0ceb1f981d0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/67738e1ff0c53481b5fba389d226f0ceb1f981d0", "message": "Pulled in TokenBalance changes and addressed feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "8057ddeb11ff23051738f7b887e57c3041c9ba97", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8057ddeb11ff23051738f7b887e57c3041c9ba97", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "d1b1530b732bcc2cb8413c04047d51f567f62e10", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1b1530b732bcc2cb8413c04047d51f567f62e10", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "bdb341700207fbd55431276bf7e6d1835ce7959f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/bdb341700207fbd55431276bf7e6d1835ce7959f", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "13a3db327004fcb200aa1e768d1363950e61206e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/13a3db327004fcb200aa1e768d1363950e61206e", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "837657ffa53fc6fa5291f886272b1d8cc2e874f0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/837657ffa53fc6fa5291f886272b1d8cc2e874f0", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "34bc0786a4a60bfc52c211543a792cd2319b1eb1", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/34bc0786a4a60bfc52c211543a792cd2319b1eb1", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "f11b44341b886c0417e25c0c1a092c6a035f9f2a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f11b44341b886c0417e25c0c1a092c6a035f9f2a", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "ed01943c39423880777ea583f49be45f6b5fbdab", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed01943c39423880777ea583f49be45f6b5fbdab", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "85b2ba5a4db4171c6084457864416dad07b97626", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/85b2ba5a4db4171c6084457864416dad07b97626", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "c26d0c6c6c5487468db55677cae1164acae833b7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c26d0c6c6c5487468db55677cae1164acae833b7", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "forcePushed"}, {"oid": "814c1fb8589220de2b0afe01e883dc949edea521", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/814c1fb8589220de2b0afe01e883dc949edea521", "message": "Fixed mad merge\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T20:04:14Z", "type": "commit"}, {"oid": "6c61ddd9e1432033b274041f62defb9e0b9c8c36", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6c61ddd9e1432033b274041f62defb9e0b9c8c36", "message": "Removed merge artifcats and toggle methods\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T20:27:54Z", "type": "commit"}]}