{"pr_number": 680, "pr_title": "Add updateEntity() and updateTransaction() to TransactionHandler", "pr_createdAt": "2020-04-10T06:45:01Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/680", "timeline": [{"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-10T19:38:08Z", "type": "commit"}, {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-10T19:38:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407500953", "bodyText": "nit: isn't this duplicate code with ContractCreateTransactionHandler.updateEntity()\nIf so shouldn't the AutoRenew, Key and proxy account logic from the TransactionBody be shared and the differences be called?", "author": "Nana-EC", "createdAt": "2020-04-13T14:17:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzNDgyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407634823", "bodyText": "wanted to, you know i really don't like duplication of code chunks :)\nBut not possible here since we can't write something like\n<T> void processCommonFieldsForCreate(T transactionBody) {\n  ....common logic\n}\n\nIf there's another simple way, lemme know.\nDitto for other similar comments. Will leave this one open.", "author": "apeksharma", "createdAt": "2020-04-13T18:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NjIyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407656221", "bodyText": "one thing could be creating utility (not base class) like\nvoid updateEntityAutoRenewPeriod(Entity entity, Duration autoRenewPeriod) {\n  if (autoRenewPeriod.getSeconds() != 0) { // proxy for hasAutoRenewPeriod()\n    entity.setAutoRenewPeriod(autoRenewPeriod.getSeconds());\n  }\n\nThen only use following in TH.updateEntity() fns.\nTransactionHandlerUtility.updateEntityAutoRenewPeriod(entity, txMessage.getAutoRenewPeriod()\nHowever, i don't think it's any better, so left it as such.", "author": "apeksharma", "createdAt": "2020-04-13T19:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java\nindex 3d16e3d1..1a13473c 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java\n\n@@ -59,11 +59,9 @@ public class CryptoCreateTransactionHandler implements TransactionHandler {\n         if (txMessage.hasKey()) {\n             entity.setKey(txMessage.getKey().toByteArray());\n         }\n-        // Stream contains transactions with proxyAccountID explicitly set to '0.0.0'. However it's not a valid entity,\n-        // so no need to persist it to repo.\n-        EntityId proxyAccountEntityId = EntityId.of(txMessage.getProxyAccountID());\n-        if (proxyAccountEntityId != null) {\n-            entity.setProxyAccountId(entityRepository.lookupOrCreateId(proxyAccountEntityId));\n+        Long proxyAccountId = entityRepository.lookupOrCreateId(EntityId.of(txMessage.getProxyAccountID()));\n+        if (proxyAccountId != null) {\n+            entity.setProxyAccountId(proxyAccountId);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMTMwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407501303", "bodyText": "Same comments. Good amount of duplicate logic shared with ContractUpdateTransactionHandler.updateEntity()", "author": "Nana-EC", "createdAt": "2020-04-13T14:18:21Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,24 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        CryptoUpdateTransactionBody txMessage = recordItem.getTransactionBody().getCryptoUpdateAccount();", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java\nindex c0a7fa0e..0f9c0882 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java\n\n@@ -57,11 +57,9 @@ public class CryptoUpdateTransactionHandler implements TransactionHandler {\n         if (txMessage.hasKey()) {\n             entity.setKey(txMessage.getKey().toByteArray());\n         }\n-        // Stream contains transactions with proxyAccountID explicitly set to '0.0.0'. However it's not a valid entity,\n-        // so no need to persist it to repo.\n-        EntityId proxyAccountEntityId = EntityId.of(txMessage.getProxyAccountID());\n-        if (proxyAccountEntityId != null) {\n-            entity.setProxyAccountId(entityRepository.lookupOrCreateId(proxyAccountEntityId));\n+        Long proxyAccountId = entityRepository.lookupOrCreateId(EntityId.of(txMessage.getProxyAccountID()));\n+        if (proxyAccountId != null) {\n+            entity.setProxyAccountId(proxyAccountId);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMjE0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407502145", "bodyText": "Duplicate code with FileCreateTransactionHandler. updateEntity()", "author": "Nana-EC", "createdAt": "2020-04-13T14:19:50Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/FileUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +42,15 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407504576", "bodyText": "nit: you call entityId.getId() 3 times. Might as well just get it once and use it 3 times.", "author": "Nana-EC", "createdAt": "2020-04-13T14:24:17Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "diffHunk": "@@ -49,8 +49,21 @@\n         return results;\n     }\n \n-    public <S extends Entities> EntityId saveAndCacheEntityId(S entity) {\n-        var saved = entityRepository.save(entity);\n-        return entityRepository.cache(saved.toEntityId());\n+    /**\n+     * @param entityId for which the id needs to be looked up (from cache/repo). If no id is found, the the entity is\n+     *                 inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        if (entityId.getId() != null && entityId.getId() != 0) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NjY3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407646673", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-04-13T18:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java\nindex 690d3867..c063074a 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java\n\n@@ -54,9 +54,13 @@ public class EntityRepositoryCustomImpl implements EntityRepositoryCustom {\n      *                 inserted into the repo and the newly minted id is returned.\n      * @return looked up/newly minted id of the given entityId.\n      */\n-    public long lookupOrCreateId(EntityId entityId) {\n-        if (entityId.getId() != null && entityId.getId() != 0) {\n-            return entityId.getId();\n+    public Long lookupOrCreateId(EntityId entityId) {\n+        if (entityId == null) {\n+            return null;\n+        }\n+        Long id = entityId.getId();\n+        if (id != null && id != 0) {\n+            return id;\n         }\n         return entityRepository.findEntityIdByNativeIds(\n                 entityId.getEntityShard(), entityId.getEntityRealm(), entityId.getEntityNum())\n"}}, {"oid": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "message": "address NPE in autoRenewAccount\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T18:44:57Z", "type": "commit"}, {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/617acd2c6adcc310c45ba6841827f8808b7e265d", "message": "Merge branch 'master' into parser_03", "committedDate": "2020-04-13T18:52:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407642335", "bodyText": "Would prefer not storing these as variables as they're not immutable. Hibernate may or may not populate id on object passed to save. Would prefer helper method entityId()", "author": "steven-sheehy", "createdAt": "2020-04-13T18:37:53Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "diffHunk": "@@ -21,13 +21,16 @@\n  */\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.junit.jupiter.api.Assertions.*;\n \n import org.junit.jupiter.api.Test;\n \n import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n+    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n+    private static final Entities ENTITY = ENTITY_ID.toEntity();", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTcxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407709712", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-04-13T20:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "598d071e29b84f1a1f5a40e6889ef682330d344f", "chunk": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java\nindex c8796b03..faae21d0 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java\n\n@@ -29,9 +29,6 @@ import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n-    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n-    private static final Entities ENTITY = ENTITY_ID.toEntity();\n-\n     @Test\n     void findByPrimaryKey() {\n         int entityTypeId = entityTypeRepository.findByName(\"account\").get().getId();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407644317", "bodyText": "Would prefer transactionBody and transactionRecord not be stored as it's confusing for sub-classes if they should use getDefaultTransactionBody()/getDefaultTransactionRecord() or use default stored in parent. It also couples the two unnecessarily.", "author": "steven-sheehy", "createdAt": "2020-04-13T18:41:36Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "diffHunk": "@@ -28,14 +28,19 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n \n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.parser.domain.RecordItem;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n \n public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n-\n+    @Mock\n+    protected EntityRepository entityRepository;\n+    protected TransactionBody transactionBody;", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNDI3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407704270", "bodyText": "yeah, right now they are redundant. Removed.", "author": "apeksharma", "createdAt": "2020-04-13T20:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw=="}], "type": "inlineReview", "revised_code": {"commit": "598d071e29b84f1a1f5a40e6889ef682330d344f", "chunk": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java\nindex c1296abf..28b63231 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java\n\n@@ -39,8 +39,6 @@ public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n     @Mock\n     protected EntityRepository entityRepository;\n-    protected TransactionBody transactionBody;\n-    protected TransactionRecord transactionRecord;\n     private TransactionHandler transactionHandler;\n \n     protected abstract TransactionHandler getTransactionHandler();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407665680", "bodyText": "Should do tx.setEntity(entityRepository.save(entity)); as Hibernate can return a proxied object. Can move this logic into getEntity() so that it either retrieves or create and saves the entity.", "author": "steven-sheehy", "createdAt": "2020-04-13T19:20:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -115,185 +110,33 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             return;\n         }\n \n-        // TODO: updatesEntity() is true for all and only the transaction types which are in body.has*() if-else\n-        //   conditions below. This is temporary to keep scope of changes in single PR limited and will be fixed in\n-        //   followup PR quickly. All if-else conditions will be replaced by:\n-        //     transactionHandler.updateEntity(entity, recordItem).\n-        Entities entity = null; // Entity used when t_entities row must be updated.\n-        if (transactionHandler.updatesEntity()) {\n-            entity = getEntity(entityId);\n-        }\n-\n-        // Only when transaction is successful:\n-        // - Fields of 'entity' will be updated. Fields are not updated for failed transactions since 'entity' may be an\n-        //   instance from cache and reused in future.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id will be looked up (from big cache)\n-        //   or created immediately.\n+        boolean isSuccessful = isSuccessful(txRecord);\n+        Transaction tx = buildTransaction(consensusNs, recordItem);\n+        transactionHandler.updateTransaction(tx, recordItem);\n \n-        // For all transactions:\n-        // - 'entity' (may have been updated or not) is always inserted into repo since\n+        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n         //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n         //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        boolean doUpdateEntity = isSuccessful(txRecord);\n-        long initialBalance = 0;\n-\n-        if (entity == null) {\n-            // Do nothing. This can be true if transaction is of type that doesn't update the entity. Or, if the\n-            // transaction doesn't contain non-zero entity id (i.e. with entityNum != 0).\n-        } else if (body.hasContractCreateInstance()) {\n-            if (txRecord.getReceipt().hasContractID()) { // implies SUCCESS\n-                ContractCreateTransactionBody txMessage = body.getContractCreateInstance();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getContractCreateInstance().getInitialBalance();\n-        } else if (body.hasContractDeleteInstance()) {\n-            if (body.getContractDeleteInstance().hasContractID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasContractUpdateInstance()) {\n-            ContractUpdateTransactionBody txMessage = body.getContractUpdateInstance();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-            }\n-        } else if (body.hasCryptoCreateAccount()) {\n-            if (txRecord.getReceipt().hasAccountID()) { // Implies SUCCESS\n-                CryptoCreateTransactionBody txMessage = body.getCryptoCreateAccount();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getCryptoCreateAccount().getInitialBalance();\n-        } else if (body.hasCryptoDelete()) {\n-            if (body.getCryptoDelete().hasDeleteAccountID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasCryptoUpdateAccount()) {\n-            CryptoUpdateTransactionBody txMessage = body.getCryptoUpdateAccount();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileCreate()) {\n-            if (txRecord.getReceipt().hasFileID()) { // Implies SUCCESS\n-                FileCreateTransactionBody txMessage = body.getFileCreate();\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileDelete()) {\n-            if (body.getFileDelete().hasFileID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasFileUpdate()) {\n-            FileUpdateTransactionBody txMessage = body.getFileUpdate();\n-            if (doUpdateEntity) {\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasSystemDelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(true);\n-            }\n-        } else if (body.hasSystemUndelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(false);\n-            }\n-        } else if (body.hasConsensusCreateTopic()) {\n-            consensusCreateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusUpdateTopic()) {\n-            consensusUpdateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusDeleteTopic()) {\n-            consensusDeleteTopicUpdateEntity(entity, body, txRecord);\n-        }\n-\n-        TransactionID transactionID = body.getTransactionID();\n-        long validDurationSeconds = body.hasTransactionValidDuration() ? body.getTransactionValidDuration()\n-                .getSeconds() : null;\n-        long validStartNs = Utility.timeStampInNanos(transactionID.getTransactionValidStart());\n-        AccountID payerAccountId = transactionID.getAccountID();\n-\n-        com.hedera.mirror.importer.domain.Transaction tx = new com.hedera.mirror.importer.domain.Transaction();\n-        tx.setChargedTxFee(txRecord.getTransactionFee());\n-        tx.setConsensusNs(consensusNs);\n-        tx.setInitialBalance(initialBalance);\n-        tx.setMemo(body.getMemo().getBytes());\n-        tx.setMaxFee(body.getTransactionFee());\n-        tx.setResult(txRecord.getReceipt().getStatusValue());\n-        tx.setType(transactionType);\n-        tx.setTransactionBytes(parserProperties.getPersist().isTransactionBytes() ?\n-                recordItem.getTransactionBytes() : null);\n-        tx.setTransactionHash(txRecord.getTransactionHash().toByteArray());\n-        tx.setValidDurationSeconds(validDurationSeconds);\n-        tx.setValidStartNs(validStartNs);\n-        if (entity != null) {\n+        //\n+        // Additionally, if transaction is successful:\n+        // - Fields of 'entity' will be updated.\n+        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n+        //   immediately in TransactionHandler.updateEntity(..).\n+        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n+            Entities entity = getEntity(entityId);\n+            transactionHandler.updateEntity(entity, recordItem);\n             tx.setEntity(entity);\n             entityRepository.save(entity);", "originalCommit": "617acd2c6adcc310c45ba6841827f8808b7e265d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzQwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407723406", "bodyText": "Done.", "author": "apeksharma", "createdAt": "2020-04-13T21:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "598d071e29b84f1a1f5a40e6889ef682330d344f", "chunk": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java\nindex 26956c14..097972cd 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java\n\n@@ -96,42 +96,23 @@ public class RecordItemParser implements RecordItemListener {\n         TransactionRecord txRecord = recordItem.getRecord();\n         TransactionBody body = recordItem.getTransactionBody();\n         TransactionHandler transactionHandler = transactionHandlerFactory.create(body);\n-        log.trace(\"Storing transaction body: {}\", () -> Utility.printProtoMessage(body));\n+        log.trace(\"Processing transaction : {}\", () -> Utility.printProtoMessage(body));\n \n-        int transactionType = recordItem.getTransactionType();\n         long consensusNs = Utility.timeStampInNanos(txRecord.getConsensusTimestamp());\n         EntityId entityId = transactionHandler.getEntityId(recordItem);\n+        TransactionTypeEnum transactionTypeEnum = TransactionTypeEnum.of(recordItem.getTransactionType());\n \n-        TransactionFilterFields transactionFilterFields =\n-                new TransactionFilterFields(entityId, TransactionTypeEnum.of(transactionType));\n+        TransactionFilterFields transactionFilterFields = new TransactionFilterFields(entityId, transactionTypeEnum);\n         if (!transactionFilter.test(transactionFilterFields)) {\n             log.debug(\"Ignoring transaction. consensusTimestamp={}, transactionType={}, entityId={}\",\n-                    consensusNs, TransactionTypeEnum.of(transactionType), entityId);\n+                    consensusNs, transactionTypeEnum, entityId);\n             return;\n         }\n \n         boolean isSuccessful = isSuccessful(txRecord);\n         Transaction tx = buildTransaction(consensusNs, recordItem);\n         transactionHandler.updateTransaction(tx, recordItem);\n-\n-        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n-        //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n-        //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        //\n-        // Additionally, if transaction is successful:\n-        // - Fields of 'entity' will be updated.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n-        //   immediately in TransactionHandler.updateEntity(..).\n-        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n-            Entities entity = getEntity(entityId);\n-            transactionHandler.updateEntity(entity, recordItem);\n-            tx.setEntity(entity);\n-            entityRepository.save(entity);\n-        } else if (entityId != null) {\n-            Entities entity = entityId.toEntity();\n-            entity.setId(entityRepository.lookupOrCreateId(entityId)); // look up in big cache\n-            tx.setEntity(entity);\n-        } // else leave tx.entity null\n+        tx.setEntity(getEntity(recordItem, transactionHandler, entityId, isSuccessful));\n \n         if ((txRecord.hasTransferList()) && parserProperties.getPersist().isCryptoTransferAmounts()) {\n             processNonFeeTransfers(consensusNs, body, txRecord);\n"}}, {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:09:08Z", "type": "commit"}, {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:09:08Z", "type": "forcePushed"}, {"oid": "39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "message": "fix @Cacheable\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:58:06Z", "type": "commit"}, {"oid": "f4ded5344bbbb1645e518c01550aff315a5a4518", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f4ded5344bbbb1645e518c01550aff315a5a4518", "message": "minor fix\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T22:09:28Z", "type": "commit"}]}