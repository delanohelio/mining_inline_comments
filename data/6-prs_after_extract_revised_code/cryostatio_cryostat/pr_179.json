{"pr_number": 179, "pr_title": "Add health check", "pr_createdAt": "2020-06-05T19:40:11Z", "pr_url": "https://github.com/cryostatio/cryostat/pull/179", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNzg2OA==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436127868", "bodyText": "I think the response needs to be cleaned up - simply try (CloseableHttpResponse response = ...) { ... } would suffice.", "author": "andrewazores", "createdAt": "2020-06-05T19:44:00Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java", "diffHunk": "@@ -534,6 +542,25 @@ void handleAuthRequest(RoutingContext ctx) {\n         }\n     }\n \n+    void handleHealthRequest(RoutingContext ctx) {\n+        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n+        ctx.response().setStatusCode(200);\n+\n+        boolean datasourceAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            HttpGet grafanaHealth = new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV));\n+            try {\n+                CloseableHttpResponse response = this.client.execute(grafanaHealth);", "originalCommit": "9d79212dbd6baf5048183e7288f2962792391c0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ae9f254ca2332f4bc0fd6ebdf34c7fc6c7a404f", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\nindex 06ff9f13..b323d646 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n\n@@ -398,534 +271,12 @@ public class WebServer {\n         return conn.getJMXURL().toString();\n     }\n \n-    private Optional<DownloadDescriptor> getRecordingDescriptor(\n-            String targetId, String recordingName) throws Exception {\n-        return getTargetRecordingDescriptor(targetId, recordingName)\n-                .or(() -> getSavedRecordingDescriptor(recordingName));\n-    }\n-\n-    private Optional<DownloadDescriptor> getTargetRecordingDescriptor(\n-            String targetId, String recordingName) throws Exception {\n-        if (targetId == null) {\n-            return Optional.empty();\n-        }\n-        JFRConnection connection = targetConnectionManager.connect(targetId);\n-        Optional<IRecordingDescriptor> desc =\n-                connection.getService().getAvailableRecordings().stream()\n-                        .filter(r -> Objects.equals(recordingName, r.getName()))\n-                        .findFirst();\n-        if (desc.isPresent()) {\n-            return Optional.of(\n-                    new DownloadDescriptor(\n-                            connection.getService().openStream(desc.get(), false),\n-                            null,\n-                            connection));\n-        } else {\n-            connection.close();\n-            return Optional.empty();\n-        }\n-    }\n-\n-    private Optional<DownloadDescriptor> getSavedRecordingDescriptor(String recordingName) {\n-        try {\n-            // TODO refactor Files calls into FileSystem for testability\n-            Optional<Path> savedRecording =\n-                    Files.list(savedRecordingsPath)\n-                            .filter(\n-                                    saved ->\n-                                            saved.getFileName()\n-                                                            .toFile()\n-                                                            .getName()\n-                                                            .equals(recordingName)\n-                                                    || saved.getFileName()\n-                                                            .toFile()\n-                                                            .getName()\n-                                                            .equals(recordingName + \".jfr\"))\n-                            .findFirst();\n-            if (savedRecording.isPresent()) {\n-                return Optional.of(\n-                        new DownloadDescriptor(\n-                                Files.newInputStream(savedRecording.get(), StandardOpenOption.READ),\n-                                Files.size(savedRecording.get()),\n-                                null));\n-            }\n-        } catch (Exception e) {\n-            logger.error(e);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private <T> void endWithJsonKeyValue(String key, T value, HttpServerResponse response) {\n-        response.end(String.format(\"{\\\"%s\\\":%s}\", key, gson.toJson(value)));\n-    }\n-\n-    private HttpServerResponse writeInputStreamLowMemPressure(\n-            InputStream inputStream, HttpServerResponse response) throws IOException {\n-        // blocking function, must be called from a blocking handler\n-        byte[] buff = new byte[WRITE_BUFFER_SIZE];\n-        Buffer chunk = Buffer.buffer();\n-\n-        ExecutorService worker = Executors.newSingleThreadExecutor();\n-        CompletableFuture<Void> future = new CompletableFuture<>();\n-        worker.submit(\n-                new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        int n;\n-                        try {\n-                            n = inputStream.read(buff);\n-                        } catch (IOException e) {\n-                            future.completeExceptionally(e);\n-                            return;\n-                        }\n-\n-                        if (n == -1) {\n-                            future.complete(null);\n-                            return;\n-                        }\n-\n-                        chunk.setBytes(0, buff, 0, n);\n-                        response.write(\n-                                chunk.slice(0, n),\n-                                (res) -> {\n-                                    if (res.failed()) {\n-                                        future.completeExceptionally(res.cause());\n-                                        return;\n-                                    }\n-                                    worker.submit(this); // recursive call on this runnable itself\n-                                });\n-                    }\n-                });\n-\n-        try {\n-            future.join();\n-            worker.shutdownNow();\n-        } catch (CompletionException e) {\n-            if (e.getCause() instanceof IOException) {\n-                throw (IOException) e.getCause();\n-            } else {\n-                throw e;\n-            }\n-        }\n-\n-        return response;\n-    }\n-\n-    private HttpServerResponse writeInputStream(\n-            InputStream inputStream, HttpServerResponse response) throws IOException {\n-        // blocking function, must be called from a blocking handler\n-        byte[] buff = new byte[WRITE_BUFFER_SIZE]; // 64 KB\n-        int n;\n-        while (true) {\n-            n = inputStream.read(buff);\n-            if (n == -1) {\n-                break;\n-            }\n-            response.write(Buffer.buffer().appendBytes(buff, 0, n));\n-        }\n-\n-        return response;\n-    }\n-\n-    void handleAuthRequest(RoutingContext ctx) {\n-        boolean authd = false;\n-        try {\n-            authd = validateRequestAuthorization(ctx.request()).get();\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-        if (authd) {\n-            ctx.response().setStatusCode(200);\n-            ctx.response().end();\n-        } else {\n-            throw new HttpStatusException(401);\n-        }\n-    }\n-\n-    void handleHealthRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        ctx.response().setStatusCode(200);\n-\n-        boolean datasourceAvailable = false;\n-\n-        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n-            HttpGet grafanaHealth = new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV));\n-            try {\n-                CloseableHttpResponse response = this.client.execute(grafanaHealth);\n-                if (response.getStatusLine().getStatusCode() == 200) {\n-                    datasourceAvailable = true;\n-                }\n-            } catch (IOException e) {\n-            }\n-        }\n-        endWithJsonKeyValue(\"datasourceAvailable\", datasourceAvailable, ctx.response());\n-    }\n-\n-    void handleWebClientIndexRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_HTML);\n-        ctx.response().sendFile(WEB_CLIENT_ASSETS_BASE + \"/index.html\");\n-    }\n-\n-    void handleClientUrlRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        try {\n-            endWithJsonKeyValue(\n-                    \"clientUrl\",\n-                    String.format(\n-                            \"%s://%s:%d/api/v1/command\",\n-                            server.isSsl() ? \"wss\" : \"ws\",\n-                            netConf.getWebServerHost(),\n-                            netConf.getExternalWebServerPort()),\n-                    ctx.response());\n-        } catch (SocketException | UnknownHostException e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    void handleGrafanaDatasourceUrlRequest(RoutingContext ctx) {\n-        if (!this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n-            throw new HttpStatusException(500, \"Deployment has no Grafana configuration\");\n-        }\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        endWithJsonKeyValue(\n-                \"grafanaDatasourceUrl\", env.getEnv(GRAFANA_DATASOURCE_ENV, \"\"), ctx.response());\n-    }\n-\n-    void handleGrafanaDashboardUrlRequest(RoutingContext ctx) {\n-        if (!this.env.hasEnv(GRAFANA_DASHBOARD_ENV)) {\n-            throw new HttpStatusException(500, \"Deployment has no Grafana configuration\");\n-        }\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        endWithJsonKeyValue(\n-                \"grafanaDashboardUrl\", env.getEnv(GRAFANA_DASHBOARD_ENV, \"\"), ctx.response());\n-    }\n-\n-    void handleRecordingUploadRequest(RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-\n-        if (!fs.isDirectory(savedRecordingsPath)) {\n-            throw new HttpStatusException(503, \"Recording saving not available\");\n-        }\n-\n-        FileUpload upload = null;\n-        for (FileUpload fu : ctx.fileUploads()) {\n-            // ignore unrecognized form fields\n-            if (\"recording\".equals(fu.name())) {\n-                upload = fu;\n-                break;\n-            }\n-        }\n-\n-        if (upload == null) {\n-            throw new HttpStatusException(400, \"No recording submission\");\n-        }\n-\n-        String fileName = upload.fileName();\n-        if (fileName == null || fileName.isEmpty()) {\n-            throw new HttpStatusException(400, \"Recording name must not be empty\");\n-        }\n-\n-        if (fileName.endsWith(\".jfr\")) {\n-            fileName = fileName.substring(0, fileName.length() - 4);\n-        }\n-\n-        Matcher m = RECORDING_FILENAME_PATTERN.matcher(fileName);\n-        if (!m.matches()) {\n-            throw new HttpStatusException(400, \"Incorrect recording file name pattern\");\n-        }\n-\n-        String targetName = m.group(1);\n-        String recordingName = m.group(2);\n-        String timestamp = m.group(3);\n-        int count =\n-                m.group(4) == null || m.group(4).isEmpty()\n-                        ? 0\n-                        : Integer.parseInt(m.group(4).substring(1));\n-\n-        final String basename = String.format(\"%s_%s_%s\", targetName, recordingName, timestamp);\n-        final String uploadedFileName = upload.uploadedFileName();\n-        validateRecording(\n-                upload.uploadedFileName(),\n-                (res) ->\n-                        saveRecording(\n-                                basename,\n-                                uploadedFileName,\n-                                count,\n-                                (res2) -> {\n-                                    if (res2.failed()) {\n-                                        ctx.fail(res2.cause());\n-                                        return;\n-                                    }\n-\n-                                    ctx.response()\n-                                            .putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-                                    endWithJsonKeyValue(\"name\", res2.result(), ctx.response());\n-\n-                                    logger.info(\n-                                            String.format(\"Recording saved as %s\", res2.result()));\n-                                }));\n-    }\n-\n-    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n-    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n-    void handleRecordingDownloadRequest(String targetId, String recordingName, RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-\n-            Optional<DownloadDescriptor> descriptor =\n-                    getRecordingDescriptor(targetId, recordingName);\n-            if (descriptor.isEmpty()) {\n-                throw new HttpStatusException(404, String.format(\"%s not found\", recordingName));\n-            }\n-\n-            ctx.response().setChunked(true);\n-            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_OCTET_STREAM);\n-            descriptor\n-                    .get()\n-                    .bytes\n-                    .ifPresent(\n-                            b ->\n-                                    ctx.response()\n-                                            .putHeader(\n-                                                    HttpHeaders.CONTENT_LENGTH, Long.toString(b)));\n-            try (InputStream stream = descriptor.get().stream) {\n-                if (env.hasEnv(USE_LOW_MEM_PRESSURE_STREAMING_ENV)) {\n-                    writeInputStreamLowMemPressure(stream, ctx.response());\n-                } else {\n-                    writeInputStream(stream, ctx.response());\n-                }\n-                ctx.response().end();\n-            } finally {\n-                descriptor\n-                        .get()\n-                        .resource\n-                        .ifPresent(\n-                                resource -> {\n-                                    try {\n-                                        resource.close();\n-                                    } catch (Exception e) {\n-                                        logger.warn(e);\n-                                    }\n-                                });\n-            }\n-        } catch (HttpStatusException e) {\n-            throw e;\n-        } catch (FlightRecorderException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be opened\", recordingName), e);\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    void handleReportPageRequest(String targetId, String recordingName, RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-            Optional<DownloadDescriptor> descriptor =\n-                    getRecordingDescriptor(targetId, recordingName);\n-            if (descriptor.isEmpty()) {\n-                throw new HttpStatusException(404, String.format(\"%s not found\", recordingName));\n-            }\n-\n-            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_HTML);\n-            try (InputStream stream = descriptor.get().stream) {\n-                // blocking function, must be called from a blocking handler\n-                ctx.response().end(reportGenerator.generateReport(stream));\n-            } finally {\n-                descriptor\n-                        .get()\n-                        .resource\n-                        .ifPresent(\n-                                resource -> {\n-                                    try {\n-                                        resource.close();\n-                                    } catch (Exception e) {\n-                                        logger.warn(e);\n-                                    }\n-                                });\n-            }\n-        } catch (HttpStatusException e) {\n-            throw e;\n-        } catch (FlightRecorderException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be opened\", recordingName), e);\n-        } catch (CouldNotLoadRecordingException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be loaded\", recordingName), e);\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    private Future<Boolean> validateRequestAuthorization(HttpServerRequest req) throws Exception {\n-        return auth.validateHttpHeader(() -> req.getHeader(HttpHeaders.AUTHORIZATION));\n-    }\n-\n-    private boolean isCorsEnabled() {\n-        return this.env.hasEnv(ENABLE_CORS_ENV);\n-    }\n-\n-    private void enableCors(HttpServerResponse response) {\n-        if (isCorsEnabled()) {\n-            response.putHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, \"http://localhost:9000\");\n-            response.putHeader(\"Vary\", \"Origin\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, OPTIONS, HEAD\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,\n-                    String.join(\", \", Arrays.asList(\"authorization\", \"Authorization\")));\n-            response.putHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS,\n-                    String.join(\", \", Arrays.asList(AUTH_SCHEME_HEADER)));\n-        }\n-    }\n-\n-    private <T> AsyncResult<T> makeAsyncResult(T result) {\n-        return new AsyncResult<>() {\n-            @Override\n-            public T result() {\n-                return result;\n-            }\n-\n-            @Override\n-            public Throwable cause() {\n-                return null;\n-            }\n-\n-            @Override\n-            public boolean succeeded() {\n-                return true;\n-            }\n-\n-            @Override\n-            public boolean failed() {\n-                return false;\n-            }\n-        };\n-    }\n-\n-    private <T> AsyncResult<T> makeFailedAsyncResult(Throwable cause) {\n-        return new AsyncResult<>() {\n-            @Override\n-            public T result() {\n-                return null;\n-            }\n-\n-            @Override\n-            public Throwable cause() {\n-                return cause;\n-            }\n-\n-            @Override\n-            public boolean succeeded() {\n-                return false;\n-            }\n-\n-            @Override\n-            public boolean failed() {\n-                return true;\n-            }\n-        };\n-    }\n-\n-    private void validateRecording(String recordingFile, Handler<AsyncResult<Void>> handler) {\n-        server.getVertx()\n-                .executeBlocking(\n-                        event -> {\n-                            try {\n-                                JfrLoaderToolkit.loadEvents(\n-                                        new File(recordingFile)); // try loading events to see if\n-                                // it's a valid file\n-                                event.complete();\n-                            } catch (CouldNotLoadRecordingException | IOException e) {\n-                                event.fail(e);\n-                            }\n-                        },\n-                        res -> {\n-                            if (res.failed()) {\n-                                Throwable t;\n-                                if (res.cause() instanceof CouldNotLoadRecordingException) {\n-                                    t =\n-                                            new HttpStatusException(\n-                                                    400,\n-                                                    \"Not a valid JFR recording file\",\n-                                                    res.cause());\n-                                } else {\n-                                    t = res.cause();\n-                                }\n-\n-                                handler.handle(makeFailedAsyncResult(t));\n-                                return;\n-                            }\n-\n-                            handler.handle(makeAsyncResult(null));\n-                        });\n-    }\n-\n-    private void saveRecording(\n-            String basename, String tmpFile, int counter, Handler<AsyncResult<String>> handler) {\n-        // TODO byte-sized rename limit is arbitrary. Probably plenty since recordings\n-        // are also differentiated by second-resolution timestamp\n-        if (counter >= Byte.MAX_VALUE) {\n-            handler.handle(\n-                    makeFailedAsyncResult(\n-                            new IOException(\n-                                    \"Recording could not be saved. File already exists and rename attempts were exhausted.\")));\n-            return;\n-        }\n-\n-        String filename = counter > 1 ? basename + \".\" + counter + \".jfr\" : basename + \".jfr\";\n-\n-        server.getVertx()\n-                .fileSystem()\n-                .exists(\n-                        savedRecordingsPath.resolve(filename).toString(),\n-                        (res) -> {\n-                            if (res.failed()) {\n-                                handler.handle(makeFailedAsyncResult(res.cause()));\n-                                return;\n-                            }\n-\n-                            if (res.result()) {\n-                                saveRecording(basename, tmpFile, counter + 1, handler);\n-                                return;\n-                            }\n-\n-                            // verified no name clash at this time\n-                            server.getVertx()\n-                                    .fileSystem()\n-                                    .move(\n-                                            tmpFile,\n-                                            savedRecordingsPath.resolve(filename).toString(),\n-                                            (res2) -> {\n-                                                if (res2.failed()) {\n-                                                    handler.handle(\n-                                                            makeFailedAsyncResult(res2.cause()));\n-                                                    return;\n-                                                }\n-\n-                                                handler.handle(makeAsyncResult(filename));\n-                                            });\n-                        });\n-    }\n-\n-    private static class DownloadDescriptor {\n-        final InputStream stream;\n-        final Optional<Long> bytes;\n-        final Optional<AutoCloseable> resource;\n+    public static class DownloadDescriptor {\n+        public final InputStream stream;\n+        public final Optional<Long> bytes;\n+        public final Optional<AutoCloseable> resource;\n \n-        DownloadDescriptor(InputStream stream, Long bytes, AutoCloseable resource) {\n+        public DownloadDescriptor(InputStream stream, Long bytes, AutoCloseable resource) {\n             this.stream = Objects.requireNonNull(stream);\n             this.bytes = Optional.ofNullable(bytes);\n             this.resource = Optional.ofNullable(resource);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyODUzOQ==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436128539", "bodyText": "I think this is probably okay, but what do you think about injecting a Provider<CloseableHttpClient>? Then later on when you need to use a client, you can create, use, and clean up the client as needed. Right now there will be a single client sticking around for the life of the webserver. That's not likely a real problem, but I guess just a stylistic thing.", "author": "andrewazores", "createdAt": "2020-06-05T19:45:42Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java", "diffHunk": "@@ -147,6 +152,7 @@\n             TargetConnectionManager targetConnectionManager,\n             Logger logger) {\n         this.server = server;\n+        this.client = client;", "originalCommit": "9d79212dbd6baf5048183e7288f2962792391c0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ae9f254ca2332f4bc0fd6ebdf34c7fc6c7a404f", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\nindex 06ff9f13..b323d646 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n\n@@ -50,124 +49,62 @@ import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n import java.net.UnknownHostException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n+import java.util.Set;\n \n-import org.apache.http.client.methods.CloseableHttpResponse;\n-import org.apache.http.client.methods.HttpGet;\n import org.apache.http.client.utils.URIBuilder;\n-import org.apache.http.impl.client.CloseableHttpClient;\n \n-import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n-import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n import org.openjdk.jmc.rjmx.services.jfr.FlightRecorderException;\n-import org.openjdk.jmc.rjmx.services.jfr.IRecordingDescriptor;\n \n import com.google.gson.Gson;\n \n import com.redhat.rhjmc.containerjfr.core.log.Logger;\n import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n-import com.redhat.rhjmc.containerjfr.core.reports.ReportGenerator;\n-import com.redhat.rhjmc.containerjfr.core.sys.Environment;\n-import com.redhat.rhjmc.containerjfr.core.sys.FileSystem;\n import com.redhat.rhjmc.containerjfr.net.AuthManager;\n import com.redhat.rhjmc.containerjfr.net.HttpServer;\n import com.redhat.rhjmc.containerjfr.net.NetworkConfiguration;\n-import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+import com.redhat.rhjmc.containerjfr.net.web.handlers.RequestHandler;\n \n-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n-import io.vertx.core.AsyncResult;\n import io.vertx.core.Handler;\n-import io.vertx.core.buffer.Buffer;\n import io.vertx.core.http.HttpHeaders;\n-import io.vertx.core.http.HttpServerRequest;\n-import io.vertx.core.http.HttpServerResponse;\n-import io.vertx.ext.web.FileUpload;\n+import io.vertx.ext.web.Route;\n import io.vertx.ext.web.Router;\n import io.vertx.ext.web.RoutingContext;\n-import io.vertx.ext.web.handler.BodyHandler;\n-import io.vertx.ext.web.handler.StaticHandler;\n import io.vertx.ext.web.handler.impl.HttpStatusException;\n \n public class WebServer {\n \n-    private static final String WEB_CLIENT_ASSETS_BASE =\n-            WebServer.class.getPackageName().replaceAll(\"\\\\.\", \"/\");\n-\n-    private static final String ENABLE_CORS_ENV = \"CONTAINER_JFR_ENABLE_CORS\";\n-    private static final String GRAFANA_DASHBOARD_ENV = \"GRAFANA_DASHBOARD_URL\";\n-    private static final String GRAFANA_DATASOURCE_ENV = \"GRAFANA_DATASOURCE_URL\";\n-    private static final String USE_LOW_MEM_PRESSURE_STREAMING_ENV =\n-            \"USE_LOW_MEM_PRESSURE_STREAMING\";\n-\n-    private static final String MIME_TYPE_JSON = \"application/json\";\n-    private static final String MIME_TYPE_HTML = \"text/html\";\n-    private static final String MIME_TYPE_PLAINTEXT = \"text/plain\";\n-    private static final String MIME_TYPE_OCTET_STREAM = \"application/octet-stream\";\n-\n     // Use X- prefix so as to not trigger web-browser auth dialogs\n-    private static final String AUTH_SCHEME_HEADER = \"X-WWW-Authenticate\";\n-\n-    private static final int WRITE_BUFFER_SIZE = 64 * 1024; // 64 KB\n-\n-    private static final Pattern RECORDING_FILENAME_PATTERN =\n-            Pattern.compile(\"([A-Za-z\\\\d-]*)_([A-Za-z\\\\d-_]*)_([\\\\d]*T[\\\\d]*Z)(.[\\\\d]+)?\");\n+    public static final String AUTH_SCHEME_HEADER = \"X-WWW-Authenticate\";\n \n     private final HttpServer server;\n-    private final CloseableHttpClient client;\n     private final NetworkConfiguration netConf;\n-    private final Environment env;\n-    private final Path savedRecordingsPath;\n-    private final FileSystem fs;\n-    private final AuthManager auth;\n+    private final List<RequestHandler> requestHandlers;\n     private final Gson gson;\n+    private final AuthManager auth;\n     private final Logger logger;\n \n-    private final ReportGenerator reportGenerator;\n-    private final TargetConnectionManager targetConnectionManager;\n-\n     WebServer(\n             HttpServer server,\n-            CloseableHttpClient client,\n             NetworkConfiguration netConf,\n-            Environment env,\n-            Path savedRecordingsPath,\n-            FileSystem fs,\n-            AuthManager auth,\n+            Set<RequestHandler> requestHandlers,\n             Gson gson,\n-            ReportGenerator reportGenerator,\n-            TargetConnectionManager targetConnectionManager,\n+            AuthManager auth,\n             Logger logger) {\n         this.server = server;\n-        this.client = client;\n         this.netConf = netConf;\n-        this.env = env;\n-        this.savedRecordingsPath = savedRecordingsPath;\n-        this.fs = fs;\n-        this.auth = auth;\n+        this.requestHandlers = new ArrayList<>(requestHandlers);\n+        Collections.sort(this.requestHandlers, (a, b) -> a.path().compareTo(b.path()));\n         this.gson = gson;\n+        this.auth = auth;\n         this.logger = logger;\n-        this.reportGenerator = reportGenerator;\n-        this.targetConnectionManager = targetConnectionManager;\n-\n-        if (env.hasEnv(USE_LOW_MEM_PRESSURE_STREAMING_ENV)) {\n-            logger.info(\"low memory pressure streaming enabled for web server\");\n-        } else {\n-            logger.info(\"low memory pressure streaming disabled for web server\");\n-        }\n     }\n \n     public void start() throws FlightRecorderException, SocketException, UnknownHostException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMjk0Nw==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436132947", "bodyText": "When you do the refactor, this endWithJsonKeyValue isn't around anymore, so the preferred equivalent would look like ctx.response().end(gson.toJson(Map.of(\"datasourceAvailable\", datasourceAvailable))).\nOn that note, what do you think about adding an equivalent JSON property for the Grafana dashboard's health as well? It would be something like a new HttpGet(this.env.getEnv(GRAFANA_DASHBOARD_ENV) + \"/api/health\")), and then the rest of the response processing you've done here would be the same I think.", "author": "andrewazores", "createdAt": "2020-06-05T19:52:55Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java", "diffHunk": "@@ -534,6 +542,25 @@ void handleAuthRequest(RoutingContext ctx) {\n         }\n     }\n \n+    void handleHealthRequest(RoutingContext ctx) {\n+        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n+        ctx.response().setStatusCode(200);\n+\n+        boolean datasourceAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            HttpGet grafanaHealth = new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV));\n+            try {\n+                CloseableHttpResponse response = this.client.execute(grafanaHealth);\n+                if (response.getStatusLine().getStatusCode() == 200) {\n+                    datasourceAvailable = true;\n+                }\n+            } catch (IOException e) {\n+            }\n+        }\n+        endWithJsonKeyValue(\"datasourceAvailable\", datasourceAvailable, ctx.response());", "originalCommit": "9d79212dbd6baf5048183e7288f2962792391c0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ae9f254ca2332f4bc0fd6ebdf34c7fc6c7a404f", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\nindex 06ff9f13..b323d646 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/WebServer.java\n\n@@ -398,534 +271,12 @@ public class WebServer {\n         return conn.getJMXURL().toString();\n     }\n \n-    private Optional<DownloadDescriptor> getRecordingDescriptor(\n-            String targetId, String recordingName) throws Exception {\n-        return getTargetRecordingDescriptor(targetId, recordingName)\n-                .or(() -> getSavedRecordingDescriptor(recordingName));\n-    }\n-\n-    private Optional<DownloadDescriptor> getTargetRecordingDescriptor(\n-            String targetId, String recordingName) throws Exception {\n-        if (targetId == null) {\n-            return Optional.empty();\n-        }\n-        JFRConnection connection = targetConnectionManager.connect(targetId);\n-        Optional<IRecordingDescriptor> desc =\n-                connection.getService().getAvailableRecordings().stream()\n-                        .filter(r -> Objects.equals(recordingName, r.getName()))\n-                        .findFirst();\n-        if (desc.isPresent()) {\n-            return Optional.of(\n-                    new DownloadDescriptor(\n-                            connection.getService().openStream(desc.get(), false),\n-                            null,\n-                            connection));\n-        } else {\n-            connection.close();\n-            return Optional.empty();\n-        }\n-    }\n-\n-    private Optional<DownloadDescriptor> getSavedRecordingDescriptor(String recordingName) {\n-        try {\n-            // TODO refactor Files calls into FileSystem for testability\n-            Optional<Path> savedRecording =\n-                    Files.list(savedRecordingsPath)\n-                            .filter(\n-                                    saved ->\n-                                            saved.getFileName()\n-                                                            .toFile()\n-                                                            .getName()\n-                                                            .equals(recordingName)\n-                                                    || saved.getFileName()\n-                                                            .toFile()\n-                                                            .getName()\n-                                                            .equals(recordingName + \".jfr\"))\n-                            .findFirst();\n-            if (savedRecording.isPresent()) {\n-                return Optional.of(\n-                        new DownloadDescriptor(\n-                                Files.newInputStream(savedRecording.get(), StandardOpenOption.READ),\n-                                Files.size(savedRecording.get()),\n-                                null));\n-            }\n-        } catch (Exception e) {\n-            logger.error(e);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private <T> void endWithJsonKeyValue(String key, T value, HttpServerResponse response) {\n-        response.end(String.format(\"{\\\"%s\\\":%s}\", key, gson.toJson(value)));\n-    }\n-\n-    private HttpServerResponse writeInputStreamLowMemPressure(\n-            InputStream inputStream, HttpServerResponse response) throws IOException {\n-        // blocking function, must be called from a blocking handler\n-        byte[] buff = new byte[WRITE_BUFFER_SIZE];\n-        Buffer chunk = Buffer.buffer();\n-\n-        ExecutorService worker = Executors.newSingleThreadExecutor();\n-        CompletableFuture<Void> future = new CompletableFuture<>();\n-        worker.submit(\n-                new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        int n;\n-                        try {\n-                            n = inputStream.read(buff);\n-                        } catch (IOException e) {\n-                            future.completeExceptionally(e);\n-                            return;\n-                        }\n-\n-                        if (n == -1) {\n-                            future.complete(null);\n-                            return;\n-                        }\n-\n-                        chunk.setBytes(0, buff, 0, n);\n-                        response.write(\n-                                chunk.slice(0, n),\n-                                (res) -> {\n-                                    if (res.failed()) {\n-                                        future.completeExceptionally(res.cause());\n-                                        return;\n-                                    }\n-                                    worker.submit(this); // recursive call on this runnable itself\n-                                });\n-                    }\n-                });\n-\n-        try {\n-            future.join();\n-            worker.shutdownNow();\n-        } catch (CompletionException e) {\n-            if (e.getCause() instanceof IOException) {\n-                throw (IOException) e.getCause();\n-            } else {\n-                throw e;\n-            }\n-        }\n-\n-        return response;\n-    }\n-\n-    private HttpServerResponse writeInputStream(\n-            InputStream inputStream, HttpServerResponse response) throws IOException {\n-        // blocking function, must be called from a blocking handler\n-        byte[] buff = new byte[WRITE_BUFFER_SIZE]; // 64 KB\n-        int n;\n-        while (true) {\n-            n = inputStream.read(buff);\n-            if (n == -1) {\n-                break;\n-            }\n-            response.write(Buffer.buffer().appendBytes(buff, 0, n));\n-        }\n-\n-        return response;\n-    }\n-\n-    void handleAuthRequest(RoutingContext ctx) {\n-        boolean authd = false;\n-        try {\n-            authd = validateRequestAuthorization(ctx.request()).get();\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-        if (authd) {\n-            ctx.response().setStatusCode(200);\n-            ctx.response().end();\n-        } else {\n-            throw new HttpStatusException(401);\n-        }\n-    }\n-\n-    void handleHealthRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        ctx.response().setStatusCode(200);\n-\n-        boolean datasourceAvailable = false;\n-\n-        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n-            HttpGet grafanaHealth = new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV));\n-            try {\n-                CloseableHttpResponse response = this.client.execute(grafanaHealth);\n-                if (response.getStatusLine().getStatusCode() == 200) {\n-                    datasourceAvailable = true;\n-                }\n-            } catch (IOException e) {\n-            }\n-        }\n-        endWithJsonKeyValue(\"datasourceAvailable\", datasourceAvailable, ctx.response());\n-    }\n-\n-    void handleWebClientIndexRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_HTML);\n-        ctx.response().sendFile(WEB_CLIENT_ASSETS_BASE + \"/index.html\");\n-    }\n-\n-    void handleClientUrlRequest(RoutingContext ctx) {\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        try {\n-            endWithJsonKeyValue(\n-                    \"clientUrl\",\n-                    String.format(\n-                            \"%s://%s:%d/api/v1/command\",\n-                            server.isSsl() ? \"wss\" : \"ws\",\n-                            netConf.getWebServerHost(),\n-                            netConf.getExternalWebServerPort()),\n-                    ctx.response());\n-        } catch (SocketException | UnknownHostException e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    void handleGrafanaDatasourceUrlRequest(RoutingContext ctx) {\n-        if (!this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n-            throw new HttpStatusException(500, \"Deployment has no Grafana configuration\");\n-        }\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        endWithJsonKeyValue(\n-                \"grafanaDatasourceUrl\", env.getEnv(GRAFANA_DATASOURCE_ENV, \"\"), ctx.response());\n-    }\n-\n-    void handleGrafanaDashboardUrlRequest(RoutingContext ctx) {\n-        if (!this.env.hasEnv(GRAFANA_DASHBOARD_ENV)) {\n-            throw new HttpStatusException(500, \"Deployment has no Grafana configuration\");\n-        }\n-        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-        endWithJsonKeyValue(\n-                \"grafanaDashboardUrl\", env.getEnv(GRAFANA_DASHBOARD_ENV, \"\"), ctx.response());\n-    }\n-\n-    void handleRecordingUploadRequest(RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-\n-        if (!fs.isDirectory(savedRecordingsPath)) {\n-            throw new HttpStatusException(503, \"Recording saving not available\");\n-        }\n-\n-        FileUpload upload = null;\n-        for (FileUpload fu : ctx.fileUploads()) {\n-            // ignore unrecognized form fields\n-            if (\"recording\".equals(fu.name())) {\n-                upload = fu;\n-                break;\n-            }\n-        }\n-\n-        if (upload == null) {\n-            throw new HttpStatusException(400, \"No recording submission\");\n-        }\n-\n-        String fileName = upload.fileName();\n-        if (fileName == null || fileName.isEmpty()) {\n-            throw new HttpStatusException(400, \"Recording name must not be empty\");\n-        }\n-\n-        if (fileName.endsWith(\".jfr\")) {\n-            fileName = fileName.substring(0, fileName.length() - 4);\n-        }\n-\n-        Matcher m = RECORDING_FILENAME_PATTERN.matcher(fileName);\n-        if (!m.matches()) {\n-            throw new HttpStatusException(400, \"Incorrect recording file name pattern\");\n-        }\n-\n-        String targetName = m.group(1);\n-        String recordingName = m.group(2);\n-        String timestamp = m.group(3);\n-        int count =\n-                m.group(4) == null || m.group(4).isEmpty()\n-                        ? 0\n-                        : Integer.parseInt(m.group(4).substring(1));\n-\n-        final String basename = String.format(\"%s_%s_%s\", targetName, recordingName, timestamp);\n-        final String uploadedFileName = upload.uploadedFileName();\n-        validateRecording(\n-                upload.uploadedFileName(),\n-                (res) ->\n-                        saveRecording(\n-                                basename,\n-                                uploadedFileName,\n-                                count,\n-                                (res2) -> {\n-                                    if (res2.failed()) {\n-                                        ctx.fail(res2.cause());\n-                                        return;\n-                                    }\n-\n-                                    ctx.response()\n-                                            .putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_JSON);\n-                                    endWithJsonKeyValue(\"name\", res2.result(), ctx.response());\n-\n-                                    logger.info(\n-                                            String.format(\"Recording saved as %s\", res2.result()));\n-                                }));\n-    }\n-\n-    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n-    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n-    void handleRecordingDownloadRequest(String targetId, String recordingName, RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-\n-            Optional<DownloadDescriptor> descriptor =\n-                    getRecordingDescriptor(targetId, recordingName);\n-            if (descriptor.isEmpty()) {\n-                throw new HttpStatusException(404, String.format(\"%s not found\", recordingName));\n-            }\n-\n-            ctx.response().setChunked(true);\n-            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_OCTET_STREAM);\n-            descriptor\n-                    .get()\n-                    .bytes\n-                    .ifPresent(\n-                            b ->\n-                                    ctx.response()\n-                                            .putHeader(\n-                                                    HttpHeaders.CONTENT_LENGTH, Long.toString(b)));\n-            try (InputStream stream = descriptor.get().stream) {\n-                if (env.hasEnv(USE_LOW_MEM_PRESSURE_STREAMING_ENV)) {\n-                    writeInputStreamLowMemPressure(stream, ctx.response());\n-                } else {\n-                    writeInputStream(stream, ctx.response());\n-                }\n-                ctx.response().end();\n-            } finally {\n-                descriptor\n-                        .get()\n-                        .resource\n-                        .ifPresent(\n-                                resource -> {\n-                                    try {\n-                                        resource.close();\n-                                    } catch (Exception e) {\n-                                        logger.warn(e);\n-                                    }\n-                                });\n-            }\n-        } catch (HttpStatusException e) {\n-            throw e;\n-        } catch (FlightRecorderException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be opened\", recordingName), e);\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    void handleReportPageRequest(String targetId, String recordingName, RoutingContext ctx) {\n-        try {\n-            if (!validateRequestAuthorization(ctx.request()).get()) {\n-                throw new HttpStatusException(401);\n-            }\n-            Optional<DownloadDescriptor> descriptor =\n-                    getRecordingDescriptor(targetId, recordingName);\n-            if (descriptor.isEmpty()) {\n-                throw new HttpStatusException(404, String.format(\"%s not found\", recordingName));\n-            }\n-\n-            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, MIME_TYPE_HTML);\n-            try (InputStream stream = descriptor.get().stream) {\n-                // blocking function, must be called from a blocking handler\n-                ctx.response().end(reportGenerator.generateReport(stream));\n-            } finally {\n-                descriptor\n-                        .get()\n-                        .resource\n-                        .ifPresent(\n-                                resource -> {\n-                                    try {\n-                                        resource.close();\n-                                    } catch (Exception e) {\n-                                        logger.warn(e);\n-                                    }\n-                                });\n-            }\n-        } catch (HttpStatusException e) {\n-            throw e;\n-        } catch (FlightRecorderException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be opened\", recordingName), e);\n-        } catch (CouldNotLoadRecordingException e) {\n-            throw new HttpStatusException(\n-                    500, String.format(\"%s could not be loaded\", recordingName), e);\n-        } catch (Exception e) {\n-            throw new HttpStatusException(500, e);\n-        }\n-    }\n-\n-    private Future<Boolean> validateRequestAuthorization(HttpServerRequest req) throws Exception {\n-        return auth.validateHttpHeader(() -> req.getHeader(HttpHeaders.AUTHORIZATION));\n-    }\n-\n-    private boolean isCorsEnabled() {\n-        return this.env.hasEnv(ENABLE_CORS_ENV);\n-    }\n-\n-    private void enableCors(HttpServerResponse response) {\n-        if (isCorsEnabled()) {\n-            response.putHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, \"http://localhost:9000\");\n-            response.putHeader(\"Vary\", \"Origin\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, OPTIONS, HEAD\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,\n-                    String.join(\", \", Arrays.asList(\"authorization\", \"Authorization\")));\n-            response.putHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n-            response.putHeader(\n-                    HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS,\n-                    String.join(\", \", Arrays.asList(AUTH_SCHEME_HEADER)));\n-        }\n-    }\n-\n-    private <T> AsyncResult<T> makeAsyncResult(T result) {\n-        return new AsyncResult<>() {\n-            @Override\n-            public T result() {\n-                return result;\n-            }\n-\n-            @Override\n-            public Throwable cause() {\n-                return null;\n-            }\n-\n-            @Override\n-            public boolean succeeded() {\n-                return true;\n-            }\n-\n-            @Override\n-            public boolean failed() {\n-                return false;\n-            }\n-        };\n-    }\n-\n-    private <T> AsyncResult<T> makeFailedAsyncResult(Throwable cause) {\n-        return new AsyncResult<>() {\n-            @Override\n-            public T result() {\n-                return null;\n-            }\n-\n-            @Override\n-            public Throwable cause() {\n-                return cause;\n-            }\n-\n-            @Override\n-            public boolean succeeded() {\n-                return false;\n-            }\n-\n-            @Override\n-            public boolean failed() {\n-                return true;\n-            }\n-        };\n-    }\n-\n-    private void validateRecording(String recordingFile, Handler<AsyncResult<Void>> handler) {\n-        server.getVertx()\n-                .executeBlocking(\n-                        event -> {\n-                            try {\n-                                JfrLoaderToolkit.loadEvents(\n-                                        new File(recordingFile)); // try loading events to see if\n-                                // it's a valid file\n-                                event.complete();\n-                            } catch (CouldNotLoadRecordingException | IOException e) {\n-                                event.fail(e);\n-                            }\n-                        },\n-                        res -> {\n-                            if (res.failed()) {\n-                                Throwable t;\n-                                if (res.cause() instanceof CouldNotLoadRecordingException) {\n-                                    t =\n-                                            new HttpStatusException(\n-                                                    400,\n-                                                    \"Not a valid JFR recording file\",\n-                                                    res.cause());\n-                                } else {\n-                                    t = res.cause();\n-                                }\n-\n-                                handler.handle(makeFailedAsyncResult(t));\n-                                return;\n-                            }\n-\n-                            handler.handle(makeAsyncResult(null));\n-                        });\n-    }\n-\n-    private void saveRecording(\n-            String basename, String tmpFile, int counter, Handler<AsyncResult<String>> handler) {\n-        // TODO byte-sized rename limit is arbitrary. Probably plenty since recordings\n-        // are also differentiated by second-resolution timestamp\n-        if (counter >= Byte.MAX_VALUE) {\n-            handler.handle(\n-                    makeFailedAsyncResult(\n-                            new IOException(\n-                                    \"Recording could not be saved. File already exists and rename attempts were exhausted.\")));\n-            return;\n-        }\n-\n-        String filename = counter > 1 ? basename + \".\" + counter + \".jfr\" : basename + \".jfr\";\n-\n-        server.getVertx()\n-                .fileSystem()\n-                .exists(\n-                        savedRecordingsPath.resolve(filename).toString(),\n-                        (res) -> {\n-                            if (res.failed()) {\n-                                handler.handle(makeFailedAsyncResult(res.cause()));\n-                                return;\n-                            }\n-\n-                            if (res.result()) {\n-                                saveRecording(basename, tmpFile, counter + 1, handler);\n-                                return;\n-                            }\n-\n-                            // verified no name clash at this time\n-                            server.getVertx()\n-                                    .fileSystem()\n-                                    .move(\n-                                            tmpFile,\n-                                            savedRecordingsPath.resolve(filename).toString(),\n-                                            (res2) -> {\n-                                                if (res2.failed()) {\n-                                                    handler.handle(\n-                                                            makeFailedAsyncResult(res2.cause()));\n-                                                    return;\n-                                                }\n-\n-                                                handler.handle(makeAsyncResult(filename));\n-                                            });\n-                        });\n-    }\n-\n-    private static class DownloadDescriptor {\n-        final InputStream stream;\n-        final Optional<Long> bytes;\n-        final Optional<AutoCloseable> resource;\n+    public static class DownloadDescriptor {\n+        public final InputStream stream;\n+        public final Optional<Long> bytes;\n+        public final Optional<AutoCloseable> resource;\n \n-        DownloadDescriptor(InputStream stream, Long bytes, AutoCloseable resource) {\n+        public DownloadDescriptor(InputStream stream, Long bytes, AutoCloseable resource) {\n             this.stream = Objects.requireNonNull(stream);\n             this.bytes = Optional.ofNullable(bytes);\n             this.resource = Optional.ofNullable(resource);\n"}}, {"oid": "9ae9f254ca2332f4bc0fd6ebdf34c7fc6c7a404f", "url": "https://github.com/cryostatio/cryostat/commit/9ae9f254ca2332f4bc0fd6ebdf34c7fc6c7a404f", "message": "Clean up code", "committedDate": "2020-06-05T20:27:31Z", "type": "forcePushed"}, {"oid": "23fd85db10ada9bd84de0843c360fa66889e6092", "url": "https://github.com/cryostatio/cryostat/commit/23fd85db10ada9bd84de0843c360fa66889e6092", "message": "Add handler for /health", "committedDate": "2020-06-05T20:41:23Z", "type": "commit"}, {"oid": "23fd85db10ada9bd84de0843c360fa66889e6092", "url": "https://github.com/cryostatio/cryostat/commit/23fd85db10ada9bd84de0843c360fa66889e6092", "message": "Add handler for /health", "committedDate": "2020-06-05T20:41:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1OTMzOA==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436159338", "bodyText": "I think at least putting a Logger warning here or something would make sense. What do you think?", "author": "andrewazores", "createdAt": "2020-06-05T20:53:35Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.inject.Provider;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.core.sys.Environment;\n+import com.redhat.rhjmc.containerjfr.net.web.HttpMimeType;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class HealthGetHandler implements RequestHandler {\n+\n+    static final String GRAFANA_DATASOURCE_ENV = \"GRAFANA_DATASOURCE_URL\";\n+\n+    private final Provider<CloseableHttpClient> httpClientProvider;\n+    private final Environment env;\n+    private final Gson gson;\n+\n+    @Inject\n+    HealthGetHandler(Provider<CloseableHttpClient> httpClientProvider, Environment env, Gson gson) {\n+        this.httpClientProvider = httpClientProvider;\n+        this.env = env;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return \"/health\";\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n+    @Override\n+    public void handle(RoutingContext ctx) {\n+        boolean datasourceAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            try (CloseableHttpResponse response =\n+                    this.httpClientProvider\n+                            .get()\n+                            .execute(new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV))); ) {\n+                if (response.getStatusLine().getStatusCode() == 200) {\n+                    datasourceAvailable = true;\n+                }\n+            } catch (IOException e) {\n+                // Do nothing", "originalCommit": "23fd85db10ada9bd84de0843c360fa66889e6092", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5OTk2NQ==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436199965", "bodyText": "Added in latest commit", "author": "jiekang", "createdAt": "2020-06-05T23:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1OTMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "6998957ac690c072d19b0302cd599c971af913b8", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\nindex d1ff454f..feef4f52 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n\n@@ -43,6 +43,8 @@ package com.redhat.rhjmc.containerjfr.net.web.handlers;\n \n import java.io.IOException;\n import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import javax.inject.Inject;\n import javax.inject.Provider;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MDA5Mg==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436160092", "bodyText": "If the env var is not set, or is blank what happens? Is a request still fired? I think in that scenario it's worth just short-circuiting and skipping the network request.", "author": "andrewazores", "createdAt": "2020-06-05T20:55:28Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.inject.Provider;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.core.sys.Environment;\n+import com.redhat.rhjmc.containerjfr.net.web.HttpMimeType;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class HealthGetHandler implements RequestHandler {\n+\n+    static final String GRAFANA_DATASOURCE_ENV = \"GRAFANA_DATASOURCE_URL\";\n+\n+    private final Provider<CloseableHttpClient> httpClientProvider;\n+    private final Environment env;\n+    private final Gson gson;\n+\n+    @Inject\n+    HealthGetHandler(Provider<CloseableHttpClient> httpClientProvider, Environment env, Gson gson) {\n+        this.httpClientProvider = httpClientProvider;\n+        this.env = env;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return \"/health\";\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n+    @Override\n+    public void handle(RoutingContext ctx) {\n+        boolean datasourceAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            try (CloseableHttpResponse response =\n+                    this.httpClientProvider\n+                            .get()\n+                            .execute(new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV))); ) {", "originalCommit": "23fd85db10ada9bd84de0843c360fa66889e6092", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5OTM1Nw==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436199357", "bodyText": "This is inside an if block for env.hasEnv so it should be skipped when env isn't set. I think it's fine to continue without checking the value; it will just error out in it's attempt in the client code", "author": "jiekang", "createdAt": "2020-06-05T22:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MDA5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "6998957ac690c072d19b0302cd599c971af913b8", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\nindex d1ff454f..feef4f52 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n\n@@ -43,6 +43,8 @@ package com.redhat.rhjmc.containerjfr.net.web.handlers;\n \n import java.io.IOException;\n import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n \n import javax.inject.Inject;\n import javax.inject.Provider;\n"}}, {"oid": "6998957ac690c072d19b0302cd599c971af913b8", "url": "https://github.com/cryostatio/cryostat/commit/6998957ac690c072d19b0302cd599c971af913b8", "message": "Update health handler to also get status of grafana service", "committedDate": "2020-06-05T22:56:25Z", "type": "commit"}, {"oid": "0b7325aaf03b48efff3d93977f2f88c706377e4c", "url": "https://github.com/cryostatio/cryostat/commit/0b7325aaf03b48efff3d93977f2f88c706377e4c", "message": "Add logging to health request exception. Apply spotless", "committedDate": "2020-06-05T23:00:58Z", "type": "commit"}, {"oid": "aab83639f5ae172a553db698a778809dd5d02300", "url": "https://github.com/cryostatio/cryostat/commit/aab83639f5ae172a553db698a778809dd5d02300", "message": "Fix health handler test", "committedDate": "2020-06-05T23:03:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436203513", "bodyText": "Is the TreeMap here jjust to ensure consistent ordering of the keys?", "author": "andrewazores", "createdAt": "2020-06-05T23:18:58Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import javax.inject.Inject;\n+import javax.inject.Provider;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.sys.Environment;\n+import com.redhat.rhjmc.containerjfr.net.web.HttpMimeType;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class HealthGetHandler implements RequestHandler {\n+\n+    static final String GRAFANA_DATASOURCE_ENV = \"GRAFANA_DATASOURCE_URL\";\n+    static final String GRAFANA_DASHBOARD_ENV = \"GRAFANA_DASHBOARD_URL\";\n+\n+    private final Provider<CloseableHttpClient> httpClientProvider;\n+    private final Environment env;\n+    private final Gson gson;\n+    private final Logger logger;\n+\n+    @Inject\n+    HealthGetHandler(\n+            Provider<CloseableHttpClient> httpClientProvider,\n+            Environment env,\n+            Gson gson,\n+            Logger logger) {\n+        this.httpClientProvider = httpClientProvider;\n+        this.env = env;\n+        this.gson = gson;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return \"/health\";\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n+    @Override\n+    public void handle(RoutingContext ctx) {\n+        boolean datasourceAvailable = false;\n+        boolean dashboardAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            try (CloseableHttpResponse response =\n+                    this.httpClientProvider\n+                            .get()\n+                            .execute(new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV))); ) {\n+                if (response.getStatusLine().getStatusCode() == 200) {\n+                    datasourceAvailable = true;\n+                }\n+            } catch (IOException e) {\n+                logger.warn(e);\n+            }\n+        }\n+\n+        if (this.env.hasEnv(GRAFANA_DASHBOARD_ENV)) {\n+            String url = this.env.getEnv(GRAFANA_DASHBOARD_ENV) + \"/api/health\";\n+            try (CloseableHttpResponse response =\n+                    this.httpClientProvider.get().execute(new HttpGet(url)); ) {\n+                if (response.getStatusLine().getStatusCode() == 200) {\n+                    dashboardAvailable = true;\n+                }\n+            } catch (IOException e) {\n+                logger.warn(e);\n+            }\n+        }\n+\n+        ctx.response()\n+                .putHeader(HttpHeaders.CONTENT_TYPE, HttpMimeType.JSON.mime())\n+                .end(\n+                        gson.toJson(\n+                                new TreeMap<>(", "originalCommit": "aab83639f5ae172a553db698a778809dd5d02300", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMjEwMA==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436212100", "bodyText": "Yeah; let me know if there's a smarter way to do it D:", "author": "jiekang", "createdAt": "2020-06-06T00:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzNTU2MA==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r436235560", "bodyText": "Hmm. I don't know of a particularly better way, although I wonder if it really matters - a typical client parsing the JSON response shouldn't care about the key order. Maybe it makes testing easier, but then perhaps the tests should grab a Gson instance (from the MainModule), parse the response, and make assertions on what is found in the deserialized structure?", "author": "andrewazores", "createdAt": "2020-06-06T04:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNjI1Nw==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r438936257", "bodyText": "Hey Andrew. I think that clients will appreciate consistent responses and the cost for us to do so is minimal, though a bit... hacky (here). If you'd like, I can keep it random and adjust the test, let me know.", "author": "jiekang", "createdAt": "2020-06-11T17:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NTA5Nw==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r438965097", "bodyText": "I don't really see the benefit to clients of having consistently ordered JSON keys, though. JSON parsing of an object should be independent of what order the keys appear in, so any client using a spec-compliant parser shouldn't even really notice whether the keys are sorted or even in consistent order or not. If we start enforcing a particular ordering of the keys here then a) we should be doing it everywhere and b) that ordering becomes an implicit part of our API, and I don't quite agree with either of those.", "author": "andrewazores", "createdAt": "2020-06-11T17:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzgxMg==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r439863812", "bodyText": "Okay. Updated in the latest commit", "author": "jiekang", "createdAt": "2020-06-14T20:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "c01fcfb019626af155c63643fa9989229ec6a25f", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\nindex 60100932..b2213b47 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n\n@@ -43,7 +43,6 @@ package com.redhat.rhjmc.containerjfr.net.web.handlers;\n \n import java.io.IOException;\n import java.util.Map;\n-import java.util.TreeMap;\n \n import javax.inject.Inject;\n import javax.inject.Provider;\n"}}, {"oid": "c01fcfb019626af155c63643fa9989229ec6a25f", "url": "https://github.com/cryostatio/cryostat/commit/c01fcfb019626af155c63643fa9989229ec6a25f", "message": "Update health handler and test for random order response", "committedDate": "2020-06-14T20:13:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxNTI2Ng==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r440215266", "bodyText": "Last thing: this auto-closes the response, but not the client itself. I think it should be something like try (CloseableHttpClient client = this.httpClientProvider.get(); CloseableHttpResponse response = client.execute()). There's a similar example in the UploadRecordingCommand", "author": "andrewazores", "createdAt": "2020-06-15T14:26:39Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+import javax.inject.Provider;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.sys.Environment;\n+import com.redhat.rhjmc.containerjfr.net.web.HttpMimeType;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class HealthGetHandler implements RequestHandler {\n+\n+    static final String GRAFANA_DATASOURCE_ENV = \"GRAFANA_DATASOURCE_URL\";\n+    static final String GRAFANA_DASHBOARD_ENV = \"GRAFANA_DASHBOARD_URL\";\n+\n+    private final Provider<CloseableHttpClient> httpClientProvider;\n+    private final Environment env;\n+    private final Gson gson;\n+    private final Logger logger;\n+\n+    @Inject\n+    HealthGetHandler(\n+            Provider<CloseableHttpClient> httpClientProvider,\n+            Environment env,\n+            Gson gson,\n+            Logger logger) {\n+        this.httpClientProvider = httpClientProvider;\n+        this.env = env;\n+        this.gson = gson;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return \"/health\";\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    // try-with-resources generates a \"redundant\" nullcheck in bytecode\n+    @SuppressFBWarnings(\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\")\n+    @Override\n+    public void handle(RoutingContext ctx) {\n+        boolean datasourceAvailable = false;\n+        boolean dashboardAvailable = false;\n+\n+        if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n+            try (CloseableHttpResponse response =\n+                    this.httpClientProvider\n+                            .get()", "originalCommit": "c01fcfb019626af155c63643fa9989229ec6a25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NjA2OA==", "url": "https://github.com/cryostatio/cryostat/pull/179#discussion_r440286068", "bodyText": "Should be fixed now. Thanks for the note.", "author": "jiekang", "createdAt": "2020-06-15T16:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxNTI2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "bd0b3609ca80eaa8248eb913e45add66dbf8312d", "chunk": "diff --git a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\nindex b2213b47..55de2435 100644\n--- a/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n+++ b/src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/HealthGetHandler.java\n\n@@ -101,10 +101,10 @@ class HealthGetHandler implements RequestHandler {\n         boolean dashboardAvailable = false;\n \n         if (this.env.hasEnv(GRAFANA_DATASOURCE_ENV)) {\n-            try (CloseableHttpResponse response =\n-                    this.httpClientProvider\n-                            .get()\n-                            .execute(new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV))); ) {\n+            try (CloseableHttpClient httpClient = httpClientProvider.get();\n+                    CloseableHttpResponse response =\n+                            httpClient.execute(\n+                                    new HttpGet(this.env.getEnv(GRAFANA_DATASOURCE_ENV))); ) {\n                 if (response.getStatusLine().getStatusCode() == 200) {\n                     datasourceAvailable = true;\n                 }\n"}}, {"oid": "bd0b3609ca80eaa8248eb913e45add66dbf8312d", "url": "https://github.com/cryostatio/cryostat/commit/bd0b3609ca80eaa8248eb913e45add66dbf8312d", "message": "Fix try close in HealthGetHandler", "committedDate": "2020-06-15T16:06:10Z", "type": "commit"}]}