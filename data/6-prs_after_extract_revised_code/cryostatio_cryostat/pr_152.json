{"pr_number": 152, "pr_title": "Replace Service discovery with Endpoint discovery", "pr_createdAt": "2020-04-22T21:01:35Z", "pr_url": "https://github.com/cryostatio/cryostat/pull/152", "timeline": [{"oid": "1f6dcaac83b900cb7ca4161aae21c28a06ae6d8f", "url": "https://github.com/cryostatio/cryostat/commit/1f6dcaac83b900cb7ca4161aae21c28a06ae6d8f", "message": "Replace Service discovery with Endpoint discovery\n\nUsing OpenShift Endpoints for discovery allows ContainerJFR to bypass\nService load-balancing, enabling connections directly to specific pod\nreplicas, rather than being load-balanced across replicas for the pod\nbacking the service\n\nFixes #151", "committedDate": "2020-04-22T17:48:37Z", "type": "commit"}, {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa", "url": "https://github.com/cryostatio/cryostat/commit/ca19b2ccf9375f64d5551b55342338c9442bf2aa", "message": "Add OpenShiftPlatformClientTest", "committedDate": "2020-04-22T21:02:16Z", "type": "commit"}, {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa", "url": "https://github.com/cryostatio/cryostat/commit/ca19b2ccf9375f64d5551b55342338c9442bf2aa", "message": "Add OpenShiftPlatformClientTest", "committedDate": "2020-04-22T21:02:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NjE5Nw==", "url": "https://github.com/cryostatio/cryostat/pull/152#discussion_r413376197", "bodyText": "Are these commented-out lines meant to be kept?", "author": "ebaron", "createdAt": "2020-04-22T22:29:27Z", "path": "src/test/java/com/redhat/rhjmc/containerjfr/platform/openshift/OpenShiftPlatformClientTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package com.redhat.rhjmc.containerjfr.platform.openshift;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.sys.FileSystem;\n+import com.redhat.rhjmc.containerjfr.platform.ServiceRef;\n+\n+import io.fabric8.kubernetes.api.model.EndpointAddress;\n+import io.fabric8.kubernetes.api.model.EndpointPort;\n+import io.fabric8.kubernetes.api.model.EndpointSubset;\n+import io.fabric8.kubernetes.api.model.Endpoints;\n+import io.fabric8.kubernetes.api.model.EndpointsList;\n+import io.fabric8.kubernetes.api.model.ObjectReference;\n+import io.fabric8.kubernetes.client.dsl.MixedOperation;\n+import io.fabric8.kubernetes.client.dsl.NonNamespaceOperation;\n+import io.fabric8.openshift.client.OpenShiftClient;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OpenShiftPlatformClientTest {\n+\n+    @Mock Logger logger;\n+    @Mock OpenShiftClient osClient;\n+    @Mock FileSystem fs;\n+    OpenShiftPlatformClient platformClient;\n+\n+    @BeforeEach\n+    void setup() {\n+        this.platformClient = new OpenShiftPlatformClient(logger, osClient, fs);\n+    }\n+\n+    @Test\n+    void shouldReturnEmptyListIfNoEndpointsFound() throws Exception {\n+        String namespace = \"foo-namespace\";\n+        setMockNamespace(namespace);\n+\n+        MixedOperation mockNamespaceOperation = Mockito.mock(MixedOperation.class);\n+        Mockito.when(osClient.endpoints()).thenReturn(mockNamespaceOperation);\n+\n+        ArgumentCaptor<String> namespaceCaptor = ArgumentCaptor.forClass(String.class);\n+        NonNamespaceOperation mockOperation = Mockito.mock(NonNamespaceOperation.class);\n+        Mockito.when(mockNamespaceOperation.inNamespace(namespaceCaptor.capture()))\n+                .thenReturn(mockOperation);\n+\n+        EndpointsList mockListable = Mockito.mock(EndpointsList.class);\n+        Mockito.when(mockOperation.list()).thenReturn(mockListable);\n+\n+        List<Endpoints> mockEndpoints = Collections.emptyList();\n+        Mockito.when(mockListable.getItems()).thenReturn(mockEndpoints);\n+\n+        List<ServiceRef> result = platformClient.listDiscoverableServices();\n+        MatcherAssert.assertThat(namespaceCaptor.getValue(), Matchers.equalTo(namespace));\n+        MatcherAssert.assertThat(result, Matchers.equalTo(Collections.emptyList()));\n+    }\n+\n+    @Test\n+    void shouldReturnListOfMatchingEndpointRefs() throws Exception {\n+        String namespace = \"foo-namespace\";\n+        setMockNamespace(namespace);\n+\n+        MixedOperation mockNamespaceOperation = Mockito.mock(MixedOperation.class);\n+        Mockito.when(osClient.endpoints()).thenReturn(mockNamespaceOperation);\n+\n+        ArgumentCaptor<String> namespaceCaptor = ArgumentCaptor.forClass(String.class);\n+        NonNamespaceOperation mockOperation = Mockito.mock(NonNamespaceOperation.class);\n+        Mockito.when(mockNamespaceOperation.inNamespace(namespaceCaptor.capture()))\n+                .thenReturn(mockOperation);\n+\n+        EndpointsList mockListable = Mockito.mock(EndpointsList.class);\n+        Mockito.when(mockOperation.list()).thenReturn(mockListable);\n+\n+        ObjectReference objRef1 = Mockito.mock(ObjectReference.class);\n+        // Mockito.when(objRef1.getName()).thenReturn(\"targetA\");\n+        ObjectReference objRef2 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef2.getName()).thenReturn(\"targetB\");\n+        ObjectReference objRef3 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef3.getName()).thenReturn(\"targetC\");\n+        ObjectReference objRef4 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef4.getName()).thenReturn(\"targetD\");\n+\n+        EndpointAddress address1 = Mockito.mock(EndpointAddress.class);\n+        // Mockito.when(address1.getIp()).thenReturn(\"127.0.0.1\");\n+        // Mockito.when(address1.getTargetRef()).thenReturn(objRef1);\n+        EndpointAddress address2 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address2.getIp()).thenReturn(\"127.0.0.2\");\n+        Mockito.when(address2.getTargetRef()).thenReturn(objRef2);\n+        EndpointAddress address3 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address3.getIp()).thenReturn(\"127.0.0.3\");\n+        Mockito.when(address3.getTargetRef()).thenReturn(objRef3);\n+        EndpointAddress address4 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address4.getIp()).thenReturn(\"127.0.0.4\");\n+        Mockito.when(address4.getTargetRef()).thenReturn(objRef4);\n+\n+        EndpointPort port1 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port1.getPort()).thenReturn(80);\n+        Mockito.when(port1.getName()).thenReturn(\"tcp-80\");\n+        EndpointPort port2 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port2.getPort()).thenReturn(9999);\n+        Mockito.when(port2.getName()).thenReturn(\"jfr-jmx\");\n+        EndpointPort port3 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port3.getPort()).thenReturn(9091);\n+        Mockito.when(port3.getName()).thenReturn(\"tcp-9091\");\n+\n+        EndpointSubset subset1 = Mockito.mock(EndpointSubset.class);\n+        // Mockito.when(subset1.getAddresses()).thenReturn(Collections.singletonList(address1));\n+        Mockito.when(subset1.getPorts()).thenReturn(Collections.singletonList(port1));", "originalCommit": "ca19b2ccf9375f64d5551b55342338c9442bf2aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3OTIxMw==", "url": "https://github.com/cryostatio/cryostat/pull/152#discussion_r413379213", "bodyText": "Sort of. I set up all that structure of a mock endpoints API response, but because of the way the selection algorithm works, the IP and TargetRef of the Address are never checked if the corresponding port isn't deemed compatible. This caused Mockito to complain about unnecessary stubbing, although if those lines were completely removed then it might be a little more difficult to come back to that test later and see how things were intended to be structured when certain fields from the mock response are just omitted entirely.", "author": "andrewazores", "createdAt": "2020-04-22T22:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NjE5Nw=="}], "type": "inlineReview", "revised_code": null}]}