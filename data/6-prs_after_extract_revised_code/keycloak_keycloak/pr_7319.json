{"pr_number": 7319, "pr_title": "KEYCLOAK-14781 Extend Admin REST API with search by federated identity", "pr_createdAt": "2020-08-04T10:52:01Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7319", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwNDg1OA==", "url": "https://github.com/keycloak/keycloak/pull/7319#discussion_r492104858", "bodyText": "This introduction of if-then-else introduces a separate branch of the search. Is there a reason for not treating UserModel.IDP_ALIAS and UserModel.IDP_USER_ID the same way as the other attributes? Could it be part of the switch instead?", "author": "hmlnarik", "createdAt": "2020-09-21T14:44:48Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -841,42 +841,60 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n             predicates.add(root.get(\"serviceAccountClientLink\").isNull());\n         }\n \n-        for (Map.Entry<String, String> entry : attributes.entrySet()) {\n-            String key = entry.getKey();\n-            String value = entry.getValue();\n+        final String idpAlias = attributes.get(UserModel.IDP_ALIAS);\n+        final String idpUserId = attributes.get(UserModel.IDP_USER_ID);\n+        if (idpAlias != null) {", "originalCommit": "8823a3e79ae0807ffa677a7ca221988e217a160b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMzc4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7319#discussion_r492123786", "bodyText": "My colleagues and I thought that it would be better to have the idp-search separated from the search for other attributes. One reason was that we decided that the idp-parameters have to be always searched for exactly - this is different from the other attributes for which a contains-search is provided.\nBut I can also understand the advantage of combining the idp-search with other attributes - the search would be more powerful.", "author": "danielFesenmeyer", "createdAt": "2020-09-21T15:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwNDg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxOTM3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7319#discussion_r493619371", "bodyText": "One reason was that we decided that the idp-parameters have to be always searched for exactly - this is different from the other attributes for which a contains-search is provided.\n\nThis limitation is a reasonable one, since it would be strange to search for an identity provider alias / username via a substring search. Still, JPA storage search would benefit from allowing for combining the predicates, so that it would be possible to search for e.g. enabled users coming from the given idp.", "author": "hmlnarik", "createdAt": "2020-09-23T14:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwNDg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "14ae04b827cd9e6fc1e6f061214ea2466ba37afb", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex fee2de9fe8..3bda35628c 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n\n@@ -841,60 +841,58 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {\n             predicates.add(root.get(\"serviceAccountClientLink\").isNull());\n         }\n \n-        final String idpAlias = attributes.get(UserModel.IDP_ALIAS);\n-        final String idpUserId = attributes.get(UserModel.IDP_USER_ID);\n-        if (idpAlias != null) {\n-            Join<UserEntity, FederatedIdentityEntity> join = root.join(\"federatedIdentities\");\n+        Join<Object, Object> federatedIdentitiesJoin = null;\n \n-            predicates.add(builder.equal(join.get(\"identityProvider\"), idpAlias));\n+        for (Map.Entry<String, String> entry : attributes.entrySet()) {\n+            String key = entry.getKey();\n+            String value = entry.getValue();\n \n-            if (idpUserId != null) {\n-                predicates.add(builder.equal(join.get(\"userId\"), idpUserId));\n+            if (value == null) {\n+                continue;\n             }\n \n-            final String enabledStr = attributes.get(UserModel.ENABLED);\n-            if (enabledStr != null) {\n-                predicates.add(builder.equal(root.get(UserModel.ENABLED), Boolean.parseBoolean(enabledStr)));\n-            }\n-        } else {\n-            for (Map.Entry<String, String> entry : attributes.entrySet()) {\n-                String key = entry.getKey();\n-                String value = entry.getValue();\n+            switch (key) {\n+                case UserModel.SEARCH:\n+                    List<Predicate> orPredicates = new ArrayList();\n \n-                if (value == null) {\n-                    continue;\n-                }\n+                    orPredicates\n+                            .add(builder.like(builder.lower(root.get(USERNAME)), \"%\" + value.toLowerCase() + \"%\"));\n+                    orPredicates.add(builder.like(builder.lower(root.get(EMAIL)), \"%\" + value.toLowerCase() + \"%\"));\n+                    orPredicates.add(builder.like(\n+                            builder.lower(builder.concat(builder.concat(\n+                                    builder.coalesce(root.get(FIRST_NAME), builder.literal(\"\")), \" \"),\n+                                    builder.coalesce(root.get(LAST_NAME), builder.literal(\"\")))),\n+                            \"%\" + value.toLowerCase() + \"%\"));\n \n-                switch (key) {\n-                    case UserModel.SEARCH:\n-                        List<Predicate> orPredicates = new ArrayList();\n-\n-                        orPredicates\n-                                .add(builder.like(builder.lower(root.get(USERNAME)), \"%\" + value.toLowerCase() + \"%\"));\n-                        orPredicates.add(builder.like(builder.lower(root.get(EMAIL)), \"%\" + value.toLowerCase() + \"%\"));\n-                        orPredicates.add(builder.like(\n-                                builder.lower(builder.concat(builder.concat(\n-                                        builder.coalesce(root.get(FIRST_NAME), builder.literal(\"\")), \" \"),\n-                                        builder.coalesce(root.get(LAST_NAME), builder.literal(\"\")))),\n-                                \"%\" + value.toLowerCase() + \"%\"));\n-\n-                        predicates.add(builder.or(orPredicates.toArray(new Predicate[orPredicates.size()])));\n-\n-                        break;\n-\n-                    case USERNAME:\n-                    case FIRST_NAME:\n-                    case LAST_NAME:\n-                    case EMAIL:\n-                        if (Boolean.valueOf(attributes.getOrDefault(UserModel.EXACT, Boolean.FALSE.toString()))) {\n-                            predicates.add(builder.equal(builder.lower(root.get(key)), value.toLowerCase()));\n-                        } else {\n-                            predicates.add(builder.like(builder.lower(root.get(key)), \"%\" + value.toLowerCase() + \"%\"));\n-                        }\n-                        break;\n-                    case UserModel.ENABLED:\n-                        predicates.add(builder.equal(root.get(key), Boolean.parseBoolean(value)));\n-                }\n+                    predicates.add(builder.or(orPredicates.toArray(new Predicate[orPredicates.size()])));\n+\n+                    break;\n+\n+                case USERNAME:\n+                case FIRST_NAME:\n+                case LAST_NAME:\n+                case EMAIL:\n+                    if (Boolean.valueOf(attributes.getOrDefault(UserModel.EXACT, Boolean.FALSE.toString()))) {\n+                        predicates.add(builder.equal(builder.lower(root.get(key)), value.toLowerCase()));\n+                    } else {\n+                        predicates.add(builder.like(builder.lower(root.get(key)), \"%\" + value.toLowerCase() + \"%\"));\n+                    }\n+                    break;\n+                case UserModel.ENABLED:\n+                    predicates.add(builder.equal(root.get(key), Boolean.parseBoolean(value)));\n+                    break;\n+                case UserModel.IDP_ALIAS:\n+                    if (federatedIdentitiesJoin == null) {\n+                        federatedIdentitiesJoin = root.join(\"federatedIdentities\");\n+                    }\n+                    predicates.add(builder.equal(federatedIdentitiesJoin.get(\"identityProvider\"), value));\n+                    break;\n+                case UserModel.IDP_USER_ID:\n+                    if (federatedIdentitiesJoin == null) {\n+                        federatedIdentitiesJoin = root.join(\"federatedIdentities\");\n+                    }\n+                    predicates.add(builder.equal(federatedIdentitiesJoin.get(\"userId\"), value));\n+                    break;\n             }\n         }\n \n"}}, {"oid": "14ae04b827cd9e6fc1e6f061214ea2466ba37afb", "url": "https://github.com/keycloak/keycloak/commit/14ae04b827cd9e6fc1e6f061214ea2466ba37afb", "message": "KEYCLOAK-14781 Extend Admin REST API with search by federated identity\n\n- Add parameters idpAlias and idpUserId to the resource /{realm}/users and allow it to be combined with the other search parameters like username, email and so on\n- Add attribute \"federatedIdentities\" to UserEntity to allow joining on this field\n- extend integration test \"UserTest\"", "committedDate": "2020-09-28T07:58:29Z", "type": "forcePushed"}, {"oid": "e1fd6474fa595f7a54dcd826f3619b2ba02bb35b", "url": "https://github.com/keycloak/keycloak/commit/e1fd6474fa595f7a54dcd826f3619b2ba02bb35b", "message": "KEYCLOAK-14781 Extend Admin REST API with search by federated identity\n\n- Add parameters idpAlias and idpUserId to the resource /{realm}/users and allow it to be combined with the other search parameters like username, email and so on\n- Add attribute \"federatedIdentities\" to UserEntity to allow joining on this field\n- extend integration test \"UserTest\"", "committedDate": "2020-10-01T10:51:43Z", "type": "commit"}, {"oid": "e1fd6474fa595f7a54dcd826f3619b2ba02bb35b", "url": "https://github.com/keycloak/keycloak/commit/e1fd6474fa595f7a54dcd826f3619b2ba02bb35b", "message": "KEYCLOAK-14781 Extend Admin REST API with search by federated identity\n\n- Add parameters idpAlias and idpUserId to the resource /{realm}/users and allow it to be combined with the other search parameters like username, email and so on\n- Add attribute \"federatedIdentities\" to UserEntity to allow joining on this field\n- extend integration test \"UserTest\"", "committedDate": "2020-10-01T10:51:43Z", "type": "forcePushed"}]}