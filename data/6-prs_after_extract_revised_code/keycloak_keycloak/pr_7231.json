{"pr_number": 7231, "pr_title": "KEYCLOAK-14553 Map storage - clients", "pr_createdAt": "2020-07-03T20:58:21Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7231", "timeline": [{"oid": "1245022706751833a15e10e22e775727b21bdf7b", "url": "https://github.com/keycloak/keycloak/commit/1245022706751833a15e10e22e775727b21bdf7b", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-07T22:03:52Z", "type": "forcePushed"}, {"oid": "9b37913940f28b08043eafa5e625a471c9d0ff85", "url": "https://github.com/keycloak/keycloak/commit/9b37913940f28b08043eafa5e625a471c9d0ff85", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-08T04:52:49Z", "type": "forcePushed"}, {"oid": "8f87674e9029e9ec313a082d3206329377409544", "url": "https://github.com/keycloak/keycloak/commit/8f87674e9029e9ec313a082d3206329377409544", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-08T18:44:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MTU5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r452441599", "bodyText": "What about this method and the other client-specific methods? Should we introduce a ClientCacheSession class and move this functionality there or is this class meant to serve as CacheSession for both of them and then maybe we could rename it?", "author": "vramik", "createdAt": "2020-07-09T19:28:02Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java", "diffHunk": "@@ -495,13 +495,13 @@ public void evictRealmOnRemoval(RealmModel realm) {\n \n     @Override\n     public ClientModel addClient(RealmModel realm, String clientId) {", "originalCommit": "8f87674e9029e9ec313a082d3206329377409544", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MzE4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454163186", "bodyText": "Yup, in the long term, this should be the way. This will be handled as part of the caching layer in store.x in some of the follow-up PR", "author": "hmlnarik", "createdAt": "2020-07-14T07:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MTU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "654c7a9d68d4e4c147e347550c82d126fbb84117", "chunk": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java\nindex 968abacf30..7717f417e5 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java\n\n@@ -493,13 +493,13 @@ public class RealmCacheSession implements CacheRealmProvider {\n     }\n \n \n-    @Override\n+//    @Override\n     public ClientModel addClient(RealmModel realm, String clientId) {\n         ClientModel client = getClientDelegate().addClient(realm, clientId);\n         return addedClient(realm, client);\n     }\n \n-    @Override\n+//    @Override\n     public ClientModel addClient(RealmModel realm, String id, String clientId) {\n         ClientModel client = getClientDelegate().addClient(realm, id, clientId);\n         return addedClient(realm, client);\n"}}, {"oid": "654c7a9d68d4e4c147e347550c82d126fbb84117", "url": "https://github.com/keycloak/keycloak/commit/654c7a9d68d4e4c147e347550c82d126fbb84117", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-10T19:52:32Z", "type": "forcePushed"}, {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3", "url": "https://github.com/keycloak/keycloak/commit/427831cd54cffb6ab6bba6f14bbda511028401a3", "message": "fixup! KEYCLOAK-14553 Client map store", "committedDate": "2020-07-14T16:39:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNTMzNA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454515334", "bodyText": "We should change the author as well.", "author": "vramik", "createdAt": "2020-07-14T17:17:13Z", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgyODUxNA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454828514", "bodyText": "I don't think we should in this case - Bill is the original author so I'd rather keep it.", "author": "hmlnarik", "createdAt": "2020-07-15T06:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNTMzNA=="}], "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\nindex ada0c5c9bf..2df6c7197a 100644\n--- a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n\n@@ -46,7 +46,7 @@ public interface ClientProvider extends ClientLookupProvider, Provider {\n      */\n     default List<ClientModel> getClients(RealmModel realm) {\n         return this.getClients(realm, null, null);\n-    };\n+    }\n \n     /**\n      * Adds a client with given {@code clientId} to the given realm.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNzA2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454517065", "bodyText": "javadoc for this method is TODO or it is omitted on purpose?", "author": "vramik", "createdAt": "2020-07-14T17:20:06Z", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    };\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\nindex ada0c5c9bf..2df6c7197a 100644\n--- a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n\n@@ -46,7 +46,7 @@ public interface ClientProvider extends ClientLookupProvider, Provider {\n      */\n     default List<ClientModel> getClients(RealmModel realm) {\n         return this.getClients(realm, null, null);\n-    };\n+    }\n \n     /**\n      * Adds a client with given {@code clientId} to the given realm.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMjM4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454522386", "bodyText": "Do we really want to introduce default implementation of this method? I can imagine that someone who will implement this interface could potentially forgot to override one of removeClient methods and it would lead to infinite loop, wouldn't it? If I understand it correctly I'd suggest to leave default implementation for removeClient(String id, RealmModel realm) and remove default from this one. Correct me if I am wrong please.", "author": "vramik", "createdAt": "2020-07-14T17:28:27Z", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    };\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param id Internal ID of the client\n+     * @param realm Realm.\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n+     */\n+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }\n \n-    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param realm Realm.\n+     * @param id Internal ID of the client\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     */\n+    default boolean removeClient(RealmModel realm, String id) { return this.removeClient(id, realm); }", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg0MTA5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454841092", "bodyText": "Yup, you're right, I'll remove that one", "author": "hmlnarik", "createdAt": "2020-07-15T07:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMjM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\nindex ada0c5c9bf..2df6c7197a 100644\n--- a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n\n@@ -46,7 +46,7 @@ public interface ClientProvider extends ClientLookupProvider, Provider {\n      */\n     default List<ClientModel> getClients(RealmModel realm) {\n         return this.getClients(realm, null, null);\n-    };\n+    }\n \n     /**\n      * Adds a client with given {@code clientId} to the given realm.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDI3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524279", "bodyText": "@author", "author": "vramik", "createdAt": "2020-07-14T17:31:23Z", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+/**\n+ * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java b/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\nindex c950453340..d6beb878bb 100644\n--- a/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\n+++ b/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\n\n@@ -21,9 +21,6 @@ import org.keycloak.provider.Provider;\n import org.keycloak.provider.ProviderFactory;\n import org.keycloak.provider.Spi;\n \n-/**\n- * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n- */\n public class ClientSpi implements Spi {\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDQ2OA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524468", "bodyText": "year?", "author": "vramik", "createdAt": "2020-07-14T17:31:44Z", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5OTYzNg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454999636", "bodyText": "May be fix in the next iteration if there would be any further.", "author": "hmlnarik", "createdAt": "2020-07-15T12:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java b/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\nindex c950453340..d6beb878bb 100644\n--- a/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\n+++ b/server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java\n\n@@ -21,9 +21,6 @@ import org.keycloak.provider.Provider;\n import org.keycloak.provider.ProviderFactory;\n import org.keycloak.provider.Spi;\n \n-/**\n- * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n- */\n public class ClientSpi implements Spi {\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDcwMA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524700", "bodyText": "year", "author": "vramik", "createdAt": "2020-07-14T17:32:09Z", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java b/server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java\nindex 45f855ba38..3117fd080c 100644\n--- a/server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java\n+++ b/server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n  * and other contributors as indicated by the @author tags.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzMjQ2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454532463", "bodyText": "Shouldn't we use equals instead of == on strings?", "author": "vramik", "createdAt": "2020-07-14T17:44:43Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0", "originalCommit": "427831cd54cffb6ab6bba6f14bbda511028401a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgyOTY0Mw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454829643", "bodyText": "This is object equality to cover also for nulls. For string contents comparison, compareTo is used (below).", "author": "hmlnarik", "createdAt": "2020-07-15T06:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzMjQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\nindex 3bd0593d3a..6a1c614de4 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n\n@@ -253,7 +253,7 @@ public class MapClientProvider implements ClientProvider {\n     }\n \n     @Override\n-    public ClientModel getClientById(String id, RealmModel realm) {\n+    public ClientModel getClientById(RealmModel realm, String id) {\n         if (id == null) {\n             return null;\n         }\n"}}, {"oid": "701f87dae6018abed97e6bc4f17c26a03e71ef05", "url": "https://github.com/keycloak/keycloak/commit/701f87dae6018abed97e6bc4f17c26a03e71ef05", "message": "fixup! KEYCLOAK-14549 Make ClientProvider independent of RealmProvider", "committedDate": "2020-07-15T11:44:11Z", "type": "forcePushed"}, {"oid": "fe525af797616e3634371e5579788f4ac1bd6f5b", "url": "https://github.com/keycloak/keycloak/commit/fe525af797616e3634371e5579788f4ac1bd6f5b", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-15T13:34:38Z", "type": "forcePushed"}, {"oid": "15a70c6ae3d596f216b2b39e01652daf3b3e236b", "url": "https://github.com/keycloak/keycloak/commit/15a70c6ae3d596f216b2b39e01652daf3b3e236b", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-15T13:35:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MjY2NA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r455562664", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);\n          \n          \n            \n                        updated = cacheSession.getClientDelegate().getClientById(cachedRealm, cached.getId());\n          \n      \n    \n    \n  \n\nWe should use new non-deprecated method instead.\nNewly depricated ClientLookupProvider.getClientById(String, RealmModel), ClientLookupProvider.getClientByClientId(String, RealmModel) and ClientLookupProvider.searchClientsByClientId(String, Integer, Integer, RealmModel) are used in several places in codebase including testsuite.", "author": "vramik", "createdAt": "2020-07-16T07:21:04Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java", "diffHunk": "@@ -53,7 +53,7 @@ public ClientAdapter(RealmModel cachedRealm, CachedClient cached, RealmCacheSess\n     private void getDelegateForUpdate() {\n         if (updated == null) {\n             cacheSession.registerClientInvalidation(cached.getId(), cached.getClientId(), cachedRealm.getId());\n-            updated = cacheSession.getRealmDelegate().getClientById(cached.getId(), cachedRealm);\n+            updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);", "originalCommit": "15a70c6ae3d596f216b2b39e01652daf3b3e236b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "05894a46f62f04960bb89e0d76ceb46948926726", "chunk": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java\nindex 24cc876d14..0b2ab44aee 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java\n\n@@ -53,7 +53,7 @@ public class ClientAdapter implements ClientModel, CachedObject {\n     private void getDelegateForUpdate() {\n         if (updated == null) {\n             cacheSession.registerClientInvalidation(cached.getId(), cached.getClientId(), cachedRealm.getId());\n-            updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);\n+            updated = cacheSession.getClientDelegate().getClientById(cachedRealm, cached.getId());\n             if (updated == null) throw new IllegalStateException(\"Not found in database\");\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2NDI4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r455564281", "bodyText": "dtto, this deprecated method is still used in the codebase", "author": "vramik", "createdAt": "2020-07-16T07:24:17Z", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,92 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    }\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    /**\n+     * Returns a list of clients that are expected to always show up in account console.\n+     * @param realm Realm owning the clients.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param id Internal ID of the client\n+     * @param realm Realm.\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n+     */\n+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }", "originalCommit": "15a70c6ae3d596f216b2b39e01652daf3b3e236b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\nindex 2df6c7197a..2d5f7f82c3 100644\n--- a/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/models/ClientProvider.java\n\n@@ -20,92 +20,30 @@ import org.keycloak.provider.Provider;\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n+import java.util.Set;\n \n /**\n- * Provider of the client records.\n- *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n-\n-    /**\n-     * Returns the clients of the given realm.\n-     * @param realm Realm.\n-     * @param firstResult First result to return. Ignored if negative or {@code null}.\n-     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n-     * @return List of the clients. Never returns {@code null}.\n-     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    /**\n-     * Returns all the clients of the given realm.\n-     * Effectively the same as the call {@code getClients(realm, null, null)}.\n-     * @param realm Realm.\n-     * @return List of the clients. Never returns {@code null}.\n-     */\n-    default List<ClientModel> getClients(RealmModel realm) {\n-        return this.getClients(realm, null, null);\n-    }\n+    List<ClientModel> getClients(RealmModel realm);\n \n-    /**\n-     * Adds a client with given {@code clientId} to the given realm.\n-     * The internal ID of the client will be created automatically.\n-     * @param realm Realm owning this client.\n-     * @param clientId String that identifies the client to the external parties.\n-     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n-     * @return Model of the created client.\n-     */\n-    default ClientModel addClient(RealmModel realm, String clientId) {\n-        return addClient(realm, null, clientId);\n-    }\n+    ClientModel addClient(RealmModel realm, String clientId);\n \n-    /**\n-     * Adds a client with given internal ID and {@code clientId} to the given realm.\n-     * @param realm Realm owning this client.\n-     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n-     * @param clientId String that identifies the client to the external parties.\n-     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n-     * @return Model of the created client.\n-     * @throws IllegalArgumentException If {@code id} does not conform\n-     *   the format understood by the underlying store.\n-     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    /**\n-     * Returns number of clients in the given realm\n-     * @param realm Realm.\n-     * @return Number of the clients in the given realm.\n-     */\n-    long getClientsCount(RealmModel realm);\n+    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n \n-    /**\n-     * Returns a list of clients that are expected to always show up in account console.\n-     * @param realm Realm owning the clients.\n-     * @return List of the clients. Never returns {@code null}.\n-     */\n-    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n+    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n \n-    /**\n-     * Removes given client from the given realm.\n-     * @param id Internal ID of the client\n-     * @param realm Realm.\n-     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n-     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n-     */\n-    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }\n+    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n \n-    /**\n-     * Removes given client from the given realm.\n-     * @param realm Realm.\n-     * @param id Internal ID of the client\n-     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n-     */\n-    boolean removeClient(RealmModel realm, String id);\n+    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    /**\n-     * Removes all clients from the given realm.\n-     * @param realm Realm.\n-     */\n-    void removeClients(RealmModel realm);\n+    boolean removeClient(String id, RealmModel realm);\n }\n"}}, {"oid": "05894a46f62f04960bb89e0d76ceb46948926726", "url": "https://github.com/keycloak/keycloak/commit/05894a46f62f04960bb89e0d76ceb46948926726", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-16T09:16:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDc5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456374796", "bodyText": "This one is actually not deprecated, right?", "author": "vramik", "createdAt": "2020-07-17T11:04:20Z", "path": "server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java", "diffHunk": "@@ -28,7 +28,66 @@\n  * @version $Revision: 1 $\n  */\n public interface ClientLookupProvider {\n-    ClientModel getClientById(String id, RealmModel realm);\n-    ClientModel getClientByClientId(String clientId, RealmModel realm);\n-    List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm);\n+    \n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientById(RealmModel realm, String id);\n+\n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientById(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientById(String id, RealmModel realm) { return getClientById(realm, id); }\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientByClientId(RealmModel realm, String clientId);\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientByClientId(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientByClientId(String clientId, RealmModel realm) { return getClientByClientId(realm, clientId); }\n+\n+    /**\n+     * Case-insensitive search for clients that contain the given string in their public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId Searched substring of the public client\n+     *   identifier ({@code client_id} in OIDC or {@code entityID} in SAML.)\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #searchClientsByClientId} instead.", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3ODQ3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456378472", "bodyText": "Indeed, thanks for spotting this!", "author": "hmlnarik", "createdAt": "2020-07-17T11:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f8873bdeb6f02c19ef5aa10d16ae4b8bf72a7c34", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java b/server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java\nindex b0c8513e0c..d9e09c296d 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java\n\n@@ -73,7 +73,6 @@ public interface ClientLookupProvider {\n      * @param firstResult First result to return. Ignored if negative or {@code null}.\n      * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n      * @return Model of the client, or {@code null} if no client is found.\n-     * @deprecated Use {@link #searchClientsByClientId} instead.\n      */\n     List<ClientModel> searchClientsByClientId(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456404512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ClientModel client = getClientById(realm, id);\n          \n          \n            \n                    final ClientModel client = session.clients().getClientById(realm, id);", "author": "mhajas", "createdAt": "2020-07-17T12:16:32Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -688,12 +686,26 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {\n         query.setParameter(\"realm\", realm.getId());\n         List<String> results = query.getResultList();\n         if (results.isEmpty()) return Collections.EMPTY_LIST;\n-        return results.stream().map(id -> session.realms().getClientById(id, realm)).collect(Collectors.toList());\n+        return results.stream().map(id -> session.clients().getClientById(realm, id)).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        TypedQuery<String> query = em.createNamedQuery(\"getClientIdsByRealm\", String.class);\n+        query.setParameter(\"realm\", realm.getId());\n+        List<String> clients = query.getResultList();\n+        for (String client : clients) {\n+            // No need to go through cache. Clients were already invalidated\n+            removeClient(realm, client);\n+        }\n     }\n \n     @Override\n-    public boolean removeClient(String id, RealmModel realm) {\n-        final ClientModel client = getClientById(id, realm);\n+    public boolean removeClient(RealmModel realm, String id) {\n+\n+        logger.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        final ClientModel client = getClientById(realm, id);", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxMTgwOA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456511808", "bodyText": "This client needs to be in this particular provider, so it needs to be getClientById only", "author": "hmlnarik", "createdAt": "2020-07-17T15:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTIxMw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456529213", "bodyText": "Yeah, we discussed it already, not sure why github included this comment. When I submitted the review, there were only 4 comments.", "author": "mhajas", "createdAt": "2020-07-17T15:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java\nindex cfa621dc90..b05f8ea043 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java\n\n@@ -686,26 +687,12 @@ public class JpaRealmProvider implements RealmProvider, ClientProvider {\n         query.setParameter(\"realm\", realm.getId());\n         List<String> results = query.getResultList();\n         if (results.isEmpty()) return Collections.EMPTY_LIST;\n-        return results.stream().map(id -> session.clients().getClientById(realm, id)).collect(Collectors.toList());\n+        return results.stream().map(id -> session.realms().getClientById(id, realm)).collect(Collectors.toList());\n     }\n \n     @Override\n-    public void removeClients(RealmModel realm) {\n-        TypedQuery<String> query = em.createNamedQuery(\"getClientIdsByRealm\", String.class);\n-        query.setParameter(\"realm\", realm.getId());\n-        List<String> clients = query.getResultList();\n-        for (String client : clients) {\n-            // No need to go through cache. Clients were already invalidated\n-            removeClient(realm, client);\n-        }\n-    }\n-\n-    @Override\n-    public boolean removeClient(RealmModel realm, String id) {\n-\n-        logger.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n-\n-        final ClientModel client = getClientById(realm, id);\n+    public boolean removeClient(String id, RealmModel realm) {\n+        final ClientModel client = getClientById(id, realm);\n         if (client == null) return false;\n \n         session.users().preRemove(realm, client);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1ODQwMQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456458401", "bodyText": "If a user doesn't provide any of these two methods, it will end up with the infinite loop. Should we remove one of these defaults, to avoid this?", "author": "mhajas", "createdAt": "2020-07-17T13:56:02Z", "path": "server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java", "diffHunk": "@@ -18,21 +18,35 @@\n package org.keycloak.models;\n \n import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ScopeContainerModel {\n \n-    Set<RoleModel> getScopeMappings();\n+    @Deprecated\n+    default Set<RoleModel> getScopeMappings() {\n+        return getScopeMappingsStream().collect(Collectors.toSet());\n+    }\n+\n+    default Stream<RoleModel> getScopeMappingsStream() {", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNzY4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456517685", "bodyText": "This is a good point and omission on my end. Thanks!", "author": "hmlnarik", "createdAt": "2020-07-17T15:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1ODQwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f8873bdeb6f02c19ef5aa10d16ae4b8bf72a7c34", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java b/server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java\nindex 907ffe6393..c3327a7d84 100755\n--- a/server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java\n+++ b/server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java\n\n@@ -32,9 +32,7 @@ public interface ScopeContainerModel {\n         return getScopeMappingsStream().collect(Collectors.toSet());\n     }\n \n-    default Stream<RoleModel> getScopeMappingsStream() {\n-        return getScopeMappings().stream();\n-    };\n+    Stream<RoleModel> getScopeMappingsStream();\n \n     /**\n      * From the scope mappings returned by {@link #getScopeMappings()} returns only those\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456482530", "bodyText": "can cache contain updated client, for example, with different roles? If yes, we should use session.clients() here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ClientModel client = getClientById(realm, id);\n          \n          \n            \n                    final ClientModel client = session.clients().getClientById(realm, id);", "author": "mhajas", "createdAt": "2020-07-17T14:35:54Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n+        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n+\n+        return resource;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n+        return getClientsStream(realm)\n+                .filter(ClientModel::isAlwaysDisplayInConsole)\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n+\n+        getClientsStream(realm)\n+          .map(ClientModel::getId)\n+          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n+          .forEach(cid -> removeClient(realm, cid));\n+    }\n+\n+    @Override\n+    public boolean removeClient(RealmModel realm, String id) {\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        // TODO: Sending an event (and client role removal) should be extracted to store layer\n+        final ClientModel client = getClientById(realm, id);", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjk5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456516995", "bodyText": "For client removal it is very unlikely. Furthermore, role deletion will soon be treated in a separate store.", "author": "hmlnarik", "createdAt": "2020-07-17T15:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyODY0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456528642", "bodyText": "ok", "author": "mhajas", "createdAt": "2020-07-17T15:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\ndeleted file mode 100644\nindex b3dbef6b67..0000000000\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n+++ /dev/null\n\n@@ -1,316 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates\n- * and other contributors as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.keycloak.models.map.client;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.models.ClientModel;\n-import org.keycloak.models.ClientProvider;\n-import org.keycloak.models.KeycloakSession;\n-import org.keycloak.models.ModelDuplicateException;\n-import org.keycloak.models.RealmModel;\n-\n-import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n-import org.keycloak.models.RealmProvider;\n-import org.keycloak.models.RoleModel;\n-import org.keycloak.models.map.storage.MapKeycloakTransaction;\n-import org.keycloak.models.map.common.Serialization;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.UUID;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import org.keycloak.models.map.storage.MapStorage;\n-import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n-\n-public class MapClientProvider implements ClientProvider {\n-\n-    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n-    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n-    private final KeycloakSession session;\n-    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n-    private final MapStorage<UUID, MapClientEntity> clientStore;\n-    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n-\n-    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n-        @Override\n-        public int compare(MapClientEntity o1, MapClientEntity o2) {\n-            String c1 = o1 == null ? null : o1.getClientId();\n-            String c2 = o2 == null ? null : o2.getClientId();\n-            return c1 == c2 ? 0\n-              : c1 == null ? -1\n-              : c2 == null ? 1\n-              : c1.compareTo(c2);\n-\n-        }\n-    };\n-\n-    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n-        this.session = session;\n-        this.clientStore = clientStore;\n-        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n-        this.tx = new MapKeycloakTransaction<>(clientStore);\n-        session.getTransactionManager().enlistAfterCompletion(tx);\n-    }\n-\n-    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n-        return new RealmModel.ClientUpdatedEvent() {\n-            @Override\n-            public ClientModel getUpdatedClient() {\n-                return c;\n-            }\n-\n-            @Override\n-            public KeycloakSession getKeycloakSession() {\n-                return session;\n-            }\n-        };\n-    }\n-\n-    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n-        final MapClientEntity res = Serialization.from(origEntity);\n-        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n-        return res;\n-    }\n-\n-    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n-        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n-\n-        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n-            @Override\n-            public void updateClient() {\n-                // commit\n-                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n-                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n-            }\n-\n-            /** This is runtime information and should have never been part of the adapter */\n-            @Override\n-            public Map<String, Integer> getRegisteredNodes() {\n-                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n-            }\n-\n-            @Override\n-            public void registerNode(String nodeHost, int registrationTime) {\n-                Map<String, Integer> value = getRegisteredNodes();\n-                value.put(nodeHost, registrationTime);\n-            }\n-\n-            @Override\n-            public void unregisterNode(String nodeHost) {\n-                getRegisteredNodes().remove(nodeHost);\n-            }\n-\n-        };\n-    }\n-\n-    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n-        if (realm == null || realm.getId() == null) {\n-            return MapClientProvider.ALWAYS_FALSE;\n-        }\n-        String realmId = realm.getId();\n-        return entity -> Objects.equals(realmId, entity.getRealmId());\n-    }\n-\n-    @Override\n-    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n-        Stream<ClientModel> s = getClientsStream(realm);\n-        if (firstResult >= 0) {\n-            s = s.skip(firstResult);\n-        }\n-        if (maxResults >= 0) {\n-            s = s.limit(maxResults);\n-        }\n-        return s.collect(Collectors.toList());\n-    }\n-\n-    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n-        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n-          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n-          .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n-    }\n-\n-//    @Override\n-    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n-        return getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .sorted(COMPARE_BY_CLIENT_ID)\n-          .map(entityToAdapterFunc(realm))\n-        ;\n-    }\n-\n-    @Override\n-    public List<ClientModel> getClients(RealmModel realm) {\n-        return getClientsStream(realm).collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n-        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n-\n-        if (clientId == null) {\n-            clientId = entityId.toString();\n-        }\n-\n-        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n-\n-        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n-        entity.setClientId(clientId);\n-        entity.setEnabled(true);\n-        entity.setStandardFlowEnabled(true);\n-        if (tx.get(entity.getId(), clientStore::get) != null) {\n-            throw new ModelDuplicateException(\"Client exists: \" + id);\n-        }\n-        tx.putIfAbsent(entity.getId(), entity);\n-        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n-\n-        // TODO: Sending an event should be extracted to store layer\n-        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n-        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n-\n-        return resource;\n-    }\n-\n-    @Override\n-    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n-        return getClientsStream(realm)\n-                .filter(ClientModel::isAlwaysDisplayInConsole)\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public void removeClients(RealmModel realm) {\n-        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n-\n-        getClientsStream(realm)\n-          .map(ClientModel::getId)\n-          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n-          .forEach(cid -> removeClient(realm, cid));\n-    }\n-\n-    @Override\n-    public boolean removeClient(RealmModel realm, String id) {\n-        if (id == null) {\n-            return false;\n-        }\n-\n-        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n-\n-        // TODO: Sending an event (and client role removal) should be extracted to store layer\n-        final ClientModel client = getClientById(realm, id);\n-        if (client == null) return false;\n-        session.users().preRemove(realm, client);\n-        final RealmProvider realms = session.realms();\n-        for (RoleModel role : client.getRoles()) {\n-            realms.removeRole(realm, role);\n-        }\n-\n-        session.getKeycloakSessionFactory().publish(new RealmModel.ClientRemovedEvent() {\n-            @Override\n-            public ClientModel getClient() {\n-                return client;\n-            }\n-\n-            @Override\n-            public KeycloakSession getKeycloakSession() {\n-                return session;\n-            }\n-        });\n-        // TODO: ^^^^^^^ Up to here\n-\n-        tx.remove(UUID.fromString(id));\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public long getClientsCount(RealmModel realm) {\n-        return this.getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .count();\n-    }\n-\n-    @Override\n-    public ClientModel getClientById(RealmModel realm, String id) {\n-        if (id == null) {\n-            return null;\n-        }\n-\n-        LOG.tracef(\"getClientById(%s, %s)%s\", realm, id, getShortStackTrace());\n-\n-        MapClientEntity entity = tx.get(UUID.fromString(id), clientStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n-          ? null\n-          : entityToAdapterFunc(realm).apply(entity);\n-    }\n-\n-    @Override\n-    public ClientModel getClientByClientId(RealmModel realm, String clientId) {\n-        if (clientId == null) {\n-            return null;\n-        }\n-        LOG.tracef(\"getClientByClientId(%s, %s)%s\", realm, clientId, getShortStackTrace());\n-\n-        String clientIdLower = clientId.toLowerCase();\n-\n-        return getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .filter(entity -> entity.getClientId() != null && Objects.equals(entity.getClientId().toLowerCase(), clientIdLower))\n-          .map(entityToAdapterFunc(realm))\n-          .findFirst()\n-          .orElse(null)\n-        ;\n-    }\n-\n-    @Override\n-    public List<ClientModel> searchClientsByClientId(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {\n-        if (clientId == null) {\n-            return Collections.EMPTY_LIST;\n-        }\n-        String clientIdLower = clientId.toLowerCase();\n-        Stream<MapClientEntity> s = getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .filter(entity -> entity.getClientId() != null && entity.getClientId().toLowerCase().contains(clientIdLower))\n-          .sorted(COMPARE_BY_CLIENT_ID);\n-\n-        if (firstResult >= 0) {\n-            s = s.skip(firstResult);\n-        }\n-        if (maxResults >= 0) {\n-            s = s.limit(maxResults);\n-        }\n-\n-        return s\n-          .map(entityToAdapterFunc(realm))\n-          .collect(Collectors.toList())\n-        ;\n-    }\n-\n-    @Override\n-    public void close() {\n-        \n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456500544", "bodyText": "This function is used, for example, to find out whether a client exists. What if there is a client with desired id in the store, and within this session, it was updated with some MapTask without value. This function will return null and the code will think the client doesn't exist. Should there be defaultValueFunc call on this line?", "author": "mhajas", "createdAt": "2020-07-17T15:04:44Z", "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTask<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTask<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTask<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists\n+     * @throws IllegalStateException\n+     */\n+    private void addTask(MapOperation op, K key, V value) throws IllegalStateException {\n+        log.tracev(\"Adding operation {0} for {1}\", op, key);\n+\n+        K taskKey = key;\n+        tasks.merge(taskKey, op.taskFor(key, value), MapTaskCompose::new);\n+    }\n+\n+    // This is for possibility to lookup for session by id, which was created in this transaction\n+    public V get(K key, Function<K, V> defaultValueFunc) {\n+        MapTask current = tasks.get(key);\n+        if (current != null) {\n+            if (current instanceof MapTaskWithValue) {\n+                return ((MapTaskWithValue<K, V>) current).getValue();\n+            }\n+            return null;", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxOTYzMA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456519630", "bodyText": "Actually, there is currently no MapTask, all instances are MapTaskWithValues, so this will never happen. Perhaps the code is worth simplifying.", "author": "hmlnarik", "createdAt": "2020-07-17T15:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNzIzNg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456527236", "bodyText": "I agree, currently, it should not happen, but in future, somebody can add such a task. Anyway, it can stay as it is, I don't have any strong reason to change it, I just wanted to point it out.", "author": "mhajas", "createdAt": "2020-07-17T15:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "f8873bdeb6f02c19ef5aa10d16ae4b8bf72a7c34", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java b/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\nindex 5fff07cf80..f1cd2dd403 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\n\n@@ -34,7 +34,7 @@ public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n     private enum MapOperation {\n         PUT {\n             @Override\n-            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n                 return new MapTaskWithValue<K, V>(value) {\n                     @Override\n                     public void execute(MapStorage<K, V> map) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456501715", "bodyText": "Why putIfAbsent()? We checked there is no client with the same id.", "author": "mhajas", "createdAt": "2020-07-17T15:06:38Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "originalCommit": "05894a46f62f04960bb89e0d76ceb46948926726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjA0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456516047", "bodyText": "Because this needs to be done in a transaction.", "author": "hmlnarik", "createdAt": "2020-07-17T15:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNDUxNA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456524514", "bodyText": "MapKeycloakTransaction supports also put()", "author": "mhajas", "createdAt": "2020-07-17T15:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU1ODM3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456558373", "bodyText": "Yup, but the transaction is only committed after the request is almost processed. The get above provides a preliminary check during processing the request - a fail-fast functionality. If a concurrent transaction (e.g. concurrent request) adds the same client, this transaction should not force replacing the client.", "author": "hmlnarik", "createdAt": "2020-07-17T16:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjUzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456572535", "bodyText": "Ok I see, thanks", "author": "mhajas", "createdAt": "2020-07-17T17:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\ndeleted file mode 100644\nindex b3dbef6b67..0000000000\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n+++ /dev/null\n\n@@ -1,316 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates\n- * and other contributors as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.keycloak.models.map.client;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.models.ClientModel;\n-import org.keycloak.models.ClientProvider;\n-import org.keycloak.models.KeycloakSession;\n-import org.keycloak.models.ModelDuplicateException;\n-import org.keycloak.models.RealmModel;\n-\n-import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n-import org.keycloak.models.RealmProvider;\n-import org.keycloak.models.RoleModel;\n-import org.keycloak.models.map.storage.MapKeycloakTransaction;\n-import org.keycloak.models.map.common.Serialization;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.UUID;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import org.keycloak.models.map.storage.MapStorage;\n-import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n-\n-public class MapClientProvider implements ClientProvider {\n-\n-    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n-    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n-    private final KeycloakSession session;\n-    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n-    private final MapStorage<UUID, MapClientEntity> clientStore;\n-    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n-\n-    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n-        @Override\n-        public int compare(MapClientEntity o1, MapClientEntity o2) {\n-            String c1 = o1 == null ? null : o1.getClientId();\n-            String c2 = o2 == null ? null : o2.getClientId();\n-            return c1 == c2 ? 0\n-              : c1 == null ? -1\n-              : c2 == null ? 1\n-              : c1.compareTo(c2);\n-\n-        }\n-    };\n-\n-    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n-        this.session = session;\n-        this.clientStore = clientStore;\n-        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n-        this.tx = new MapKeycloakTransaction<>(clientStore);\n-        session.getTransactionManager().enlistAfterCompletion(tx);\n-    }\n-\n-    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n-        return new RealmModel.ClientUpdatedEvent() {\n-            @Override\n-            public ClientModel getUpdatedClient() {\n-                return c;\n-            }\n-\n-            @Override\n-            public KeycloakSession getKeycloakSession() {\n-                return session;\n-            }\n-        };\n-    }\n-\n-    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n-        final MapClientEntity res = Serialization.from(origEntity);\n-        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n-        return res;\n-    }\n-\n-    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n-        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n-\n-        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n-            @Override\n-            public void updateClient() {\n-                // commit\n-                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n-                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n-            }\n-\n-            /** This is runtime information and should have never been part of the adapter */\n-            @Override\n-            public Map<String, Integer> getRegisteredNodes() {\n-                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n-            }\n-\n-            @Override\n-            public void registerNode(String nodeHost, int registrationTime) {\n-                Map<String, Integer> value = getRegisteredNodes();\n-                value.put(nodeHost, registrationTime);\n-            }\n-\n-            @Override\n-            public void unregisterNode(String nodeHost) {\n-                getRegisteredNodes().remove(nodeHost);\n-            }\n-\n-        };\n-    }\n-\n-    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n-        if (realm == null || realm.getId() == null) {\n-            return MapClientProvider.ALWAYS_FALSE;\n-        }\n-        String realmId = realm.getId();\n-        return entity -> Objects.equals(realmId, entity.getRealmId());\n-    }\n-\n-    @Override\n-    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n-        Stream<ClientModel> s = getClientsStream(realm);\n-        if (firstResult >= 0) {\n-            s = s.skip(firstResult);\n-        }\n-        if (maxResults >= 0) {\n-            s = s.limit(maxResults);\n-        }\n-        return s.collect(Collectors.toList());\n-    }\n-\n-    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n-        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n-          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n-          .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n-    }\n-\n-//    @Override\n-    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n-        return getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .sorted(COMPARE_BY_CLIENT_ID)\n-          .map(entityToAdapterFunc(realm))\n-        ;\n-    }\n-\n-    @Override\n-    public List<ClientModel> getClients(RealmModel realm) {\n-        return getClientsStream(realm).collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n-        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n-\n-        if (clientId == null) {\n-            clientId = entityId.toString();\n-        }\n-\n-        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n-\n-        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n-        entity.setClientId(clientId);\n-        entity.setEnabled(true);\n-        entity.setStandardFlowEnabled(true);\n-        if (tx.get(entity.getId(), clientStore::get) != null) {\n-            throw new ModelDuplicateException(\"Client exists: \" + id);\n-        }\n-        tx.putIfAbsent(entity.getId(), entity);\n-        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n-\n-        // TODO: Sending an event should be extracted to store layer\n-        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n-        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n-\n-        return resource;\n-    }\n-\n-    @Override\n-    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n-        return getClientsStream(realm)\n-                .filter(ClientModel::isAlwaysDisplayInConsole)\n-                .collect(Collectors.toList());\n-    }\n-\n-    @Override\n-    public void removeClients(RealmModel realm) {\n-        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n-\n-        getClientsStream(realm)\n-          .map(ClientModel::getId)\n-          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n-          .forEach(cid -> removeClient(realm, cid));\n-    }\n-\n-    @Override\n-    public boolean removeClient(RealmModel realm, String id) {\n-        if (id == null) {\n-            return false;\n-        }\n-\n-        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n-\n-        // TODO: Sending an event (and client role removal) should be extracted to store layer\n-        final ClientModel client = getClientById(realm, id);\n-        if (client == null) return false;\n-        session.users().preRemove(realm, client);\n-        final RealmProvider realms = session.realms();\n-        for (RoleModel role : client.getRoles()) {\n-            realms.removeRole(realm, role);\n-        }\n-\n-        session.getKeycloakSessionFactory().publish(new RealmModel.ClientRemovedEvent() {\n-            @Override\n-            public ClientModel getClient() {\n-                return client;\n-            }\n-\n-            @Override\n-            public KeycloakSession getKeycloakSession() {\n-                return session;\n-            }\n-        });\n-        // TODO: ^^^^^^^ Up to here\n-\n-        tx.remove(UUID.fromString(id));\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public long getClientsCount(RealmModel realm) {\n-        return this.getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .count();\n-    }\n-\n-    @Override\n-    public ClientModel getClientById(RealmModel realm, String id) {\n-        if (id == null) {\n-            return null;\n-        }\n-\n-        LOG.tracef(\"getClientById(%s, %s)%s\", realm, id, getShortStackTrace());\n-\n-        MapClientEntity entity = tx.get(UUID.fromString(id), clientStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n-          ? null\n-          : entityToAdapterFunc(realm).apply(entity);\n-    }\n-\n-    @Override\n-    public ClientModel getClientByClientId(RealmModel realm, String clientId) {\n-        if (clientId == null) {\n-            return null;\n-        }\n-        LOG.tracef(\"getClientByClientId(%s, %s)%s\", realm, clientId, getShortStackTrace());\n-\n-        String clientIdLower = clientId.toLowerCase();\n-\n-        return getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .filter(entity -> entity.getClientId() != null && Objects.equals(entity.getClientId().toLowerCase(), clientIdLower))\n-          .map(entityToAdapterFunc(realm))\n-          .findFirst()\n-          .orElse(null)\n-        ;\n-    }\n-\n-    @Override\n-    public List<ClientModel> searchClientsByClientId(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {\n-        if (clientId == null) {\n-            return Collections.EMPTY_LIST;\n-        }\n-        String clientIdLower = clientId.toLowerCase();\n-        Stream<MapClientEntity> s = getNotRemovedUpdatedClientsStream()\n-          .filter(entityRealmFilter(realm))\n-          .filter(entity -> entity.getClientId() != null && entity.getClientId().toLowerCase().contains(clientIdLower))\n-          .sorted(COMPARE_BY_CLIENT_ID);\n-\n-        if (firstResult >= 0) {\n-            s = s.skip(firstResult);\n-        }\n-        if (maxResults >= 0) {\n-            s = s.limit(maxResults);\n-        }\n-\n-        return s\n-          .map(entityToAdapterFunc(realm))\n-          .collect(Collectors.toList())\n-        ;\n-    }\n-\n-    @Override\n-    public void close() {\n-        \n-    }\n-\n-}\n"}}, {"oid": "f8873bdeb6f02c19ef5aa10d16ae4b8bf72a7c34", "url": "https://github.com/keycloak/keycloak/commit/f8873bdeb6f02c19ef5aa10d16ae4b8bf72a7c34", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-17T19:22:08Z", "type": "forcePushed"}, {"oid": "50c2533b5027352ede369cfa1cc84fae0c839552", "url": "https://github.com/keycloak/keycloak/commit/50c2533b5027352ede369cfa1cc84fae0c839552", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-19T19:48:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDk0OA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456994948", "bodyText": "Shouldn't the 2 lines above be swapped?", "author": "sguilhen", "createdAt": "2020-07-20T02:21:31Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {\n+        this.id = null;\n+        this.realmId = null;\n+    }\n+\n+    public AbstractClientEntity(K id, String realmId) {\n+        Objects.requireNonNull(id, \"id\");\n+        Objects.requireNonNull(realmId, \"realmId\");\n+\n+        this.id = id;\n+        this.realmId = realmId;\n+    }\n+\n+    @Override\n+    public K getId() {\n+        return this.id;\n+    }\n+\n+    @Override\n+    public boolean isUpdated() {\n+        return this.updated;\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.updated |= ! Objects.equals(this.clientId, clientId);\n+        this.clientId = clientId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.updated |= ! Objects.equals(this.name, name);\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.updated |= ! Objects.equals(this.description, description);\n+        this.description = description;\n+    }\n+\n+    public Set<String> getRedirectUris() {\n+        return redirectUris;\n+    }\n+\n+    public void setRedirectUris(Set<String> redirectUris) {\n+        this.updated |= ! Objects.equals(this.redirectUris, redirectUris);\n+        this.redirectUris = redirectUris;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.updated |= ! Objects.equals(this.enabled, enabled);\n+        this.enabled = enabled;\n+    }\n+\n+    public boolean isAlwaysDisplayInConsole() {\n+        return alwaysDisplayInConsole;\n+    }\n+\n+    public void setAlwaysDisplayInConsole(boolean alwaysDisplayInConsole) {\n+        this.updated |= ! Objects.equals(this.alwaysDisplayInConsole, alwaysDisplayInConsole);\n+        this.alwaysDisplayInConsole = alwaysDisplayInConsole;\n+    }\n+\n+    public String getClientAuthenticatorType() {\n+        return clientAuthenticatorType;\n+    }\n+\n+    public void setClientAuthenticatorType(String clientAuthenticatorType) {\n+        this.updated |= ! Objects.equals(this.clientAuthenticatorType, clientAuthenticatorType);\n+        this.clientAuthenticatorType = clientAuthenticatorType;\n+    }\n+\n+    public String getSecret() {\n+        return secret;\n+    }\n+\n+    public void setSecret(String secret) {\n+        this.updated |= ! Objects.equals(this.secret, secret);\n+        this.secret = secret;\n+    }\n+\n+    public String getRegistrationToken() {\n+        return registrationToken;\n+    }\n+\n+    public void setRegistrationToken(String registrationToken) {\n+        this.updated |= ! Objects.equals(this.registrationToken, registrationToken);\n+        this.registrationToken = registrationToken;\n+    }\n+\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    public void setProtocol(String protocol) {\n+        this.updated |= ! Objects.equals(this.protocol, protocol);\n+        this.protocol = protocol;\n+    }\n+\n+    public Map<String, String> getAttributes() {\n+        return attributes;\n+    }\n+\n+    public void setAttributes(Map<String, String> attributes) {\n+        this.updated |= ! Objects.equals(this.attributes, attributes);\n+        this.attributes = attributes;\n+    }\n+\n+    public Map<String, String> getAuthFlowBindings() {\n+        return authFlowBindings;\n+    }\n+\n+    public void setAuthFlowBindings(Map<String, String> authFlowBindings) {\n+        this.updated |= ! Objects.equals(this.authFlowBindings, authFlowBindings);\n+        this.authFlowBindings = authFlowBindings;\n+    }\n+\n+    public boolean isPublicClient() {\n+        return publicClient;\n+    }\n+\n+    public void setPublicClient(boolean publicClient) {\n+        this.updated |= ! Objects.equals(this.publicClient, publicClient);\n+        this.publicClient = publicClient;\n+    }\n+\n+    public boolean isFullScopeAllowed() {\n+        return fullScopeAllowed;\n+    }\n+\n+    public void setFullScopeAllowed(boolean fullScopeAllowed) {\n+        this.updated |= ! Objects.equals(this.fullScopeAllowed, fullScopeAllowed);\n+        this.fullScopeAllowed = fullScopeAllowed;\n+    }\n+\n+    public boolean isFrontchannelLogout() {\n+        return frontchannelLogout;\n+    }\n+\n+    public void setFrontchannelLogout(boolean frontchannelLogout) {\n+        this.updated |= ! Objects.equals(this.frontchannelLogout, frontchannelLogout);\n+        this.frontchannelLogout = frontchannelLogout;\n+    }\n+\n+    public int getNotBefore() {\n+        return notBefore;\n+    }\n+\n+    public void setNotBefore(int notBefore) {\n+        this.updated |= ! Objects.equals(this.notBefore, notBefore);\n+        this.notBefore = notBefore;\n+    }\n+\n+    public Set<String> getScope() {\n+        return scope;\n+    }\n+\n+    public void setScope(Set<String> scope) {\n+        this.updated |= ! Objects.equals(this.scope, scope);\n+        this.scope.clear();\n+        this.scope.addAll(scope);\n+    }\n+\n+    public Set<String> getWebOrigins() {\n+        return webOrigins;\n+    }\n+\n+    public void setWebOrigins(Set<String> webOrigins) {\n+        this.updated |= ! Objects.equals(this.webOrigins, webOrigins);\n+        this.webOrigins.clear();\n+        this.webOrigins.addAll(webOrigins);\n+    }\n+\n+    public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n+        updated = true;\n+        Objects.requireNonNull(model.getId(), \"protocolMapper.id\");", "originalCommit": "405a9cc8739377e11be40306ffb9f8341742ba8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MTkyOA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457071928", "bodyText": "Yup, thanks for spotting this!", "author": "hmlnarik", "createdAt": "2020-07-20T05:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "4f69556e084053f12500968b7d3f65b0ac309d74", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java b/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java\nindex 360f4ecaa6..5f43d6face 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java\n\n@@ -268,8 +268,8 @@ public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n     }\n \n     public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n-        updated = true;\n         Objects.requireNonNull(model.getId(), \"protocolMapper.id\");\n+        updated = true;\n         this.protocolMappers.put(model.getId(), model);\n         return model;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NTE5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456995196", "bodyText": "Minor: wrong year", "author": "sguilhen", "createdAt": "2020-07-20T02:22:48Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "originalCommit": "405a9cc8739377e11be40306ffb9f8341742ba8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f69556e084053f12500968b7d3f65b0ac309d74", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\nindex c001553bd8..b3dbef6b67 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n  * and other contributors as indicated by the @author tags.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NTIzNg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456995236", "bodyText": "Wrong author", "author": "sguilhen", "createdAt": "2020-07-20T02:22:58Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+/**\n+ * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n+ * @version $Revision: 1 $", "originalCommit": "405a9cc8739377e11be40306ffb9f8341742ba8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f69556e084053f12500968b7d3f65b0ac309d74", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\nindex c001553bd8..b3dbef6b67 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n  * and other contributors as indicated by the @author tags.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5OTA2OA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456999068", "bodyText": "Method doesn't return any value", "author": "sguilhen", "createdAt": "2020-07-20T02:40:15Z", "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTaskWithValue<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTaskWithValue<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTaskWithValue<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists", "originalCommit": "5b51c8c093982984e11bea86a7d7c45ddcd9701a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3Mjg2NA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457072864", "bodyText": "That's true :-) Fixed, thanks!", "author": "hmlnarik", "createdAt": "2020-07-20T05:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5OTA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "4f69556e084053f12500968b7d3f65b0ac309d74", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java b/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\nindex f1cd2dd403..c94f836149 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java\n\n@@ -129,10 +129,8 @@ public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n \n     /**\n      * Adds a given task if not exists for the given key\n-     * @return {@code true} if a task for the given key already exists\n-     * @throws IllegalStateException\n      */\n-    private void addTask(MapOperation op, K key, V value) throws IllegalStateException {\n+    private void addTask(MapOperation op, K key, V value) {\n         log.tracev(\"Adding operation {0} for {1}\", op, key);\n \n         K taskKey = key;\n"}}, {"oid": "4f69556e084053f12500968b7d3f65b0ac309d74", "url": "https://github.com/keycloak/keycloak/commit/4f69556e084053f12500968b7d3f65b0ac309d74", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-20T05:44:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExNTQwNg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457115406", "bodyText": "When running KeycloakServer.java from idea the working directory is set to keycloak root directory. Therefore this fails with file or directory doesn't exists because target directory is not there. Can we use project.build.directory variable? Also how this will work if we will run it on wildfly or using quarkus jar file? Should we provide some env variable to set this path?", "author": "mhajas", "createdAt": "2020-07-20T07:06:08Z", "path": "model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import org.keycloak.models.map.common.Serialization;\n+import com.fasterxml.jackson.databind.JavaType;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.jboss.logging.Logger;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class ConcurrentHashMapStorageProvider implements MapStorageProvider {\n+\n+    private static class ConcurrentHashMapStorage<K, V> extends ConcurrentHashMap<K, V> implements MapStorage<K, V> {\n+    }\n+\n+    private static final String PROVIDER_ID = \"concurrenthashmap\";\n+\n+    private static final Logger LOG = Logger.getLogger(ConcurrentHashMapStorageProvider.class);\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<?,?>> storages = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public MapStorageProvider create(KeycloakSession session) {\n+        return this;\n+    }\n+\n+    @Override\n+    public void init(Scope config) {\n+    }\n+\n+    @Override\n+    public void postInit(KeycloakSessionFactory factory) {\n+    }\n+\n+    @Override\n+    public void close() {\n+        storages.forEach(ConcurrentHashMapStorageProvider::storeMap);\n+    }\n+\n+    private static void storeMap(String fileName, ConcurrentHashMap<?, ?> store) {\n+        if (fileName != null) {\n+            final File f = new File(\"target/map-\" + fileName + \".json\");", "originalCommit": "4f69556e084053f12500968b7d3f65b0ac309d74", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java b/model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java\nindex efbead823c..21cfa0ad4e 100644\n--- a/model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java\n+++ b/model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java\n\n@@ -24,9 +24,11 @@ import org.keycloak.models.map.common.Serialization;\n import com.fasterxml.jackson.databind.JavaType;\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.util.EnumSet;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n import org.jboss.logging.Logger;\n \n /**\n"}}, {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "url": "https://github.com/keycloak/keycloak/commit/59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-20T09:15:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzMjAwOQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457332009", "bodyText": "In regards to methods returning a Collection, would it break other places if we return an unmodifiable collection?\nI'm wondering if not doing so, client code could change state by changing those collections directly without reflecting on the update state.", "author": "pedroigor", "createdAt": "2020-07-20T12:20:47Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {", "originalCommit": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MzY4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457393683", "bodyText": "*Entity is private class and the high-level code only uses *Model implementations.\nIn the particular case of map models introduced here, if the client code fails to update the updated state, then the entity is never persisted (see MapKeycloakTransaction.putIfChanged(K, V, Predicate<V>)). Other implementations can choose another mechanism, e.g. by returning unmodifiable collections as you suggested.\nGenerally, the model implementations ensure that the contract of updating the updated is properly maintained, e.g. by only exposing read-only collections for getters, and separate methods for modifying the collections. Cf. ProtocolMappers handling in MapClientAdapter.", "author": "hmlnarik", "createdAt": "2020-07-20T13:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzMjAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java b/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java\ndeleted file mode 100644\nindex 5f43d6face..0000000000\n--- a/model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java\n+++ /dev/null\n\n@@ -1,508 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates\n- * and other contributors as indicated by the @author tags.\n- * \n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * \n- * http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.keycloak.models.map.client;\n-\n-import org.keycloak.models.ProtocolMapperModel;\n-import org.keycloak.models.map.common.AbstractEntity;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-/**\n- *\n- * @author hmlnarik\n- */\n-public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n-\n-    private K id;\n-    private String realmId;\n-\n-    private String clientId;\n-    private String name;\n-    private String description;\n-    private Set<String> redirectUris = new HashSet<>();\n-    private boolean enabled;\n-    private boolean alwaysDisplayInConsole;\n-    private String clientAuthenticatorType;\n-    private String secret;\n-    private String registrationToken;\n-    private String protocol;\n-    private Map<String, String> attributes = new HashMap<>();\n-    private Map<String, String> authFlowBindings = new HashMap<>();\n-    private boolean publicClient;\n-    private boolean fullScopeAllowed;\n-    private boolean frontchannelLogout;\n-    private int notBefore;\n-    private Set<String> scope = new HashSet<>();\n-    private Set<String> webOrigins = new HashSet<>();\n-    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n-    private Map<String, Boolean> clientScopes = new HashMap<>();\n-    private Set<String> scopeMappings = new LinkedHashSet<>();\n-    private List<String> defaultRoles = new LinkedList<>();\n-    private boolean surrogateAuthRequired;\n-    private String managementUrl;\n-    private String rootUrl;\n-    private String baseUrl;\n-    private boolean bearerOnly;\n-    private boolean consentRequired;\n-    private boolean standardFlowEnabled;\n-    private boolean implicitFlowEnabled;\n-    private boolean directAccessGrantsEnabled;\n-    private boolean serviceAccountsEnabled;\n-    private int nodeReRegistrationTimeout;\n-\n-    /**\n-     * Flag signalizing that any of the setters has been meaningfully used.\n-     */\n-    protected boolean updated;\n-\n-    protected AbstractClientEntity() {\n-        this.id = null;\n-        this.realmId = null;\n-    }\n-\n-    public AbstractClientEntity(K id, String realmId) {\n-        Objects.requireNonNull(id, \"id\");\n-        Objects.requireNonNull(realmId, \"realmId\");\n-\n-        this.id = id;\n-        this.realmId = realmId;\n-    }\n-\n-    @Override\n-    public K getId() {\n-        return this.id;\n-    }\n-\n-    @Override\n-    public boolean isUpdated() {\n-        return this.updated;\n-    }\n-\n-    public String getClientId() {\n-        return clientId;\n-    }\n-\n-    public void setClientId(String clientId) {\n-        this.updated |= ! Objects.equals(this.clientId, clientId);\n-        this.clientId = clientId;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.updated |= ! Objects.equals(this.name, name);\n-        this.name = name;\n-    }\n-\n-    public String getDescription() {\n-        return description;\n-    }\n-\n-    public void setDescription(String description) {\n-        this.updated |= ! Objects.equals(this.description, description);\n-        this.description = description;\n-    }\n-\n-    public Set<String> getRedirectUris() {\n-        return redirectUris;\n-    }\n-\n-    public void setRedirectUris(Set<String> redirectUris) {\n-        this.updated |= ! Objects.equals(this.redirectUris, redirectUris);\n-        this.redirectUris = redirectUris;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void setEnabled(boolean enabled) {\n-        this.updated |= ! Objects.equals(this.enabled, enabled);\n-        this.enabled = enabled;\n-    }\n-\n-    public boolean isAlwaysDisplayInConsole() {\n-        return alwaysDisplayInConsole;\n-    }\n-\n-    public void setAlwaysDisplayInConsole(boolean alwaysDisplayInConsole) {\n-        this.updated |= ! Objects.equals(this.alwaysDisplayInConsole, alwaysDisplayInConsole);\n-        this.alwaysDisplayInConsole = alwaysDisplayInConsole;\n-    }\n-\n-    public String getClientAuthenticatorType() {\n-        return clientAuthenticatorType;\n-    }\n-\n-    public void setClientAuthenticatorType(String clientAuthenticatorType) {\n-        this.updated |= ! Objects.equals(this.clientAuthenticatorType, clientAuthenticatorType);\n-        this.clientAuthenticatorType = clientAuthenticatorType;\n-    }\n-\n-    public String getSecret() {\n-        return secret;\n-    }\n-\n-    public void setSecret(String secret) {\n-        this.updated |= ! Objects.equals(this.secret, secret);\n-        this.secret = secret;\n-    }\n-\n-    public String getRegistrationToken() {\n-        return registrationToken;\n-    }\n-\n-    public void setRegistrationToken(String registrationToken) {\n-        this.updated |= ! Objects.equals(this.registrationToken, registrationToken);\n-        this.registrationToken = registrationToken;\n-    }\n-\n-    public String getProtocol() {\n-        return protocol;\n-    }\n-\n-    public void setProtocol(String protocol) {\n-        this.updated |= ! Objects.equals(this.protocol, protocol);\n-        this.protocol = protocol;\n-    }\n-\n-    public Map<String, String> getAttributes() {\n-        return attributes;\n-    }\n-\n-    public void setAttributes(Map<String, String> attributes) {\n-        this.updated |= ! Objects.equals(this.attributes, attributes);\n-        this.attributes = attributes;\n-    }\n-\n-    public Map<String, String> getAuthFlowBindings() {\n-        return authFlowBindings;\n-    }\n-\n-    public void setAuthFlowBindings(Map<String, String> authFlowBindings) {\n-        this.updated |= ! Objects.equals(this.authFlowBindings, authFlowBindings);\n-        this.authFlowBindings = authFlowBindings;\n-    }\n-\n-    public boolean isPublicClient() {\n-        return publicClient;\n-    }\n-\n-    public void setPublicClient(boolean publicClient) {\n-        this.updated |= ! Objects.equals(this.publicClient, publicClient);\n-        this.publicClient = publicClient;\n-    }\n-\n-    public boolean isFullScopeAllowed() {\n-        return fullScopeAllowed;\n-    }\n-\n-    public void setFullScopeAllowed(boolean fullScopeAllowed) {\n-        this.updated |= ! Objects.equals(this.fullScopeAllowed, fullScopeAllowed);\n-        this.fullScopeAllowed = fullScopeAllowed;\n-    }\n-\n-    public boolean isFrontchannelLogout() {\n-        return frontchannelLogout;\n-    }\n-\n-    public void setFrontchannelLogout(boolean frontchannelLogout) {\n-        this.updated |= ! Objects.equals(this.frontchannelLogout, frontchannelLogout);\n-        this.frontchannelLogout = frontchannelLogout;\n-    }\n-\n-    public int getNotBefore() {\n-        return notBefore;\n-    }\n-\n-    public void setNotBefore(int notBefore) {\n-        this.updated |= ! Objects.equals(this.notBefore, notBefore);\n-        this.notBefore = notBefore;\n-    }\n-\n-    public Set<String> getScope() {\n-        return scope;\n-    }\n-\n-    public void setScope(Set<String> scope) {\n-        this.updated |= ! Objects.equals(this.scope, scope);\n-        this.scope.clear();\n-        this.scope.addAll(scope);\n-    }\n-\n-    public Set<String> getWebOrigins() {\n-        return webOrigins;\n-    }\n-\n-    public void setWebOrigins(Set<String> webOrigins) {\n-        this.updated |= ! Objects.equals(this.webOrigins, webOrigins);\n-        this.webOrigins.clear();\n-        this.webOrigins.addAll(webOrigins);\n-    }\n-\n-    public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n-        Objects.requireNonNull(model.getId(), \"protocolMapper.id\");\n-        updated = true;\n-        this.protocolMappers.put(model.getId(), model);\n-        return model;\n-    }\n-\n-    public Collection<ProtocolMapperModel> getProtocolMappers() {\n-        return protocolMappers.values();\n-    }\n-\n-    public void updateProtocolMapper(String id, ProtocolMapperModel mapping) {\n-        updated = true;\n-        protocolMappers.put(id, mapping);\n-    }\n-\n-    public void removeProtocolMapper(String id) {\n-        updated |= protocolMappers.remove(id) != null;\n-    }\n-\n-    public void setProtocolMappers(Collection<ProtocolMapperModel> protocolMappers) {\n-        this.updated |= ! Objects.equals(this.protocolMappers, protocolMappers);\n-        this.protocolMappers.clear();\n-        this.protocolMappers.putAll(protocolMappers.stream().collect(Collectors.toMap(ProtocolMapperModel::getId, Function.identity())));\n-    }\n-\n-    public ProtocolMapperModel getProtocolMapperById(String id) {\n-        return id == null ? null : protocolMappers.get(id);\n-    }\n-\n-    public boolean isSurrogateAuthRequired() {\n-        return surrogateAuthRequired;\n-    }\n-\n-    public void setSurrogateAuthRequired(boolean surrogateAuthRequired) {\n-        this.updated |= ! Objects.equals(this.surrogateAuthRequired, surrogateAuthRequired);\n-        this.surrogateAuthRequired = surrogateAuthRequired;\n-    }\n-\n-    public String getManagementUrl() {\n-        return managementUrl;\n-    }\n-\n-    public void setManagementUrl(String managementUrl) {\n-        this.updated |= ! Objects.equals(this.managementUrl, managementUrl);\n-        this.managementUrl = managementUrl;\n-    }\n-\n-    public String getRootUrl() {\n-        return rootUrl;\n-    }\n-\n-    public void setRootUrl(String rootUrl) {\n-        this.updated |= ! Objects.equals(this.rootUrl, rootUrl);\n-        this.rootUrl = rootUrl;\n-    }\n-\n-    public String getBaseUrl() {\n-        return baseUrl;\n-    }\n-\n-    public void setBaseUrl(String baseUrl) {\n-        this.updated |= ! Objects.equals(this.baseUrl, baseUrl);\n-        this.baseUrl = baseUrl;\n-    }\n-\n-    public List<String> getDefaultRoles() {\n-        return defaultRoles;\n-    }\n-\n-    public void setDefaultRoles(Collection<String> defaultRoles) {\n-        this.updated |= ! Objects.equals(this.defaultRoles, defaultRoles);\n-        this.defaultRoles.clear();\n-        this.defaultRoles.addAll(defaultRoles);\n-    }\n-\n-    public void addDefaultRole(String name) {\n-        updated = true;\n-        if (name != null) {\n-            defaultRoles.add(name);\n-        }\n-    }\n-\n-    public void removeDefaultRoles(String... defaultRoles) {\n-        for (String defaultRole : defaultRoles) {\n-            updated |= this.defaultRoles.remove(defaultRole);\n-        }\n-    }\n-\n-    public boolean isBearerOnly() {\n-        return bearerOnly;\n-    }\n-\n-    public void setBearerOnly(boolean bearerOnly) {\n-        this.updated |= ! Objects.equals(this.bearerOnly, bearerOnly);\n-        this.bearerOnly = bearerOnly;\n-    }\n-\n-    public boolean isConsentRequired() {\n-        return consentRequired;\n-    }\n-\n-    public void setConsentRequired(boolean consentRequired) {\n-        this.updated |= ! Objects.equals(this.consentRequired, consentRequired);\n-        this.consentRequired = consentRequired;\n-    }\n-\n-    public boolean isStandardFlowEnabled() {\n-        return standardFlowEnabled;\n-    }\n-\n-    public void setStandardFlowEnabled(boolean standardFlowEnabled) {\n-        this.updated |= ! Objects.equals(this.standardFlowEnabled, standardFlowEnabled);\n-        this.standardFlowEnabled = standardFlowEnabled;\n-    }\n-\n-    public boolean isImplicitFlowEnabled() {\n-        return implicitFlowEnabled;\n-    }\n-\n-    public void setImplicitFlowEnabled(boolean implicitFlowEnabled) {\n-        this.updated |= ! Objects.equals(this.implicitFlowEnabled, implicitFlowEnabled);\n-        this.implicitFlowEnabled = implicitFlowEnabled;\n-    }\n-\n-    public boolean isDirectAccessGrantsEnabled() {\n-        return directAccessGrantsEnabled;\n-    }\n-\n-    public void setDirectAccessGrantsEnabled(boolean directAccessGrantsEnabled) {\n-        this.updated |= ! Objects.equals(this.directAccessGrantsEnabled, directAccessGrantsEnabled);\n-        this.directAccessGrantsEnabled = directAccessGrantsEnabled;\n-    }\n-\n-    public boolean isServiceAccountsEnabled() {\n-        return serviceAccountsEnabled;\n-    }\n-\n-    public void setServiceAccountsEnabled(boolean serviceAccountsEnabled) {\n-        this.updated |= ! Objects.equals(this.serviceAccountsEnabled, serviceAccountsEnabled);\n-        this.serviceAccountsEnabled = serviceAccountsEnabled;\n-    }\n-\n-    public int getNodeReRegistrationTimeout() {\n-        return nodeReRegistrationTimeout;\n-    }\n-\n-    public void setNodeReRegistrationTimeout(int nodeReRegistrationTimeout) {\n-        this.updated |= ! Objects.equals(this.nodeReRegistrationTimeout, nodeReRegistrationTimeout);\n-        this.nodeReRegistrationTimeout = nodeReRegistrationTimeout;\n-    }\n-\n-    public void addWebOrigin(String webOrigin) {\n-        updated = true;\n-        this.webOrigins.add(webOrigin);\n-    }\n-\n-    public void removeWebOrigin(String webOrigin) {\n-        updated |= this.webOrigins.remove(webOrigin);\n-    }\n-\n-    public void addRedirectUri(String redirectUri) {\n-        this.updated |= ! this.redirectUris.contains(redirectUri);\n-        this.redirectUris.add(redirectUri);\n-    }\n-\n-    public void removeRedirectUri(String redirectUri) {\n-        updated |= this.redirectUris.remove(redirectUri);\n-    }\n-\n-    public void setAttribute(String name, String value) {\n-        this.updated = true;\n-        this.attributes.put(name, value);\n-    }\n-\n-    public void removeAttribute(String name) {\n-        this.updated |= this.attributes.remove(name) != null;\n-    }\n-\n-    public String getAttribute(String name) {\n-        return this.attributes.get(name);\n-    }\n-\n-    public String getAuthenticationFlowBindingOverride(String binding) {\n-        return this.authFlowBindings.get(binding);\n-    }\n-\n-    public Map<String, String> getAuthenticationFlowBindingOverrides() {\n-        return this.authFlowBindings;\n-    }\n-\n-    public void removeAuthenticationFlowBindingOverride(String binding) {\n-        updated |= this.authFlowBindings.remove(binding) != null;\n-    }\n-\n-    public void setAuthenticationFlowBindingOverride(String binding, String flowId) {\n-        this.updated = true;\n-        this.authFlowBindings.put(binding, flowId);\n-    }\n-\n-    public Collection<String> getScopeMappings() {\n-        return scopeMappings;\n-    }\n-\n-    public void addScopeMapping(String id) {\n-        if (id != null) {\n-            updated = true;\n-            scopeMappings.add(id);\n-        }\n-    }\n-\n-    public void deleteScopeMapping(String id) {\n-        updated |= scopeMappings.remove(id);\n-    }\n-\n-    public void addClientScope(String id, boolean defaultScope) {\n-        if (id != null) {\n-            updated = true;\n-            this.clientScopes.put(id, defaultScope);\n-        }\n-    }\n-\n-    public void removeClientScope(String id) {\n-        if (id != null) {\n-            updated |= clientScopes.remove(id) != null;\n-        }\n-    }\n-\n-    public Stream<String> getClientScopes(boolean defaultScope) {\n-        return this.clientScopes.entrySet().stream()\n-          .filter(me -> Objects.equals(me.getValue(), defaultScope))\n-          .map(Entry::getKey);\n-    }\n-\n-    public String getRealmId() {\n-        return this.realmId;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzNjMwOA==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457336308", "bodyText": "Any reason why those methods are not in AbstractClientModel ? Are we supposed to have other implementations of AbstractClientModel ?", "author": "pedroigor", "createdAt": "2020-07-20T12:27:11Z", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import com.google.common.base.Functions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class MapClientAdapter extends AbstractClientModel<MapClientEntity> implements ClientModel {", "originalCommit": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM3OTA5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457379093", "bodyText": "AbstractClientModel only contains methods that operate on data that are not directly stored in entity and are delegated via session object. The implementation can choose to store the physical format (i.e. the entity) in any way - e.g. json, POJO, DB columns in tables - and should implement the ClientModel methods accordingly without any prescription from a predecessor.", "author": "hmlnarik", "createdAt": "2020-07-20T13:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzNjMwOA=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java b/model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java\ndeleted file mode 100644\nindex b23aab8be6..0000000000\n--- a/model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java\n+++ /dev/null\n\n@@ -1,540 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates\n- * and other contributors as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.keycloak.models.map.client;\n-\n-import org.keycloak.models.ClientModel;\n-import org.keycloak.models.ClientScopeModel;\n-import org.keycloak.models.KeycloakSession;\n-import org.keycloak.models.ProtocolMapperModel;\n-import org.keycloak.models.RealmModel;\n-import org.keycloak.models.RoleModel;\n-import org.keycloak.models.utils.KeycloakModelUtils;\n-import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n-import com.google.common.base.Functions;\n-import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-/**\n- *\n- * @author hmlnarik\n- */\n-public abstract class MapClientAdapter extends AbstractClientModel<MapClientEntity> implements ClientModel {\n-\n-    public MapClientAdapter(KeycloakSession session, RealmModel realm, MapClientEntity entity) {\n-        super(session, realm, entity);\n-    }\n-\n-    @Override\n-    public String getId() {\n-        return entity.getId().toString();\n-    }\n-\n-    @Override\n-    public String getClientId() {\n-        return entity.getClientId();\n-    }\n-\n-    @Override\n-    public void setClientId(String clientId) {\n-        entity.setClientId(clientId);\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return entity.getName();\n-    }\n-\n-    @Override\n-    public void setName(String name) {\n-        entity.setName(name);\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return entity.getDescription();\n-    }\n-\n-    @Override\n-    public void setDescription(String description) {\n-        entity.setDescription(description);\n-    }\n-\n-    @Override\n-    public boolean isEnabled() {\n-        return entity.isEnabled();\n-    }\n-\n-    @Override\n-    public void setEnabled(boolean enabled) {\n-        entity.setEnabled(enabled);\n-    }\n-\n-    @Override\n-    public boolean isAlwaysDisplayInConsole() {\n-        return entity.isAlwaysDisplayInConsole();\n-    }\n-\n-    @Override\n-    public void setAlwaysDisplayInConsole(boolean alwaysDisplayInConsole) {\n-        entity.setAlwaysDisplayInConsole(alwaysDisplayInConsole);\n-    }\n-\n-    @Override\n-    public boolean isSurrogateAuthRequired() {\n-        return entity.isSurrogateAuthRequired();\n-    }\n-\n-    @Override\n-    public void setSurrogateAuthRequired(boolean surrogateAuthRequired) {\n-        entity.setSurrogateAuthRequired(surrogateAuthRequired);\n-    }\n-\n-    @Override\n-    public Set<String> getWebOrigins() {\n-        return entity.getWebOrigins();\n-    }\n-\n-    @Override\n-    public void setWebOrigins(Set<String> webOrigins) {\n-        entity.setWebOrigins(webOrigins);\n-    }\n-\n-    @Override\n-    public void addWebOrigin(String webOrigin) {\n-        entity.addWebOrigin(webOrigin);\n-    }\n-\n-    @Override\n-    public void removeWebOrigin(String webOrigin) {\n-        entity.removeWebOrigin(webOrigin);\n-    }\n-\n-    @Override\n-    public Set<String> getRedirectUris() {\n-        return entity.getRedirectUris();\n-    }\n-\n-    @Override\n-    public void setRedirectUris(Set<String> redirectUris) {\n-        entity.setRedirectUris(redirectUris);\n-    }\n-\n-    @Override\n-    public void addRedirectUri(String redirectUri) {\n-        entity.addRedirectUri(redirectUri);\n-    }\n-\n-    @Override\n-    public void removeRedirectUri(String redirectUri) {\n-        entity.removeRedirectUri(redirectUri);\n-    }\n-\n-    @Override\n-    public String getManagementUrl() {\n-        return entity.getManagementUrl();\n-    }\n-\n-    @Override\n-    public void setManagementUrl(String url) {\n-        entity.setManagementUrl(url);\n-    }\n-\n-    @Override\n-    public String getRootUrl() {\n-        return entity.getRootUrl();\n-    }\n-\n-    @Override\n-    public void setRootUrl(String url) {\n-        entity.setRootUrl(url);\n-    }\n-\n-    @Override\n-    public String getBaseUrl() {\n-        return entity.getBaseUrl();\n-    }\n-\n-    @Override\n-    public void setBaseUrl(String url) {\n-        entity.setBaseUrl(url);\n-    }\n-\n-    @Override\n-    public boolean isBearerOnly() {\n-        return entity.isBearerOnly();\n-    }\n-\n-    @Override\n-    public void setBearerOnly(boolean only) {\n-        entity.setBearerOnly(only);\n-    }\n-\n-    @Override\n-    public String getClientAuthenticatorType() {\n-        return entity.getClientAuthenticatorType();\n-    }\n-\n-    @Override\n-    public void setClientAuthenticatorType(String clientAuthenticatorType) {\n-        entity.setClientAuthenticatorType(clientAuthenticatorType);\n-    }\n-\n-    @Override\n-    public boolean validateSecret(String secret) {\n-        return MessageDigest.isEqual(secret.getBytes(), entity.getSecret().getBytes());\n-    }\n-\n-    @Override\n-    public String getSecret() {\n-        return entity.getSecret();\n-    }\n-\n-    @Override\n-    public void setSecret(String secret) {\n-        entity.setSecret(secret);\n-    }\n-\n-    @Override\n-    public int getNodeReRegistrationTimeout() {\n-        return entity.getNodeReRegistrationTimeout();\n-    }\n-\n-    @Override\n-    public void setNodeReRegistrationTimeout(int timeout) {\n-        entity.setNodeReRegistrationTimeout(timeout);\n-    }\n-\n-    @Override\n-    public String getRegistrationToken() {\n-        return entity.getRegistrationToken();\n-    }\n-\n-    @Override\n-    public void setRegistrationToken(String registrationToken) {\n-        entity.setRegistrationToken(registrationToken);\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return entity.getProtocol();\n-    }\n-\n-    @Override\n-    public void setProtocol(String protocol) {\n-        entity.setProtocol(protocol);\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, String value) {\n-        entity.setAttribute(name, value);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        entity.removeAttribute(name);\n-    }\n-\n-    @Override\n-    public String getAttribute(String name) {\n-        return entity.getAttribute(name);\n-    }\n-\n-    @Override\n-    public Map<String, String> getAttributes() {\n-        return entity.getAttributes();\n-    }\n-\n-    @Override\n-    public String getAuthenticationFlowBindingOverride(String binding) {\n-        return entity.getAuthenticationFlowBindingOverride(binding);\n-    }\n-\n-    @Override\n-    public Map<String, String> getAuthenticationFlowBindingOverrides() {\n-        return entity.getAuthenticationFlowBindingOverrides();\n-    }\n-\n-    @Override\n-    public void removeAuthenticationFlowBindingOverride(String binding) {\n-        entity.removeAuthenticationFlowBindingOverride(binding);\n-    }\n-\n-    @Override\n-    public void setAuthenticationFlowBindingOverride(String binding, String flowId) {\n-        entity.setAuthenticationFlowBindingOverride(binding, flowId);\n-    }\n-\n-    @Override\n-    public boolean isFrontchannelLogout() {\n-        return entity.isFrontchannelLogout();\n-    }\n-\n-    @Override\n-    public void setFrontchannelLogout(boolean flag) {\n-        entity.setFrontchannelLogout(flag);\n-    }\n-\n-    @Override\n-    public boolean isFullScopeAllowed() {\n-        return entity.isFullScopeAllowed();\n-    }\n-\n-    @Override\n-    public void setFullScopeAllowed(boolean value) {\n-        entity.setFullScopeAllowed(value);\n-    }\n-\n-    @Override\n-    public boolean isPublicClient() {\n-        return entity.isPublicClient();\n-    }\n-\n-    @Override\n-    public void setPublicClient(boolean flag) {\n-        entity.setPublicClient(flag);\n-    }\n-\n-    @Override\n-    public boolean isConsentRequired() {\n-        return entity.isConsentRequired();\n-    }\n-\n-    @Override\n-    public void setConsentRequired(boolean consentRequired) {\n-        entity.setConsentRequired(consentRequired);\n-    }\n-\n-    @Override\n-    public boolean isStandardFlowEnabled() {\n-        return entity.isStandardFlowEnabled();\n-    }\n-\n-    @Override\n-    public void setStandardFlowEnabled(boolean standardFlowEnabled) {\n-        entity.setStandardFlowEnabled(standardFlowEnabled);\n-    }\n-\n-    @Override\n-    public boolean isImplicitFlowEnabled() {\n-        return entity.isImplicitFlowEnabled();\n-    }\n-\n-    @Override\n-    public void setImplicitFlowEnabled(boolean implicitFlowEnabled) {\n-        entity.setImplicitFlowEnabled(implicitFlowEnabled);\n-    }\n-\n-    @Override\n-    public boolean isDirectAccessGrantsEnabled() {\n-        return entity.isDirectAccessGrantsEnabled();\n-    }\n-\n-    @Override\n-    public void setDirectAccessGrantsEnabled(boolean directAccessGrantsEnabled) {\n-        entity.setDirectAccessGrantsEnabled(directAccessGrantsEnabled);\n-    }\n-\n-    @Override\n-    public boolean isServiceAccountsEnabled() {\n-        return entity.isServiceAccountsEnabled();\n-    }\n-\n-    @Override\n-    public void setServiceAccountsEnabled(boolean serviceAccountsEnabled) {\n-        entity.setServiceAccountsEnabled(serviceAccountsEnabled);\n-    }\n-\n-    @Override\n-    public RealmModel getRealm() {\n-        return realm;\n-    }\n-\n-    @Override\n-    public int getNotBefore() {\n-        return entity.getNotBefore();\n-    }\n-\n-    @Override\n-    public void setNotBefore(int notBefore) {\n-        entity.setNotBefore(notBefore);\n-    }\n-\n-    /*************** Client scopes ****************/\n-\n-    @Override\n-    public void addClientScope(ClientScopeModel clientScope, boolean defaultScope) {\n-        final String id = clientScope == null ? null : clientScope.getId();\n-        if (id != null) {\n-            entity.addClientScope(id, defaultScope);\n-        }\n-    }\n-\n-    @Override\n-    public void removeClientScope(ClientScopeModel clientScope) {\n-        final String id = clientScope == null ? null : clientScope.getId();\n-        if (id != null) {\n-            entity.removeClientScope(id);\n-        }\n-    }\n-\n-    @Override\n-    public Map<String, ClientScopeModel> getClientScopes(boolean defaultScope, boolean filterByProtocol) {\n-        Stream<ClientScopeModel> res = this.entity.getClientScopes(defaultScope)\n-          .map(realm::getClientScopeById)\n-          .filter(Objects::nonNull);\n-\n-        if (filterByProtocol) {\n-            String clientProtocol = getProtocol() == null ? OIDCLoginProtocol.LOGIN_PROTOCOL : getProtocol();\n-            res = res.filter(cs -> Objects.equals(cs.getProtocol(), clientProtocol));\n-        }\n-\n-        return res.collect(Collectors.toMap(ClientScopeModel::getName, Functions.identity()));\n-    }\n-\n-    /*************** Scopes mappings ****************/\n-\n-    @Override\n-    public Stream<RoleModel> getScopeMappingsStream() {\n-        return this.entity.getScopeMappings().stream()\n-                .map(realm::getRoleById)\n-                .filter(Objects::nonNull);\n-    }\n-\n-    @Override\n-    public void addScopeMapping(RoleModel role) {\n-        final String id = role == null ? null : role.getId();\n-        if (id != null) {\n-            this.entity.addScopeMapping(id);\n-        }\n-    }\n-\n-    @Override\n-    public void deleteScopeMapping(RoleModel role) {\n-        final String id = role == null ? null : role.getId();\n-        if (id != null) {\n-            this.entity.deleteScopeMapping(id);\n-        }\n-    }\n-\n-    @Override\n-    public boolean hasScope(RoleModel role) {\n-        if (isFullScopeAllowed()) return true;\n-\n-        final String id = role == null ? null : role.getId();\n-        if (id != null && this.entity.getScopeMappings().contains(id)) {\n-            return true;\n-        }\n-\n-        if (getScopeMappingsStream().anyMatch(r -> r.hasRole(role))) {\n-            return true;\n-        }\n-\n-        Set<RoleModel> roles = getRoles();\n-        if (roles.contains(role)) return true;\n-\n-        return roles.stream().anyMatch(r -> r.hasRole(role));\n-    }\n-\n-    /*************** Default roles ****************/\n-\n-    @Override\n-    public List<String> getDefaultRoles() {\n-        return entity.getDefaultRoles();\n-    }\n-\n-    @Override\n-    public void addDefaultRole(String name) {\n-        RoleModel role = getRole(name);\n-        if (role == null) {\n-            addRole(name);\n-        }\n-        this.entity.addDefaultRole(name);\n-    }\n-\n-    @Override\n-    public void removeDefaultRoles(String... defaultRoles) {\n-        this.entity.removeDefaultRoles(defaultRoles);\n-    }\n-\n-    /*************** Protocol mappers ****************/\n-\n-    @Override\n-    public Set<ProtocolMapperModel> getProtocolMappers() {\n-        return Collections.unmodifiableSet(new HashSet<>(entity.getProtocolMappers()));\n-    }\n-\n-    @Override\n-    public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n-        if (model == null) {\n-            return null;\n-        }\n-\n-        ProtocolMapperModel pm = new ProtocolMapperModel();\n-        pm.setId(KeycloakModelUtils.generateId());\n-        pm.setName(model.getName());\n-        pm.setProtocol(model.getProtocol());\n-        pm.setProtocolMapper(model.getProtocolMapper());\n-\n-        if (model.getConfig() != null) {\n-            pm.setConfig(new HashMap<>(model.getConfig()));\n-        } else {\n-            pm.setConfig(new HashMap<>());\n-        }\n-\n-        return entity.addProtocolMapper(pm);\n-    }\n-\n-    @Override\n-    public void removeProtocolMapper(ProtocolMapperModel mapping) {\n-        final String id = mapping == null ? null : mapping.getId();\n-        if (id != null) {\n-            entity.removeProtocolMapper(id);\n-        }\n-    }\n-\n-    @Override\n-    public void updateProtocolMapper(ProtocolMapperModel mapping) {\n-        final String id = mapping == null ? null : mapping.getId();\n-        if (id != null) {\n-            entity.updateProtocolMapper(id, mapping);\n-        }\n-    }\n-\n-    @Override\n-    public ProtocolMapperModel getProtocolMapperById(String id) {\n-        return entity.getProtocolMapperById(id);\n-    }\n-\n-    @Override\n-    public ProtocolMapperModel getProtocolMapperByName(String protocol, String name) {\n-        return entity.getProtocolMappers().stream()\n-          .filter(pm -> Objects.equals(pm.getProtocol(), protocol) && Objects.equals(pm.getName(), name))\n-          .findAny()\n-          .orElse(null);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM1MDkyNg==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457350926", "bodyText": "Does it need to be public? Wondering if public would cause people misusing this instance and not using the method.\nI think I understand why you have another instance of ObjectMapper and JsonSerialization is not enough. But is there some way to just reuse JsonSerialization ?", "author": "pedroigor", "createdAt": "2020-07-20T12:47:15Z", "path": "model/map/src/main/java/org/keycloak/models/map/common/Serialization.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.common;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class Serialization {\n+\n+    public static final ObjectMapper MAPPER = new ObjectMapper();", "originalCommit": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM3NDQyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457374425", "bodyText": "Does it need to be public?\n\nNo, it need not, yet having it public helps in ConcurrentHashMapStorageProvider to use the same way of entity serialization as this \"cloning\" utility, and that in turn helps to debug issues with storing a representation of entities.\n\nWondering if public would cause people misusing this instance and not using the method.\n\nThis instance should not be ordinarily visible to the public since model/map module (as well as any from the model/ modules) is not usually included as a dependency.\n\nI think I understand why you have another instance of ObjectMapper and JsonSerialization is not enough. But is there some way to just reuse JsonSerialization ?\n\nHaving these two separately is a better option, since the aim is to minimize impact on the existing code. The way of serialization is different (fields vs getters/setters), and aim is to have the entitites decoupled from serialization annotations. In the case of this Serialization class, jackson annotations on the fields (e.g. @JsonIgnore) are never in the entity, and are located in the serialization logics, i.e. in Serialization class. This makes it easy to decouple entities from their physical storage layout.", "author": "hmlnarik", "createdAt": "2020-07-20T13:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM1MDkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "chunk": "diff --git a/model/map/src/main/java/org/keycloak/models/map/common/Serialization.java b/model/map/src/main/java/org/keycloak/models/map/common/Serialization.java\ndeleted file mode 100644\nindex ccb1b8000d..0000000000\n--- a/model/map/src/main/java/org/keycloak/models/map/common/Serialization.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates\n- * and other contributors as indicated by the @author tags.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.keycloak.models.map.common;\n-\n-import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.annotation.JsonIgnore;\n-import com.fasterxml.jackson.annotation.JsonInclude;\n-import com.fasterxml.jackson.annotation.PropertyAccessor;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import java.io.IOException;\n-\n-/**\n- *\n- * @author hmlnarik\n- */\n-public class Serialization {\n-\n-    public static final ObjectMapper MAPPER = new ObjectMapper();\n-\n-    abstract class IgnoreUpdatedMixIn { @JsonIgnore public abstract boolean isUpdated(); }\n-\n-    static {\n-        MAPPER.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n-        MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n-        MAPPER.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n-        MAPPER.setVisibility(PropertyAccessor.ALL, Visibility.NONE);\n-        MAPPER.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);\n-\n-        MAPPER.addMixIn(AbstractEntity.class, IgnoreUpdatedMixIn.class);\n-    }\n-\n-\n-    public static <T extends AbstractEntity> T from(T orig) {\n-        if (orig == null) {\n-            return null;\n-        }\n-        try {\n-            // Naive solution but will do.\n-            final T res = MAPPER.readValue(MAPPER.writeValueAsBytes(orig), (Class<T>) orig.getClass());\n-            return res;\n-        } catch (IOException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-}\n"}}, {"oid": "86e5a0128f8a00244288a7cfa8fed4266107e44f", "url": "https://github.com/keycloak/keycloak/commit/86e5a0128f8a00244288a7cfa8fed4266107e44f", "message": "KEYCLOAK-14551 Map transaction", "committedDate": "2020-07-21T13:20:18Z", "type": "commit"}, {"oid": "4fdda1540bef8e4e23aaf4f0b25b7188cab87dd3", "url": "https://github.com/keycloak/keycloak/commit/4fdda1540bef8e4e23aaf4f0b25b7188cab87dd3", "message": "KEYCLOAK-14553 Client map store\n\nCo-Authored-By: vramik <vramik@redhat.com>", "committedDate": "2020-07-21T13:20:18Z", "type": "commit"}, {"oid": "9bea8ab7f396cb4e8e779e8def5c46ff3232685b", "url": "https://github.com/keycloak/keycloak/commit/9bea8ab7f396cb4e8e779e8def5c46ff3232685b", "message": "KEYCLOAK-14549 Make ClientProvider independent of RealmProvider\n\nCo-Authored-By: vramik <vramik@redhat.com>", "committedDate": "2020-07-21T13:23:42Z", "type": "commit"}, {"oid": "8dbdb0528e9da777f2fff55613686493f21232c9", "url": "https://github.com/keycloak/keycloak/commit/8dbdb0528e9da777f2fff55613686493f21232c9", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-21T13:23:42Z", "type": "commit"}, {"oid": "8dbdb0528e9da777f2fff55613686493f21232c9", "url": "https://github.com/keycloak/keycloak/commit/8dbdb0528e9da777f2fff55613686493f21232c9", "message": "KEYCLOAK-14553 Improve logging", "committedDate": "2020-07-21T13:23:42Z", "type": "forcePushed"}]}