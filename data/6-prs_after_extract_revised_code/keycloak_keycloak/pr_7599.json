{"pr_number": 7599, "pr_title": "[KEYCLOAK-16232] Replace usages of deprecated collection-based method\u2026", "pr_createdAt": "2020-11-12T02:12:55Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7599", "timeline": [{"oid": "3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "url": "https://github.com/keycloak/keycloak/commit/3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants", "committedDate": "2020-11-12T13:25:09Z", "type": "forcePushed"}, {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "url": "https://github.com/keycloak/keycloak/commit/f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants", "committedDate": "2020-11-12T13:34:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxMzAyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523013025", "bodyText": "Maybe we could keep stream here and pass it to UserFullInvalidationEvent.create while replacing for loop with stream processing inside the method.", "author": "martin-kanis", "createdAt": "2020-11-13T15:12:49Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -796,7 +792,8 @@ public UserModel addUser(RealmModel realm, String username) {\n \n     // just in case the transaction is rolled back you need to invalidate the user and all cache queries for that user\n     protected void fullyInvalidateUser(RealmModel realm, UserModel user) {\n-        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ? getFederatedIdentities(user, realm) : null;\n+        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMTI4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530521283", "bodyText": "Good suggestion, changed", "author": "sguilhen", "createdAt": "2020-11-25T16:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxMzAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex daf9c7de87..41b6c42ce7 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n\n@@ -792,8 +792,8 @@ public class UserCacheSession implements UserCache {\n \n     // just in case the transaction is rolled back you need to invalidate the user and all cache queries for that user\n     protected void fullyInvalidateUser(RealmModel realm, UserModel user) {\n-        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?\n-                getFederatedIdentitiesStream(user, realm).collect(Collectors.toSet()) : null;\n+        Stream<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?\n+                getFederatedIdentitiesStream(user, realm) : Stream.empty();\n \n         UserFullInvalidationEvent event = UserFullInvalidationEvent.create(user.getId(), user.getUsername(), user.getEmail(), realm.getId(), realm.isIdentityFederationEnabled(), federatedIdentities);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523021802", "bodyText": "This part confuses me little bit. We wanted to keep original collection based methods in UserCredentialStore and deprecate those in UserFederatedUserCredentialStore?\nI know we had some discussion around this but I don't remember exact outcome.", "author": "martin-kanis", "createdAt": "2020-11-13T15:25:47Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,\n \n     @Override\n     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentials(realm, user.getId());\n+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNjM4MA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530526380", "bodyText": "The other way around - things in the federated package need to preserve the original collection-based methods.\nThe original PR that introduced the streams for User interfaces ended up changing the interfaces in the federated package (as they are tightly related) but it didn't touch the UserCredentialStore, this is why this particular method hasn't been updated yet. Once we streamify UserCredentialStore it will be replaced with the Stream-based implementation.\nIf you feel like UserCredentialStore should be changed as well as part of this work I can change this PR to include the its streamification and change everything at once.", "author": "sguilhen", "createdAt": "2020-11-25T17:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMDUzMw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r531030533", "bodyText": "Update: for consistency I've decided to streamify the UserCredentialStore and UserCredentialManager interfaces as part of this work (see second commit in this PR).", "author": "sguilhen", "createdAt": "2020-11-26T13:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "28430f5e4fa9df85c833677165bd579c607d41aa", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 46bd11444d..6bc57a6fd7 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n\n@@ -690,13 +690,13 @@ public class JpaUserFederatedStorageProvider implements\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return getStoredCredentialsStream(realm, user.getId());\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentialsByTypeStream(realm, user.getId(), type).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsByTypeStream(realm, user.getId(), type);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjEzOA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523026138", "bodyText": "It's not your change but maybe worth to use isEmpty().", "author": "martin-kanis", "createdAt": "2020-11-13T15:32:28Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java", "diffHunk": "@@ -121,13 +122,13 @@ public void onRegisterUserToLDAP(LDAPObject ldapUser, UserModel localUser, Realm\n         } else {\n \n             // we don't have java property. Let's set attribute\n-            List<String> attrValues = localUser.getAttribute(userModelAttrName);\n+            List<String> attrValues = localUser.getAttributeStream(userModelAttrName).collect(Collectors.toList());\n \n             if (attrValues.size() == 0) {", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNzI1Nw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530527257", "bodyText": "Yeah, changing.", "author": "sguilhen", "createdAt": "2020-11-25T17:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java\nindex d009aa9c8d..3e5b7f6630 100644\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java\n\n@@ -124,7 +124,7 @@ public class UserAttributeLDAPStorageMapper extends AbstractLDAPStorageMapper {\n             // we don't have java property. Let's set attribute\n             List<String> attrValues = localUser.getAttributeStream(userModelAttrName).collect(Collectors.toList());\n \n-            if (attrValues.size() == 0) {\n+            if (attrValues.isEmpty()) {\n                 if (isMandatoryInLdap) {\n                     ldapUser.setSingleAttribute(ldapAttrName, LDAPConstants.EMPTY_ATTRIBUTE_VALUE);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5OTU0Mw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525899543", "bodyText": "users != null can be omitted. Same in the return statement.", "author": "martin-kanis", "createdAt": "2020-11-18T08:32:14Z", "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,14 +62,14 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n             }\n+            List<UserModel> users = usersStream.collect(Collectors.toList());\n             if (users != null && users.size() > 1) {", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyODI4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530528286", "bodyText": "Good catch", "author": "sguilhen", "createdAt": "2020-11-25T17:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5OTU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java b/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\nindex 0e3c29cfd9..6ae819c933 100644\n--- a/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\n+++ b/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\n\n@@ -70,10 +70,10 @@ public abstract class UserIdentityToModelMapper {\n                 usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n             }\n             List<UserModel> users = usersStream.collect(Collectors.toList());\n-            if (users != null && users.size() > 1) {\n+            if (users.size() > 1) {\n                 throw new ModelDuplicateException();\n             }\n-            return users != null && users.size() == 1 ? users.get(0) : null;\n+            return users.size() == 1 ? users.get(0) : null;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNzgzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525907831", "bodyText": "I think this method and all its usages are worth to \"streamify\".", "author": "martin-kanis", "createdAt": "2020-11-18T08:45:50Z", "path": "services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java", "diffHunk": "@@ -103,6 +104,6 @@ public String getFirstAttribute(String name) {\n \n     @Override\n     public List<String> getAttribute(String key) {", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MzQ1MA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530543450", "bodyText": "Working on it", "author": "sguilhen", "createdAt": "2020-11-25T17:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNzgzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java b/services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java\nindex 5abb42971d..fc52597144 100644\n--- a/services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java\n+++ b/services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java\n\n@@ -103,7 +104,7 @@ public class UserUpdateProfileContext implements UpdateProfileContext {\n     }\n \n     @Override\n-    public List<String> getAttribute(String key) {\n-        return user.getAttributeStream(key).collect(Collectors.toList());\n+    public Stream<String> getAttributeStream(String key) {\n+        return user.getAttributeStream(key);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyMjk2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525922965", "bodyText": "Here can you confirm my assumption the cached version of getFederatedIdentitiesStream(user, realm) will be used to prevent multiple database calls?", "author": "martin-kanis", "createdAt": "2020-11-18T09:09:24Z", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java", "diffHunk": "@@ -47,15 +48,13 @@\n     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {\n         this.session = session;\n \n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-\n         AtomicInteger availableIdentities = new AtomicInteger(0);\n         this.identities = realm.getIdentityProvidersStream()\n                 .filter(IdentityProviderModel::isEnabled)\n                 .map(provider -> {\n                     String providerId = provider.getAlias();\n \n-                    FederatedIdentityModel identity = getIdentity(identities, providerId);\n+                    FederatedIdentityModel identity = getIdentity(session.users().getFederatedIdentitiesStream(user, realm), providerId);", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODk2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530548962", "bodyText": "I believe it is the version that goes through UserCacheSession, so it should be cached. The session.users() implementation tries to obtain the UserCache provider first and if it exists it returns the cached version, otherwise the UserStorageManager is returned.", "author": "sguilhen", "createdAt": "2020-11-25T17:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyMjk2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyNzMxNg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525927316", "bodyText": "This could be probably slightly changed to use map + collect instead of foreach.", "author": "martin-kanis", "createdAt": "2020-11-18T09:15:51Z", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,10 +51,9 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n+        this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .forEach(client -> {", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NzQ2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530547466", "bodyText": "+1", "author": "sguilhen", "createdAt": "2020-11-25T17:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyNzMxNg=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java b/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\nindex 7a01b3d4e8..f5710c227c 100755\n--- a/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\n+++ b/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\n\n@@ -51,48 +52,49 @@ public class ApplicationsBean {\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        this.getApplications(session, realm, user)\n+        this.applications = this.getApplications(session, realm, user)\n                 .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n-                .forEach(client -> {\n-\n-            // Construct scope parameter with all optional scopes to see all potentially available roles\n-            Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                    client.getClientScopes(true, true).values().stream(),\n-                    client.getClientScopes(false, true).values().stream());\n-            allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-            Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-            // Don't show applications, which user doesn't have access into (any available roles)\n-            // unless this is can be changed by approving/revoking consent\n-            if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                return;\n-            }\n-\n-            List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-            MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-            processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-            List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-            if (client.isConsentRequired()) {\n-                UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                if (consent != null) {\n-                    orderedScopes.addAll(consent.getGrantedClientScopes());\n-                }\n-            }\n-            List<String> clientScopesGranted = orderedScopes.stream()\n-                    .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                    .map(ClientScopeModel::getConsentScreenText)\n-                    .collect(Collectors.toList());\n-\n-            List<String> additionalGrants = new ArrayList<>();\n-            if (offlineClients.contains(client)) {\n-                additionalGrants.add(\"${offlineToken}\");\n-            }\n-\n-            applications.add(new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants));\n-        });\n+                .map(client -> {\n+\n+                    // Construct scope parameter with all optional scopes to see all potentially available roles\n+                    Stream<ClientScopeModel> allClientScopes = Stream.concat(\n+                            client.getClientScopes(true, true).values().stream(),\n+                            client.getClientScopes(false, true).values().stream());\n+                    allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n+\n+                    Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n+\n+                    // Don't show applications, which user doesn't have access into (any available roles)\n+                    // unless this is can be changed by approving/revoking consent\n+                    if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n+                        return null;\n+                    }\n+\n+                    List<RoleModel> realmRolesAvailable = new LinkedList<>();\n+                    MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n+                    processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n+\n+                    List<ClientScopeModel> orderedScopes = new LinkedList<>();\n+                    if (client.isConsentRequired()) {\n+                        UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+\n+                        if (consent != null) {\n+                            orderedScopes.addAll(consent.getGrantedClientScopes());\n+                        }\n+                    }\n+                    List<String> clientScopesGranted = orderedScopes.stream()\n+                            .sorted(OrderedModel.OrderedModelComparator.getInstance())\n+                            .map(ClientScopeModel::getConsentScreenText)\n+                            .collect(Collectors.toList());\n+\n+                    List<String> additionalGrants = new ArrayList<>();\n+                    if (offlineClients.contains(client)) {\n+                        additionalGrants.add(\"${offlineToken}\");\n+                    }\n+                    return new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants);\n+                })\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList());\n     }\n \n     public static boolean isAdminClient(ClientModel client) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NzIxNw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525947217", "bodyText": "Maybe you can do similar thing which you did in one of the previous classes? toLinkedAccountRepresentation(provider, socialIds, session.users().getFederatedIdentitiesStream(user, realm)); + rewrite getIdentity method to accept a stream.  But only if the same predicate about caching is valid to avoid performance degradation.", "author": "martin-kanis", "createdAt": "2020-11-18T09:45:19Z", "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -110,7 +111,8 @@ public Response linkedAccounts() {\n \n     public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<String> socialIds = findSocialIds();\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n+        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)\n+                .collect(Collectors.toSet());", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NzI3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530557272", "bodyText": "That's a good suggestion, makes this code a little bit simpler. Implementing it.", "author": "sguilhen", "createdAt": "2020-11-25T18:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NzIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java b/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\nindex 8ae1851527..14ab906de6 100644\n--- a/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\n\n@@ -111,15 +112,13 @@ public class LinkedAccountsResource {\n \n     public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<String> socialIds = findSocialIds();\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)\n-                .collect(Collectors.toSet());\n         return realm.getIdentityProvidersStream().filter(IdentityProviderModel::isEnabled)\n-                .map(provider -> toLinkedAccountRepresentation(provider, socialIds, identities))\n+                .map(provider -> toLinkedAccountRepresentation(provider, socialIds, session.users().getFederatedIdentitiesStream(user, realm)))\n                 .collect(Collectors.toCollection(TreeSet::new));\n     }\n \n     private LinkedAccountRepresentation toLinkedAccountRepresentation(IdentityProviderModel provider, Set<String> socialIds,\n-                                                                      Set<FederatedIdentityModel> identities) {\n+                                                                      Stream<FederatedIdentityModel> identities) {\n         String providerId = provider.getAlias();\n \n         FederatedIdentityModel identity = getIdentity(identities, providerId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4OTgyMQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526089821", "bodyText": "Not needed", "author": "martin-kanis", "createdAt": "2020-11-18T13:33:09Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -358,30 +358,24 @@ public UserRepresentation getUser() {\n     /**\n      * Get social logins associated with the user\n      *\n-     * @return\n+     * @return a non-null {@code Stream} of social logins (federated identities).\n      */\n     @Path(\"federated-identity\")\n     @GET\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<FederatedIdentityRepresentation> getFederatedIdentity() {\n+    public Stream<FederatedIdentityRepresentation> getFederatedIdentity() {\n         auth.users().requireView(user);\n-\n         return getFederatedIdentities(user);\n     }\n \n-    private List<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();\n+    private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n         Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());\n+        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1ODI3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530558272", "bodyText": "Oops, forgot to clean this up.", "author": "sguilhen", "createdAt": "2020-11-25T18:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4OTgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\nindex dba6215428..ae0a8a7152 100755\n--- a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\n\n@@ -371,8 +371,6 @@ public class UserResource {\n \n     private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n         Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());\n-        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();\n-\n         return session.users().getFederatedIdentitiesStream(user, realm)\n                 .filter(identity -> idps.contains(identity.getIdentityProvider()))\n                 .map(ModelToRepresentation::toRepresentation);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA5MzgxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526093819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    models.forEach(c -> c.setSecretData(null));\n          \n          \n            \n                    return session.userCredentialManager().getStoredCredentials(realm, user)\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .peek(c -> c.setSecretData(null))\n          \n          \n            \n                            .map(ModelToRepresentation::toRepresentation);", "author": "martin-kanis", "createdAt": "2020-11-18T13:39:23Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -607,11 +600,11 @@ public void resetPassword(CredentialRepresentation cred) {\n     @Path(\"credentials\")\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<CredentialRepresentation> credentials(){\n+    public Stream<CredentialRepresentation> credentials(){\n         auth.users().requireManage(user);\n         List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n         models.forEach(c -> c.setSecretData(null));", "originalCommit": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2MDA2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530560066", "bodyText": "Great point, I completely missed the opportunity to rewrite the logic here.", "author": "sguilhen", "createdAt": "2020-11-25T18:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA5MzgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d82758c2e07debd26ffe80de6badb4374ae60377", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\nindex dba6215428..ae0a8a7152 100755\n--- a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java\n\n@@ -602,9 +600,9 @@ public class UserResource {\n     @Produces(MediaType.APPLICATION_JSON)\n     public Stream<CredentialRepresentation> credentials(){\n         auth.users().requireManage(user);\n-        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n-        models.forEach(c -> c.setSecretData(null));\n-        return models.stream().map(ModelToRepresentation::toRepresentation);\n+        return session.userCredentialManager().getStoredCredentials(realm, user).stream()\n+                .peek(model -> model.setSecretData(null))\n+                .map(ModelToRepresentation::toRepresentation);\n     }\n \n \n"}}, {"oid": "d82758c2e07debd26ffe80de6badb4374ae60377", "url": "https://github.com/keycloak/keycloak/commit/d82758c2e07debd26ffe80de6badb4374ae60377", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants", "committedDate": "2020-11-25T18:15:40Z", "type": "forcePushed"}, {"oid": "28430f5e4fa9df85c833677165bd579c607d41aa", "url": "https://github.com/keycloak/keycloak/commit/28430f5e4fa9df85c833677165bd579c607d41aa", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-11-26T13:27:33Z", "type": "forcePushed"}, {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "url": "https://github.com/keycloak/keycloak/commit/74341de5f2d1ea877d611c78cd416ecca2a3ad45", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-11-26T14:39:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTk2MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532759961", "bodyText": "Star import.", "author": "martin-kanis", "createdAt": "2020-11-30T17:12:04Z", "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.security.MessageDigest;\n import java.util.*;", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5Njc2NA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533496764", "bodyText": "Thanks for spotting this", "author": "sguilhen", "createdAt": "2020-12-01T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTk2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java b/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\nindex 14ab906de6..9665ab5be6 100644\n--- a/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java\n\n@@ -19,7 +19,13 @@ package org.keycloak.services.resources.account;\n import java.net.URI;\n import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n-import java.util.*;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.UUID;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDQzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532770435", "bodyText": "Wouldn't be possible to extract this huge map body to a separate method for better readability?", "author": "martin-kanis", "createdAt": "2020-11-30T17:27:13Z", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,72 +52,64 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n-\n-            // Construct scope parameter with all optional scopes to see all potentially available roles\n-            Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                    client.getClientScopes(true, true).values().stream(),\n-                    client.getClientScopes(false, true).values().stream());\n-            allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-            Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-            // Don't show applications, which user doesn't have access into (any available roles)\n-            // unless this is can be changed by approving/revoking consent\n-            if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                continue;\n-            }\n-\n-            List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-            MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-            processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-            List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-            if (client.isConsentRequired()) {\n-                UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                if (consent != null) {\n-                    orderedScopes.addAll(consent.getGrantedClientScopes());\n-                }\n-            }\n-            List<String> clientScopesGranted = orderedScopes.stream()\n-                    .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                    .map(ClientScopeModel::getConsentScreenText)\n-                    .collect(Collectors.toList());\n-\n-            List<String> additionalGrants = new ArrayList<>();\n-            if (offlineClients.contains(client)) {\n-                additionalGrants.add(\"${offlineToken}\");\n-            }\n-\n-            applications.add(new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants));\n-        }\n+        this.applications = this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .map(client -> {", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzE0NA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497144", "bodyText": "Yeah, I could do that.", "author": "sguilhen", "createdAt": "2020-12-01T15:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDQzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java b/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\nindex f5710c227c..67fd692b77 100755\n--- a/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\n+++ b/services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java\n\n@@ -54,45 +54,7 @@ public class ApplicationsBean {\n \n         this.applications = this.getApplications(session, realm, user)\n                 .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n-                .map(client -> {\n-\n-                    // Construct scope parameter with all optional scopes to see all potentially available roles\n-                    Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                            client.getClientScopes(true, true).values().stream(),\n-                            client.getClientScopes(false, true).values().stream());\n-                    allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-                    Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-                    // Don't show applications, which user doesn't have access into (any available roles)\n-                    // unless this is can be changed by approving/revoking consent\n-                    if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                        return null;\n-                    }\n-\n-                    List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-                    MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-                    processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-                    List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-                    if (client.isConsentRequired()) {\n-                        UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                        if (consent != null) {\n-                            orderedScopes.addAll(consent.getGrantedClientScopes());\n-                        }\n-                    }\n-                    List<String> clientScopesGranted = orderedScopes.stream()\n-                            .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                            .map(ClientScopeModel::getConsentScreenText)\n-                            .collect(Collectors.toList());\n-\n-                    List<String> additionalGrants = new ArrayList<>();\n-                    if (offlineClients.contains(client)) {\n-                        additionalGrants.add(\"${offlineToken}\");\n-                    }\n-                    return new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants);\n-                })\n+                .map(client -> toApplicationEntry(session, realm, user, client, offlineClients))\n                 .filter(Objects::nonNull)\n                 .collect(Collectors.toList());\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779161", "bodyText": "Will be the getDisableableCredentialTypes method streamified?", "author": "martin-kanis", "createdAt": "2020-11-30T17:40:13Z", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzQ0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497441", "bodyText": "It could, I thought about it at the time I was making this change. I'll re-evaluate.", "author": "sguilhen", "createdAt": "2020-12-01T15:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0ODY2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533648662", "bodyText": "Done, it was indeed better to streamify this one as well.", "author": "sguilhen", "createdAt": "2020-12-01T18:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\nindex 0cd282a7f3..220a00852f 100644\n--- a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\n+++ b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\n\n@@ -226,12 +226,12 @@ public class UserCredentialStoreManager extends AbstractStorageManager<UserStora\n             if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n+            if (updater != null) types = updater.getDisableableCredentialTypesStream(realm, user);\n         }\n \n         return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n-                .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream));\n+                .flatMap(updater -> updater.getDisableableCredentialTypesStream(realm, user)))\n+                .distinct();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTg0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779845", "bodyText": "Maybe distinct() is missing?", "author": "martin-kanis", "createdAt": "2020-11-30T17:41:11Z", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n         }\n \n-        types.addAll(getCredentialProviders(session, CredentialInputUpdater.class)\n+        return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n                 .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream)\n-                .collect(Collectors.toSet()));\n-\n-        return types;\n+                .flatMap(Set::stream));", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5Nzk1Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497952", "bodyText": "Will double check", "author": "sguilhen", "createdAt": "2020-12-01T15:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\nindex 0cd282a7f3..220a00852f 100644\n--- a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\n+++ b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java\n\n@@ -226,12 +226,12 @@ public class UserCredentialStoreManager extends AbstractStorageManager<UserStora\n             if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n+            if (updater != null) types = updater.getDisableableCredentialTypesStream(realm, user);\n         }\n \n         return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n-                .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream));\n+                .flatMap(updater -> updater.getDisableableCredentialTypesStream(realm, user)))\n+                .distinct();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjIyOA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532796228", "bodyText": "Isn't the ConcurrentModificationException possible here?", "author": "martin-kanis", "createdAt": "2020-11-30T18:06:35Z", "path": "services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java", "diffHunk": "@@ -115,14 +116,11 @@ public CredentialModel createCredential(RealmModel realm, UserModel user, Passwo\n         }\n         \n         // 3) remove old password history items\n-        List<CredentialModel> passwordHistoryList = getCredentialStore().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n         final int passwordHistoryListMaxSize = Math.max(0, expiredPasswordsPolicyValue - 1);\n-        if (passwordHistoryList.size() > passwordHistoryListMaxSize) {\n-            passwordHistoryList.stream()\n-                    .sorted(CredentialModel.comparingByStartDateDesc())\n-                    .skip(passwordHistoryListMaxSize)\n-                    .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));\n-        }\n+        getCredentialStore().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY)\n+                .sorted(CredentialModel.comparingByStartDateDesc())\n+                .skip(passwordHistoryListMaxSize)\n+                .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzY5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497692", "bodyText": "Yes, thanks!", "author": "sguilhen", "createdAt": "2020-12-01T15:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java b/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java\nindex 040ce0f1bc..9b9de61a5d 100644\n--- a/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java\n+++ b/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java\n\n@@ -120,6 +119,7 @@ public class PasswordCredentialProvider implements CredentialProvider<PasswordCr\n         getCredentialStore().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY)\n                 .sorted(CredentialModel.comparingByStartDateDesc())\n                 .skip(passwordHistoryListMaxSize)\n+                .collect(Collectors.toList())\n                 .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));\n \n         UserCache userCache = session.userCache();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODk3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532828973", "bodyText": "Rather use Objects.equals as it's null safe.", "author": "martin-kanis", "createdAt": "2020-11-30T19:01:19Z", "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,18 +62,18 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODE5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498199", "bodyText": "Noted!", "author": "sguilhen", "createdAt": "2020-12-01T15:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java b/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\nindex 6ae819c933..74b061b6e6 100644\n--- a/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\n+++ b/services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java\n\n@@ -67,7 +68,7 @@ public abstract class UserIdentityToModelMapper {\n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n+                usersStream = usersStream.filter(user -> Objects.equals(user.getFirstAttribute(customAttribute), userIdentityValue));\n             }\n             List<UserModel> users = usersStream.collect(Collectors.toList());\n             if (users.size() > 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDU4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834583", "bodyText": "Rather use Objects.equals as it's null safe.", "author": "martin-kanis", "createdAt": "2020-11-30T19:11:00Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODMwNA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498304", "bodyText": "Noted!", "author": "sguilhen", "createdAt": "2020-12-01T15:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\nindex ab9ff06214..0c066d5bab 100644\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n\n@@ -118,18 +120,18 @@ public class JpaUserCredentialStore implements UserCredentialStore {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n     public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n+        return getStoredCredentialsStream(realm, user).filter(credential -> Objects.equals(type, credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n         return getStoredCredentialsStream(realm, user).filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))\n+                Objects.equals(type, credential.getType()) && Objects.equals(name, credential.getUserLabel()))\n                 .findFirst().orElse(null);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDkwNA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834904", "bodyText": "Again Objects.equals", "author": "martin-kanis", "createdAt": "2020-11-30T19:11:35Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n-        List<CredentialModel> results = getStoredCredentials(realm, user).stream().filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel())).collect(Collectors.toList());\n-        if (results.isEmpty()) return null;\n-        return results.get(0);\n+        return getStoredCredentialsStream(realm, user).filter(credential ->\n+                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODA0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498042", "bodyText": "Noted!", "author": "sguilhen", "createdAt": "2020-12-01T15:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\nindex ab9ff06214..0c066d5bab 100644\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n\n@@ -118,18 +120,18 @@ public class JpaUserCredentialStore implements UserCredentialStore {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n     public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n+        return getStoredCredentialsStream(realm, user).filter(credential -> Objects.equals(type, credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n         return getStoredCredentialsStream(realm, user).filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))\n+                Objects.equals(type, credential.getType()) && Objects.equals(name, credential.getUserLabel()))\n                 .findFirst().orElse(null);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzA5MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532837091", "bodyText": "It's sorted in SQL query. Is it needed to sort again with streams?", "author": "martin-kanis", "createdAt": "2020-11-30T19:15:19Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODYyOA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498628", "bodyText": "Ugh, I haven't checked the query.. I think you have a point, remember seeing a comment about it somewhere.", "author": "sguilhen", "createdAt": "2020-12-01T15:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\nindex ab9ff06214..0c066d5bab 100644\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java\n\n@@ -118,18 +120,18 @@ public class JpaUserCredentialStore implements UserCredentialStore {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n     public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n+        return getStoredCredentialsStream(realm, user).filter(credential -> Objects.equals(type, credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n         return getStoredCredentialsStream(realm, user).filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))\n+                Objects.equals(type, credential.getType()) && Objects.equals(name, credential.getUserLabel()))\n                 .findFirst().orElse(null);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDA2MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532840061", "bodyText": "Unused imports LinkedList, Collectors", "author": "martin-kanis", "createdAt": "2020-11-30T19:20:12Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -1022,27 +1022,20 @@ protected CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return credentialStore.getStoredCredentials(realm, user);\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return credentialStore.getStoredCredentialsStream(realm, user);\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        List<CredentialEntity> results;\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n         UserEntity userEntity = userInEntityManagerContext(user.getId());\n         if (userEntity != null) {\n-\n             // user already in persistence context, no need to execute a query\n-            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n+            return userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODc2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498766", "bodyText": "Noted!", "author": "sguilhen", "createdAt": "2020-12-01T15:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a278c1372b39f998c9832647150bc74abbab5d1f", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex 04a1f0672b..5224568fc0 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n\n@@ -1022,20 +1022,27 @@ public class JpaUserProvider implements UserProvider.Streams, UserCredentialStor\n     }\n \n     @Override\n-    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n-        return credentialStore.getStoredCredentialsStream(realm, user);\n+    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n+        return credentialStore.getStoredCredentials(realm, user);\n     }\n \n     @Override\n-    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n+        List<CredentialEntity> results;\n         UserEntity userEntity = userInEntityManagerContext(user.getId());\n         if (userEntity != null) {\n+\n             // user already in persistence context, no need to execute a query\n-            return userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n+            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n                     .sorted(Comparator.comparingInt(CredentialEntity::getPriority))\n-                    .map(this::toModel);\n+                    .collect(Collectors.toList());\n+            List<CredentialModel> rtn = new LinkedList<>();\n+            for (CredentialEntity entity : results) {\n+                rtn.add(toModel(entity));\n+            }\n+            return rtn;\n         } else {\n-           return credentialStore.getStoredCredentialsByTypeStream(realm, user, type);\n+           return credentialStore.getStoredCredentialsByType(realm, user, type);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NTQyNg==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532845426", "bodyText": "Maybe worth to consider this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n          \n          \n            \n                        if (session.userCredentialManager()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n          \n          \n            \n                                .map(PasswordCredentialModel::createFromCredentialModel)\n          \n          \n            \n                                .anyMatch(passwordCredential -> {\n          \n          \n            \n                                    PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n          \n          \n            \n                                    return hash != null && hash.verify(password, passwordCredential);\n          \n          \n            \n                                })) {\n          \n          \n            \n                            return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n          \n          \n            \n                        }", "author": "martin-kanis", "createdAt": "2020-11-30T19:29:16Z", "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5OTA0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533499046", "bodyText": "Ahh, yes, this looks a lot better, thanks for the suggestion.", "author": "sguilhen", "createdAt": "2020-12-01T15:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NTQyNg=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\nindex 759a507260..350b15ba4b 100644\n--- a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\n+++ b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\n\n@@ -54,28 +54,26 @@ public class HistoryPasswordPolicyProvider implements PasswordPolicyProvider {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n-                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+            if (session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n                     .map(PasswordCredentialModel::createFromCredentialModel)\n-                    .collect(Collectors.toList());\n-            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n-                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash != null && hash.verify(password, passwordCredential)) {\n-                    return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n-                }\n+                    .anyMatch(passwordCredential -> {\n+                        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class,\n+                                passwordCredential.getPasswordCredentialData().getAlgorithm());\n+                        return hash != null && hash.verify(password, passwordCredential);\n+                    })) {\n+                return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                if (this.getRecent(session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY),\n+                        passwordHistoryPolicyValue - 1)\n                         .map(PasswordCredentialModel::createFromCredentialModel)\n-                        .collect(Collectors.toList());\n-                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {\n-                    PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                    if (hash.verify(password, passwordCredential)) {\n-                        return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n-                    }\n-\n+                        .anyMatch(passwordCredential -> {\n+                            PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class,\n+                                    passwordCredential.getPasswordCredentialData().getAlgorithm());\n+                            return hash.verify(password, passwordCredential);\n+                        })) {\n+                    return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NjQ1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532846451", "bodyText": "Maybe something similar could be used as in suggestion above.", "author": "martin-kanis", "createdAt": "2020-11-30T19:30:47Z", "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n+                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+                    .map(PasswordCredentialModel::createFromCredentialModel)\n+                    .collect(Collectors.toList());\n+            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n                 PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash == null) continue;\n-                if (hash.verify(password, passwordCredential)) {\n+                if (hash != null && hash.verify(password, passwordCredential)) {\n                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<CredentialModel> recentPasswordHistory = getRecent(passwordHistory, passwordHistoryPolicyValue - 1);\n-                for (CredentialModel cred : recentPasswordHistory) {\n-                    PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n+                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                        .map(PasswordCredentialModel::createFromCredentialModel)\n+                        .collect(Collectors.toList());\n+                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {", "originalCommit": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5OTEzOA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533499138", "bodyText": "Definitely!", "author": "sguilhen", "createdAt": "2020-12-01T15:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NjQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\nindex 759a507260..350b15ba4b 100644\n--- a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\n+++ b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java\n\n@@ -54,28 +54,26 @@ public class HistoryPasswordPolicyProvider implements PasswordPolicyProvider {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n-                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+            if (session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n                     .map(PasswordCredentialModel::createFromCredentialModel)\n-                    .collect(Collectors.toList());\n-            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n-                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash != null && hash.verify(password, passwordCredential)) {\n-                    return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n-                }\n+                    .anyMatch(passwordCredential -> {\n+                        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class,\n+                                passwordCredential.getPasswordCredentialData().getAlgorithm());\n+                        return hash != null && hash.verify(password, passwordCredential);\n+                    })) {\n+                return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                if (this.getRecent(session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY),\n+                        passwordHistoryPolicyValue - 1)\n                         .map(PasswordCredentialModel::createFromCredentialModel)\n-                        .collect(Collectors.toList());\n-                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {\n-                    PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                    if (hash.verify(password, passwordCredential)) {\n-                        return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n-                    }\n-\n+                        .anyMatch(passwordCredential -> {\n+                            PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class,\n+                                    passwordCredential.getPasswordCredentialData().getAlgorithm());\n+                            return hash.verify(password, passwordCredential);\n+                        })) {\n+                    return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n         }\n"}}, {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "url": "https://github.com/keycloak/keycloak/commit/80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-12-01T19:26:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3ODc5MA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534178790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Optional<CredentialModel> existing = session.userFederatedStorage()\n          \n          \n            \n                        return session.userFederatedStorage()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\")\n          \n          \n            \n                                .map(CredentialModel::getSecretData)\n          \n          \n            \n                                .anyMatch(Predicate.isEqual(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\"));", "author": "martin-kanis", "createdAt": "2020-12-02T13:47:58Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -80,9 +82,12 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n              if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {\n                  return true;\n              }\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) return false;\n-            return existing.get(0).getSecretData().equals(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\");\n+            Optional<CredentialModel> existing = session.userFederatedStorage()", "originalCommit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5NjA0NA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534596044", "bodyText": "Thanks for the suggestion, it is indeed clearer.", "author": "sguilhen", "createdAt": "2020-12-03T01:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3ODc5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9851cfdc7a1881bd1cebd8116df2eecf9147468d", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java\nindex 2ad5002da2..32760be72f 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java\n\n@@ -82,12 +83,9 @@ public class PassThroughFederatedUserStorageProvider implements\n              if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {\n                  return true;\n              }\n-            Optional<CredentialModel> existing = session.userFederatedStorage()\n-                    .getStoredCredentialsByTypeStream(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\")\n-                    .findFirst();\n-            if (existing.isPresent())\n-                return existing.get().getSecretData().equals(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\");\n-            return false;\n+            return session.userFederatedStorage().getStoredCredentialsByTypeStream(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\")\n+                    .map(credentialModel -> credentialModel.getSecretData())\n+                    .anyMatch(Predicate.isEqual(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\"));\n         }\n         return false;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534303300", "bodyText": "You switched the content between if and else blocks on purpose?", "author": "martin-kanis", "createdAt": "2020-12-02T16:25:51Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -91,18 +96,19 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n         // testing federated credential attributes\n         if (input.getType().equals(PasswordCredentialModel.TYPE)) {\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) {", "originalCommit": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5NzM0Mw==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534597343", "bodyText": "Yeah, do you think I should have preserved the original logic instead?", "author": "sguilhen", "createdAt": "2020-12-03T01:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc0OTYzOA==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534749638", "bodyText": "No it's OK. I didn't notice the difference in existing.isEmpty() vs existing.isPresent() :)", "author": "martin-kanis", "createdAt": "2020-12-03T06:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d", "url": "https://github.com/keycloak/keycloak/commit/9851cfdc7a1881bd1cebd8116df2eecf9147468d", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-12-03T01:27:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzMzI4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r535933289", "bodyText": "Please keep the original variant in this particular storage.", "author": "hmlnarik", "createdAt": "2020-12-04T08:50:43Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "diffHunk": "@@ -209,15 +207,9 @@ private MyUser getMyUser(UserModel user) {\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n-\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {", "originalCommit": "9851cfdc7a1881bd1cebd8116df2eecf9147468d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a278c1372b39f998c9832647150bc74abbab5d1f", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java\nindex 35072695ad..89e7585c5f 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java\n\n@@ -207,9 +209,15 @@ public class BackwardsCompatibilityUserStorage implements UserLookupProvider, Us\n     }\n \n     @Override\n-    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n+        Set<String> types = new HashSet<>();\n+\n         MyUser myUser = getMyUser(user);\n-        return (myUser != null && myUser.otp != null) ? Stream.of(CredentialModel.OTP) : Stream.empty();\n+        if (myUser != null && myUser.otp != null) {\n+            types.add(CredentialModel.OTP);\n+        }\n+\n+        return types;\n     }\n \n     @Override\n"}}, {"oid": "a278c1372b39f998c9832647150bc74abbab5d1f", "url": "https://github.com/keycloak/keycloak/commit/a278c1372b39f998c9832647150bc74abbab5d1f", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants", "committedDate": "2020-12-07T13:15:45Z", "type": "commit"}, {"oid": "f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "url": "https://github.com/keycloak/keycloak/commit/f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-12-07T13:15:45Z", "type": "forcePushed"}, {"oid": "5ef87c568740141848eb305353f8bdf472c88d2d", "url": "https://github.com/keycloak/keycloak/commit/5ef87c568740141848eb305353f8bdf472c88d2d", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-12-07T16:47:29Z", "type": "commit"}, {"oid": "5ef87c568740141848eb305353f8bdf472c88d2d", "url": "https://github.com/keycloak/keycloak/commit/5ef87c568740141848eb305353f8bdf472c88d2d", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces", "committedDate": "2020-12-07T16:47:29Z", "type": "forcePushed"}]}