{"pr_number": 7657, "pr_title": "KEYCLOAK-11908 Support for conditional creating indices based on number", "pr_createdAt": "2020-12-03T04:06:45Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7657", "timeline": [{"oid": "74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "url": "https://github.com/keycloak/keycloak/commit/74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-07T02:49:29Z", "type": "forcePushed"}, {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "url": "https://github.com/keycloak/keycloak/commit/f997c299d53b316f4c1a45c05549f2b96a4117ce", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-11T04:12:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540835670", "bodyText": "nit: missing copyright comment", "author": "vramik", "createdAt": "2020-12-11T10:11:22Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NjkxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542186915", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjAwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236005", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540836924", "bodyText": "If I understand it correctly this check is here to test if the table actually exist, am I right? If so I wonder if the check is necessary.", "author": "vramik", "createdAt": "2020-12-11T10:13:19Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NzQ5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542187496", "bodyText": "If this check not exists, the initial startup fails.", "author": "y-tabata", "createdAt": "2020-12-14T08:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4ODk3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544188979", "bodyText": "You're right. The reason why it fails is the fact that generateStatements(Database) is called during validation and other stuff multiple times when the table doesn't have to be there yet. Maybe it'd be worth to add a // comment with the info to this check as well, wdyt?", "author": "vramik", "createdAt": "2020-12-16T10:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NzExOA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544647118", "bodyText": "Added a comment.", "author": "y-tabata", "createdAt": "2020-12-16T21:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzUyNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540843524", "bodyText": "Have you chance to test this sql in various databases like MySQL, Oracle, Portgres and MSSQL? It seems there is missing whitespace character after from keyword.\nIf I remember correctly there is also a need to properly escape schema for select statements when the table name is retrieved. Please see CustomKeycloakTask.getTableName(String) for more details.", "author": "vramik", "createdAt": "2020-12-11T10:24:14Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188045", "bodyText": "Modified. And I tested on PostgreSQL.", "author": "y-tabata", "createdAt": "2020-12-14T08:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDYyNw==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540844627", "bodyText": "Could @DatabaseChange annotation be used directly instead of overriding this method?", "author": "vramik", "createdAt": "2020-12-11T10:25:57Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n+\n+            if (result > (Integer) indexCreationThreshold) {\n+                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n+                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n+                return new SqlStatement[] {};\n+            }\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    @Override\n+    public ChangeMetaData createChangeMetaData() {", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODE0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188145", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540846141", "bodyText": "I'd suggest to add a // comment with a note the CustomCreateIndexChange is registered for handle conditional indices creation", "author": "vramik", "createdAt": "2020-12-11T10:28:17Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODIxMg==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188212", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNTkxNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544235914", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\nindex 6f4279282d..753a226d3e 100644\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\n\n@@ -116,13 +113,11 @@ public class DefaultLiquibaseConnectionProvider implements LiquibaseConnectionPr\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-\n-        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);\n     }\n \n     @Override\n     public void init(Config.Scope config) {\n-        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 10000);\n+        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 100000);\n         logger.debugf(\"indexCreationThreshold is %d\", indexCreationThreshold);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540848405", "bodyText": "I'd suggest to add // comment where could be specified that this check is here for manual migration. It should be easily overlooked and the comment should help.", "author": "vramik", "createdAt": "2020-12-11T10:32:00Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODI5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188299", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjA4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236086", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDEwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540864105", "bodyText": "The intention is to avoid tens of seconds spent on index creation upon upgrade, so I think 100000 would be still perfectly acceptable.", "author": "vramik", "createdAt": "2020-12-11T10:58:05Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);\n+    }\n \n     @Override\n     public void init(Config.Scope config) {\n-\n+        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 10000);", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODQ1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188451", "bodyText": "Changed.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDEwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\nindex 6f4279282d..753a226d3e 100644\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java\n\n@@ -116,13 +113,11 @@ public class DefaultLiquibaseConnectionProvider implements LiquibaseConnectionPr\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-\n-        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);\n     }\n \n     @Override\n     public void init(Config.Scope config) {\n-        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 10000);\n+        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 100000);\n         logger.debugf(\"indexCreationThreshold is %d\", indexCreationThreshold);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MDg1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540880855", "bodyText": "I'd suggest to introduce private int indexCreationThreshold; in this class and I'd also suggest following\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n          \n          \n            \n                    if (indexCreationThreshold instanceof Integer) {\n          \n          \n            \n                        this.indexCreationThreshold = (Integer) indexCreationThreshold;\n          \n          \n            \n                        if (this.indexCreationThreshold <= 0) return super.generateStatements(database);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return super.generateStatements(database);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\ninstanceof  should take care of null and we can avoid type casting on line 50. wdyt?", "author": "vramik", "createdAt": "2020-12-11T11:27:52Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODU5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188593", "bodyText": "Changed.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MDg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bce93fb0c80e637282040e762ca880e1e5542ce0", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\ndeleted file mode 100644\nindex 4556d3c8c1..0000000000\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-package org.keycloak.connections.jpa.updater.liquibase.custom;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-\n-import org.jboss.logging.Logger;\n-import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n-\n-import liquibase.change.ChangeMetaData;\n-import liquibase.change.DatabaseChange;\n-import liquibase.change.DatabaseChangeNote;\n-import liquibase.change.core.CreateIndexChange;\n-import liquibase.database.AbstractJdbcDatabase;\n-import liquibase.database.Database;\n-import liquibase.exception.DatabaseException;\n-import liquibase.exception.UnexpectedLiquibaseException;\n-import liquibase.executor.ExecutorService;\n-import liquibase.executor.LoggingExecutor;\n-import liquibase.snapshot.InvalidExampleException;\n-import liquibase.snapshot.SnapshotGeneratorFactory;\n-import liquibase.statement.SqlStatement;\n-import liquibase.statement.core.RawSqlStatement;\n-import liquibase.structure.core.Index;\n-import liquibase.structure.core.Schema;\n-import liquibase.structure.core.Table;\n-\n-public class CustomCreateIndexChange extends CreateIndexChange {\n-    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n-\n-    @Override\n-    public SqlStatement[] generateStatements(Database database) {\n-        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n-            return super.generateStatements(database);\n-\n-        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n-            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n-\n-        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n-            return super.generateStatements(database);\n-\n-        try {\n-            if (!SnapshotGeneratorFactory.getInstance()\n-                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n-                return super.generateStatements(database);\n-\n-            int result = ExecutorService.getInstance().getExecutor(database)\n-                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n-\n-            if (result > (Integer) indexCreationThreshold) {\n-                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n-                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n-                return new SqlStatement[] {};\n-            }\n-        } catch (DatabaseException | InvalidExampleException e) {\n-            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n-        }\n-\n-        return super.generateStatements(database);\n-    }\n-\n-    @Override\n-    public ChangeMetaData createChangeMetaData() {\n-        ChangeMetaData changeMetaData = super.createChangeMetaData();\n-        DatabaseChange databaseChange = this.getClass().getAnnotation(DatabaseChange.class);\n-\n-        if (databaseChange == null) {\n-            throw new UnexpectedLiquibaseException(\"No @DatabaseChange annotation for \" + getClass().getName());\n-        }\n-\n-        Map<String, String> notes = new HashMap<String, String>();\n-        for (DatabaseChangeNote note : databaseChange.databaseNotes()) {\n-            notes.put(note.database(), note.notes());\n-        }\n-\n-        return new ChangeMetaData(changeMetaData.getName(), changeMetaData.getDescription(), changeMetaData.getPriority() + 1,\n-            changeMetaData.getAppliesTo().toArray(new String[changeMetaData.getAppliesTo().size()]), notes,\n-            new HashSet<>(changeMetaData.getParameters().values()));\n-    }\n-}\n"}}, {"oid": "bce93fb0c80e637282040e762ca880e1e5542ce0", "url": "https://github.com/keycloak/keycloak/commit/bce93fb0c80e637282040e762ca880e1e5542ce0", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-14T07:49:22Z", "type": "forcePushed"}, {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "url": "https://github.com/keycloak/keycloak/commit/052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-15T05:49:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544343881", "bodyText": "What'd you say about idea to create make DefaultLiquibaseConnectionProvider.indexCreationThreshold static and to introduce\n    public static int getIndexCreationThreshold() {\n        return indexCreationThreshold;\n    }\n\nthere? We'd then be able to use\nif (DefaultLiquibaseConnectionProvider.getIndexCreationThreshold() <= 0)\n                return super.generateStatements(database);\n\nhere instead of parsing Integer from attributes.", "author": "vramik", "createdAt": "2020-12-16T14:31:20Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)", "originalCommit": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQzNzYzNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544437634", "bodyText": "I'd say if the indexCreationThreshold would need to be static, then the current approach is cleaner.", "author": "hmlnarik", "createdAt": "2020-12-16T16:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0OTQ1MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544649450", "bodyText": "@vramik @hmlnarik\nI keep this implementation as-is.", "author": "y-tabata", "createdAt": "2020-12-16T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "486733f8f8fc557a94ee93072eba08eed8daea74", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\nindex 69234f13da..404c3e74fe 100644\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n\n@@ -71,6 +71,7 @@ public class CustomCreateIndexChange extends CreateIndexChange {\n             return super.generateStatements(database);\n         }\n         try {\n+            // To check that the table already exists or not on which the index will be created.\n             if (!SnapshotGeneratorFactory.getInstance()\n                 .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n                 return super.generateStatements(database);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODU2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544348565", "bodyText": "Can we avoid overriding this and following two methods?", "author": "vramik", "createdAt": "2020-12-16T14:37:27Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold instanceof Integer) {\n+            this.indexCreationThreshold = (Integer) indexCreationThreshold;\n+            if (this.indexCreationThreshold <= 0)\n+                return super.generateStatements(database);\n+        } else {\n+            return super.generateStatements(database);\n+        }\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database).queryForInt(\n+                new RawSqlStatement(\"SELECT COUNT(*) FROM \" + getTableNameForSqlSelects(database, getTableName())));\n+\n+            if (result > this.indexCreationThreshold) {\n+                String loggingString = createLoggingString(database);\n+                logger.warnv(\"Following index should be created: {0}\", loggingString);\n+                getChangeSet().setComments(loggingString);\n+                return new SqlStatement[] {};\n+            }\n+\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    private String getTableNameForSqlSelects(Database database, String tableName) {\n+        String correctedSchemaName = database.escapeObjectName(database.getDefaultSchemaName(), Schema.class);\n+        return LiquibaseJpaUpdaterProvider.getTable(tableName, correctedSchemaName);\n+    }\n+\n+    private String createLoggingString(Database database) throws DatabaseException {\n+        StringWriter writer = new StringWriter();\n+        LoggingExecutor loggingExecutor = new LoggingExecutor(ExecutorService.getInstance().getExecutor(database), writer,\n+            database);\n+        SqlStatement sqlStatement = new CreateIndexStatement(getIndexName(), getCatalogName(), getSchemaName(), getTableName(),\n+            this.isUnique(), getAssociatedWith(), getColumns().toArray(new AddColumnConfig[getColumns().size()]))\n+                .setTablespace(getTablespace()).setClustered(getClustered());\n+\n+        loggingExecutor.execute(sqlStatement);\n+\n+        return writer.toString();\n+    }\n+\n+    @Override\n+    public boolean generateStatementsVolatile(Database database) {", "originalCommit": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NzU4MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544657580", "bodyText": "Without these 3 override methods and without expressly calling the generateStatements method of the superclass, the generateStatements method of this class is called 14 times in one migration (so the warning outputs 14 times).\nI also considered the way to add if which judges the caller method by using stack trace in the generateStatements method, but I think the current way is smarter.\nIf there is a better way, I'm happy if you tell me.", "author": "y-tabata", "createdAt": "2020-12-16T22:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "486733f8f8fc557a94ee93072eba08eed8daea74", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\nindex 69234f13da..404c3e74fe 100644\n--- a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java\n\n@@ -71,6 +71,7 @@ public class CustomCreateIndexChange extends CreateIndexChange {\n             return super.generateStatements(database);\n         }\n         try {\n+            // To check that the table already exists or not on which the index will be created.\n             if (!SnapshotGeneratorFactory.getInstance()\n                 .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n                 return super.generateStatements(database);\n"}}, {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-16T21:46:29Z", "type": "commit"}, {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-16T21:46:29Z", "type": "forcePushed"}]}