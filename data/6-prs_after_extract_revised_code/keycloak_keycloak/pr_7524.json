{"pr_number": 7524, "pr_title": "[KEYCLOAK-15200] Complement methods for accessing users with Stream v\u2026", "pr_createdAt": "2020-10-21T17:35:10Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7524", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511784406", "bodyText": "ldapQuery.getResultList() doesn't seem to return null so maybe this if may be removed?", "author": "martin-kanis", "createdAt": "2020-10-26T08:23:53Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -257,23 +256,18 @@ public boolean supportsCredentialAuthenticationFor(String type) {\n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n              if (ldapObjects == null || ldapObjects.isEmpty()) {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NDgwMg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511984802", "bodyText": "Yeah, good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -255,10 +256,6 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n-             if (ldapObjects == null || ldapObjects.isEmpty()) {\n-                 return Stream.empty();\n-             }\n-\n              return ldapObjects.stream().map(ldapUser -> {\n                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n                  UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511794014", "bodyText": "I think we need to be more careful with skip which throws an IllegalArgumentException when a negative number is provided.", "author": "martin-kanis", "createdAt": "2020-10-26T08:41:43Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTMwMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985300", "bodyText": "You are right, I think I've added some guards somewhere but forgot to check all other places", "author": "sguilhen", "createdAt": "2020-10-26T14:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511799229", "bodyText": "This lambda can be avoided like this: ((Predicate<List>) List::isEmpty).negate()", "author": "martin-kanis", "createdAt": "2020-10-26T08:51:05Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTQzOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985438", "bodyText": "I like the suggestion, will change it.", "author": "sguilhen", "createdAt": "2020-10-26T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511800715", "bodyText": "Maybe it can be simplified like\nreturn...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());", "author": "martin-kanis", "createdAt": "2020-10-26T08:53:45Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjQyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986420", "bodyText": "I suppose this would work, yes. I will make the change", "author": "sguilhen", "createdAt": "2020-10-26T14:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NDUyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512274520", "bodyText": "Prefer list.isEmpty() to list.size() where possible. The former is simple check while the latter may need to enumerate the items e.g. in case of LinkedList", "author": "hmlnarik", "createdAt": "2020-10-26T21:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801460", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:00Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjUzMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986530", "bodyText": "Noted", "author": "sguilhen", "createdAt": "2020-10-26T14:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTU3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801572", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:10Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)\n+                .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex 1c8f5d22b0..45d34e572f 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -387,11 +384,16 @@ public class LDAPStorageProvider implements UserStorageProvider,\n             }\n         }\n \n-        List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n-            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n-            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n-        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n+        Stream<LDAPObject> stream = searchLDAP(realm, params).stream()\n+            .filter(ldapObject -> {\n+                String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+            });\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511833444", "bodyText": "Is this equal to the collection variant? Shouldn't there be Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct(); ?", "author": "martin-kanis", "createdAt": "2020-10-26T09:47:50Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java", "diffHunk": "@@ -299,18 +300,13 @@ public void removeRequiredAction(String action) {\n         }\n \n         @Override\n-        public Set<String> getRequiredActions() {\n-            Set<String> requiredActions = super.getRequiredActions();\n-\n+        public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    requiredActions = new HashSet<>(requiredActions);\n-                    requiredActions.add(RequiredAction.UPDATE_PASSWORD.toString());\n-                    return requiredActions;\n+                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMDU0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512000547", "bodyText": "You are absolutely right, I misread the if() section and didn't see the creation of the collection with the values already obtained by calling super.getRequiredActions().", "author": "sguilhen", "createdAt": "2020-10-26T14:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\nindex 78174a882f..b76ecf641a 100644\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java\n\n@@ -303,7 +303,8 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp\n         public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());\n+                    return Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString()))\n+                            .distinct();\n                 }\n             }\n             return super.getRequiredActionsStream();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511857287", "bodyText": "Couldn't we just return already obtained identities? federatedIdentities.stream();?", "author": "martin-kanis", "createdAt": "2020-10-26T10:27:18Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -578,64 +576,65 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n-        return getDelegate().getUsers(realm, firstResult, maxResults, includeServiceAccounts);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n+        return getDelegate().getUsersStream(realm, firstResult, maxResults, includeServiceAccounts);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        return getUsers(realm, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return getUsersStream(realm, false);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-         return getUsers(realm, firstResult, maxResults, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+         return getUsersStream(realm, firstResult, maxResults, false);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return getDelegate().searchForUser(search, realm);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        return getDelegate().searchForUserStream(search, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(search, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(search, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return getDelegate().searchForUser(attributes, realm);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return getDelegate().searchForUserStream(attributes, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(attributes, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(attributes, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return getDelegate().searchForUserByUserAttribute(attrName, attrValue, realm);\n+    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n+        return getDelegate().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         logger.tracev(\"getFederatedIdentities: {0}\", user.getUsername());\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentities(user, realm);\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);\n         }\n \n         CachedFederatedIdentityLinks cachedLinks = cache.get(cacheKey, CachedFederatedIdentityLinks.class);\n \n         if (cachedLinks == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentities(user, realm);\n+            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(user, realm)\n+                    .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return federatedIdentities;\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzE1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003155", "bodyText": "Yeah, we could do that. This is one of the places where using streams leads to code that is a bit odd - we get a stream, consume it into a collection, then get the cached collection and streamify it again.", "author": "sguilhen", "createdAt": "2020-10-26T14:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n\n@@ -632,7 +632,7 @@ public class UserCacheSession implements UserCache {\n                     .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return getDelegate().getFederatedIdentitiesStream(user, realm);\n+            return federatedIdentities.stream();\n         } else {\n             return cachedLinks.getFederatedIdentities().stream();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODQ0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511858445", "bodyText": "Couldn't we just return already obtained consents? consents.stream();?", "author": "martin-kanis", "createdAt": "2020-10-26T10:29:14Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -708,31 +707,25 @@ public UserConsentModel getConsentByClient(RealmModel realm, String userId, Stri\n     }\n \n     @Override\n-    public List<UserConsentModel> getConsents(RealmModel realm, String userId) {\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n         logger.tracev(\"getConsents: {0}\", userId);\n \n         String cacheKey = getConsentCacheKey(userId);\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(userId) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getConsents(realm, userId);\n+            return getDelegate().getConsentsStream(realm, userId);\n         }\n \n         CachedUserConsents cached = cache.get(cacheKey, CachedUserConsents.class);\n \n         if (cached == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            List<UserConsentModel> consents = getDelegate().getConsents(realm, userId);\n+            List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return consents;\n+            return getDelegate().getConsentsStream(realm, userId);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\nindex d7657ebd7e..6a0c37e105 100755\n--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java\n\n@@ -722,7 +722,7 @@ public class UserCacheSession implements UserCache {\n             List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return getDelegate().getConsentsStream(realm, userId);\n+            return consents.stream();\n         } else {\n             return cached.getConsents().values().stream().map(cachedConsent -> toConsentModel(realm, cachedConsent))\n                     .filter(Objects::nonNull);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511861718", "bodyText": "I know you didn't introduce this star import but maybe it's right time to fix it now :)", "author": "martin-kanis", "createdAt": "2020-10-26T10:34:37Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -59,8 +59,13 @@\n import javax.persistence.criteria.Subquery;\n import java.util.*;", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODI5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998293", "bodyText": "Hahaha, good catch. Will change it :D", "author": "sguilhen", "createdAt": "2020-10-26T14:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\nindex da111a9ec3..050355e4b7 100755\n--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java\n\n@@ -54,10 +54,21 @@ import javax.persistence.TypedQuery;\n import javax.persistence.criteria.CriteriaBuilder;\n import javax.persistence.criteria.CriteriaQuery;\n import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.Join;\n import javax.persistence.criteria.Predicate;\n import javax.persistence.criteria.Root;\n import javax.persistence.criteria.Subquery;\n-import java.util.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511889665", "bodyText": "Missing closing of the stream.", "author": "martin-kanis", "createdAt": "2020-10-26T11:25:13Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -164,12 +163,12 @@ public void removeAttribute(RealmModel realm, String userId, String name) {\n     }\n \n     @Override\n-    public List<String> getUsersByUserAttribute(RealmModel realm, String name, String value) {\n+    public Stream<String> getUsersByUserAttributeStream(RealmModel realm, String name, String value) {\n         TypedQuery<String> query = em.createNamedQuery(\"getFederatedAttributesByNameAndValue\", String.class)\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultList();\n+        return query.getResultStream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODUwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998505", "bodyText": "Nice catch, thanks", "author": "sguilhen", "createdAt": "2020-10-26T14:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n\n@@ -168,7 +168,7 @@ public class JpaUserFederatedStorageProvider implements\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultStream();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511891983", "bodyText": "Maybe also use distinct() here.", "author": "martin-kanis", "createdAt": "2020-10-26T11:29:45Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -489,28 +476,21 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n         if (max != -1) {\n             query.setMaxResults(max);\n         }\n-\n-        return query.getResultList();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n-    public Set<String> getRequiredActions(RealmModel realm, String userId) {\n-        Set<String> set = new HashSet<>();\n-        List<FederatedUserRequiredActionEntity> values = getRequiredActionEntities(realm, userId, LockModeType.NONE);\n-        for (FederatedUserRequiredActionEntity entity : values) {\n-            set.add(entity.getAction());\n-        }\n-\n-        return set;\n-\n+    public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n+        return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n+                map(FederatedUserRequiredActionEntity::getAction);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzk2NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003964", "bodyText": "Yeah, definitely.", "author": "sguilhen", "createdAt": "2020-10-26T14:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\nindex 9696283532..ee4c4f5ca3 100644\n--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java\n\n@@ -482,7 +482,7 @@ public class JpaUserFederatedStorageProvider implements\n     @Override\n     public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n         return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n-                map(FederatedUserRequiredActionEntity::getAction);\n+                map(FederatedUserRequiredActionEntity::getAction).distinct();\n     }\n \n     private Stream<FederatedUserRequiredActionEntity> getRequiredActionEntitiesStream(RealmModel realm, String userId, LockModeType lockMode) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896260", "bodyText": "You kept the original deprecated method on purpose?", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:22Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {\n         return value;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3OTQxNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512079416", "bodyText": "No, that was definitely a brain fart :)", "author": "sguilhen", "createdAt": "2020-10-26T16:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n\n@@ -151,18 +151,10 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes.getFirst(name);\n     }\n \n-    @Override\n-    public List<String> getAttribute(String name) {\n-        List<String> value = attributes.get(name);\n-        if (value == null) {\n-            return new LinkedList<>();\n-        }\n-        return value;\n-    }\n-\n     @Override\n     public Stream<String> getAttributeStream(String name) {\n-        return this.getAttribute(name).stream();\n+        List<String> value = this.attributes.get(name);\n+        return value != null ? value.stream() : Stream.empty();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896360", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:33Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -170,6 +175,11 @@ public String getFirstAttribute(String name) {\n         return requiredActions;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\nindex b2dae45f12..0d1471e5a2 100644\n--- a/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n+++ b/server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java\n\n@@ -170,14 +162,9 @@ public class InMemoryUserAdapter extends UserModelDefaultMethods {\n         return attributes;\n     }\n \n-    @Override\n-    public Set<String> getRequiredActions() {\n-        return requiredActions;\n-    }\n-\n     @Override\n     public Stream<String> getRequiredActionsStream() {\n-        return this.getRequiredActions().stream();\n+        return this.requiredActions.stream();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5OTM1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511899353", "bodyText": "Missing Javadoc.", "author": "martin-kanis", "createdAt": "2020-10-26T11:44:16Z", "path": "server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java", "diffHunk": "@@ -38,6 +38,15 @@\n \n     void joinGroup(RealmModel realm, String userId, GroupModel group);\n     void leaveGroup(RealmModel realm, String userId, GroupModel group);\n-    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n+\n+    /**\n+     * @deprecated Use {@link #getMembershipStream(RealmModel, GroupModel, int, int) getMembershipStream} instead.\n+     */\n+    @Deprecated\n+    default List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+        return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n+    }\n+\n+    Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\nindex 1a86551614..aad956d471 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java\n\n@@ -47,6 +47,15 @@ public interface UserGroupMembershipFederatedStorage {\n         return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Obtains the federated users that are members of the given {@code group} in the specified {@code realm}.\n+     *\n+     * @param realm a reference to the realm.\n+     * @param group a reference to the group whose federated members are being searched.\n+     * @param firstResult first result to return. Ignored if negative.\n+     * @param max maximum number of results to return. Ignored if negative.\n+     * @return a non-null {@code Stream} of federated user ids that are members of the group in the realm.\n+     */\n     Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511911685", "bodyText": "To avoid extra lambda  (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();", "author": "martin-kanis", "createdAt": "2020-10-26T12:08:19Z", "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -126,10 +122,8 @@ default int getUsersCount(Map<String, String> params, RealmModel realm, Set<Stri\n      * @param groupIds id of groups that should be checked for\n      * @return number of users that are in at least one of the groups\n      */\n-    static int countUsersInGroups(List<UserModel> users, Set<String> groupIds) {\n-        return (int) users.stream()\n-                .filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId())))\n-                .count();\n+    static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n+        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzA2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511997068", "bodyText": "Thanks for the suggestion, definitely worth changing.", "author": "sguilhen", "createdAt": "2020-10-26T14:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\nindex 6c703650c1..8e8de6ad5b 100644\n--- a/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n+++ b/server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java\n\n@@ -123,7 +123,7 @@ public interface UserQueryProvider {\n      * @return number of users that are in at least one of the groups\n      */\n     static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n-        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();\n+        return (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511955159", "bodyText": "I'm wondering if we should time bound the results from federated storage same as we did in ClientStorageManager.searchClientsByClientIdStream whenever we concat local and federated entities.", "author": "martin-kanis", "createdAt": "2020-10-26T13:24:00Z", "path": "services/src/main/java/org/keycloak/storage/UserStorageManager.java", "diffHunk": "@@ -608,14 +600,13 @@ public UserModel getServiceAccount(ClientModel client) {\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n-        Set<FederatedIdentityModel> set = new HashSet<>();\n-        if (StorageId.isLocalStorage(user)) {\n-            set.addAll(localStorage().getFederatedIdentities(user, realm));\n-        }\n-        if (getFederatedStorage() != null) set.addAll(getFederatedStorage().getFederatedIdentities(user.getId(), realm));\n-        return set;\n+        Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n+                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n+        if (getFederatedStorage() != null)\n+            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NjE3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511996173", "bodyText": "I will check this", "author": "sguilhen", "createdAt": "2020-10-26T14:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NTYwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512275605", "bodyText": "@mhajas FYI", "author": "hmlnarik", "createdAt": "2020-10-26T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ4MjA2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512482069", "bodyText": "Well, this is a good question. However, I don't think we should. The federatedStorage is something little bit confusing, I spent quite a lot of time on investigating what is it for. If I understand correctly, this is the point: if you have some users, from external storage/provider and you are not able to store some keycloak specific properties (attributes, roles, groups etc.) in that external storage, you can configure keycloak to store it for you using this federatedStorage. For example you store a user with id id_pointing_to_external_storage have roles admin and manager. So whenever there is a call to federatedStorage for FederatedIdentityModel, it should be a call to a database/map storage (in future). See current jpa implementation.\nTherefore, If we would time bound federated storage, the same logic would apply also to localStorage() and I don't like this idea. WDYT?", "author": "mhajas", "createdAt": "2020-10-27T08:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzM1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r514437355", "bodyText": "Given @mhajas comment, I'm leaving it as is for now.", "author": "sguilhen", "createdAt": "2020-10-29T17:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzcwNw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511957707", "bodyText": "Here again \"-1\" in skip will cause an IllegalStateException.", "author": "martin-kanis", "createdAt": "2020-10-26T13:27:56Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n\n@@ -298,11 +298,12 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream().sorted();\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTU2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511959568", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:30:21Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)\n           .limit(maxResults)\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n\n@@ -298,11 +298,12 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream()\n-          .sorted()\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        Stream<String> userStream = userPasswords.keySet().stream().sorted();\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTQyNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511961424", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:33:02Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -361,30 +355,27 @@ public int getUsersCount(RealmModel realm) {\n         return userStream\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n\n@@ -352,10 +355,11 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n             }\n         }\n \n-        return userStream\n-          .skip(firstResult)\n-          .limit(maxResults)\n-          .map(userName -> createUser(realm, userName));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (maxResults >= 0)\n+            userStream = userStream.limit(maxResults);\n+        return userStream.map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjM1OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511962358", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:34:20Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -412,15 +403,14 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n     }\n \n     @Override\n-    public List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+    public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n         return userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n           .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\nindex 4717512ea5..dc8da1c643 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java\n\n@@ -404,13 +408,16 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,\n \n     @Override\n     public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n-        return userGroups.entrySet().stream()\n+        Stream<String> userStream = userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n-          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n-          .skip(firstResult)\n-          .limit(max);\n+          .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1));\n+        if (firstResult > 0)\n+            userStream = userStream.skip(firstResult);\n+        if (max >= 0)\n+            userStream = userStream.limit(max);\n+        return userStream;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511973619", "bodyText": "What \"-1\" in maxResults actually should achieve? If that means we don't want limit number of results shouldn't we use Integer.MAX_VALUE - 1 ? Not sure if limit(0) will do the same.\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.", "author": "martin-kanis", "createdAt": "2020-10-26T13:50:09Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java", "diffHunk": "@@ -146,88 +144,64 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        List<UserModel> users = new LinkedList<>();\n-        for (Object username : userPasswords.keySet()) {\n-            users.add(createUser(realm, (String)username));\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return userPasswords.keySet().stream().map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return searchForUserStream(attributes, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            if (count++ < firstResult) continue;\n-            String username = (String)un;\n-            users.add(createUser(realm, username));\n-            if (users.size() + 1 > maxResults) break;\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NzQwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511987405", "bodyText": "I will have to check this again, this is a very good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b839690d32f81140a94289f9a443ed61111fa8e5", "chunk": "diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\nindex 5d0dfa07df..dd8ba1594e 100644\n--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java\n\n@@ -155,8 +155,12 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP\n \n     @Override\n     public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n-        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)\n-                .map(obj -> createUser(realm, (String) obj));\n+        Stream<Object> stream = userPasswords.keySet().stream();\n+        if (firstResult > 0)\n+            stream = stream.skip(firstResult);\n+        if (maxResults >= 0)\n+            stream = stream.limit(maxResults);\n+        return stream.map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n"}}, {"oid": "b839690d32f81140a94289f9a443ed61111fa8e5", "url": "https://github.com/keycloak/keycloak/commit/b839690d32f81140a94289f9a443ed61111fa8e5", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-29T17:23:27Z", "type": "forcePushed"}, {"oid": "73b8207ab295a9a00c192d2d5debc14317a05816", "url": "https://github.com/keycloak/keycloak/commit/73b8207ab295a9a00c192d2d5debc14317a05816", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-30T19:28:40Z", "type": "forcePushed"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "commit"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "forcePushed"}]}