{"pr_number": 7425, "pr_title": "KEYCLOAK-15450 Complement methods for accessing realms with Stream va\u2026", "pr_createdAt": "2020-09-16T08:06:03Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7425", "timeline": [{"oid": "da136dd1571ad99b0a5f0a36758da71ce4ba7446", "url": "https://github.com/keycloak/keycloak/commit/da136dd1571ad99b0a5f0a36758da71ce4ba7446", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-16T10:08:47Z", "type": "forcePushed"}, {"oid": "6101e3407d7623782ac5f8ae90fb027c5db991b3", "url": "https://github.com/keycloak/keycloak/commit/6101e3407d7623782ac5f8ae90fb027c5db991b3", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-17T09:33:48Z", "type": "forcePushed"}, {"oid": "06efa3fd25351830973019b7751bf2c5ca2db07a", "url": "https://github.com/keycloak/keycloak/commit/06efa3fd25351830973019b7751bf2c5ca2db07a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-18T13:22:01Z", "type": "forcePushed"}, {"oid": "00135c2a18266dc541801d2943e4a7c5daead89f", "url": "https://github.com/keycloak/keycloak/commit/00135c2a18266dc541801d2943e4a7c5daead89f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-21T14:09:42Z", "type": "forcePushed"}, {"oid": "2a2b4c2ec3bf985020dc1218dde17f434d30883a", "url": "https://github.com/keycloak/keycloak/commit/2a2b4c2ec3bf985020dc1218dde17f434d30883a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T06:19:23Z", "type": "forcePushed"}, {"oid": "14be7cb2d43201a72828a8823a4f3f6a1cadce39", "url": "https://github.com/keycloak/keycloak/commit/14be7cb2d43201a72828a8823a4f3f6a1cadce39", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T14:43:14Z", "type": "forcePushed"}, {"oid": "4ebf4e5aa8ab0213289079f015de237a51a072fe", "url": "https://github.com/keycloak/keycloak/commit/4ebf4e5aa8ab0213289079f015de237a51a072fe", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T14:45:39Z", "type": "forcePushed"}, {"oid": "524f0e993521ba2a1a8fc01cfb6d49b6fae8db2f", "url": "https://github.com/keycloak/keycloak/commit/524f0e993521ba2a1a8fc01cfb6d49b6fae8db2f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-23T15:10:35Z", "type": "forcePushed"}, {"oid": "6609c3586be187dd2ed5e7b6a2a87f7a71d36e12", "url": "https://github.com/keycloak/keycloak/commit/6609c3586be187dd2ed5e7b6a2a87f7a71d36e12", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-25T16:27:17Z", "type": "forcePushed"}, {"oid": "c1f6dc034b30016ebd69d3672846633fabc5333f", "url": "https://github.com/keycloak/keycloak/commit/c1f6dc034b30016ebd69d3672846633fabc5333f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T08:24:13Z", "type": "forcePushed"}, {"oid": "d09343696edde423ae7cec4360ecd4d6c1ecdd6a", "url": "https://github.com/keycloak/keycloak/commit/d09343696edde423ae7cec4360ecd4d6c1ecdd6a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T12:31:39Z", "type": "forcePushed"}, {"oid": "c7c7d987c91c52b392e23f41db53541ddeceac38", "url": "https://github.com/keycloak/keycloak/commit/c7c7d987c91c52b392e23f41db53541ddeceac38", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T16:05:59Z", "type": "forcePushed"}, {"oid": "59cbfa8d184508e14dd79edf317cde79547d2251", "url": "https://github.com/keycloak/keycloak/commit/59cbfa8d184508e14dd79edf317cde79547d2251", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T18:25:58Z", "type": "forcePushed"}, {"oid": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "url": "https://github.com/keycloak/keycloak/commit/ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-30T13:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MjEwNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497572104", "bodyText": "I'm usually not a fan of star imports, but not sure what the code policy in keycloak is.", "author": "sguilhen", "createdAt": "2020-09-30T14:49:32Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -17,14 +17,9 @@\n \n package org.keycloak.storage.ldap;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex dce0adc4c2..0224b0a841 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -17,7 +17,14 @@\n \n package org.keycloak.storage.ldap;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MjYwNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497572606", "bodyText": "Same, not sure if we should be changing that.", "author": "sguilhen", "createdAt": "2020-09-30T14:50:11Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -58,10 +53,7 @@\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n import org.keycloak.storage.ldap.kerberos.LDAPProviderKerberosConfig;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperManager;\n-import org.keycloak.storage.ldap.mappers.PasswordUpdateCallback;\n-import org.keycloak.storage.ldap.mappers.LDAPOperationDecorator;\n+import org.keycloak.storage.ldap.mappers.*;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex dce0adc4c2..0224b0a841 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -53,7 +71,11 @@ import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n import org.keycloak.storage.ldap.kerberos.LDAPProviderKerberosConfig;\n-import org.keycloak.storage.ldap.mappers.*;\n+import org.keycloak.storage.ldap.mappers.LDAPMappersComparator;\n+import org.keycloak.storage.ldap.mappers.LDAPOperationDecorator;\n+import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n+import org.keycloak.storage.ldap.mappers.LDAPStorageMapperManager;\n+import org.keycloak.storage.ldap.mappers.PasswordUpdateCallback;\n import org.keycloak.storage.user.ImportedUserValidation;\n import org.keycloak.storage.user.UserLookupProvider;\n import org.keycloak.storage.user.UserQueryProvider;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497579385", "bodyText": "If I'm reading this right, this change works because there can be only one enabled default required action provider for the real. Is that the case?", "author": "sguilhen", "createdAt": "2020-09-30T14:58:28Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -286,11 +283,13 @@ public UserModel addUser(RealmModel realm, String username) {\n \n         realm.getDefaultGroupsStream().forEach(proxy::joinGroup);\n \n-        for (RequiredActionProviderModel r : realm.getRequiredActionProviders()) {\n-            if (r.isEnabled() && r.isDefaultAction()) {\n-                proxy.addRequiredAction(r.getAlias());\n-            }\n-        }\n+        Optional<String> requiredAction = realm.getRequiredActionProvidersStream()\n+                .filter(RequiredActionProviderModel::isEnabled)\n+                .filter(RequiredActionProviderModel::isDefaultAction)\n+                .map(RequiredActionProviderModel::getAlias)\n+                .findFirst();\n+        if (requiredAction.isPresent())\n+            proxy.addRequiredAction(requiredAction.get());", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4Nzk3Nw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498087977", "bodyText": "Looking more into this, I think I wrongly understood the original method. I'm changing it to realm.getRequiredActionProvidersStream() .filter(RequiredActionProviderModel::isEnabled) .filter(RequiredActionProviderModel::isDefaultAction) .map(RequiredActionProviderModel::getAlias) .forEach(proxy::addRequiredAction);  which should have the same semantic.", "author": "martin-kanis", "createdAt": "2020-10-01T08:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1NzM5NA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498457394", "bodyText": "Yeah, I agree with you here. I remember seeing something very similar in another class, I'll try to locate it so you can fix both places if needed", "author": "sguilhen", "createdAt": "2020-10-01T19:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\nindex dce0adc4c2..0224b0a841 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java\n\n@@ -283,13 +305,11 @@ public class LDAPStorageProvider implements UserStorageProvider,\n \n         realm.getDefaultGroupsStream().forEach(proxy::joinGroup);\n \n-        Optional<String> requiredAction = realm.getRequiredActionProvidersStream()\n+        realm.getRequiredActionProvidersStream()\n                 .filter(RequiredActionProviderModel::isEnabled)\n                 .filter(RequiredActionProviderModel::isDefaultAction)\n                 .map(RequiredActionProviderModel::getAlias)\n-                .findFirst();\n-        if (requiredAction.isPresent())\n-            proxy.addRequiredAction(requiredAction.get());\n+                .forEachOrdered(proxy::addRequiredAction);\n \n         return proxy;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4Nzc2MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497587760", "bodyText": "Suggestion: This can be replaced by LDAPConfigDecorator.isInstance() in a single statement\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return mapperFactory instanceof LDAPConfigDecorator;\n          \n          \n            \n                                LDAPConfigDecorator.isInstance(session.getKeycloakSessionFactory()\n          \n          \n            \n                                        .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()));", "author": "sguilhen", "createdAt": "2020-09-30T15:09:10Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)\n     // Check if it's some performance overhead to create this map in every request. But probably not...\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());\n-\n-        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();\n-        for (ComponentModel mapperModel : mapperComponents) {\n-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-            if (mapperFactory instanceof LDAPConfigDecorator) {\n-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-            }\n-        }\n-\n-        return result;\n+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n+                .filter(mapperModel -> {\n+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                    return mapperFactory instanceof LDAPConfigDecorator;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTgzNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498081836", "bodyText": "maybe like this? mapperModel -> session.getKeycloakSessionFactory() .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()) instanceof LDAPConfigDecorator", "author": "martin-kanis", "createdAt": "2020-10-01T08:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4Nzc2MA=="}], "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\nindex aaf1cbae7f..2f41d0d0f3 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n\n@@ -234,18 +235,11 @@ public class LDAPStorageProviderFactory implements UserStorageProviderFactory<LD\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n         return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n-                .filter(mapperModel -> {\n-                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n-                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-                    return mapperFactory instanceof LDAPConfigDecorator;\n-                })\n-                .collect(HashMap::new,\n-                        (map, mapperModel) -> {\n-                            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n-                                    .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-                            map.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-                        },\n-                        HashMap::putAll);\n+                .filter(mapperModel -> session.getKeycloakSessionFactory()\n+                        .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()) instanceof LDAPConfigDecorator)\n+                .collect(Collectors.toMap(Function.identity(), mapperModel ->\n+                        (LDAPConfigDecorator) session.getKeycloakSessionFactory()\n+                                .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId())));\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTk1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497679953", "bodyText": "I'm not 100% sure, but couldn't this be handled with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    HashMap::putAll);\n          \n          \n            \n                                    .collect(Collectors.toMap(Function.identity, mapperModel -> (LDAPConfigDecorator) session.getKeycloakSessionFactory()\n          \n          \n            \n                                            .getProviderFactory(LDAPStorageManager.class, mapperModel.getProviderId())));\n          \n      \n    \n    \n  \n\nJust suggesting something off the top of myhead, syntax might be a bit off", "author": "sguilhen", "createdAt": "2020-09-30T17:24:31Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)\n     // Check if it's some performance overhead to create this map in every request. But probably not...\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());\n-\n-        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();\n-        for (ComponentModel mapperModel : mapperComponents) {\n-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-            if (mapperFactory instanceof LDAPConfigDecorator) {\n-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-            }\n-        }\n-\n-        return result;\n+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n+                .filter(mapperModel -> {\n+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                    return mapperFactory instanceof LDAPConfigDecorator;\n+                })\n+                .collect(HashMap::new,\n+                        (map, mapperModel) -> {\n+                            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                                    .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                            map.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n+                        },\n+                        HashMap::putAll);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTEyMg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498081122", "bodyText": "Yeah, I used your suggestion.", "author": "martin-kanis", "createdAt": "2020-10-01T08:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTk1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\nindex aaf1cbae7f..2f41d0d0f3 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n\n@@ -234,18 +235,11 @@ public class LDAPStorageProviderFactory implements UserStorageProviderFactory<LD\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n         return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n-                .filter(mapperModel -> {\n-                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n-                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-                    return mapperFactory instanceof LDAPConfigDecorator;\n-                })\n-                .collect(HashMap::new,\n-                        (map, mapperModel) -> {\n-                            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n-                                    .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-                            map.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-                        },\n-                        HashMap::putAll);\n+                .filter(mapperModel -> session.getKeycloakSessionFactory()\n+                        .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()) instanceof LDAPConfigDecorator)\n+                .collect(Collectors.toMap(Function.identity(), mapperModel ->\n+                        (LDAPConfigDecorator) session.getKeycloakSessionFactory()\n+                                .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId())));\n     }\n \n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497739382", "bodyText": "Question: since this returns a sorted stream, shouldn't every use of this method that consumes the stream with forEach use forEachOrdered instead? If order was relevant in the original list-based implementation I believe we need to pay attention to that.\nAlso, if order is important shouldn't the Javadoc in the interface mention that the returned stream is sorted and that if order is important forEachOrdered should be used when consuming the stream?", "author": "sguilhen", "createdAt": "2020-09-30T19:10:16Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1725,15 +1669,13 @@ public AuthenticationFlowModel addAuthenticationFlow(AuthenticationFlowModel mod\n     }\n \n     @Override\n-    public List<AuthenticationExecutionModel> getAuthenticationExecutions(String flowId) {\n+    public Stream<AuthenticationExecutionModel> getAuthenticationExecutionsStream(String flowId) {\n         AuthenticationFlowEntity flow = em.getReference(AuthenticationFlowEntity.class, flowId);\n \n         return flow.getExecutions().stream()\n                 .filter(e -> getId().equals(e.getRealm().getId()))\n                 .map(this::entityToModel)\n-                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON)\n-                .collect(Collectors.collectingAndThen(\n-                        Collectors.toList(), Collections::unmodifiableList));\n+                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwNjgyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498106829", "bodyText": "I think you are right. I switched to forEachOrdered from forEach in each usage. One concern which I have is whether the corresponding methods in infinispan/RealmAdapter will preserve the ordering in case the data was cached.", "author": "martin-kanis", "createdAt": "2020-10-01T09:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4NDYwMA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498184600", "bodyText": "Yeah, I was also wondering about that.", "author": "sguilhen", "createdAt": "2020-10-01T11:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTY2NA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497739664", "bodyText": "Same here regarding the sorted stream.", "author": "sguilhen", "createdAt": "2020-09-30T19:10:48Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1973,15 +1909,10 @@ public void updateRequiredActionProvider(RequiredActionProviderModel model) {\n     }\n \n     @Override\n-    public List<RequiredActionProviderModel> getRequiredActionProviders() {\n-        Collection<RequiredActionProviderEntity> entities = realm.getRequiredActionProviders();\n-        if (entities.isEmpty()) return Collections.EMPTY_LIST;\n-        List<RequiredActionProviderModel> actions = new LinkedList<>();\n-        for (RequiredActionProviderEntity entity : entities) {\n-            actions.add(entityToModel(entity));\n-        }\n-        Collections.sort(actions, RequiredActionProviderModel.RequiredActionComparator.SINGLETON);\n-        return Collections.unmodifiableList(actions);\n+    public Stream<RequiredActionProviderModel> getRequiredActionProvidersStream() {\n+        return realm.getRequiredActionProviders().stream()\n+                .map(this::entityToModel)\n+                .sorted(RequiredActionProviderModel.RequiredActionComparator.SINGLETON);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3NDI0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497774249", "bodyText": "shouldn't this be else if (e.isAlternative()) instead?", "author": "sguilhen", "createdAt": "2020-09-30T20:16:14Z", "path": "services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java", "diffHunk": "@@ -106,19 +104,22 @@ public Response processFlow() {\n     }\n \n     protected List<AuthenticationExecutionModel> findExecutionsToRun() {\n-        List<AuthenticationExecutionModel> executions = processor.getRealm().getAuthenticationExecutions(flow.getId());\n-        List<AuthenticationExecutionModel> executionsToRun = new ArrayList<>();\n-\n-        for (AuthenticationExecutionModel execution : executions) {\n-            if (execution.isRequired()) {\n-                executionsToRun = Arrays.asList(execution);\n-                break;\n-            }\n+        List<AuthenticationExecutionModel> executionsToRun = new LinkedList<>();\n+        List<AuthenticationExecutionModel> finalExecutionsToRun = executionsToRun;\n+        Optional<AuthenticationExecutionModel> first = processor.getRealm().getAuthenticationExecutionsStream(flow.getId())\n+                .filter(e -> {\n+                    if (e.isRequired()) {\n+                        return true;\n+                    } else {", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwMjYxMw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498102613", "bodyText": "Yeah, good catch!", "author": "martin-kanis", "createdAt": "2020-10-01T09:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3NDI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\nindex 9867ecd25f..167c15afd7 100755\n--- a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\n+++ b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\n\n@@ -110,10 +110,11 @@ public class ClientAuthenticationFlow implements AuthenticationFlow {\n                 .filter(e -> {\n                     if (e.isRequired()) {\n                         return true;\n-                    } else {\n+                    } else if (e.isAlternative()){\n                         finalExecutionsToRun.add(e);\n                         return false;\n                     }\n+                    return false;\n                 }).findFirst();\n \n         if (first.isPresent())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Njg2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497796862", "bodyText": "Is this change here for performance reasons?", "author": "sguilhen", "createdAt": "2020-09-30T20:59:19Z", "path": "services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalUserConfiguredAuthenticator.java", "diffHunk": "@@ -1,7 +1,8 @@\n package org.keycloak.authentication.authenticators.conditional;\n \n-import java.util.ArrayList;\n+import java.util.LinkedList;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MDQzOA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498080438", "bodyText": "Correct", "author": "martin-kanis", "createdAt": "2020-10-01T08:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Njg2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Mjg0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497862842", "bodyText": "is this method used? Search for usages came up empty. Probably intended to be used in the first filter at the top of the file?", "author": "sguilhen", "createdAt": "2020-09-30T23:53:33Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "diffHunk": "@@ -1349,6 +1343,18 @@ private String generateS256CodeChallenge(String codeVerifier) throws Exception {\n         return codeVerifierEncoded;\n     }\n \n+    private boolean isExternal(IdentityProviderModel idpModel, String issuer) {\n+        IdentityProviderFactory factory = IdentityBrokerService.getIdentityProviderFactory(session, idpModel);\n+        IdentityProvider idp = factory.create(session, idpModel);\n+        if (idp instanceof ExchangeExternalToken) {\n+            ExchangeExternalToken external = (ExchangeExternalToken) idp;\n+            if (idpModel.getAlias().equals(issuer) || external.isIssuer(issuer, formParams)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MDMxMg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498080312", "bodyText": "It was unsuccessful attempt to put that filter inside a method and I forgot to remove it at the end.", "author": "martin-kanis", "createdAt": "2020-10-01T08:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Mjg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java b/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java\nindex d7e4fb7a40..7cd10ed906 100644\n--- a/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java\n+++ b/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java\n\n@@ -1343,18 +1343,6 @@ public class TokenEndpoint {\n         return codeVerifierEncoded;\n     }\n \n-    private boolean isExternal(IdentityProviderModel idpModel, String issuer) {\n-        IdentityProviderFactory factory = IdentityBrokerService.getIdentityProviderFactory(session, idpModel);\n-        IdentityProvider idp = factory.create(session, idpModel);\n-        if (idp instanceof ExchangeExternalToken) {\n-            ExchangeExternalToken external = (ExchangeExternalToken) idp;\n-            if (idpModel.getAlias().equals(issuer) || external.isIssuer(issuer, formParams)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n     private class TokenExchangeSamlProtocol extends SamlProtocol {\n         final SamlClient samlClient;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MTM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497951360", "bodyText": "Is this used in this class?", "author": "sguilhen", "createdAt": "2020-10-01T02:33:55Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java", "diffHunk": "@@ -3,6 +3,7 @@\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import org.jboss.logging.Logger;\n import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.keycloak.TokenVerifier;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3dc79672e3752ba00839f2543d30aa12f4842385", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\nindex 3b48e7c479..5db1e0e03a 100644\n--- a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\n\n@@ -3,7 +3,6 @@ package org.keycloak.services.resources.account;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import org.jboss.logging.Logger;\n import org.jboss.resteasy.annotations.cache.NoCache;\n-import org.keycloak.TokenVerifier;\n import org.keycloak.authentication.Authenticator;\n import org.keycloak.authentication.AuthenticatorFactory;\n import org.keycloak.credential.CredentialModel;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497952414", "bodyText": "Just out of curiosity, why the usage of flatMap here?", "author": "sguilhen", "createdAt": "2020-10-01T02:38:33Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java", "diffHunk": "@@ -228,29 +226,23 @@ public CredentialTypeMetadata getMetadata() {\n     // Going through all authentication flows and their authentication executions to see if there is any authenticator of the corresponding\n     // credential type.\n     private Set<String> getEnabledCredentialTypes(List<CredentialProvider> credentialProviders) {\n-        Set<String> enabledCredentialTypes = new HashSet<>();\n-\n-        for (AuthenticationFlowModel flow : realm.getAuthenticationFlows()) {\n-            // Ignore DISABLED executions and flows\n-            if (isFlowEffectivelyDisabled(flow)) continue;\n-\n-            for (AuthenticationExecutionModel execution : realm.getAuthenticationExecutions(flow.getId())) {\n-                if (execution.getAuthenticator() != null && DISABLED != execution.getRequirement()) {\n-                    AuthenticatorFactory authenticatorFactory = (AuthenticatorFactory) session.getKeycloakSessionFactory().getProviderFactory(Authenticator.class, execution.getAuthenticator());\n-                    if (authenticatorFactory != null && authenticatorFactory.getReferenceCategory() != null) {\n-                        enabledCredentialTypes.add(authenticatorFactory.getReferenceCategory());\n-                    }\n-                }\n-            }\n-        }\n+        Stream<String> enabledCredentialTypes = realm.getAuthenticationFlowsStream()\n+                .filter(((Predicate<AuthenticationFlowModel>) this::isFlowEffectivelyDisabled).negate())\n+                .flatMap(flow ->", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498079045", "bodyText": "We have here a stream of streams and we need to return just flat set of strings.", "author": "martin-kanis", "createdAt": "2020-10-01T08:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MzYzNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498183636", "bodyText": "Yeah, but that could have been handled with map only, no? I was mainly curious why flatMap (instead of map) is used since I don't see the need to ensure the underlying stream gets closed, but I might be missing something.", "author": "sguilhen", "createdAt": "2020-10-01T11:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzODEyNw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r500538127", "bodyText": "Sorry @martin-kanis, I misinterpreted the code. You are right, we have a stream of streams, so we need to flatten them into a single one. Nothing to change here.", "author": "sguilhen", "createdAt": "2020-10-06T19:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "da00a88cb2315f11f9d5279b56a85bba954cbddf", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\nindex 3b48e7c479..2247992d1a 100644\n--- a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java\n\n@@ -199,28 +193,28 @@ public class AccountCredentialResource {\n                         .collect(Collectors.toList());\n \n                 if (userCredentialModels.isEmpty() &&\n-                        session.userCredentialManager().isConfiguredFor(realm, user, credentialProviderType)) {\n+                        session.userCredentialManager().isConfiguredFor(realm, user, credentialProvider.getType())) {\n                     // In case user is federated in the userStorage, he may have credential configured on the userStorage side. We're\n                     // creating \"dummy\" credential representing the credential provided by userStorage\n-                    CredentialRepresentation credential = createUserStorageCredentialRepresentation(credentialProviderType);\n-\n+                    CredentialRepresentation credential = createUserStorageCredentialRepresentation(credentialProvider.getType());\n                     userCredentialModels = Collections.singletonList(credential);\n                 }\n \n                 // In case that there are no userCredentials AND there are not required actions for setup new credential,\n                 // we won't include credentialType as user won't be able to do anything with it\n                 if (userCredentialModels.isEmpty() && metadata.getCreateAction() == null && metadata.getUpdateAction() == null) {\n-                    continue;\n+                    return null;\n                 }\n             }\n \n-            CredentialContainer credType = new CredentialContainer(metadata, userCredentialModels);\n-            credentialTypes.add(credType);\n-        }\n-\n-        credentialTypes.sort(Comparator.comparing(CredentialContainer::getMetadata));\n+            return new CredentialContainer(metadata, userCredentialModels);\n+        };\n \n-        return credentialTypes;\n+        return credentialProviders.stream()\n+                .filter(p -> p.getType() == null || Objects.equals(p.getType(), type))\n+                .filter(enabledCredentialTypes::contains)\n+                .map(toCredentialContainer)\n+                .sorted(Comparator.comparing(CredentialContainer::getMetadata));\n     }\n \n     // Going through all authentication flows and their authentication executions to see if there is any authenticator of the corresponding\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497965673", "bodyText": "Is it necessary to call collect here?", "author": "sguilhen", "createdAt": "2020-10-01T03:37:25Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/IdentityProviderResource.java", "diffHunk": "@@ -133,10 +125,8 @@ public Response delete() {\n         session.users().preRemove(realm, identityProviderModel);\n         this.realm.removeIdentityProviderByAlias(alias);\n \n-        Set<IdentityProviderMapperModel> mappers = this.realm.getIdentityProviderMappersByAlias(alias);\n-        for (IdentityProviderMapperModel mapper : mappers) {\n-            this.realm.removeIdentityProviderMapper(mapper);\n-        }\n+        realm.getIdentityProviderMappersByAliasStream(alias)\n+                .collect(Collectors.toList()).forEach(realm::removeIdentityProviderMapper);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTUwNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498079504", "bodyText": "Yes, otherwise it throws ConcurrentModificationException.", "author": "martin-kanis", "createdAt": "2020-10-01T08:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4NDA3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498184071", "bodyText": "Ah ok, thanks!", "author": "sguilhen", "createdAt": "2020-10-01T11:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "0d1b52ca25d277ae58f6db932c1ab9babcb7d68b", "url": "https://github.com/keycloak/keycloak/commit/0d1b52ca25d277ae58f6db932c1ab9babcb7d68b", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T07:46:11Z", "type": "forcePushed"}, {"oid": "3dc79672e3752ba00839f2543d30aa12f4842385", "url": "https://github.com/keycloak/keycloak/commit/3dc79672e3752ba00839f2543d30aa12f4842385", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T09:38:25Z", "type": "forcePushed"}, {"oid": "46fc6d69d097d08688d912ad4fe7d699085aed78", "url": "https://github.com/keycloak/keycloak/commit/46fc6d69d097d08688d912ad4fe7d699085aed78", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T15:02:34Z", "type": "forcePushed"}, {"oid": "8e15cbaf9bdfa768868caccfebcba91f728ac6a2", "url": "https://github.com/keycloak/keycloak/commit/8e15cbaf9bdfa768868caccfebcba91f728ac6a2", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T19:35:39Z", "type": "forcePushed"}, {"oid": "224b86d3acae4e23ed71157cf6ca2982fa45bec5", "url": "https://github.com/keycloak/keycloak/commit/224b86d3acae4e23ed71157cf6ca2982fa45bec5", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T09:29:20Z", "type": "forcePushed"}, {"oid": "da00a88cb2315f11f9d5279b56a85bba954cbddf", "url": "https://github.com/keycloak/keycloak/commit/da00a88cb2315f11f9d5279b56a85bba954cbddf", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T12:20:26Z", "type": "forcePushed"}, {"oid": "74b8ce308cc023d69a2e3cd8df6c2e77f3ff3460", "url": "https://github.com/keycloak/keycloak/commit/74b8ce308cc023d69a2e3cd8df6c2e77f3ff3460", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T16:10:02Z", "type": "forcePushed"}, {"oid": "cf356b30bda94a2ed0d7f999a3268276b36ae822", "url": "https://github.com/keycloak/keycloak/commit/cf356b30bda94a2ed0d7f999a3268276b36ae822", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-05T16:40:32Z", "type": "forcePushed"}, {"oid": "e48ead63ab0b0542f2098d7c5227dfcf0d833620", "url": "https://github.com/keycloak/keycloak/commit/e48ead63ab0b0542f2098d7c5227dfcf0d833620", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-05T19:24:29Z", "type": "forcePushed"}, {"oid": "416b096d687466a6a31c20bbb65a1e86682b6c66", "url": "https://github.com/keycloak/keycloak/commit/416b096d687466a6a31c20bbb65a1e86682b6c66", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T05:52:33Z", "type": "forcePushed"}, {"oid": "130e5c87b145f4da7631d38e6d4b496461b288e5", "url": "https://github.com/keycloak/keycloak/commit/130e5c87b145f4da7631d38e6d4b496461b288e5", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T08:02:25Z", "type": "forcePushed"}, {"oid": "f3dfc34234153377a8ab4d41836d16a19c273ff1", "url": "https://github.com/keycloak/keycloak/commit/f3dfc34234153377a8ab4d41836d16a19c273ff1", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T10:56:31Z", "type": "forcePushed"}, {"oid": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "url": "https://github.com/keycloak/keycloak/commit/e53827dedd14ebf38a5f9e2060dad84c9839c51e", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T12:36:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwMjU0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502602545", "bodyText": "Star import that was reverted in previous classes is used here", "author": "sguilhen", "createdAt": "2020-10-09T18:25:17Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -47,24 +47,17 @@\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapperFactory;\n-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapper;\n-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapperFactory;\n-import org.keycloak.storage.ldap.mappers.LDAPConfigDecorator;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperFactory;\n-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapperFactory;\n+import org.keycloak.storage.ldap.mappers.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\nindex 2f41d0d0f3..66aef7024c 100755\n--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java\n\n@@ -47,7 +47,15 @@ import org.keycloak.storage.ldap.idm.query.Condition;\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n-import org.keycloak.storage.ldap.mappers.*;\n+import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapper;\n+import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapperFactory;\n+import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapper;\n+import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapperFactory;\n+import org.keycloak.storage.ldap.mappers.LDAPConfigDecorator;\n+import org.keycloak.storage.ldap.mappers.LDAPMappersComparator;\n+import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n+import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapper;\n+import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapperFactory;\n import org.keycloak.storage.ldap.mappers.msad.MSADUserAccountControlStorageMapperFactory;\n import org.keycloak.storage.user.ImportSynchronization;\n import org.keycloak.storage.user.SynchronizationResult;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwNTk1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502605959", "bodyText": "Javadoc for new method?", "author": "sguilhen", "createdAt": "2020-10-09T18:32:15Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventQuery.java", "diffHunk": "@@ -43,6 +45,13 @@\n \n     EventQuery maxResults(int results);\n \n-    List<Event> getResultList();\n+    /**\n+     * @deprecated Use {@link #getResultStream() getResultStream} instead.\n+     */\n+    @Deprecated\n+    default List<Event> getResultList() {\n+        return getResultStream().collect(Collectors.toList());\n+    }\n \n+    Stream<Event> getResultStream();", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/events/EventQuery.java b/server-spi-private/src/main/java/org/keycloak/events/EventQuery.java\nindex 69c7793265..57687f93cd 100644\n--- a/server-spi-private/src/main/java/org/keycloak/events/EventQuery.java\n+++ b/server-spi-private/src/main/java/org/keycloak/events/EventQuery.java\n\n@@ -53,5 +53,9 @@ public interface EventQuery {\n         return getResultStream().collect(Collectors.toList());\n     }\n \n+    /**\n+     * Returns requested results that match given criteria as a stream.\n+     * @return Stream of events\n+     */\n     Stream<Event> getResultStream();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwNjEzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502606135", "bodyText": "Javadoc for new method?", "author": "sguilhen", "createdAt": "2020-10-09T18:32:37Z", "path": "server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java", "diffHunk": "@@ -127,8 +129,12 @@\n \n     /**\n      * Executes the query and returns the results\n-     * \n-     * @return\n+     * @deprecated Use {@link #getResultStream() getResultStream} instead.\n      */\n-    List<AdminEvent> getResultList();\n+    @Deprecated\n+    default List<AdminEvent> getResultList() {\n+        return getResultStream().collect(Collectors.toList());\n+    }\n+\n+    Stream<AdminEvent> getResultStream();", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java b/server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java\nindex f61eaa978d..330130997c 100644\n--- a/server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java\n+++ b/server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java\n\n@@ -136,5 +136,9 @@ public interface AdminEventQuery {\n         return getResultStream().collect(Collectors.toList());\n     }\n \n+    /**\n+     * Executes the query and returns the results as a stream.\n+     * @return Stream of admin events\n+     */\n     Stream<AdminEvent> getResultStream();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjAxMw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502626013", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T19:15:21Z", "path": "services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java", "diffHunk": "@@ -27,9 +27,7 @@\n import org.keycloak.services.ServicesLogger;\n \n import javax.ws.rs.core.Response;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\nindex 167c15afd7..8e6eda6789 100755\n--- a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\n+++ b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java\n\n@@ -27,7 +27,11 @@ import org.keycloak.models.utils.KeycloakModelUtils;\n import org.keycloak.services.ServicesLogger;\n \n import javax.ws.rs.core.Response;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n \n /**\n  * @author <a href=\"mailto:mposolda@redhat.com\">Marek Posolda</a>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MjcxNw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502682717", "bodyText": "Why are these changes part of this PR? What does it have to do with the realms?", "author": "sguilhen", "createdAt": "2020-10-09T21:39:46Z", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -347,50 +334,38 @@ private UserStorageCredentialConfigured isConfiguredThroughUserStorage(RealmMode\n \n     @Override\n     public boolean isConfiguredLocally(RealmModel realm, UserModel user, String type) {\n-        List<CredentialInputValidator> credentialProviders = getCredentialProviders(session, realm, CredentialInputValidator.class);\n-        for (CredentialInputValidator validator : credentialProviders) {\n-            if (validator.supportsCredentialType(type) && validator.isConfiguredFor(realm, user, type)) {\n-                return true;\n-            }\n-\n-        }\n-        return false;\n+        return getCredentialProviders(session, CredentialInputValidator.class)\n+                .anyMatch(validator -> validator.supportsCredentialType(type) && validator.isConfiguredFor(realm, user, type));\n     }\n \n     @Override\n     public CredentialValidationOutput authenticate(KeycloakSession session, RealmModel realm, CredentialInput input) {\n-        List<CredentialAuthentication> list = UserStorageManager.getEnabledStorageProviders(session, realm, CredentialAuthentication.class);\n-        for (CredentialAuthentication auth : list) {\n-            if (auth.supportsCredentialAuthenticationFor(input.getType())) {\n-                CredentialValidationOutput output = auth.authenticate(realm, input);\n-                if (output != null) return output;\n-            }\n-        }\n+        CredentialValidationOutput output = authenticate(\n+                UserStorageManager.getEnabledStorageProviders(session, realm, CredentialAuthentication.class),\n+                realm, input);\n \n-        list = getCredentialProviders(session, realm, CredentialAuthentication.class);\n-        for (CredentialAuthentication auth : list) {\n-            if (auth.supportsCredentialAuthenticationFor(input.getType())) {\n-                CredentialValidationOutput output = auth.authenticate(realm, input);\n-                if (output != null) return output;\n-            }\n-        }\n+        return (output != null) ? output : authenticate(getCredentialProviders(session, CredentialAuthentication.class),\n+                realm, input);\n+    }\n \n-        return null;\n+    public CredentialValidationOutput authenticate(Stream<CredentialAuthentication> storageProviders,\n+                                                       RealmModel realm, CredentialInput input) {\n+        return storageProviders\n+                .filter(auth -> auth.supportsCredentialAuthenticationFor(input.getType()))\n+                .map(auth -> auth.authenticate(realm, input))\n+                .filter(Objects::nonNull)\n+                .findFirst()\n+                .orElse(null);\n     }\n \n     @Override\n     public void onCache(RealmModel realm, CachedUserModel user, UserModel delegate) {\n-        List<OnUserCache> credentialProviders = getCredentialProviders(session, realm, OnUserCache.class);\n-        for (OnUserCache validator : credentialProviders) {\n-            validator.onCache(realm, user, delegate);\n-        }\n+        getCredentialProviders(session, OnUserCache.class).forEach(validator -> validator.onCache(realm, user, delegate));\n     }\n \n     @Override\n     public List<String> getConfiguredUserStorageCredentialTypes(RealmModel realm, UserModel user) {\n-        List<CredentialProvider> credentialProviders = getCredentialProviders(session, realm, CredentialProvider.class);\n-\n-        return credentialProviders.stream().map(CredentialProvider::getType)\n+        return getCredentialProviders(session, CredentialProvider.class).map(CredentialProvider::getType)\n                 .filter(credentialType -> UserStorageCredentialConfigured.CONFIGURED == isConfiguredThroughUserStorage(realm, user, credentialType))\n                 .collect(Collectors.toList());\n     }", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzExNjg0MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r503116840", "bodyText": "As part of RealmModel streamification I changed RealmModel.getUserStorageProviders to use streams. Then I refactored all the code which use that method. In this case it's used in UserCredentialStoreManager.authenticate (indirectly via UserStorageManager.getEnabledStorageProviders) which also uses getCredentialProviders. Changing getCredentialProviders to streams helped me to simplify the code. Does it make sense to you or you prefer to revert this part?", "author": "martin-kanis", "createdAt": "2020-10-12T08:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MjcxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4NTM0MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502685340", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T21:50:38Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java", "diffHunk": "@@ -102,15 +101,8 @@\n import java.net.URI;\n import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java b/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java\nindex ca497044cf..2860a465f9 100755\n--- a/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java\n+++ b/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java\n\n@@ -101,7 +101,16 @@ import java.lang.reflect.Method;\n import java.net.URI;\n import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n import java.util.stream.Collectors;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4NjU1MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502686550", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T21:56:20Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java", "diffHunk": "@@ -64,12 +64,10 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.UriBuilder;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "chunk": "diff --git a/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java b/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java\nindex e4eff2e03e..79829556c7 100755\n--- a/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java\n+++ b/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java\n\n@@ -64,7 +64,14 @@ import javax.ws.rs.Produces;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.UriBuilder;\n-import java.util.*;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n"}}, {"oid": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "url": "https://github.com/keycloak/keycloak/commit/1fbb7e49687f67317d20c229039c9b7692dc8a33", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-12T08:17:44Z", "type": "commit"}, {"oid": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "url": "https://github.com/keycloak/keycloak/commit/1fbb7e49687f67317d20c229039c9b7692dc8a33", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-12T08:17:44Z", "type": "forcePushed"}]}