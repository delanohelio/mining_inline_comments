{"pr_number": 51644, "pr_title": "[ML][Inference] stream inflate to parser + throw when byte limit is reached", "pr_createdAt": "2020-01-29T19:01:00Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51644", "timeline": [{"oid": "87284112ca22ef673ec56724f65b6635d34f26a2", "url": "https://github.com/elastic/elasticsearch/commit/87284112ca22ef673ec56724f65b6635d34f26a2", "message": "[ML][Inference] indicating when limit is reached, stream to parser", "committedDate": "2020-01-29T18:50:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNTY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372815667", "bodyText": "Why is 10% a good number?", "author": "przemekwitek", "createdAt": "2020-01-30T08:35:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -33,7 +34,10 @@\n  */\n public final class InferenceToXContentCompressor {\n     private static final int BUFFER_SIZE = 4096;\n-    private static final long MAX_INFLATED_BYTES = 1_000_000_000; // 1 gb maximum\n+    // Either 10% of the configured JVM heap, or 1 GB, which ever is smaller", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NjIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372856208", "bodyText": "Eventually we could have a dynamic limit that's integrated with the real memory circuit breaker (#31767).  Maybe we could reserve a percentage of free memory and use that as the dynamic limit for a given request, then give back that reservation after finding out the actual size required.  That's something to investigate for 7.7 or 7.8.\nHowever, I think 10% is an OK first step for 7.6 to reduce the risk of someone accidentally triggering an OOM on a node with a small heap.", "author": "droberts195", "createdAt": "2020-01-30T10:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNTY2Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");\n          \n          \n            \n                        throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize + \"]\");", "author": "przemekwitek", "createdAt": "2020-01-30T08:36:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,29 +49,30 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        if (compressedBytes.length > streamSize) {\n+            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1019208dac59e6be282fa5d966c9938871665e7e", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\nindex b479c29839d..b85e50fdd87 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n\n@@ -66,17 +66,16 @@ public final class InferenceToXContentCompressor {\n     }\n \n     static InputStream inflate(String compressedString, long streamSize) throws IOException {\n-        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         if (compressedBytes.length > streamSize) {\n-            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");\n+            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize + \"]\");\n         }\n         InputStream gzipStream = new GZIPInputStream(new BytesArray(compressedBytes).streamInput(), BUFFER_SIZE);\n-        return new SimpleBoundedInputStream(gzipStream, streamSize, true);\n+        return new SimpleBoundedInputStream(gzipStream, streamSize);\n     }\n \n-    //Public for testing (for now)\n-    public static String deflate(BytesReference reference) throws IOException {\n+    private static String deflate(BytesReference reference) throws IOException {\n         BytesStreamOutput out = new BytesStreamOutput();\n         try (OutputStream compressedOutput = new GZIPOutputStream(out, BUFFER_SIZE)) {\n             reference.writeTo(compressedOutput);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816336", "bodyText": "Could you move this line after line 70 (compressedBytes) so that it is clearly visible that it refers to the if check?", "author": "przemekwitek", "createdAt": "2020-01-30T08:36:50Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,29 +49,30 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1019208dac59e6be282fa5d966c9938871665e7e", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\nindex b479c29839d..b85e50fdd87 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n\n@@ -66,17 +66,16 @@ public final class InferenceToXContentCompressor {\n     }\n \n     static InputStream inflate(String compressedString, long streamSize) throws IOException {\n-        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well\n         if (compressedBytes.length > streamSize) {\n-            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize +\"]\");\n+            throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize + \"]\");\n         }\n         InputStream gzipStream = new GZIPInputStream(new BytesArray(compressedBytes).streamInput(), BUFFER_SIZE);\n-        return new SimpleBoundedInputStream(gzipStream, streamSize, true);\n+        return new SimpleBoundedInputStream(gzipStream, streamSize);\n     }\n \n-    //Public for testing (for now)\n-    public static String deflate(BytesReference reference) throws IOException {\n+    private static String deflate(BytesReference reference) throws IOException {\n         BytesStreamOutput out = new BytesStreamOutput();\n         try (OutputStream compressedOutput = new GZIPOutputStream(out, BUFFER_SIZE)) {\n             reference.writeTo(compressedOutput);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n          \n          \n            \n                            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes + \"]\");", "author": "przemekwitek", "createdAt": "2020-01-30T08:37:45Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java", "diffHunk": "@@ -38,6 +39,9 @@ public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n+            if (throwWhenExceeded) {\n+                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1019208dac59e6be282fa5d966c9938871665e7e", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\nindex 8f90c36a5f4..1d845d3b332 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\n\n@@ -19,30 +19,25 @@ public final class SimpleBoundedInputStream extends InputStream {\n     private final InputStream in;\n     private final long maxBytes;\n     private long numBytes;\n-    private final boolean throwWhenExceeded;\n \n-    public SimpleBoundedInputStream(InputStream inputStream, long maxBytes, boolean throwWhenExceeded) {\n+    public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n         this.in = ExceptionsHelper.requireNonNull(inputStream, \"inputStream\");\n         if (maxBytes < 0) {\n             throw new IllegalArgumentException(\"[maxBytes] must be greater than or equal to 0\");\n         }\n         this.maxBytes = maxBytes;\n-        this.throwWhenExceeded = throwWhenExceeded;\n     }\n \n     /**\n      * A simple wrapper around the injected input stream that restricts the total number of bytes able to be read.\n-     * @return The byte read. -1 on internal stream completion or when maxBytes is exceeded.\n-     * @throws IOException on failure\n+     * @return The byte read.\n+     * @throws IOException on failure or when byte limit is exceeded\n      */\n     @Override\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n-            if (throwWhenExceeded) {\n-                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n-            }\n-            return -1;\n+            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes + \"]\");\n         }\n         numBytes++;\n         return in.read();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgxNjk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372816981", "bodyText": "Why do we sometimes throw and sometimes return -1? Would it be possible to have only one exit point?", "author": "przemekwitek", "createdAt": "2020-01-30T08:38:19Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java", "diffHunk": "@@ -38,6 +39,9 @@ public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n+            if (throwWhenExceeded) {\n+                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n+            }\n             return -1;", "originalCommit": "87284112ca22ef673ec56724f65b6635d34f26a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1019208dac59e6be282fa5d966c9938871665e7e", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\nindex 8f90c36a5f4..1d845d3b332 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/utils/SimpleBoundedInputStream.java\n\n@@ -19,30 +19,25 @@ public final class SimpleBoundedInputStream extends InputStream {\n     private final InputStream in;\n     private final long maxBytes;\n     private long numBytes;\n-    private final boolean throwWhenExceeded;\n \n-    public SimpleBoundedInputStream(InputStream inputStream, long maxBytes, boolean throwWhenExceeded) {\n+    public SimpleBoundedInputStream(InputStream inputStream, long maxBytes) {\n         this.in = ExceptionsHelper.requireNonNull(inputStream, \"inputStream\");\n         if (maxBytes < 0) {\n             throw new IllegalArgumentException(\"[maxBytes] must be greater than or equal to 0\");\n         }\n         this.maxBytes = maxBytes;\n-        this.throwWhenExceeded = throwWhenExceeded;\n     }\n \n     /**\n      * A simple wrapper around the injected input stream that restricts the total number of bytes able to be read.\n-     * @return The byte read. -1 on internal stream completion or when maxBytes is exceeded.\n-     * @throws IOException on failure\n+     * @return The byte read.\n+     * @throws IOException on failure or when byte limit is exceeded\n      */\n     @Override\n     public int read() throws IOException {\n         // We have reached the maximum, signal stream completion.\n         if (numBytes >= maxBytes) {\n-            if (throwWhenExceeded) {\n-                throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes +\"]\");\n-            }\n-            return -1;\n+            throw new IOException(\"input stream exceeded maximum bytes of [\" + maxBytes + \"]\");\n         }\n         numBytes++;\n         return in.read();\n"}}, {"oid": "1019208dac59e6be282fa5d966c9938871665e7e", "url": "https://github.com/elastic/elasticsearch/commit/1019208dac59e6be282fa5d966c9938871665e7e", "message": "addressing PR commens", "committedDate": "2020-01-30T12:12:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxOTY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372919677", "bodyText": "Should we also verify that the IOException has the message containing \"input stream exceeded maximum bytes\"?", "author": "przemekwitek", "createdAt": "2020-01-30T12:26:26Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java", "diffHunk": "@@ -35,18 +31,11 @@ public void testInflateAndDeflate() throws IOException {\n     public void testInflateTooLargeStream() throws IOException {\n         TrainedModelDefinition definition = TrainedModelDefinitionTests.createRandomBuilder().build();\n         String firstDeflate = InferenceToXContentCompressor.deflate(definition);\n-        BytesReference inflatedBytes = InferenceToXContentCompressor.inflate(firstDeflate, 10L);\n-        assertThat(inflatedBytes.length(), equalTo(10));\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry(),\n-            LoggingDeprecationHandler.INSTANCE,\n-            inflatedBytes,\n-            XContentType.JSON)) {\n-            expectThrows(IOException.class, () -> TrainedModelConfig.fromXContent(parser, true));\n-        }\n+        expectThrows(IOException.class, () -> Streams.readFully(InferenceToXContentCompressor.inflate(firstDeflate, 10L)));", "originalCommit": "1019208dac59e6be282fa5d966c9938871665e7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3456259f90d890cf71e4bb23a62ab12fe879b1e1", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java\nindex 913927f676d..099c9ea4465 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressorTests.java\n\n@@ -29,9 +35,18 @@ public class InferenceToXContentCompressorTests extends ESTestCase {\n     }\n \n     public void testInflateTooLargeStream() throws IOException {\n-        TrainedModelDefinition definition = TrainedModelDefinitionTests.createRandomBuilder().build();\n+        TrainedModelDefinition definition = TrainedModelDefinitionTests.createRandomBuilder()\n+            .setPreProcessors(Stream.generate(() -> randomFrom(FrequencyEncodingTests.createRandom(),\n+                OneHotEncodingTests.createRandom(),\n+                TargetMeanEncodingTests.createRandom()))\n+                .limit(100)\n+                .collect(Collectors.toList()))\n+            .build();\n         String firstDeflate = InferenceToXContentCompressor.deflate(definition);\n-        expectThrows(IOException.class, () -> Streams.readFully(InferenceToXContentCompressor.inflate(firstDeflate, 10L)));\n+        int max = firstDeflate.getBytes(StandardCharsets.UTF_8).length + 10;\n+        IOException ex = expectThrows(IOException.class,\n+            () -> Streams.readFully(InferenceToXContentCompressor.inflate(firstDeflate, max)));\n+        assertThat(ex.getMessage(), equalTo(\"input stream exceeded maximum bytes of [\" + max + \"]\"));\n     }\n \n     public void testInflateGarbage() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyNzk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51644#discussion_r372927951", "bodyText": "This comment isn't true in general.  If you compress a very small string then the compressed size is bigger than the original.  For example echo a | gzip -9 | wc -c returns 22.\nThe assumption is OK with the sort of streamSize values this method is going to be called with given the current code, so it's not essential to change now, but you could make it something like if (compressedBytes.length > Math.max(100L, streamSize)) in case it ever needs to cope with an extreme edge case in the future.\nAlso, it would be good to adjust the comment to acknowledge the edge case.", "author": "droberts195", "createdAt": "2020-01-30T12:48:12Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java", "diffHunk": "@@ -45,33 +49,33 @@ private InferenceToXContentCompressor() {}\n     static <T> T inflate(String compressedString,\n                          CheckedFunction<XContentParser, T, IOException> parserFunction,\n                          NamedXContentRegistry xContentRegistry) throws IOException {\n-        try(XContentParser parser = XContentHelper.createParser(xContentRegistry,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parserFunction.apply(parser);\n         }\n     }\n \n     static Map<String, Object> inflateToMap(String compressedString) throws IOException {\n         // Don't need the xcontent registry as we are not deflating named objects.\n-        try(XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY,\n+        try(XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY,\n             LoggingDeprecationHandler.INSTANCE,\n-            inflate(compressedString, MAX_INFLATED_BYTES),\n-            XContentType.JSON)) {\n+            inflate(compressedString, MAX_INFLATED_BYTES))) {\n             return parser.mapOrdered();\n         }\n     }\n \n-    static BytesReference inflate(String compressedString, long streamSize) throws IOException {\n+    static InputStream inflate(String compressedString, long streamSize) throws IOException {\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n+        // If the compressed length is already too large, it make sense that the inflated length would be as well", "originalCommit": "1019208dac59e6be282fa5d966c9938871665e7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3456259f90d890cf71e4bb23a62ab12fe879b1e1", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\nindex b85e50fdd87..1b064029526 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/InferenceToXContentCompressor.java\n\n@@ -68,7 +68,8 @@ public final class InferenceToXContentCompressor {\n     static InputStream inflate(String compressedString, long streamSize) throws IOException {\n         byte[] compressedBytes = Base64.getDecoder().decode(compressedString.getBytes(StandardCharsets.UTF_8));\n         // If the compressed length is already too large, it make sense that the inflated length would be as well\n-        if (compressedBytes.length > streamSize) {\n+        // In the extremely small string case, the compressed data could actually be longer than the compressed stream\n+        if (compressedBytes.length > Math.max(100L, streamSize)) {\n             throw new IOException(\"compressed stream is longer than maximum allowed bytes [\" + streamSize + \"]\");\n         }\n         InputStream gzipStream = new GZIPInputStream(new BytesArray(compressedBytes).streamInput(), BUFFER_SIZE);\n"}}, {"oid": "3456259f90d890cf71e4bb23a62ab12fe879b1e1", "url": "https://github.com/elastic/elasticsearch/commit/3456259f90d890cf71e4bb23a62ab12fe879b1e1", "message": "adjusting test and throw conditions", "committedDate": "2020-01-30T13:20:05Z", "type": "commit"}]}