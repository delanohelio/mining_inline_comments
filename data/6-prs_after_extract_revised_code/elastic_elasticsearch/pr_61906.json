{"pr_number": 61906, "pr_title": "Determine shard size before allocating shards recovering from snapshots", "pr_createdAt": "2020-09-03T12:45:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61906", "timeline": [{"oid": "1268d7aaa5d28a182afb552613f688a23b079985", "url": "https://github.com/elastic/elasticsearch/commit/1268d7aaa5d28a182afb552613f688a23b079985", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T10:17:35Z", "type": "forcePushed"}, {"oid": "99d2a2806285e590af136f7d8937d1afc93a27b5", "url": "https://github.com/elastic/elasticsearch/commit/99d2a2806285e590af136f7d8937d1afc93a27b5", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T12:41:37Z", "type": "forcePushed"}, {"oid": "4a999820dc192645bc8c024648343bcddc48fca6", "url": "https://github.com/elastic/elasticsearch/commit/4a999820dc192645bc8c024648343bcddc48fca6", "message": "Determine shard size before searchable snapshot shard allocation", "committedDate": "2020-09-07T15:27:58Z", "type": "commit"}, {"oid": "311d08f2b348911002873c328c9901cadc298aa5", "url": "https://github.com/elastic/elasticsearch/commit/311d08f2b348911002873c328c9901cadc298aa5", "message": "Add test for restore case", "committedDate": "2020-09-07T15:27:58Z", "type": "commit"}, {"oid": "311d08f2b348911002873c328c9901cadc298aa5", "url": "https://github.com/elastic/elasticsearch/commit/311d08f2b348911002873c328c9901cadc298aa5", "message": "Add test for restore case", "committedDate": "2020-09-07T15:27:58Z", "type": "forcePushed"}, {"oid": "232cc2e3764b5b13f15320e2441da78094c4ba82", "url": "https://github.com/elastic/elasticsearch/commit/232cc2e3764b5b13f15320e2441da78094c4ba82", "message": "more  test fixes  + CCR integration", "committedDate": "2020-09-08T09:32:30Z", "type": "commit"}, {"oid": "e6a9a4717961129f8c5676727a87187552e312d7", "url": "https://github.com/elastic/elasticsearch/commit/e6a9a4717961129f8c5676727a87187552e312d7", "message": "checkstyle", "committedDate": "2020-09-08T11:18:18Z", "type": "commit"}, {"oid": "f0c48e691cc50566a8267fe0fc13f2404d8d4d92", "url": "https://github.com/elastic/elasticsearch/commit/f0c48e691cc50566a8267fe0fc13f2404d8d4d92", "message": "Merge remote-tracking branch 'elastic/master' into snapshot-size-based-allocation", "committedDate": "2020-09-08T11:19:02Z", "type": "commit"}, {"oid": "c596dac2b8e18068772118b07e6fe8b5da91a8ff", "url": "https://github.com/elastic/elasticsearch/commit/c596dac2b8e18068772118b07e6fe8b5da91a8ff", "message": "checkstyle", "committedDate": "2020-09-08T19:16:51Z", "type": "commit"}, {"oid": "7fc0052540cb493e6921ec6dfd20cab7d0e04f00", "url": "https://github.com/elastic/elasticsearch/commit/7fc0052540cb493e6921ec6dfd20cab7d0e04f00", "message": "chasdada", "committedDate": "2020-09-09T07:40:14Z", "type": "commit"}, {"oid": "5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "url": "https://github.com/elastic/elasticsearch/commit/5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "message": "Merge remote-tracking branch 'elastic/master' into snapshot-size-based-allocation", "committedDate": "2020-09-09T08:50:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MDg0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r485450843", "bodyText": "I'm not sure which thread-pool to use here. SNAPSHOT wasn't great because I feared allocation could be delayed by long-running backups. ASYNC_FETCH thread pool could turn out to be problematic as it might interfere with recoveries of local primaries (although that threadpool is generously sized).", "author": "ywelsch", "createdAt": "2020-09-09T08:56:25Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId &&\n+                snapshot.equals(that.snapshot) &&\n+                index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {", "originalCommit": "5e64f308895ac9bfb2f33e5d30701b59cf3eb3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzMDQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r495930498", "bodyText": "I agree with not using the SNAPSHOT thread pool here. I think we should reuse FETCH_SHARD_STORE or add a new one.", "author": "tlrx", "createdAt": "2020-09-28T13:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MDg0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d1d805782b65f3d0e5376f0cb23ae3205a6b2bd9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex de63f661000..489a1ec530d 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -27,6 +27,7 @@ import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RecoverySource.SnapshotRecoverySource;\n import org.elasticsearch.cluster.routing.RerouteService;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.ShardRoutingState;\n"}}, {"oid": "7dda136a6f4c6aa3696be30be4d196d31fb5c352", "url": "https://github.com/elastic/elasticsearch/commit/7dda136a6f4c6aa3696be30be4d196d31fb5c352", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-09-28T10:56:09Z", "type": "commit"}, {"oid": "ef544ce81231bb5d36ae883e8c2135fb99bd9f9b", "url": "https://github.com/elastic/elasticsearch/commit/ef544ce81231bb5d36ae883e8c2135fb99bd9f9b", "message": "Fix DataTierAllocationDeciderTests", "committedDate": "2020-09-28T11:07:38Z", "type": "commit"}, {"oid": "d1d805782b65f3d0e5376f0cb23ae3205a6b2bd9", "url": "https://github.com/elastic/elasticsearch/commit/d1d805782b65f3d0e5376f0cb23ae3205a6b2bd9", "message": "Apply some feedback and cosmetics", "committedDate": "2020-09-28T13:36:40Z", "type": "commit"}, {"oid": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "url": "https://github.com/elastic/elasticsearch/commit/cb6daa1f9262d2b11f68ee18775db67c074b7da7", "message": "Fix imports", "committedDate": "2020-09-28T14:50:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2MzUwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r496863502", "bodyText": "On failures, every reroute will trigger another round of fetch of shard size(s) and lead to more warning logs. And in the meantime, the cluster is yellow due to ClusterShardHealth.getInactivePrimaryHealth.\nIn particular if this happens together with the bursts described below, it could be a burdensome load on the master node?", "author": "henningandersen", "createdAt": "2020-09-29T16:14:37Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            final SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId\n+                && snapshot.equals(that.snapshot)\n+                && index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {\n+                                @Override\n+                                public void onFailure(Exception e) {\n+                                    logger.warn(new ParameterizedMessage(\"failed to retrieve shard size information for {}\",", "originalCommit": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f5c2abdb1454b863fab860274ef1c201f9274ca", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 2ba49abfc08..5756a03388d 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -30,10 +30,17 @@ import org.elasticsearch.cluster.routing.RecoverySource;\n import org.elasticsearch.cluster.routing.RerouteService;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n import org.elasticsearch.repositories.IndexId;\n import org.elasticsearch.repositories.RepositoriesService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MDYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r496880617", "bodyText": "I think this will lead to a burst of many requests to the blob store to get the shard size whenever a node holding searchable snapshots fails or is restarted.\nThis could block the generic thread pool for a while, potentially causing other issues. Similarly if moving to the FETCH_SHARD_STORE pool it might interfere with recoveries of primaries.\nGeneric pool has minimum 128 threads, which does mean a decent amount of parallel fetching from blobstore, but going for other pools would likely lower this considerably.\nIt also feels like a bad spot in our allocation to have a dependency on an external blob store, in particular if it responds very slowly for odd reasons. Once persistent cache is in place, we should be able to recover on our own without accessing the blob store.", "author": "henningandersen", "createdAt": "2020-09-29T16:33:51Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesServiceSupplier;\n+    private final Supplier<RerouteService> rerouteServiceSupplier;\n+\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> snapshotShardSizes;\n+\n+    private final Set<SnapshotShard> fetchingShards = Sets.newConcurrentHashSet();\n+\n+    public InternalSnapshotsInfoService(ThreadPool threadPool, Supplier<RepositoriesService> repositoriesServiceSupplier,\n+                                        Supplier<RerouteService> rerouteServiceSupplier) {\n+        this.threadPool = threadPool;\n+        this.repositoriesServiceSupplier = repositoriesServiceSupplier;\n+        this.rerouteServiceSupplier = rerouteServiceSupplier;\n+        snapshotShardSizes = ImmutableOpenMap.of();\n+    }\n+\n+    public static class SnapshotShard {\n+\n+        private final Snapshot snapshot;\n+        private final IndexId index;\n+        private final int shardId;\n+\n+        public SnapshotShard(Snapshot snapshot, IndexId index, int shardId) {\n+            this.snapshot = snapshot;\n+            this.index = index;\n+            this.shardId = shardId;\n+        }\n+\n+        public Snapshot getSnapshot() {\n+            return snapshot;\n+        }\n+\n+        public IndexId getIndex() {\n+            return index;\n+        }\n+\n+        public int getShardId() {\n+            return shardId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (o == null || getClass() != o.getClass()) {\n+                return false;\n+            }\n+            final SnapshotShard that = (SnapshotShard) o;\n+            return shardId == that.shardId\n+                && snapshot.equals(that.snapshot)\n+                && index.equals(that.index);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(snapshot, index, shardId);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SnapshotShard{\" +\n+                \"snapshot=\" + snapshot +\n+                \", index=\" + index +\n+                \", shardId=\" + shardId +\n+                '}';\n+        }\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(snapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> requiredSnapshotShards = new HashSet<>();\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.id());\n+                    requiredSnapshotShards.add(snapshotShard);\n+                    // check if already populated entry\n+                    if (snapshotShardSizes.get(snapshotShard) == null) {\n+                        // check if already fetching snapshot info in progress\n+                        if (fetchingShards.add(snapshotShard)) {\n+                            // TODO: Use a dedicated threadpool here? Use FETCH thread pool?\n+                            threadPool.generic().execute(new AbstractRunnable() {\n+                                @Override\n+                                public void onFailure(Exception e) {\n+                                    logger.warn(new ParameterizedMessage(\"failed to retrieve shard size information for {}\",\n+                                        shardRouting), e);\n+                                }\n+\n+                                @Override\n+                                protected void doRun() {\n+                                    final RepositoriesService repositories = repositoriesServiceSupplier.get();\n+                                    assert repositories != null;\n+                                    final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+                                    final IndexShardSnapshotStatus status =\n+                                        repository.getShardSnapshotStatus(snapshotRecoverySource.snapshot().getSnapshotId(),", "originalCommit": "cb6daa1f9262d2b11f68ee18775db67c074b7da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MjA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r497482098", "bodyText": "++ we must limit the concurrency here. This isn't just about threads (though that's reason enough) but also about memory to some degree.  org.elasticsearch.repositories.blobstore.BlobStoreRepository#getShardSnapshotStatus might use a few MB per shard in memory because the underlying metadata file that is loaded from the blobstore is non-trivial in size (we essentially have the same requests in the _status APIs for snapshot status and don't parallelize them there either at least for now because we have to be careful about the concurrency).", "author": "original-brownbear", "createdAt": "2020-09-30T12:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MDYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "8f5c2abdb1454b863fab860274ef1c201f9274ca", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 2ba49abfc08..5756a03388d 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -30,10 +30,17 @@ import org.elasticsearch.cluster.routing.RecoverySource;\n import org.elasticsearch.cluster.routing.RerouteService;\n import org.elasticsearch.cluster.routing.ShardRouting;\n import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.Priority;\n import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n import org.elasticsearch.repositories.IndexId;\n import org.elasticsearch.repositories.RepositoriesService;\n"}}, {"oid": "8f5c2abdb1454b863fab860274ef1c201f9274ca", "url": "https://github.com/elastic/elasticsearch/commit/8f5c2abdb1454b863fab860274ef1c201f9274ca", "message": "Bound concurrent snapshot shard size retrievals", "committedDate": "2020-10-05T07:57:01Z", "type": "commit"}, {"oid": "f5ea5a9d9059598248ed25e0e383d3d242794269", "url": "https://github.com/elastic/elasticsearch/commit/f5ea5a9d9059598248ed25e0e383d3d242794269", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-10-05T07:57:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxOTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499419217", "bodyText": "This only need to be added on master nodes right? (relates #63223)", "author": "original-brownbear", "createdAt": "2020-10-05T08:15:38Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private final AdjustableSemaphore semaphore;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.semaphore = new AdjustableSemaphore(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings), false);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        clusterService.addListener(this);", "originalCommit": "f5ea5a9d9059598248ed25e0e383d3d242794269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NDk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499454991", "bodyText": "Good catch, I pushed 6c59655#diff-555b04095ef512902f5b90599d4a8da1R101-R103", "author": "tlrx", "createdAt": "2020-10-05T09:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxOTIxNw=="}], "type": "inlineReview", "revised_code": {"commit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 5756a03388d..e1ce8f4077b 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -26,6 +26,7 @@ import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n import org.elasticsearch.cluster.routing.RerouteService;\n import org.elasticsearch.cluster.routing.ShardRouting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyODE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499428159", "bodyText": "Do we really need a Semaphore here? Can't we just have these tasks increment a counter with incrementAndGet whenever we try to start one and if it's below the current limit + 1 we start a task? Then we only need to decrement the counter when we poll a null from the queue and it's all a lot easier isn't it?", "author": "original-brownbear", "createdAt": "2020-10-05T08:31:40Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.AdjustableSemaphore;\n+import org.elasticsearch.common.util.concurrent.RunOnce;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private final AdjustableSemaphore semaphore;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.semaphore = new AdjustableSemaphore(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings), false);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        clusterService.addListener(this);\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        semaphore.setMaxPermits(maxConcurrentFetches);\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, semaphore.getMaxPermits());\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        if (semaphore.tryAcquire()) {", "originalCommit": "f5ea5a9d9059598248ed25e0e383d3d242794269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTMzMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499455330", "bodyText": "Something like 6c59655?", "author": "tlrx", "createdAt": "2020-10-05T09:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyODE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 5756a03388d..e1ce8f4077b 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -26,6 +26,7 @@ import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n import org.elasticsearch.cluster.routing.RerouteService;\n import org.elasticsearch.cluster.routing.ShardRouting;\n"}}, {"oid": "9aea78a9c829d69f0d01829127e3c07b36d66687", "url": "https://github.com/elastic/elasticsearch/commit/9aea78a9c829d69f0d01829127e3c07b36d66687", "message": "Revert", "committedDate": "2020-10-05T09:08:54Z", "type": "commit"}, {"oid": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "url": "https://github.com/elastic/elasticsearch/commit/6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "message": "apply feedback", "committedDate": "2020-10-05T09:15:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzk5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499507993", "bodyText": "NIT: we could make this ActionListener just a static constant?", "author": "original-brownbear", "createdAt": "2020-10-05T10:48:04Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718274", "bodyText": "Sure, I pushed bfd352c", "author": "tlrx", "createdAt": "2020-10-05T16:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMDczOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499510739", "bodyText": "This method can just be inlined, we never overwrite it?", "author": "original-brownbear", "createdAt": "2020-10-05T10:53:46Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718303", "bodyText": "This is a left-over, I removed it in f9ed974", "author": "tlrx", "createdAt": "2020-10-05T16:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMzU2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499513566", "bodyText": "Maybe extract these two lines into a method releaseFetcher or so and with a one liner describing what this does since we use this in two spots?", "author": "original-brownbear", "createdAt": "2020-10-05T10:59:05Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);\n+                        fetchNextSnapshotShard();\n+                    }\n+                });\n+                success = true;\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+        } finally {\n+            if (success == false) {\n+                final int value = concurrentFetches.decrementAndGet();\n+                assert value >= 0 : \"Unexpected value: \" + value;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNjE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499516152", "bodyText": "Maybe just make this a one liner with the above since we never really use status otherwise:\n                        final long snapshotShardSize = repository.getShardSnapshotStatus(\n                                snapshotShard.snapshot().getSnapshotId(),\n                                snapshotShard.index(),\n                                snapshotShard.shardId()\n                        ).asCopy().getTotalSize();", "author": "original-brownbear", "createdAt": "2020-10-05T11:04:32Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718360", "bodyText": "Ok, I pushed 866ba36", "author": "tlrx", "createdAt": "2020-10-05T16:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNjE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxODEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499518135", "bodyText": "NIT: Maybe just if (isMaster == false) ?", "author": "original-brownbear", "createdAt": "2020-10-05T11:08:36Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718410", "bodyText": "Done in 7343b63", "author": "tlrx", "createdAt": "2020-10-05T16:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxODEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTc4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499521780", "bodyText": "Should we make sure to return the same size for the same shard consistently? (and maybe also assert that we are indeed dealing with a snapshot recovery routing here?)", "author": "original-brownbear", "createdAt": "2020-10-05T11:15:25Z", "path": "test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java", "diffHunk": "@@ -55,6 +58,14 @@\n     private static final ClusterSettings EMPTY_CLUSTER_SETTINGS =\n         new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n \n+    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_SHARD_SIZES = () ->\n+        new SnapshotShardSizeInfo(ImmutableOpenMap.of()) {\n+            @Override\n+            public Long getShardSize(ShardRouting shardRouting) {\n+                return randomNonNegativeLong();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQ0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718447", "bodyText": "I think that it is trappy to always return an random size here. Test that rely on snapshot shard information should use their own implementation. I pushed 28de2d6 to add an assertion as you suggested + throw an unsupported exception here.", "author": "tlrx", "createdAt": "2020-10-05T16:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTc4MA=="}], "type": "inlineReview", "revised_code": {"commit": "28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java b/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\nindex ada090eebfb..6b8483e9d12 100644\n--- a/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\n\n@@ -62,7 +63,9 @@ public abstract class ESAllocationTestCase extends ESTestCase {\n         new SnapshotShardSizeInfo(ImmutableOpenMap.of()) {\n             @Override\n             public Long getShardSize(ShardRouting shardRouting) {\n-                return randomNonNegativeLong();\n+                assert shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT :\n+                    \"Expecting a recovery source of type [SNAPSHOT] but got [\" + shardRouting.recoverySource().getType() + ']';\n+                throw new UnsupportedOperationException();\n             }\n     };\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNTE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499535167", "bodyText": "Isn't updated always true since we won't double schedule a job for a certain shard's size ever?", "author": "original-brownbear", "createdAt": "2020-10-05T11:41:08Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODQ4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718482", "bodyText": "Indeed - I added an assertion on this in 2faf525", "author": "tlrx", "createdAt": "2020-10-05T16:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNTE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNzE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499537167", "bodyText": "Should we assert that this returned true?", "author": "original-brownbear", "createdAt": "2020-10-05T11:44:53Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718537", "bodyText": "I think we can -> a3dcb20", "author": "tlrx", "createdAt": "2020-10-05T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzNzE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzOTY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499539673", "bodyText": "NIT: } else if (event.previousState().nodes().isLocalNodeElectedMaster()) { maybe so we don't execute this over and over?\nI also wonder if we even need to do this? Maybe we should instead just clean out unnecessary items in the map on event.routingTableChanged() if we're not master to not have to repopulate the map over and over in an unstable master situation where it might jump in and out of the cluster a few times (which would be really painful if we're dealing with a large number of shards)?", "author": "original-brownbear", "createdAt": "2020-10-05T11:49:26Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718571", "bodyText": "+1 on the previous state isLocalNodeElectedMaster() condition (ada6dd5).\nI added a //TODO for the other point you raise. I'm not sure we should do it but if we think we should I can do it in a follow up PR.", "author": "tlrx", "createdAt": "2020-10-05T16:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzOTY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540175", "bodyText": "NIT: space after null,", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:16Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -553,7 +551,7 @@ public void testClusterAndIndex() {\n                 .put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, \"data_warm,data_cold\")\n                 .build());\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540389", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:38Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -181,7 +183,7 @@ public void testIndexRequires() {\n                 .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, \"data_hot\")\n                 .build());\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b942b2db21b646f910664c935f11e3919d329945", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\nindex b003442dd00..8a9487b44db 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n\n@@ -183,7 +183,7 @@ public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n                 .put(DataTierAllocationDecider.INDEX_ROUTING_REQUIRE, \"data_hot\")\n                 .build());\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         Decision d;\n         RoutingNode node;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQyMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540422", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:42Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -143,7 +145,7 @@ public void testClusterIncludes() {\n     public void testClusterExcludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b942b2db21b646f910664c935f11e3919d329945", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\nindex b003442dd00..8a9487b44db 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n\n@@ -145,7 +145,7 @@ public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n     public void testClusterExcludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         clusterSettings.applySettings(Settings.builder()\n             .put(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE, \"data_warm\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540442", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:44Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -108,7 +110,7 @@ public void testClusterRequires() {\n     public void testClusterIncludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b942b2db21b646f910664c935f11e3919d329945", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\nindex b003442dd00..8a9487b44db 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n\n@@ -110,7 +110,7 @@ public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n     public void testClusterIncludes() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         clusterSettings.applySettings(Settings.builder()\n             .put(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE, \"data_warm,data_cold\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499540471", "bodyText": "NIT: Missing space here", "author": "original-brownbear", "createdAt": "2020-10-05T11:50:48Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -74,7 +76,7 @@\n     public void testClusterRequires() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718651", "bodyText": "Spaces addressed in b942b2d (sorry)", "author": "tlrx", "createdAt": "2020-10-05T16:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MDQ3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b942b2db21b646f910664c935f11e3919d329945", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\nindex b003442dd00..8a9487b44db 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n\n@@ -76,7 +76,7 @@ public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n     public void testClusterRequires() {\n         ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"));\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         clusterSettings.applySettings(Settings.builder()\n             .put(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE, \"data_hot\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499541123", "bodyText": "NIT: use org.elasticsearch.threadpool.ThreadPool#terminate(java.util.concurrent.ExecutorService, long, java.util.concurrent.TimeUnit) and assert it returns true?", "author": "original-brownbear", "createdAt": "2020-10-05T11:51:58Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        threadPool.shutdownNow();\n+        threadPool.awaitTermination(30L, TimeUnit.SECONDS);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718693", "bodyText": "Sure, see be18fad", "author": "tlrx", "createdAt": "2020-10-05T16:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0MTEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "be18fad0a34ae29242e2414d1f36f01d7d19c127", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 10cdda3d39a..20ef6e03e0c 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -107,8 +107,8 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n     @Override\n     public void tearDown() throws Exception {\n         super.tearDown();\n-        threadPool.shutdownNow();\n-        threadPool.awaitTermination(30L, TimeUnit.SECONDS);\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n         clusterService.close();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NDIzMg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499544232", "bodyText": "NIT: Could do this in one go with the utilities we have as (also avoid mixing our own concurrency primitives with the JDK's):\n        PlainActionFuture.get(future -> clusterService.getClusterApplierService().onNewClusterState(reason,\n                () -> applier.apply(clusterService.state()),\n                new ClusterApplier.ClusterApplyListener() {\n                    @Override\n                    public void onSuccess(String source) {\n                        future.onResponse(source);\n                    }\n\n                    @Override\n                    public void onFailure(String source, Exception e) {\n                        future.onFailure(e);\n                    }\n                }));", "author": "original-brownbear", "createdAt": "2020-10-05T11:57:40Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        threadPool.shutdownNow();\n+        threadPool.awaitTermination(30L, TimeUnit.SECONDS);\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+        verify(rerouteService, times(numberOfShards)).reroute(anyString(), any(Priority.class), any());\n+\n+        for (int i = 0; i < numberOfShards; i++) {\n+            final ShardRouting shardRouting = clusterService.state().routingTable().index(indexName).shard(i).primaryShard();\n+            assertThat(snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting), equalTo(expectedShardSizes[i]));\n+        }\n+    }\n+\n+    public void testErroneousSnapshotShardSizes() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), randomIntBetween(1, 10))\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> succeed = Sets.newConcurrentHashSet();\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> failed = Sets.newConcurrentHashSet();\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    final InternalSnapshotsInfoService.SnapshotShard snapshotShard =\n+                        new InternalSnapshotsInfoService.SnapshotShard(new Snapshot(\"_repo\", snapshotId), indexId, shardId);\n+                    if (randomBoolean()) {\n+                        failed.add(snapshotShard);\n+                        throw new SnapshotException(snapshotShard.snapshot(), \"simulated\");\n+                    } else {\n+                        succeed.add(snapshotShard);\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                    }\n+                }\n+            });\n+\n+        final int maxShardsToCreate = scaledRandomIntBetween(10, 500);\n+        final Thread addSnapshotRestoreIndicesThread = new Thread(() -> {\n+            int remainingShards = maxShardsToCreate;\n+            while (remainingShards > 0) {\n+                final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+                final int numberOfShards = randomIntBetween(1, maxShardsToCreate);\n+                try {\n+                    applyClusterState(\"add-more-unassigned-shards-for-\" + indexName,\n+                        clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                } finally {\n+                    remainingShards -= numberOfShards;\n+                }\n+            }\n+        });\n+        addSnapshotRestoreIndicesThread.start();\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(succeed.size()));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+\n+        addSnapshotRestoreIndicesThread.join();\n+    }\n+\n+    public void testNoLongerMaster() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.EMPTY, clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                }\n+            });\n+\n+        for (int i = 0; i < randomIntBetween(1, 10); i++) {\n+            final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+            final int nbShards =  randomIntBetween(1, 5);\n+            applyClusterState(\"restore-indices-when-master-\" + indexName,\n+                clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+        }\n+\n+        applyClusterState(\"demote-current-master\", this::demoteMasterNode);\n+\n+        for (int i = 0; i < randomIntBetween(1, 10); i++) {\n+            final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+            final int nbShards =  randomIntBetween(1, 5);\n+            applyClusterState(\"restore-indices-when-no-longer-master-\" + indexName,\n+                clusterState -> addUnassignedShards(clusterState, indexName, nbShards));\n+        }\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+    }\n+\n+    private void applyClusterState(final String reason, final Function<ClusterState, ClusterState> applier) throws Exception {\n+        final CompletableFuture<String> future = new CompletableFuture<>();\n+        clusterService.getClusterApplierService().onNewClusterState(reason,", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODc0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718746", "bodyText": "Indeed, thanks: 6dcff94", "author": "tlrx", "createdAt": "2020-10-05T16:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU0NDIzMg=="}], "type": "inlineReview", "revised_code": {"commit": "be18fad0a34ae29242e2414d1f36f01d7d19c127", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 10cdda3d39a..20ef6e03e0c 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -107,8 +107,8 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n     @Override\n     public void tearDown() throws Exception {\n         super.tearDown();\n-        threadPool.shutdownNow();\n-        threadPool.awaitTermination(30L, TimeUnit.SECONDS);\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n         clusterService.close();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499550651", "bodyText": "I think there is a race here, in that if all threads polled and found out that queue is empty but did not count down the counter yet, we could add to the queue here and risk that the increment results in a number higher than maxConcurrentFetches?", "author": "henningandersen", "createdAt": "2020-10-05T12:10:29Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3Mjc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499572762", "bodyText": "Right sorry for missing that ... looking at this again, do we even have to be so tricky here? :) Maybe we should just sychronize fetchNextSnapshotShard and this block:\n            for (int i = 0; i < nbFetchers; i++) {\n                final int activeFetches = concurrentFetches.incrementAndGet();\n                if (activeFetches < maxConcurrentFetches + 1) {\n                    fetchNextSnapshotShard();\n                } else {\n                    final int value = concurrentFetches.decrementAndGet();\n                    assert value >= 0 : \"Unexpected value: \" + value;\n                }\n            }\non the same mutex (e.g.  on queue) and use a normal int for the in-progress count (no need to bother with the count-down here then as well, we can just call fetchNextSnapshotShard() however often we are allowed in a loop and just adjust the in-progress count once)?  That seems the simplest and least error prone since the performance of the locking is not relevant here anyway?", "author": "original-brownbear", "createdAt": "2020-10-05T12:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499719720", "bodyText": "Following Armin's opinion for simplicity and usage of synchronized blocks I reworked the concurrency part in 674d6c9. I hope it makes things simpler but I must admit that I don't have clear ideas today so I'd appreciate more reviews there.", "author": "tlrx", "createdAt": "2020-10-05T16:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MDY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bfd352c3757230037fee9344ff202f293ce648de", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..c599442c716 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"oid": "bfd352c3757230037fee9344ff202f293ce648de", "url": "https://github.com/elastic/elasticsearch/commit/bfd352c3757230037fee9344ff202f293ce648de", "message": "listener as a constant", "committedDate": "2020-10-05T12:44:07Z", "type": "commit"}, {"oid": "f9ed97469d10f6d5473c56d351421ecdb54c5bbc", "url": "https://github.com/elastic/elasticsearch/commit/f9ed97469d10f6d5473c56d351421ecdb54c5bbc", "message": "remove left over", "committedDate": "2020-10-05T12:45:04Z", "type": "commit"}, {"oid": "866ba36c7ec8a02b7a2ca2e69b0f5c3826691541", "url": "https://github.com/elastic/elasticsearch/commit/866ba36c7ec8a02b7a2ca2e69b0f5c3826691541", "message": "inline snapshotShardSize", "committedDate": "2020-10-05T12:46:37Z", "type": "commit"}, {"oid": "7343b63aafb0b19510e0b4f7236628f4dd41aebf", "url": "https://github.com/elastic/elasticsearch/commit/7343b63aafb0b19510e0b4f7236628f4dd41aebf", "message": "isMaster == false", "committedDate": "2020-10-05T12:48:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499576714", "bodyText": "I think there is a race with unknownSnapshotShards. It does take something extreme but in this case I think we might not read one of the shard sizes:\n\nA cluster state change results in queuing a read for a shard.\nThe read happens and populates knownSnapshotShards, but the thread is halted before removing from unkonwnSnapshotShards.\nA cluster state change removes the need for the shard (deleted index?).\nA cluster state change reintroduces the need to read the shard sizes. This will not add to queue, since this line did not complete yet on the original read.\nThe fetch thread removes shard from unknownSnapshotShards", "author": "henningandersen", "createdAt": "2020-10-05T12:55:40Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private final ClusterService clusterService;\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private final AtomicInteger concurrentFetches;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.clusterService = clusterService;\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = Sets.newConcurrentHashSet();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.concurrentFetches = new AtomicInteger(0);\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    protected String executorName() {\n+        return ThreadPool.Names.GENERIC;\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = new HashSet<>();\n+\n+            int unknownShards = 0;\n+            for (ShardRouting shardRouting : event.state().routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {\n+                if (shardRouting.primary() && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                    final RecoverySource.SnapshotRecoverySource snapshotRecoverySource =\n+                        (RecoverySource.SnapshotRecoverySource) shardRouting.recoverySource();\n+                    final SnapshotShard snapshotShard = new SnapshotShard(snapshotRecoverySource.snapshot(),\n+                        snapshotRecoverySource.index(), shardRouting.shardId());\n+                    onGoingSnapshotRecoveries.add(snapshotShard);\n+\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+            synchronized (this) {\n+                isMaster = true;\n+                ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+                for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+                    if (onGoingSnapshotRecoveries.contains(shard.value) == false) {\n+                        if (newSnapshotShardSizes == null) {\n+                            newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                        }\n+                        newSnapshotShardSizes.remove(shard.value);\n+                    }\n+                }\n+                if (newSnapshotShardSizes != null) {\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                final int activeFetches = concurrentFetches.incrementAndGet();\n+                if (activeFetches < maxConcurrentFetches + 1) {\n+                    fetchNextSnapshotShard();\n+                } else {\n+                    final int value = concurrentFetches.decrementAndGet();\n+                    assert value >= 0 : \"Unexpected value: \" + value;\n+                }\n+            }\n+        } else {\n+            synchronized (this) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        boolean success = false;\n+        try {\n+            final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (snapshotShard != null) {\n+                threadPool.executor(executorName()).execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        if (clusterService.state().nodes().isLocalNodeElectedMaster() == false) {\n+                            logger.debug(\"skipping snapshot shard size retrieval for {} as node is no longer master\", snapshotShard);\n+                            return;\n+                        }\n+\n+                        final RepositoriesService repositories = repositoriesService.get();\n+                        assert repositories != null;\n+                        final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+                        logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+                        final IndexShardSnapshotStatus status = repository.getShardSnapshotStatus(\n+                            snapshotShard.snapshot().getSnapshotId(),\n+                            snapshotShard.index(),\n+                            snapshotShard.shardId()\n+                        );\n+\n+                        final long snapshotShardSize = status.asCopy().getTotalSize();\n+                        logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+                        boolean updated = false;\n+                        synchronized (InternalSnapshotsInfoService.this) {\n+                            if (isMaster) {\n+                                final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                                    ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                                updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                                knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                            }\n+                        }\n+                        if (updated) {\n+                            rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH,\n+                                ActionListener.wrap(\n+                                    r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+                                    e -> logger.debug(\"reroute after snapshot shard size update failed\", e)));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+                    }\n+\n+                    @Override\n+                    public void onAfter() {\n+                        unknownSnapshotShards.remove(snapshotShard);", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwOTY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499609674", "bodyText": "but the thread is halted before removing from\n\nThis is impossible for a running node isn't it? We don't ever kill/interrupt actively executing threads on the generic pool and then keep going with the node?\n(can you even halt a thread in such a way that this method which is called in a finally block isn't executed every time we run this Runnable?)", "author": "original-brownbear", "createdAt": "2020-10-05T13:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzOTk3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499639973", "bodyText": "I'm interested in Armin's questions answers, but besides this Henning raised a good point where the snapshot shard size should be removed from unknownSnapshotShards as soon as it is read, before it is added back to knownSnapshotShards", "author": "tlrx", "createdAt": "2020-10-05T14:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNzg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499807859", "bodyText": "I should probably have used \"paused\" rather than \"halted\". The finally block does run, but steps 3 and 4 could go in before it runs. Thanks for addressing this.", "author": "henningandersen", "createdAt": "2020-10-05T19:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NjcxNA=="}], "type": "inlineReview", "revised_code": {"commit": "28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex e1ce8f4077b..b90f7e1acce 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -25,6 +25,7 @@ import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateListener;\n import org.elasticsearch.cluster.node.DiscoveryNode;\n import org.elasticsearch.cluster.routing.RecoverySource;\n"}}, {"oid": "28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "url": "https://github.com/elastic/elasticsearch/commit/28de2d67de1b28c7d3e29e46bda50e2bef38baa9", "message": "add assert + throw UOE", "committedDate": "2020-10-05T13:40:29Z", "type": "commit"}, {"oid": "2faf52519a6d663559eacac5592a7cbe6a317f80", "url": "https://github.com/elastic/elasticsearch/commit/2faf52519a6d663559eacac5592a7cbe6a317f80", "message": "assert updated", "committedDate": "2020-10-05T13:45:24Z", "type": "commit"}, {"oid": "a3dcb20796c2dec4189289bd6a7e2fcc554bbf93", "url": "https://github.com/elastic/elasticsearch/commit/a3dcb20796c2dec4189289bd6a7e2fcc554bbf93", "message": "assert removed", "committedDate": "2020-10-05T13:47:12Z", "type": "commit"}, {"oid": "b942b2db21b646f910664c935f11e3919d329945", "url": "https://github.com/elastic/elasticsearch/commit/b942b2db21b646f910664c935f11e3919d329945", "message": "spaces", "committedDate": "2020-10-05T13:51:05Z", "type": "commit"}, {"oid": "be18fad0a34ae29242e2414d1f36f01d7d19c127", "url": "https://github.com/elastic/elasticsearch/commit/be18fad0a34ae29242e2414d1f36f01d7d19c127", "message": "terminate()", "committedDate": "2020-10-05T13:51:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5MTU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499591541", "bodyText": "This is unused?", "author": "DaveCTurner", "createdAt": "2020-10-05T13:18:54Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java", "diffHunk": "@@ -150,6 +150,7 @@\n     private final SetOnce<BlobStoreCacheService> blobStoreCacheService = new SetOnce<>();\n     private final SetOnce<CacheService> cacheService = new SetOnce<>();\n     private final SetOnce<ThreadPool> threadPool = new SetOnce<>();\n+    private final SetOnce<ClusterService> clusterService = new SetOnce<>();", "originalCommit": "6c59655bd4c6d5c6ccc19c1a9c9324a3c170e910", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODg4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499718886", "bodyText": "It is, I removed it in ae5895c", "author": "tlrx", "createdAt": "2020-10-05T16:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5MTU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ae5895ce811addbc5094133031dabec540882c02", "chunk": "diff --git a/x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java b/x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java\nindex 29d23917366..a67c14b521c 100644\n--- a/x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java\n+++ b/x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/xpack/searchablesnapshots/SearchableSnapshots.java\n\n@@ -150,7 +150,6 @@ public class SearchableSnapshots extends Plugin implements IndexStorePlugin, Eng\n     private final SetOnce<BlobStoreCacheService> blobStoreCacheService = new SetOnce<>();\n     private final SetOnce<CacheService> cacheService = new SetOnce<>();\n     private final SetOnce<ThreadPool> threadPool = new SetOnce<>();\n-    private final SetOnce<ClusterService> clusterService = new SetOnce<>();\n     private final SetOnce<FailShardsOnInvalidLicenseClusterListener> failShardsListener = new SetOnce<>();\n     private final Settings settings;\n \n"}}, {"oid": "ada6dd50fd6c550822361263efe8e943bae6e13f", "url": "https://github.com/elastic/elasticsearch/commit/ada6dd50fd6c550822361263efe8e943bae6e13f", "message": "isLocalNodeElectedMaster + TODO", "committedDate": "2020-10-05T13:59:03Z", "type": "commit"}, {"oid": "ae5895ce811addbc5094133031dabec540882c02", "url": "https://github.com/elastic/elasticsearch/commit/ae5895ce811addbc5094133031dabec540882c02", "message": "Remove SetOnce<ClusterService>", "committedDate": "2020-10-05T14:03:01Z", "type": "commit"}, {"oid": "6dcff94a1e851651bf8c954f07276426cbedb970", "url": "https://github.com/elastic/elasticsearch/commit/6dcff94a1e851651bf8c954f07276426cbedb970", "message": "PlainActionFuture.get()", "committedDate": "2020-10-05T14:05:31Z", "type": "commit"}, {"oid": "674d6c9387d90f492eaf3d04bd573616b06d5327", "url": "https://github.com/elastic/elasticsearch/commit/674d6c9387d90f492eaf3d04bd573616b06d5327", "message": "another shot at concurrent fetches", "committedDate": "2020-10-05T16:13:57Z", "type": "commit"}, {"oid": "291831f02ced1131a8aecb2104f6ca89853ae69b", "url": "https://github.com/elastic/elasticsearch/commit/291831f02ced1131a8aecb2104f6ca89853ae69b", "message": "Merge branch 'master' into snapshot-size-based-allocation", "committedDate": "2020-10-05T18:51:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499973462", "bodyText": "NIT: revert", "author": "original-brownbear", "createdAt": "2020-10-06T02:36:22Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterInfo.java", "diffHunk": "@@ -22,7 +22,6 @@\n import com.carrotsearch.hppc.ObjectHashSet;\n import com.carrotsearch.hppc.cursors.ObjectCursor;\n import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n-", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185889", "bodyText": "Done in 881f621", "author": "tlrx", "createdAt": "2020-10-06T11:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzQ2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499975641", "bodyText": "We can save some code here now that we have the mutex and don't need a concurrent collection any longer?\ne.g.\ndiff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1917c3544b 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n@@ -46,13 +46,12 @@ import org.elasticsearch.repositories.Repository;\n import org.elasticsearch.threadpool.ThreadPool;\n \n import java.util.Collections;\n+import java.util.Deque;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.Objects;\n import java.util.Set;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n@@ -81,7 +80,7 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n     private final Set<SnapshotShard> unknownSnapshotShards;\n \n     /** a blocking queue used for concurrent fetching **/\n-    private final BlockingQueue<SnapshotShard> queue;\n+    private final Deque<SnapshotShard> queue;\n \n     private volatile int maxConcurrentFetches;\n     private volatile int activeFetches;\n@@ -99,7 +98,7 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n         this.rerouteService = rerouteServiceSupplier;\n         this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n         this.unknownSnapshotShards  = new LinkedHashSet<>();\n-        this.queue = new LinkedBlockingQueue<>();\n+        this.queue = new LinkedList<>();\n         this.mutex = new Object();\n         this.activeFetches = 0;\n         this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n@@ -159,15 +158,10 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n     private void fetchNextSnapshotShard() {\n         synchronized (mutex) {\n             if (activeFetches < maxConcurrentFetches) {\n-                try {\n-                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n-                    if (snapshotShard != null) {\n-                        threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n-                        activeFetches += 1;\n-                    }\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+                final SnapshotShard snapshotShard = queue.pollFirst();\n+                if (snapshotShard != null) {\n+                    threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                    activeFetches += 1;\n                 }\n             }\n             assert assertNumberOfConcurrentFetches();", "author": "original-brownbear", "createdAt": "2020-10-06T02:45:24Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                try {\n+                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwOTk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500009972", "bodyText": "Can we just use poll() and make the queue declaration non blocking? That also removes the need for interrupt handling.", "author": "henningandersen", "createdAt": "2020-10-06T05:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185941", "bodyText": "Makes perfect sense, thanks for noticing this! I pushed 528a848", "author": "tlrx", "createdAt": "2020-10-06T11:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NTY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1912795c98 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -261,7 +261,9 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n \n     // used in tests\n     int numberOfUnknownSnapshotShardSizes() {\n-        return unknownSnapshotShards.size();\n+        synchronized (mutex) {\n+            return unknownSnapshotShards.size();\n+        }\n     }\n \n     // used in tests\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499976138", "bodyText": "This should now synchronise on the mutex as well shouldn't it?", "author": "original-brownbear", "createdAt": "2020-10-06T02:47:30Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                try {\n+                    final SnapshotShard snapshotShard = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                    if (snapshotShard != null) {\n+                        threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                        activeFetches += 1;\n+                    }\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    logger.warn(\"snapshot shard size fetcher has been interrupted\", e);\n+                }\n+            }\n+            assert assertNumberOfConcurrentFetches();\n+        }\n+    }\n+\n+    private class FetchingSnapshotShardSizeRunnable extends AbstractRunnable {\n+\n+        private final SnapshotShard snapshotShard;\n+        private boolean removed;\n+\n+        FetchingSnapshotShardSizeRunnable(SnapshotShard snapshotShard) {\n+            super();\n+            this.snapshotShard = snapshotShard;\n+            this.removed = false;\n+        }\n+\n+        @Override\n+        protected void doRun() throws Exception {\n+            final RepositoriesService repositories = repositoriesService.get();\n+            assert repositories != null;\n+            final Repository repository = repositories.repository(snapshotShard.snapshot.getRepository());\n+\n+            logger.debug(\"fetching snapshot shard size for {}\", snapshotShard);\n+            final long snapshotShardSize = repository.getShardSnapshotStatus(\n+                snapshotShard.snapshot().getSnapshotId(),\n+                snapshotShard.index(),\n+                snapshotShard.shardId()\n+            ).asCopy().getTotalSize();\n+\n+            logger.debug(\"snapshot shard size for {}: {} bytes\", snapshotShard, snapshotShardSize);\n+\n+            boolean updated = false;\n+            synchronized (mutex) {\n+                removed = unknownSnapshotShards.remove(snapshotShard);\n+                assert removed : \"snapshot shard to remove does not exist \" + snapshotShardSize;\n+                if (isMaster) {\n+                    final ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes =\n+                        ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                    updated = newSnapshotShardSizes.put(snapshotShard, snapshotShardSize) == null;\n+                    assert updated : \"snapshot shard size already exists for \" + snapshotShard;\n+                    knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+                }\n+                activeFetches -= 1;\n+                assert assertNumberOfConcurrentFetches();\n+            }\n+            if (updated) {\n+                rerouteService.get().reroute(\"snapshot shard size updated\", Priority.HIGH, REROUTE_LISTENER);\n+            }\n+        }\n+\n+        @Override\n+        public void onFailure(Exception e) {\n+            logger.warn(() -> new ParameterizedMessage(\"failed to retrieve shard size for {}\", snapshotShard), e);\n+            synchronized (mutex) {\n+                if (removed == false) {\n+                    unknownSnapshotShards.remove(snapshotShard);\n+                }\n+                activeFetches -= 1;\n+                assert assertNumberOfConcurrentFetches();\n+            }\n+        }\n+\n+        @Override\n+        public void onAfter() {\n+            fetchNextSnapshotShard();\n+        }\n+    }\n+\n+    private void cleanUpKnownSnapshotShardSizes(Set<SnapshotShard> requiredSnapshotShards) {\n+        assert Thread.holdsLock(mutex);\n+        ImmutableOpenMap.Builder<SnapshotShard, Long> newSnapshotShardSizes = null;\n+        for (ObjectCursor<SnapshotShard> shard : knownSnapshotShardSizes.keys()) {\n+            if (requiredSnapshotShards.contains(shard.value) == false) {\n+                if (newSnapshotShardSizes == null) {\n+                    newSnapshotShardSizes = ImmutableOpenMap.builder(knownSnapshotShardSizes);\n+                }\n+                newSnapshotShardSizes.remove(shard.value);\n+            }\n+        }\n+        if (newSnapshotShardSizes != null) {\n+            knownSnapshotShardSizes = newSnapshotShardSizes.build();\n+        }\n+    }\n+\n+    private boolean assertNumberOfConcurrentFetches() {\n+        assert activeFetches >= 0 : \"active fetches should be greater than or equal to zero but got: \" + activeFetches;\n+        assert activeFetches <= maxConcurrentFetches : activeFetches + \" <= \" + maxConcurrentFetches;\n+        return true;\n+    }\n+\n+    // used in tests\n+    int numberOfUnknownSnapshotShardSizes() {\n+        return unknownSnapshotShards.size();", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NTk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500185969", "bodyText": "Yes -> a777c12", "author": "tlrx", "createdAt": "2020-10-06T11:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1912795c98 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -261,7 +261,9 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n \n     // used in tests\n     int numberOfUnknownSnapshotShardSizes() {\n-        return unknownSnapshotShards.size();\n+        synchronized (mutex) {\n+            return unknownSnapshotShards.size();\n+        }\n     }\n \n     // used in tests\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r499976816", "bodyText": "Should we also clear queue here?", "author": "original-brownbear", "createdAt": "2020-10-06T02:50:15Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedBlockingQueue<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODExNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188116", "bodyText": "Yes we should -> 4a716b0", "author": "tlrx", "createdAt": "2020-10-06T11:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NjgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1912795c98 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -261,7 +261,9 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n \n     // used in tests\n     int numberOfUnknownSnapshotShardSizes() {\n-        return unknownSnapshotShards.size();\n+        synchronized (mutex) {\n+            return unknownSnapshotShards.size();\n+        }\n     }\n \n     // used in tests\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAxMDUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500010506", "bodyText": "AFAICS, this is now fully protected by mutex.", "author": "henningandersen", "createdAt": "2020-10-06T05:16:21Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final BlockingQueue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private volatile int activeFetches;", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODE5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188193", "bodyText": "Good catch: a8e7475", "author": "tlrx", "createdAt": "2020-10-06T11:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAxMDUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex 43cd8cd11b1..a1912795c98 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -261,7 +261,9 @@ public class InternalSnapshotsInfoService implements ClusterStateListener, Snaps\n \n     // used in tests\n     int numberOfUnknownSnapshotShardSizes() {\n-        return unknownSnapshotShards.size();\n+        synchronized (mutex) {\n+            return unknownSnapshotShards.size();\n+        }\n     }\n \n     // used in tests\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500027707", "bodyText": "This seems to assume that we only get here for unassigned shards, never for initializing shards. I have not found a smoking gun where we could get here in that case, but I would prefer to be more specific in the condition above to only go here for unassigned shards.", "author": "henningandersen", "createdAt": "2020-10-06T06:13:58Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java", "diffHunk": "@@ -482,6 +484,12 @@ public static long getExpectedShardSize(ShardRouting shard, long defaultValue, C\n             }\n             return targetShardSize == 0 ? defaultValue : targetShardSize;\n         } else {\n+            if (shard.active() == false\n+                && shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+                final Long shardSize = snapshotShardSizeInfo.getShardSize(shard);\n+                assert shardSize != null : \"no shard size provided for \" + shard;", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODI4NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188284", "bodyText": "It seems reasonable indeed (0aaf829)", "author": "tlrx", "createdAt": "2020-10-06T11:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5Nzc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500197762", "bodyText": "FWIW I think we don't get here for shards that are initialising from a snapshot today: the callers are canAllocate(), sizeOfRelocatingShards() and BalancedShardsAllocator#allocateUnassigned:\n\nBalancedShardsAllocator#allocateUnassigned only works with unassigned shards\nsizeOfRelocatingShards() only works with relocating shards (either source or target) which necessarily don't have recovery source SNAPSHOT,\ncanAllocate() only tries to allocate unassigned shards and shards that are fully started.\n\nI'm still +1 on this change.", "author": "DaveCTurner", "createdAt": "2020-10-06T11:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNzcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "0aaf829e30b0c3a0c869843650f866357731d6d7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\nindex 6f448453160..9c783c1a414 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java\n\n@@ -484,8 +484,7 @@ public class DiskThresholdDecider extends AllocationDecider {\n             }\n             return targetShardSize == 0 ? defaultValue : targetShardSize;\n         } else {\n-            if (shard.active() == false\n-                && shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n+            if (shard.unassigned() && shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {\n                 final Long shardSize = snapshotShardSizeInfo.getShardSize(shard);\n                 assert shardSize != null : \"no shard size provided for \" + shard;\n                 return shardSize;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:30:47Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -104,7 +106,7 @@ private ClusterState createInitialClusterState(boolean startShards) {\n     public void testNonResizeRouting() {\n         ClusterState clusterState = createInitialClusterState(true);\n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\nindex ab9515b8eee..92776fd53af 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n\n@@ -106,7 +106,7 @@ public class ResizeAllocationDeciderTests extends ESAllocationTestCase {\n     public void testNonResizeRouting() {\n         ClusterState clusterState = createInitialClusterState(true);\n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);\n         ShardRouting shardRouting = TestShardRouting.newShardRouting(\"non-resize\", 0, null, true, ShardRoutingState.UNASSIGNED);\n         assertEquals(Decision.ALWAYS, resizeAllocationDecider.canAllocate(shardRouting, routingAllocation));\n         assertEquals(Decision.ALWAYS, resizeAllocationDecider.canAllocate(shardRouting, clusterState.getRoutingNodes().node(\"node1\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:01Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -128,7 +130,7 @@ public void testShrink() { // we don't handle shrink yet\n         Index idx = clusterState.metadata().index(\"target\").getIndex();\n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\nindex ab9515b8eee..92776fd53af 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n\n@@ -130,7 +130,7 @@ public class ResizeAllocationDeciderTests extends ESAllocationTestCase {\n         Index idx = clusterState.metadata().index(\"target\").getIndex();\n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null,0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, null, clusterState, null, null, 0);\n         ShardRouting shardRouting = TestShardRouting.newShardRouting(new ShardId(idx, 0), null, true, ShardRoutingState.UNASSIGNED,\n             RecoverySource.LocalShardsRecoverySource.INSTANCE);\n         assertEquals(Decision.ALWAYS, resizeAllocationDecider.canAllocate(shardRouting, routingAllocation));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDE4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:14Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -156,7 +158,7 @@ public void testSourceNotActive() {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\nindex ab9515b8eee..92776fd53af 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n\n@@ -158,7 +158,7 @@ public class ResizeAllocationDeciderTests extends ESAllocationTestCase {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);\n         int shardId = randomIntBetween(0, 3);\n         int sourceShardId = IndexMetadata.selectSplitShard(shardId, clusterState.metadata().index(\"source\"), 4).id();\n         ShardRouting shardRouting = TestShardRouting.newShardRouting(new ShardId(idx, shardId), null, true, ShardRoutingState.UNASSIGNED,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzNDI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500034279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n          \n          \n            \n                    RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:31:29Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java", "diffHunk": "@@ -196,7 +198,7 @@ public void testSourcePrimaryActive() {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, 0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\nindex ab9515b8eee..92776fd53af 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/ResizeAllocationDeciderTests.java\n\n@@ -198,7 +198,7 @@ public class ResizeAllocationDeciderTests extends ESAllocationTestCase {\n \n \n         ResizeAllocationDecider resizeAllocationDecider = new ResizeAllocationDecider();\n-        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null,0);\n+        RoutingAllocation routingAllocation = new RoutingAllocation(null, clusterState.getRoutingNodes(), clusterState, null, null, 0);\n         int shardId = randomIntBetween(0, 3);\n         int sourceShardId = IndexMetadata.selectSplitShard(shardId, clusterState.metadata().index(\"source\"), 4).id();\n         ShardRouting shardRouting = TestShardRouting.newShardRouting(new ShardId(idx, shardId), null, true, ShardRoutingState.UNASSIGNED,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzODk4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500038983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        null, null,0);\n          \n          \n            \n                        null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:03Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java", "diffHunk": "@@ -73,7 +75,7 @@ public void testFilterInitialRecovery() {\n \n         // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\nindex 30fac93e5e4..7bf67839247 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\n\n@@ -75,7 +75,7 @@ public class FilterAllocationDeciderTests extends ESAllocationTestCase {\n \n         // after failing the shard we are unassigned since the node is blacklisted and we can't initialize on the other node\n         RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         Decision.Single decision = (Decision.Single) filterAllocationDecider.canAllocate(\n             routingTable.index(\"idx\").shard(0).primaryShard(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTE0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        null, null,0);\n          \n          \n            \n                        null, null, 0);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:28Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java", "diffHunk": "@@ -124,7 +126,7 @@ public void testFilterInitialRecovery() {\n         assertEquals(routingTable.index(\"idx\").shard(0).primaryShard().currentNodeId(), \"node1\");\n \n         allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, 0);\n+            null, null,0);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\nindex 30fac93e5e4..7bf67839247 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/FilterAllocationDeciderTests.java\n\n@@ -126,7 +126,7 @@ public class FilterAllocationDeciderTests extends ESAllocationTestCase {\n         assertEquals(routingTable.index(\"idx\").shard(0).primaryShard().currentNodeId(), \"node1\");\n \n         allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n-            null, null,0);\n+            null, null, 0);\n         allocation.debugDecision(true);\n         decision = (Decision.Single) filterAllocationDecider.canAllocate(\n             routingTable.index(\"idx\").shard(0).shards().get(0),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTI0MA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039240", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        clusterState.getRoutingNodes(), clusterState, null, null,0L);\n          \n          \n            \n                        clusterState.getRoutingNodes(), clusterState, null, null, 0L);", "author": "henningandersen", "createdAt": "2020-10-06T06:43:44Z", "path": "server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java", "diffHunk": "@@ -193,7 +193,7 @@ private ClusterState createInitialClusterState() {\n     private Decision executeAllocation(final ClusterState clusterState, final ShardRouting shardRouting) {\n         final AllocationDecider decider = new RestoreInProgressAllocationDecider();\n         final RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n-            clusterState.getRoutingNodes(), clusterState, null, 0L);\n+            clusterState.getRoutingNodes(), clusterState, null, null,0L);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java\nindex d9f4ff72579..1186577e122 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/RestoreInProgressAllocationDeciderTests.java\n\n@@ -193,7 +193,7 @@ public class RestoreInProgressAllocationDeciderTests extends ESAllocationTestCas\n     private Decision executeAllocation(final ClusterState clusterState, final ShardRouting shardRouting) {\n         final AllocationDecider decider = new RestoreInProgressAllocationDecider();\n         final RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Collections.singleton(decider)),\n-            clusterState.getRoutingNodes(), clusterState, null, null,0L);\n+            clusterState.getRoutingNodes(), clusterState, null, null, 0L);\n         allocation.debugDecision(true);\n \n         final Decision decision;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(),\"allocId\");\n          \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(), \"allocId\");", "author": "henningandersen", "createdAt": "2020-10-06T06:44:09Z", "path": "server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java", "diffHunk": "@@ -341,7 +343,7 @@ public void testFoundAllocationButNoDecider() {\n      * deciders say yes, we allocate to that node.\n      */\n     public void testRestore() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), \"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(),\"allocId\");", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java b/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\nindex 0af09006cd1..8555ec1ea14 100644\n--- a/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\n\n@@ -343,7 +343,7 @@ public class PrimaryShardAllocatorTests extends ESAllocationTestCase {\n      * deciders say yes, we allocate to that node.\n      */\n     public void testRestore() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(),\"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), randomLong(), \"allocId\");\n         testAllocator.addData(node1, \"some allocId\", randomBoolean());\n         allocateAllUnassigned(allocation);\n         assertThat(allocation.routingNodesChanged(), equalTo(true));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQ5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500039495", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(),\"allocId\");\n          \n          \n            \n                    RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(), \"allocId\");", "author": "henningandersen", "createdAt": "2020-10-06T06:44:18Z", "path": "server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java", "diffHunk": "@@ -355,7 +357,7 @@ public void testRestore() {\n      * deciders say throttle, we add it to ignored shards.\n      */\n     public void testRestoreThrottle() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), \"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(),\"allocId\");", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODM4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188385", "bodyText": "Sorry for the noise, the reported spaces issues are addressed in 42ba44f", "author": "tlrx", "createdAt": "2020-10-06T11:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzOTQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "42ba44f71085aed68965e1f74a26ab30f2f10723", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java b/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\nindex 0af09006cd1..8555ec1ea14 100644\n--- a/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/gateway/PrimaryShardAllocatorTests.java\n\n@@ -357,7 +357,7 @@ public class PrimaryShardAllocatorTests extends ESAllocationTestCase {\n      * deciders say throttle, we add it to ignored shards.\n      */\n     public void testRestoreThrottle() {\n-        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(),\"allocId\");\n+        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), randomLong(), \"allocId\");\n         testAllocator.addData(node1, \"some allocId\", randomBoolean());\n         allocateAllUnassigned(allocation);\n         assertThat(allocation.routingNodesChanged(), equalTo(true));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0MTM1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500041353", "bodyText": "I find this name confusing, since this service has no shard sizes? Should it be ...WITH_NO_SHARD_SIZES?", "author": "henningandersen", "createdAt": "2020-10-06T06:48:34Z", "path": "test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java", "diffHunk": "@@ -55,6 +59,16 @@\n     private static final ClusterSettings EMPTY_CLUSTER_SETTINGS =\n         new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n \n+    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_SHARD_SIZES = () ->", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODQ1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188453", "bodyText": "Indeed -> 212c8e3", "author": "tlrx", "createdAt": "2020-10-06T11:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0MTM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "212c8e397dd9fac63587f6c39e12317c624c6667", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java b/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\nindex 6b8483e9d12..109f967383f 100644\n--- a/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/cluster/ESAllocationTestCase.java\n\n@@ -59,7 +59,7 @@ public abstract class ESAllocationTestCase extends ESTestCase {\n     private static final ClusterSettings EMPTY_CLUSTER_SETTINGS =\n         new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n \n-    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_SHARD_SIZES = () ->\n+    public static final SnapshotsInfoService SNAPSHOT_INFO_SERVICE_WITH_NO_SHARD_SIZES = () ->\n         new SnapshotShardSizeInfo(ImmutableOpenMap.of()) {\n             @Override\n             public Long getShardSize(ShardRouting shardRouting) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0Njc5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500046798", "bodyText": "I think we are missing a test for this.", "author": "henningandersen", "createdAt": "2020-10-06T06:59:58Z", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/repository/CcrRepository.java", "diffHunk": "@@ -429,8 +433,23 @@ void acquireRetentionLeaseOnLeader(\n     }\n \n     @Override\n-    public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId leaderShardId) {\n-        throw new UnsupportedOperationException(\"Unsupported for repository of type: \" + TYPE);\n+    public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId index, ShardId shardId) {", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzczMTc2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r503731764", "bodyText": "I opened #63590 for this.", "author": "tlrx", "createdAt": "2020-10-13T07:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0Njc5OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0ODc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500048775", "bodyText": "This change seems odd to me. I suppose the allocationDeciders are effectively unused, but in that case I would still prefer to pass down allocationDeciders.", "author": "henningandersen", "createdAt": "2020-10-06T07:04:18Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java", "diffHunk": "@@ -70,8 +70,8 @@ public Result isConditionMet(Index index, ClusterState clusterState) {\n     static int getPendingAllocations(Index index, AllocationDeciders allocationDeciders, ClusterState clusterState) {\n         // All the allocation attributes are already set so just need to check\n         // if the allocation has happened\n-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, clusterState.getRoutingNodes(), clusterState, null,\n-            System.nanoTime());\n+        RoutingAllocation allocation = new RoutingAllocation(ALLOCATION_DECIDERS, clusterState.getRoutingNodes(), clusterState, null,", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4ODY3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500188672", "bodyText": "Thanks for catching this! It seems that git's merge algorithm did not report a conflict when I merged master back to this branch :(\nIt is fixed in 3dd593d", "author": "tlrx", "createdAt": "2020-10-06T11:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0ODc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3dd593d203c328882683e2febcd7dbd37cc0f62b", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java\nindex bfdad41737d..461932dcacb 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AllocationRoutedStep.java\n\n@@ -70,7 +70,7 @@ public class AllocationRoutedStep extends ClusterStateWaitStep {\n     static int getPendingAllocations(Index index, AllocationDeciders allocationDeciders, ClusterState clusterState) {\n         // All the allocation attributes are already set so just need to check\n         // if the allocation has happened\n-        RoutingAllocation allocation = new RoutingAllocation(ALLOCATION_DECIDERS, clusterState.getRoutingNodes(), clusterState, null,\n+        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, clusterState.getRoutingNodes(), clusterState, null,\n                 null, System.nanoTime());\n \n         int allocationPendingAllShards = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1OTg5NA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500059894", "bodyText": "I would think that assertBusy is unnecessary here, given that we wait for generic thread pool to be unused?", "author": "henningandersen", "createdAt": "2020-10-06T07:26:41Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTEzOA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189138", "bodyText": "I'd expect something like this too but ThreadPoolExecutor#getActiveCount() returns an approximate numbers of active threads. It works well when active threads are blocked but waiting for 0 does not make much sense here. I removed waitForMaxActiveGenericThreads(0) to only rely on the assertBusy() (39da087)", "author": "tlrx", "createdAt": "2020-10-06T11:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1OTg5NA=="}], "type": "inlineReview", "revised_code": {"commit": "39da08724cd8cecdb4338a6daccce374971a6e16", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 7ce61e47cef..caf2ed0bffe 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -149,7 +149,6 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n         assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n \n         latch.countDown();\n-        waitForMaxActiveGenericThreads(0);\n \n         assertBusy(() -> {\n             assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NTc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500065782", "bodyText": "I think we risk these two assertions being OK if they run before any of the threads start adding anything? If that happens on most runs, the test does not verify anything.\nI wonder if it was good enough to just do this after the join below? Or keep it here but add it below the join too.", "author": "henningandersen", "createdAt": "2020-10-06T07:37:09Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+\n+        latch.countDown();\n+        waitForMaxActiveGenericThreads(0);\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));\n+        });\n+        verify(rerouteService, times(numberOfShards)).reroute(anyString(), any(Priority.class), any());\n+\n+        for (int i = 0; i < numberOfShards; i++) {\n+            final ShardRouting shardRouting = clusterService.state().routingTable().index(indexName).shard(i).primaryShard();\n+            assertThat(snapshotsInfoService.snapshotShardSizes().getShardSize(shardRouting), equalTo(expectedShardSizes[i]));\n+        }\n+    }\n+\n+    public void testErroneousSnapshotShardSizes() throws Exception {\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), randomIntBetween(1, 10))\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> succeed = Sets.newConcurrentHashSet();\n+        final Set<InternalSnapshotsInfoService.SnapshotShard> failed = Sets.newConcurrentHashSet();\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    final InternalSnapshotsInfoService.SnapshotShard snapshotShard =\n+                        new InternalSnapshotsInfoService.SnapshotShard(new Snapshot(\"_repo\", snapshotId), indexId, shardId);\n+                    if (randomBoolean()) {\n+                        failed.add(snapshotShard);\n+                        throw new SnapshotException(snapshotShard.snapshot(), \"simulated\");\n+                    } else {\n+                        succeed.add(snapshotShard);\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, randomNonNegativeLong(), null);\n+                    }\n+                }\n+            });\n+\n+        final int maxShardsToCreate = scaledRandomIntBetween(10, 500);\n+        final Thread addSnapshotRestoreIndicesThread = new Thread(() -> {\n+            int remainingShards = maxShardsToCreate;\n+            while (remainingShards > 0) {\n+                final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+                final int numberOfShards = randomIntBetween(1, maxShardsToCreate);\n+                try {\n+                    applyClusterState(\"add-more-unassigned-shards-for-\" + indexName,\n+                        clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+                } catch (Exception e) {\n+                    throw new AssertionError(e);\n+                } finally {\n+                    remainingShards -= numberOfShards;\n+                }\n+            }\n+        });\n+        addSnapshotRestoreIndicesThread.start();\n+\n+        assertBusy(() -> {\n+            assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(succeed.size()));\n+            assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(0));", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTIwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189201", "bodyText": "You're right, not sure why I moved this before the join.\n\nI wonder if it was good enough to just do this after the join below?\n\nDone in 3732dd2.", "author": "tlrx", "createdAt": "2020-10-06T11:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NTc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "39da08724cd8cecdb4338a6daccce374971a6e16", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 7ce61e47cef..caf2ed0bffe 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -149,7 +149,6 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n         assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n \n         latch.countDown();\n-        waitForMaxActiveGenericThreads(0);\n \n         assertBusy(() -> {\n             assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MDAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500070006", "bodyText": "I suppose this is somewhat verified by the reroute count check below, but I would like to add a counter for how many times getShardSnapshotStatus was called too and verify that it is correct.", "author": "henningandersen", "createdAt": "2020-10-06T07:44:29Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTMxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189310", "bodyText": "Makes sense, added in ac45f17", "author": "tlrx", "createdAt": "2020-10-06T11:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MDAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "39da08724cd8cecdb4338a6daccce374971a6e16", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 7ce61e47cef..caf2ed0bffe 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -149,7 +149,6 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n         assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n \n         latch.countDown();\n-        waitForMaxActiveGenericThreads(0);\n \n         assertBusy(() -> {\n             assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MjU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500072558", "bodyText": "Can we add more shards (or just one) here to verify that the deduplication works? We can verify that there is nothing on the queue and at the end that we get the right amount of repo calls.", "author": "henningandersen", "createdAt": "2020-10-06T07:48:59Z", "path": "server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.TestShardRouting;\n+import org.elasticsearch.cluster.service.ClusterApplier;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.index.snapshots.IndexShardSnapshotStatus;\n+import org.elasticsearch.repositories.FilterRepository;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPoolStats;\n+\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_CREATION_DATE;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_REPLICAS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_NUMBER_OF_SHARDS;\n+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_VERSION_CREATED;\n+import static org.elasticsearch.snapshots.InternalSnapshotsInfoService.INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.lessThan;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n+\n+    private TestThreadPool threadPool;\n+    private ClusterService clusterService;\n+    private RepositoriesService repositoriesService;\n+    private RerouteService rerouteService;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        threadPool = new TestThreadPool(getTestName());\n+        clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        repositoriesService = mock(RepositoriesService.class);\n+        rerouteService = mock(RerouteService.class);\n+        doAnswer(invocation -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final ActionListener<ClusterState> listener = (ActionListener<ClusterState>) invocation.getArguments()[2];\n+            listener.onResponse(clusterService.state());\n+            return null;\n+        }).when(rerouteService).reroute(anyString(), any(Priority.class), any());\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        final boolean terminated = terminate(threadPool);\n+        assert terminated;\n+        clusterService.close();\n+    }\n+\n+    public void testSnapshotShardSizes() throws Exception {\n+        final int maxConcurrentFetches = randomIntBetween(1, 10);\n+        final InternalSnapshotsInfoService snapshotsInfoService =\n+            new InternalSnapshotsInfoService(Settings.builder()\n+                .put(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.getKey(), maxConcurrentFetches)\n+                .build(), clusterService, () -> repositoriesService, () -> rerouteService);\n+\n+        final int numberOfShards = randomIntBetween(1, 50);\n+        final String indexName = randomAlphaOfLength(10).toLowerCase(Locale.ROOT);\n+        final long[] expectedShardSizes = new long[numberOfShards];\n+        for (int i = 0; i < expectedShardSizes.length; i++) {\n+            expectedShardSizes[i] = randomNonNegativeLong();\n+        }\n+\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        when(repositoriesService.repository(\"_repo\"))\n+            .thenReturn(new FilterRepository(mock(Repository.class)) {\n+                @Override\n+                public IndexShardSnapshotStatus getShardSnapshotStatus(SnapshotId snapshotId, IndexId indexId, ShardId shardId) {\n+                    try {\n+                        assertThat(indexId.getName(), equalTo(indexName));\n+                        assertThat(shardId.id(), allOf(greaterThanOrEqualTo(0), lessThan(numberOfShards)));\n+                        latch.await();\n+                        return IndexShardSnapshotStatus.newDone(0L, 0L, 0, 0, 0L, expectedShardSizes[shardId.id()], null);\n+                    } catch (InterruptedException e) {\n+                        throw new AssertionError(e);\n+                    }\n+                }\n+            });\n+\n+        applyClusterState(\"add-unassigned-shards\", clusterState -> addUnassignedShards(clusterState, indexName, numberOfShards));\n+        waitForMaxActiveGenericThreads(Math.min(numberOfShards, maxConcurrentFetches));\n+\n+        assertThat(snapshotsInfoService.numberOfUnknownSnapshotShardSizes(), equalTo(numberOfShards));\n+        assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n+", "originalCommit": "291831f02ced1131a8aecb2104f6ca89853ae69b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500189529", "bodyText": "I added 465c8fb that reapplies the last cluster state which should be enough I think\n(as the test verifies that there are no more unknown shard sizes and that the snapshot shard size have been fetched the right number of time).", "author": "tlrx", "createdAt": "2020-10-06T11:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA3MjU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "39da08724cd8cecdb4338a6daccce374971a6e16", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\nindex 7ce61e47cef..caf2ed0bffe 100644\n--- a/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/snapshots/InternalSnapshotsInfoServiceTests.java\n\n@@ -149,7 +149,6 @@ public class InternalSnapshotsInfoServiceTests extends ESTestCase {\n         assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(0));\n \n         latch.countDown();\n-        waitForMaxActiveGenericThreads(0);\n \n         assertBusy(() -> {\n             assertThat(snapshotsInfoService.numberOfKnownSnapshotShardSizes(), equalTo(numberOfShards));\n"}}, {"oid": "881f6210a9e1dccba37497555a1a7fbb68f8b410", "url": "https://github.com/elastic/elasticsearch/commit/881f6210a9e1dccba37497555a1a7fbb68f8b410", "message": "revert extra line", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "url": "https://github.com/elastic/elasticsearch/commit/a777c126e10c17f3ae0f5c07ec607cde49ed3c23", "message": "mutex for unknowns", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "528a8485fbf3501f0770c702c7693538e359115e", "url": "https://github.com/elastic/elasticsearch/commit/528a8485fbf3501f0770c702c7693538e359115e", "message": "non blocking queue", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "4a716b02cce940402831cb20fdd6155d5badbd18", "url": "https://github.com/elastic/elasticsearch/commit/4a716b02cce940402831cb20fdd6155d5badbd18", "message": "clear queue", "committedDate": "2020-10-06T11:02:28Z", "type": "commit"}, {"oid": "a8e7475afc25dc2877012ae195f30418e5437f61", "url": "https://github.com/elastic/elasticsearch/commit/a8e7475afc25dc2877012ae195f30418e5437f61", "message": "activeFetches", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "0aaf829e30b0c3a0c869843650f866357731d6d7", "url": "https://github.com/elastic/elasticsearch/commit/0aaf829e30b0c3a0c869843650f866357731d6d7", "message": "check unassigned", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "42ba44f71085aed68965e1f74a26ab30f2f10723", "url": "https://github.com/elastic/elasticsearch/commit/42ba44f71085aed68965e1f74a26ab30f2f10723", "message": "spaces", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "212c8e397dd9fac63587f6c39e12317c624c6667", "url": "https://github.com/elastic/elasticsearch/commit/212c8e397dd9fac63587f6c39e12317c624c6667", "message": "SNAPSHOT_INFO_SERVICE_WITH_NO_SHARD_SIZES", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "3dd593d203c328882683e2febcd7dbd37cc0f62b", "url": "https://github.com/elastic/elasticsearch/commit/3dd593d203c328882683e2febcd7dbd37cc0f62b", "message": "allocationDeciders", "committedDate": "2020-10-06T11:02:29Z", "type": "commit"}, {"oid": "39da08724cd8cecdb4338a6daccce374971a6e16", "url": "https://github.com/elastic/elasticsearch/commit/39da08724cd8cecdb4338a6daccce374971a6e16", "message": "remove wait for zero active threads", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "3732dd28962b074c1c0ec9ac48e7534e5d4d3b08", "url": "https://github.com/elastic/elasticsearch/commit/3732dd28962b074c1c0ec9ac48e7534e5d4d3b08", "message": "move assertBusy()", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "ac45f178bbd0b3907c6e2dc2d9feac1de90cfd61", "url": "https://github.com/elastic/elasticsearch/commit/ac45f178bbd0b3907c6e2dc2d9feac1de90cfd61", "message": "getShardSnapshotStatusCount", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "465c8fb893c6af46757c40c17354cd8f50bb12dd", "url": "https://github.com/elastic/elasticsearch/commit/465c8fb893c6af46757c40c17354cd8f50bb12dd", "message": "check deduplication", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"oid": "59ab20c3c3a450f4233753c131d62938bc602daa", "url": "https://github.com/elastic/elasticsearch/commit/59ab20c3c3a450f4233753c131d62938bc602daa", "message": "SnapshotResiliencyTests", "committedDate": "2020-10-06T11:02:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzMTQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500231461", "bodyText": "I think this needs to be done before spawning the task: we assert that this is \u22650 elsewhere but that assertion will fail if it's decremented by the completion of the runnable before it's incremented here.", "author": "DaveCTurner", "createdAt": "2020-10-06T12:23:26Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();\n+                while (iterator.hasNext()) {\n+                    final SnapshotShard snapshotShard = iterator.next();\n+                    final boolean removed = unknownSnapshotShards.remove(snapshotShard);\n+                    assert removed : \"snapshot shard to remove does not exist \" + snapshotShard;\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void fetchNextSnapshotShard() {\n+        synchronized (mutex) {\n+            if (activeFetches < maxConcurrentFetches) {\n+                final SnapshotShard snapshotShard = queue.poll();\n+                if (snapshotShard != null) {\n+                    threadPool.generic().execute(new FetchingSnapshotShardSizeRunnable(snapshotShard));\n+                    activeFetches += 1;", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d9917489f22a731cd69ba33311dca9e9134aee1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex a14151878b9..355b6b168eb 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -47,7 +47,6 @@ import org.elasticsearch.threadpool.ThreadPool;\n \n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.LinkedList;\n import java.util.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzNTk2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500235967", "bodyText": "Why not drain the queue using .poll() until it's empty?", "author": "DaveCTurner", "createdAt": "2020-10-06T12:30:32Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d9917489f22a731cd69ba33311dca9e9134aee1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex a14151878b9..355b6b168eb 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -47,7 +47,6 @@ import org.elasticsearch.threadpool.ThreadPool;\n \n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.LinkedList;\n import java.util.Objects;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIzODkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500238901", "bodyText": "can we assert something about the state if neither of the previous if blocks matched (so this node isn't/wasn't just the master): isMaster == false, queue and unknownSnapshotShards and knownSnapshotShardSizes are all empty, ...", "author": "DaveCTurner", "createdAt": "2020-10-06T12:35:17Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.snapshots;\n+\n+import com.carrotsearch.hppc.cursors.ObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.cluster.ClusterChangedEvent;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateListener;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RerouteService;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.repositories.IndexId;\n+import org.elasticsearch.repositories.RepositoriesService;\n+import org.elasticsearch.repositories.Repository;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class InternalSnapshotsInfoService implements ClusterStateListener, SnapshotsInfoService {\n+\n+    public static final Setting<Integer> INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING =\n+        Setting.intSetting(\"cluster.snapshot.info.max_concurrent_fetches\", 5, 1,\n+            Setting.Property.Dynamic, Setting.Property.NodeScope);\n+\n+    private static final Logger logger = LogManager.getLogger(InternalSnapshotsInfoService.class);\n+\n+    private static final ActionListener<ClusterState> REROUTE_LISTENER = ActionListener.wrap(\n+        r -> logger.trace(\"reroute after snapshot shard size update completed\"),\n+        e -> logger.debug(\"reroute after snapshot shard size update failed\", e)\n+    );\n+\n+    private final ThreadPool threadPool;\n+    private final Supplier<RepositoriesService> repositoriesService;\n+    private final Supplier<RerouteService> rerouteService;\n+\n+    /** contains the snapshot shards for which the size is known **/\n+    private volatile ImmutableOpenMap<SnapshotShard, Long> knownSnapshotShardSizes;\n+\n+    private volatile boolean isMaster;\n+\n+    /** contains the snapshot shards for which the size is unknown and must be fetched (or is being fetched) **/\n+    private final Set<SnapshotShard> unknownSnapshotShards;\n+\n+    /** a blocking queue used for concurrent fetching **/\n+    private final Queue<SnapshotShard> queue;\n+\n+    private volatile int maxConcurrentFetches;\n+    private int activeFetches;\n+\n+    private final Object mutex;\n+\n+    public InternalSnapshotsInfoService(\n+        final Settings settings,\n+        final ClusterService clusterService,\n+        final Supplier<RepositoriesService> repositoriesServiceSupplier,\n+        final Supplier<RerouteService> rerouteServiceSupplier\n+    ) {\n+        this.threadPool = clusterService.getClusterApplierService().threadPool();\n+        this.repositoriesService = repositoriesServiceSupplier;\n+        this.rerouteService = rerouteServiceSupplier;\n+        this.knownSnapshotShardSizes = ImmutableOpenMap.of();\n+        this.unknownSnapshotShards  = new LinkedHashSet<>();\n+        this.queue = new LinkedList<>();\n+        this.mutex = new Object();\n+        this.activeFetches = 0;\n+        this.maxConcurrentFetches = INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING.get(settings);\n+        final ClusterSettings clusterSettings = clusterService.getClusterSettings();\n+        clusterSettings.addSettingsUpdateConsumer(INTERNAL_SNAPSHOT_INFO_MAX_CONCURRENT_FETCHES_SETTING, this::setMaxConcurrentFetches);\n+        if (DiscoveryNode.isMasterNode(settings)) {\n+            clusterService.addListener(this);\n+        }\n+    }\n+\n+    private void setMaxConcurrentFetches(Integer maxConcurrentFetches) {\n+        this.maxConcurrentFetches = maxConcurrentFetches;\n+    }\n+\n+    @Override\n+    public SnapshotShardSizeInfo snapshotShardSizes() {\n+        return new SnapshotShardSizeInfo(knownSnapshotShardSizes);\n+    }\n+\n+    @Override\n+    public void clusterChanged(ClusterChangedEvent event) {\n+        if (event.localNodeMaster()) {\n+            final Set<SnapshotShard> onGoingSnapshotRecoveries = listOfSnapshotShards(event.state());\n+\n+            int unknownShards = 0;\n+            synchronized (mutex) {\n+                isMaster = true;\n+                for (SnapshotShard snapshotShard : onGoingSnapshotRecoveries) {\n+                    // check if already populated entry\n+                    if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n+                        // check if already fetching snapshot info in progress\n+                        if (unknownSnapshotShards.add(snapshotShard)) {\n+                            queue.add(snapshotShard);\n+                            unknownShards += 1;\n+                        }\n+                    }\n+                }\n+                // Clean up keys from knownSnapshotShardSizes that are no longer needed for recoveries\n+                cleanUpKnownSnapshotShardSizes(onGoingSnapshotRecoveries);\n+            }\n+\n+            final int nbFetchers = Math.min(unknownShards, maxConcurrentFetches);\n+            for (int i = 0; i < nbFetchers; i++) {\n+                fetchNextSnapshotShard();\n+            }\n+        } else if (event.previousState().nodes().isLocalNodeElectedMaster()) {\n+            // TODO Maybe just clear out non-ongoing snapshot recoveries is the node is master eligible, so that we don't\n+            // have to repopulate the data over and over in an unstable master situation?\n+            synchronized (mutex) {\n+                // information only needed on current master\n+                knownSnapshotShardSizes = ImmutableOpenMap.of();\n+                isMaster = false;\n+                final Iterator<SnapshotShard> iterator = queue.iterator();\n+                while (iterator.hasNext()) {\n+                    final SnapshotShard snapshotShard = iterator.next();\n+                    final boolean removed = unknownSnapshotShards.remove(snapshotShard);\n+                    assert removed : \"snapshot shard to remove does not exist \" + snapshotShard;\n+                    iterator.remove();\n+                }\n+            }\n+        }", "originalCommit": "59ab20c3c3a450f4233753c131d62938bc602daa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0d9917489f22a731cd69ba33311dca9e9134aee1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\nindex a14151878b9..355b6b168eb 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java\n\n@@ -47,7 +47,6 @@ import org.elasticsearch.threadpool.ThreadPool;\n \n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.LinkedList;\n import java.util.Objects;\n"}}, {"oid": "0d9917489f22a731cd69ba33311dca9e9134aee1", "url": "https://github.com/elastic/elasticsearch/commit/0d9917489f22a731cd69ba33311dca9e9134aee1", "message": "handle snapshot shard size failures", "committedDate": "2020-10-06T13:53:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4MDE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r500380141", "bodyText": "I think we should also remove this in cleanUpKnownSnapshotShardSizes to avoid this eventually potentially leading to a memory issue. We can do this in a follow-up too, no need to hold merging this PR.", "author": "henningandersen", "createdAt": "2020-10-06T15:17:43Z", "path": "server/src/main/java/org/elasticsearch/snapshots/InternalSnapshotsInfoService.java", "diffHunk": "@@ -132,6 +142,7 @@ public void clusterChanged(ClusterChangedEvent event) {\n                     if (knownSnapshotShardSizes.containsKey(snapshotShard) == false) {\n                         // check if already fetching snapshot info in progress\n                         if (unknownSnapshotShards.add(snapshotShard)) {\n+                            failedSnapshotShards.remove(snapshotShard); // retry the failed shard", "originalCommit": "0d9917489f22a731cd69ba33311dca9e9134aee1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzYxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61906#discussion_r501763610", "bodyText": "I opened #63492 to address this", "author": "tlrx", "createdAt": "2020-10-08T14:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4MDE0MQ=="}], "type": "inlineReview", "revised_code": null}]}