{"pr_number": 56874, "pr_title": "Improve Efficiency of SnapshotsService CS Apply", "pr_createdAt": "2020-05-17T18:32:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56874", "timeline": [{"oid": "025cb77204d919ce79c5127690b20be4e69c4277", "url": "https://github.com/elastic/elasticsearch/commit/025cb77204d919ce79c5127690b20be4e69c4277", "message": "Improve Efficiency of SnapshotsService CS Apply\n\nThis change removes the redundant submitting of two separate cluster state updates\nfor the node configuration changes and routing changes that affect snapshots.\nSince we submitted the task to deal with node configuration changes every time on master\nfail-over we could also move the BwC cleanup loop that removes `INIT` state snapshots as well\nas snapshots that have all their shards completed into this cluster state update task.\n\nAside from improving efficiency overall this change has the fortunate side effect of moving\nall snapshot finalization to the CS update thread. This is helpful for concurrent snapshots\nsince it makes it very natural and straight forward to order snapshot finalizations by exploiting\nthat they are all initiated on the same thread.", "committedDate": "2020-05-17T18:24:32Z", "type": "commit"}, {"oid": "19fe58e3b6ef672a5a5e5a4645ffdd3d179566fc", "url": "https://github.com/elastic/elasticsearch/commit/19fe58e3b6ef672a5a5e5a4645ffdd3d179566fc", "message": "shorter", "committedDate": "2020-05-17T18:32:35Z", "type": "commit"}, {"oid": "827d959e5b143e338381519642c2f7faf2712fda", "url": "https://github.com/elastic/elasticsearch/commit/827d959e5b143e338381519642c2f7faf2712fda", "message": "shorter", "committedDate": "2020-05-17T18:34:11Z", "type": "commit"}, {"oid": "e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "url": "https://github.com/elastic/elasticsearch/commit/e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "message": "shorter", "committedDate": "2020-05-17T18:35:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5MTE3OA==", "url": "https://github.com/elastic/elasticsearch/pull/56874#discussion_r426291178", "bodyText": "This was really evil for large snapshots (even more so in the context of concurrent snapshots). We would iterate all the shards even if no nodes were removed or the snapshot finished already.", "author": "original-brownbear", "createdAt": "2020-05-17T18:37:01Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -678,11 +633,26 @@ private static boolean waitingShardsStartedOrUnassigned(SnapshotsInProgress snap\n     }\n \n     private static boolean removedNodesCleanupNeeded(SnapshotsInProgress snapshotsInProgress, List<DiscoveryNode> removedNodes) {\n-        // If at least one shard was running on a removed node - we need to fail it\n-        return removedNodes.isEmpty() == false && snapshotsInProgress.entries().stream().flatMap(snapshot ->\n-                StreamSupport.stream(((Iterable<ShardSnapshotStatus>) () -> snapshot.shards().valuesIt()).spliterator(), false)", "originalCommit": "e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5MTMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/56874#discussion_r426291323", "bodyText": "This is unnecessary now, we will not pass a snapshot with UNKNOWN_REPO_GEN to this method any longer, we just remove it from the cluster state in processWaitingShardsAndRemovedNodes and are done with it.", "author": "original-brownbear", "createdAt": "2020-05-17T18:38:24Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -697,12 +667,6 @@ private void endSnapshot(SnapshotsInProgress.Entry entry, Metadata metadata) {\n             return;\n         }\n         final Snapshot snapshot = entry.snapshot();\n-        if (entry.repositoryStateId() == RepositoryData.UNKNOWN_REPO_GEN) {", "originalCommit": "e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be57075b6d2bb916673fff6bf15ed18c372aa476", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\nindex e9c0ae353c1..10a87162959 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n\n@@ -667,27 +665,24 @@ public class SnapshotsService extends AbstractLifecycleComponent implements Clus\n             return;\n         }\n         final Snapshot snapshot = entry.snapshot();\n-        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {\n-            @Override\n-            protected void doRun() {\n-                final Repository repository = repositoriesService.repository(snapshot.getRepository());\n-                final String failure = entry.failure();\n-                logger.trace(\"[{}] finalizing snapshot in repository, state: [{}], failure[{}]\", snapshot, entry.state(), failure);\n-                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>();\n-                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {\n-                    ShardId shardId = shardStatus.key;\n-                    ShardSnapshotStatus status = shardStatus.value;\n-                    final ShardState state = status.state();\n-                    if (state.failed()) {\n-                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()));\n-                    } else if (state.completed() == false) {\n-                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, \"skipped\"));\n-                    } else {\n-                        assert state == ShardState.SUCCESS;\n-                    }\n+        try {\n+            final String failure = entry.failure();\n+            logger.trace(\"[{}] finalizing snapshot in repository, state: [{}], failure[{}]\", snapshot, entry.state(), failure);\n+            ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>();\n+            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {\n+                ShardId shardId = shardStatus.key;\n+                ShardSnapshotStatus status = shardStatus.value;\n+                final ShardState state = status.state();\n+                if (state.failed()) {\n+                    shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()));\n+                } else if (state.completed() == false) {\n+                    shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, \"skipped\"));\n+                } else {\n+                    assert state == ShardState.SUCCESS;\n                 }\n-                final ShardGenerations shardGenerations = buildGenerations(entry, metadata);\n-                repository.finalizeSnapshot(\n+            }\n+            final ShardGenerations shardGenerations = buildGenerations(entry, metadata);\n+            repositoriesService.repository(snapshot.getRepository()).finalizeSnapshot(\n                     snapshot.getSnapshotId(),\n                     shardGenerations,\n                     entry.startTime(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5MTUwNw==", "url": "https://github.com/elastic/elasticsearch/pull/56874#discussion_r426291507", "bodyText": "This was a bug introduced in #56669 , we could NPE here if a data node were to resend a state update for an already finished snapshot (master fail-over or node disconnect can easily lead to this) causing an NPE here needlessly.", "author": "original-brownbear", "createdAt": "2020-05-17T18:40:23Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1424,7 +1388,8 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                             if (endingSnapshots.contains(request.snapshot()) == false) {\n                                 final SnapshotsInProgress snapshotsInProgress = newState.custom(SnapshotsInProgress.TYPE);\n                                 final SnapshotsInProgress.Entry updatedEntry = snapshotsInProgress.snapshot(request.snapshot());\n-                                if (updatedEntry.state().completed()) {\n+                                // If the entry is still in the cluster state and is completed, try finalizing the snapshot in the repo\n+                                if (updatedEntry != null && updatedEntry.state().completed()) {", "originalCommit": "e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5MTg0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56874#discussion_r426291845", "bodyText": "Combining both node removal and shard starting into one method saves us iterating all the shards twice for the relevant updates to each snapshot.", "author": "original-brownbear", "createdAt": "2020-05-17T18:43:58Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -616,8 +560,8 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n         });\n     }\n \n-    private static ImmutableOpenMap<ShardId, ShardSnapshotStatus> processWaitingShards(\n-            ImmutableOpenMap<ShardId, ShardSnapshotStatus> snapshotShards, RoutingTable routingTable) {\n+    private static ImmutableOpenMap<ShardId, ShardSnapshotStatus> processWaitingShardsAndRemovedNodes(", "originalCommit": "e4dd86c5bb28b2955fe80ef0e3d62d76651c2256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "be57075b6d2bb916673fff6bf15ed18c372aa476", "url": "https://github.com/elastic/elasticsearch/commit/be57075b6d2bb916673fff6bf15ed18c372aa476", "message": "Merge remote-tracking branch 'elastic/master' into faster-snapshot-cs-application", "committedDate": "2020-05-27T08:21:34Z", "type": "commit"}]}