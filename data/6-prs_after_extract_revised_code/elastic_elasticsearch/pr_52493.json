{"pr_number": 52493, "pr_title": "Comprehensively test supported/unsupported field type:agg combinations", "pr_createdAt": "2020-02-18T21:37:09Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52493", "timeline": [{"oid": "5ad9a9641f7c24a0476e27afe1d28c6dbd382ff7", "url": "https://github.com/elastic/elasticsearch/commit/5ad9a9641f7c24a0476e27afe1d28c6dbd382ff7", "message": "Put values source types on fields (#51503)", "committedDate": "2020-02-18T21:30:04Z", "type": "commit"}, {"oid": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "url": "https://github.com/elastic/elasticsearch/commit/e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "message": "Comprehensively test supported/unsupported field type:aggs combinations\n\nThis adds a test to AggregatorTestCase that allows us to programmatically\nverify that an aggregator supports or does not support a particular\nfield type.  It fetches the list of registered field type parsers,\ncreates a MappedFieldType from the parser and then attempts to run\na basic agg against the field.\n\nA supplied list of supported VSTypes are then compared against the\noutput (success or exception) and suceeds or fails the test accordingly.", "committedDate": "2020-02-18T21:30:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1MDE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380950157", "bodyText": "The meat of the PR is here.", "author": "polyfractal", "createdAt": "2020-02-18T21:38:10Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1MDUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380950510", "bodyText": "Note: we think this is a bug, I'll open a separate PR fixing this", "author": "polyfractal", "createdAt": "2020-02-18T21:38:53Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/RangeFieldMapper.java", "diffHunk": "@@ -92,14 +94,6 @@ public RangeFieldType fieldType() {\n             return (RangeFieldType)fieldType;\n         }\n \n-        @Override\n-        public Builder docValues(boolean docValues) {", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NDAwNw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380954007", "bodyText": "I think you missed removing this check when adding the blacklist?", "author": "not-napoleon", "createdAt": "2020-02-18T21:46:16Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NDM5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380954391", "bodyText": "Ayup", "author": "polyfractal", "createdAt": "2020-02-18T21:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NDAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NTQ4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380955481", "bodyText": "Why not just let the exception happen here? The test will still fail, and the exception is likely to be clearer as to what went wrong than just a call to fail()", "author": "not-napoleon", "createdAt": "2020-02-18T21:48:48Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {\n+                // Cannot aggregate objects\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            FieldMapper mapper = null;\n+            try {\n+                Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+                mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+            } catch (Exception e) {\n+                fail();", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1ODkzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380958932", "bodyText": "Leftovers from debugging, this should not be here.  WIP :)", "author": "polyfractal", "createdAt": "2020-02-18T21:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NTQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NzAzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380957037", "bodyText": "I'm not sure how I feel about pulling the specialized values source types here into Master without the code that uses them.  That seems potentially confusing without context - e.g. We have an IP type now, but VSConfig will still resolve IP fields to Bytes because this isn't wired up.  At a minimum, we should leave a comment in big letters that this is test only until the refactor lands (which hopefully is soon, but still)", "author": "not-napoleon", "createdAt": "2020-02-18T21:51:51Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java", "diffHunk": "@@ -224,6 +224,72 @@ public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFa\n         public ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat, LongSupplier now) {\n             throw new IllegalArgumentException(\"Can't apply missing values on a \" + valuesSource.getClass());\n         }\n+    },\n+    // TODO: Ordinal Numbering sync with types from master\n+    IP{", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java b/server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java\nindex ec5a9d749ec..6df32b4deef 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/support/CoreValuesSourceType.java\n\n@@ -224,72 +224,6 @@ public enum CoreValuesSourceType implements Writeable, ValuesSourceType {\n         public ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat, LongSupplier now) {\n             throw new IllegalArgumentException(\"Can't apply missing values on a \" + valuesSource.getClass());\n         }\n-    },\n-    // TODO: Ordinal Numbering sync with types from master\n-    IP{\n-        @Override\n-        public ValuesSource getEmpty() {\n-            return BYTES.getEmpty();\n-        }\n-\n-        @Override\n-        public ValuesSource getScript(AggregationScript.LeafFactory script, ValueType scriptValueType) {\n-            return BYTES.getScript(script, scriptValueType);\n-        }\n-\n-        @Override\n-        public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFactory script) {\n-            return BYTES.getField(fieldContext, script);\n-        }\n-\n-        @Override\n-        public ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat, LongSupplier now) {\n-            return BYTES.replaceMissing(valuesSource, rawMissing, docValueFormat, now);\n-        }\n-    },\n-    DATE {\n-        @Override\n-        public ValuesSource getEmpty() {\n-            return NUMERIC.getEmpty();\n-        }\n-\n-        @Override\n-        public ValuesSource getScript(AggregationScript.LeafFactory script, ValueType scriptValueType) {\n-            return NUMERIC.getScript(script, scriptValueType);\n-        }\n-\n-        @Override\n-        public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFactory script) {\n-            return NUMERIC.getField(fieldContext, script);\n-        }\n-\n-        @Override\n-        public ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat, LongSupplier now) {\n-            return NUMERIC.replaceMissing(valuesSource, rawMissing, docValueFormat, now);\n-        }\n-\n-    },\n-    BOOLEAN {\n-        @Override\n-        public ValuesSource getEmpty() {\n-            return NUMERIC.getEmpty();\n-        }\n-\n-        @Override\n-        public ValuesSource getScript(AggregationScript.LeafFactory script, ValueType scriptValueType) {\n-            return NUMERIC.getScript(script, scriptValueType);\n-        }\n-\n-        @Override\n-        public ValuesSource getField(FieldContext fieldContext, AggregationScript.LeafFactory script) {\n-            return NUMERIC.getField(fieldContext, script);\n-        }\n-\n-        @Override\n-        public ValuesSource replaceMissing(ValuesSource valuesSource, Object rawMissing, DocValueFormat docValueFormat, LongSupplier now) {\n-            return NUMERIC.replaceMissing(valuesSource, rawMissing, docValueFormat, now);\n-        }\n-\n     };\n \n     public static ValuesSourceType fromString(String name) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Nzc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380957783", "bodyText": "Maybe throw here by default instead of returning null?  Otherwise we're going to get an NPE deep in the aggregation code when someone forgets to implement this, and it won't be at all clear why.", "author": "not-napoleon", "createdAt": "2020-02-18T21:53:29Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380959876", "bodyText": "Once we are running these tests against aggregations using the VS Registry, we can say reliably what exception should be thrown.  At that point, we should invert this test - if the VSType is not supported, we should use expectThrows to confirm we get the right exception, and otherwise fail on any exception.  Probably can't do that now though since our exceptions are a bit inconsistent in master.", "author": "not-napoleon", "createdAt": "2020-02-18T21:57:41Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {\n+                // Cannot aggregate objects\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            FieldMapper mapper = null;\n+            try {\n+                Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+                mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+            } catch (Exception e) {\n+                fail();\n+            }\n+            MappedFieldType fieldType = mapper.fieldType();\n+\n+\n+            try (Directory directory = newDirectory()) {\n+                RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+                writeTestDoc(fieldType, fieldName, indexWriter);\n+                indexWriter.close();\n+\n+                try (IndexReader indexReader = DirectoryReader.open(directory)) {\n+                    IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n+                    AggregationBuilder aggregationBuilder = createAggBuilderForTypeTest(fieldType, fieldName);\n+\n+                    try {\n+                        searchAndReduce(indexSearcher, new MatchAllDocsQuery(), aggregationBuilder, fieldType);\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType()) == false) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] should not support field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field did not throw an excetion\");\n+                        }\n+                    } catch (Exception e) {", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MjgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380962809", "bodyText": "We've got copies of this same function in IpRangeTests and IpRangeAggregatorTests, at least.  Maybe put it up in ESTestCase and have all three use the same version?", "author": "not-napoleon", "createdAt": "2020-02-18T22:03:45Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {\n+                // Cannot aggregate objects\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            FieldMapper mapper = null;\n+            try {\n+                Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+                mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+            } catch (Exception e) {\n+                fail();\n+            }\n+            MappedFieldType fieldType = mapper.fieldType();\n+\n+\n+            try (Directory directory = newDirectory()) {\n+                RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+                writeTestDoc(fieldType, fieldName, indexWriter);\n+                indexWriter.close();\n+\n+                try (IndexReader indexReader = DirectoryReader.open(directory)) {\n+                    IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n+                    AggregationBuilder aggregationBuilder = createAggBuilderForTypeTest(fieldType, fieldName);\n+\n+                    try {\n+                        searchAndReduce(indexSearcher, new MatchAllDocsQuery(), aggregationBuilder, fieldType);\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType()) == false) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] should not support field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field did not throw an excetion\");\n+                        }\n+                    } catch (Exception e) {\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType())) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] supports field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field threw an exception: [\" + e.getMessage() + \"]\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void writeTestDoc(MappedFieldType fieldType, String fieldName, RandomIndexWriter iw) throws IOException {\n+\n+        if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.NUMERIC)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.DATE)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomNonNegativeLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.BYTES)) {\n+            if (fieldType.typeName().equals(BinaryFieldMapper.CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new BinaryFieldMapper.CustomBinaryDocValuesField(fieldName, new BytesRef(\"a\").bytes)));\n+            } else {\n+                iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(\"a\"))));\n+            }\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.RANGE)) {\n+            Object start;\n+            Object end;\n+            RangeType rangeType;\n+\n+            if (fieldType.typeName().equals(RangeType.DOUBLE.typeName())) {\n+                start = randomDouble();\n+                end = randomDoubleBetween(Math.nextUp((Double)start), Double.MAX_VALUE, false);\n+                rangeType = RangeType.DOUBLE;\n+            } else if (fieldType.typeName().equals(RangeType.FLOAT.typeName())) {\n+                start = randomFloat();\n+                end = randomFloatBetween(Math.nextUp((Float) start), Float.MAX_VALUE, false);\n+                rangeType = RangeType.DOUBLE;\n+            } else if (fieldType.typeName().equals(RangeType.IP.typeName())) {\n+                boolean v4 = randomBoolean();\n+                start = randomIp(v4);\n+                end = randomIp(v4);\n+                rangeType = RangeType.IP;\n+            } else if (fieldType.typeName().equals(RangeType.LONG.typeName())) {\n+                start = randomLong();\n+                end = randomLongBetween((Long)start + 1, Long.MAX_VALUE);\n+                rangeType = RangeType.LONG;\n+            } else if (fieldType.typeName().equals(RangeType.INTEGER.typeName())) {\n+                start = randomInt();\n+                end = randomIntBetween((Integer)start, Integer.MAX_VALUE);\n+                rangeType = RangeType.INTEGER;\n+            } else if (fieldType.typeName().equals(RangeType.DATE.typeName())) {\n+                start = randomNonNegativeLong();\n+                end = randomLongBetween((Long)start + 1, Long.MAX_VALUE);\n+                rangeType = RangeType.DATE;\n+            } else {\n+                throw new IllegalStateException(\"Unknown type of range [\" + fieldType.typeName() + \"]\");\n+            }\n+\n+            final RangeFieldMapper.Range range = new RangeFieldMapper.Range(rangeType, start, end, true, true);\n+            iw.addDocument(singleton(new BinaryDocValuesField(fieldName, rangeType.encodeRanges(Collections.singleton(range)))));\n+\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.BOOLEAN)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomBoolean() ? 0 : 1)));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.IP)) {\n+            boolean v4 = randomBoolean();\n+            iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(InetAddressPoint.encode(randomIp(v4))))));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.GEOPOINT)) {\n+            iw.addDocument(singleton(new LatLonDocValuesField(fieldName, randomDouble(), randomDouble())));\n+        } else {\n+            throw new IllegalStateException(\"Unknown field type [\" + fieldType.typeName() + \"]\");\n+        }\n+    }\n+\n+    private class MockParserContext extends Mapper.TypeParser.ParserContext {\n+        MockParserContext() {\n+            super(null, null, null, null, null);\n+        }\n+    }\n+\n+    private static InetAddress randomIp(boolean v4) {", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NTkxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380965913", "bodyText": "I'm concerned we might introduce some instability by trying to aggregate over arbitrarily large ranges, which isn't really supported (i.e. it eventually trips the circuit breaker).  I'd suggest just just setting the end value to the next value after the start.  Also, you can use RangeType.nextUp(Object) for all cases, it's always well defined.", "author": "not-napoleon", "createdAt": "2020-02-18T22:10:36Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {\n+                // Cannot aggregate objects\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            FieldMapper mapper = null;\n+            try {\n+                Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+                mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+            } catch (Exception e) {\n+                fail();\n+            }\n+            MappedFieldType fieldType = mapper.fieldType();\n+\n+\n+            try (Directory directory = newDirectory()) {\n+                RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+                writeTestDoc(fieldType, fieldName, indexWriter);\n+                indexWriter.close();\n+\n+                try (IndexReader indexReader = DirectoryReader.open(directory)) {\n+                    IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n+                    AggregationBuilder aggregationBuilder = createAggBuilderForTypeTest(fieldType, fieldName);\n+\n+                    try {\n+                        searchAndReduce(indexSearcher, new MatchAllDocsQuery(), aggregationBuilder, fieldType);\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType()) == false) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] should not support field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field did not throw an excetion\");\n+                        }\n+                    } catch (Exception e) {\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType())) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] supports field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field threw an exception: [\" + e.getMessage() + \"]\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void writeTestDoc(MappedFieldType fieldType, String fieldName, RandomIndexWriter iw) throws IOException {\n+\n+        if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.NUMERIC)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.DATE)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomNonNegativeLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.BYTES)) {\n+            if (fieldType.typeName().equals(BinaryFieldMapper.CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new BinaryFieldMapper.CustomBinaryDocValuesField(fieldName, new BytesRef(\"a\").bytes)));\n+            } else {\n+                iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(\"a\"))));\n+            }\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.RANGE)) {\n+            Object start;\n+            Object end;\n+            RangeType rangeType;\n+\n+            if (fieldType.typeName().equals(RangeType.DOUBLE.typeName())) {\n+                start = randomDouble();\n+                end = randomDoubleBetween(Math.nextUp((Double)start), Double.MAX_VALUE, false);", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQzMDAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r381430018", "bodyText": "Ah nice, didn't realize the RangeType's had a nextUp() on them \ud83d\udc4d", "author": "polyfractal", "createdAt": "2020-02-19T17:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NTkxMw=="}], "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NjE2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r380966160", "bodyText": "Can this generate an invalid range if end sorts before start?", "author": "not-napoleon", "createdAt": "2020-02-18T22:11:09Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +560,163 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return null;\n+    }\n+\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return Collections.emptyList();\n+    }\n+\n+    public void testSupportedFieldTypes() throws IOException {\n+\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            if (mappedType.getKey().equals(ObjectMapper.CONTENT_TYPE)) {\n+                // Cannot aggregate objects\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            FieldMapper mapper = null;\n+            try {\n+                Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+                mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+            } catch (Exception e) {\n+                fail();\n+            }\n+            MappedFieldType fieldType = mapper.fieldType();\n+\n+\n+            try (Directory directory = newDirectory()) {\n+                RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+                writeTestDoc(fieldType, fieldName, indexWriter);\n+                indexWriter.close();\n+\n+                try (IndexReader indexReader = DirectoryReader.open(directory)) {\n+                    IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n+                    AggregationBuilder aggregationBuilder = createAggBuilderForTypeTest(fieldType, fieldName);\n+\n+                    try {\n+                        searchAndReduce(indexSearcher, new MatchAllDocsQuery(), aggregationBuilder, fieldType);\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType()) == false) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] should not support field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field did not throw an excetion\");\n+                        }\n+                    } catch (Exception e) {\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType())) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] supports field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field threw an exception: [\" + e.getMessage() + \"]\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void writeTestDoc(MappedFieldType fieldType, String fieldName, RandomIndexWriter iw) throws IOException {\n+\n+        if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.NUMERIC)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.DATE)) {\n+            iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomNonNegativeLong())));\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.BYTES)) {\n+            if (fieldType.typeName().equals(BinaryFieldMapper.CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new BinaryFieldMapper.CustomBinaryDocValuesField(fieldName, new BytesRef(\"a\").bytes)));\n+            } else {\n+                iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(\"a\"))));\n+            }\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.RANGE)) {\n+            Object start;\n+            Object end;\n+            RangeType rangeType;\n+\n+            if (fieldType.typeName().equals(RangeType.DOUBLE.typeName())) {\n+                start = randomDouble();\n+                end = randomDoubleBetween(Math.nextUp((Double)start), Double.MAX_VALUE, false);\n+                rangeType = RangeType.DOUBLE;\n+            } else if (fieldType.typeName().equals(RangeType.FLOAT.typeName())) {\n+                start = randomFloat();\n+                end = randomFloatBetween(Math.nextUp((Float) start), Float.MAX_VALUE, false);\n+                rangeType = RangeType.DOUBLE;\n+            } else if (fieldType.typeName().equals(RangeType.IP.typeName())) {\n+                boolean v4 = randomBoolean();\n+                start = randomIp(v4);\n+                end = randomIp(v4);", "originalCommit": "e5340d5bbf7f7f509c1e40a0d1a4198117d46852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex 5ce1f0b53da..40934efbad6 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -560,16 +562,50 @@ public abstract class AggregatorTestCase extends ESTestCase {\n         }\n     }\n \n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return null;\n-    }\n-\n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n         return Collections.emptyList();\n     }\n \n-    public void testSupportedFieldTypes() throws IOException {\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n \n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n         MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n         Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n         String fieldName = \"typeTestFieldName\";\n"}}, {"oid": "197b1b0ff8f6da763195109aeb4c8ab2936e493e", "url": "https://github.com/elastic/elasticsearch/commit/197b1b0ff8f6da763195109aeb4c8ab2936e493e", "message": "Cleanup, javadocs, review comments", "committedDate": "2020-02-19T18:17:31Z", "type": "commit"}, {"oid": "f0973f97610cb8344fab357cedc98494fd0d2073", "url": "https://github.com/elastic/elasticsearch/commit/f0973f97610cb8344fab357cedc98494fd0d2073", "message": "Tweak for date_nanos", "committedDate": "2020-02-19T19:01:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA1NDQwNw==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r382054407", "bodyText": "If fieldType.isAggregatable() returns false, we can probably skip the field here, since it shouldn't have a ValuesSourceType if it doesn't support aggregations.  That will save folks adding fields that aren't intended to work with aggregations having to update writeTestDoc.", "author": "not-napoleon", "createdAt": "2020-02-20T15:01:06Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +562,184 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n+\n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+\n+            // Some field types should not be tested, or require more work and are not ready yet\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+            FieldMapper mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+\n+            MappedFieldType fieldType = mapper.fieldType();", "originalCommit": "f0973f97610cb8344fab357cedc98494fd0d2073", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMTQ1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r382101452", "bodyText": "Ah good catch \ud83d\udc4d", "author": "polyfractal", "createdAt": "2020-02-20T16:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA1NDQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "24a62aa4479e5e31a869e030c754b6ad37b5bbbc", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex cc22e5d4f69..f70396e2406 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -701,7 +701,7 @@ public abstract class AggregatorTestCase extends ESTestCase {\n                 rangeType = RangeType.DOUBLE;\n             } else if (fieldType.typeName().equals(RangeType.FLOAT.typeName())) {\n                 start = randomFloat();\n-                end = RangeType.FLOAT.nextUp(randomFloat());\n+                end = RangeType.FLOAT.nextUp(start);\n                 rangeType = RangeType.DOUBLE;\n             } else if (fieldType.typeName().equals(RangeType.IP.typeName())) {\n                 boolean v4 = randomBoolean();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA1NjY1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52493#discussion_r382056652", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            end = RangeType.FLOAT.nextUp(randomFloat());\n          \n          \n            \n                            end = RangeType.FLOAT.nextUp(start);", "author": "not-napoleon", "createdAt": "2020-02-20T15:04:31Z", "path": "test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java", "diffHunk": "@@ -524,6 +562,184 @@ protected static IndexReader maybeWrapReaderEs(DirectoryReader reader) throws IO\n         }\n     }\n \n+    /**\n+     * Implementors should return a list of {@link ValuesSourceType} that the aggregator supports.\n+     * This is used to test the matrix of supported/unsupported field types against the aggregator\n+     * and verify it works (or doesn't) as expected.\n+     *\n+     * If this method is implemented, {@link AggregatorTestCase#createAggBuilderForTypeTest(MappedFieldType, String)}\n+     * should be implemented as well.\n+     *\n+     * @return list of supported ValuesSourceTypes\n+     */\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        // If aggs don't override this method, an empty list allows the test to be skipped.\n+        // Once all aggs implement this method we should make it abstract and not allow skipping.\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * This method is invoked each time a field type is tested in {@link AggregatorTestCase#testSupportedFieldTypes()}.\n+     * The field type and name are provided, and the implementor is expected to return an AggBuilder accordingly.\n+     * The AggBuilder should be returned even if the aggregation does not support the field type, because\n+     * the test will check if an exception is thrown in that case.\n+     *\n+     * The list of supported types are provided by {@link AggregatorTestCase#getSupportedValuesSourceTypes()},\n+     * which must also be implemented.\n+     *\n+     * @param fieldType the type of the field that will be tested\n+     * @param fieldName the name of the field that will be test\n+     * @return an aggregation builder to test against the field\n+     */\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        throw new UnsupportedOperationException(\"If getSupportedValuesSourceTypes() is implemented, \" +\n+            \"createAggBuilderForTypeTest() must be implemented as well.\");\n+    }\n+\n+    /**\n+     * This test will validate that an aggregator succeeds or fails to run against all the field types\n+     * that are registered in {@link IndicesModule} (e.g. all the core field types).  An aggregator\n+     * is provided by the implementor class, and it is executed against each field type in turn.  If\n+     * an exception is thrown when the field is supported, that will fail the test.  Similarly, if\n+     * an exception _is not_ thrown when a field is unsupported, that will also fail the test.\n+     *\n+     * Exception types/messages are not currently checked, just presence/absence of an exception.\n+     */\n+    public void testSupportedFieldTypes() throws IOException {\n+        MapperRegistry mapperRegistry = new IndicesModule(Collections.emptyList()).getMapperRegistry();\n+        Settings settings = Settings.builder().put(\"index.version.created\", Version.CURRENT.id).build();\n+        String fieldName = \"typeTestFieldName\";\n+        List<ValuesSourceType> supportedVSTypes = getSupportedValuesSourceTypes();\n+\n+        if (supportedVSTypes.isEmpty()) {\n+            // If the test says it doesn't support any VStypes, it has not been converted yet so skip\n+            return;\n+        } else if (supportedVSTypes.contains(CoreValuesSourceType.ANY)) {\n+            throw new IllegalArgumentException(\"Tests should not specify CoreValuesSourceType.ANY as a supported ValuesSourceType, \" +\n+                \"but should instead list the concrete ValuesSourceTypes that are supported\");\n+        }\n+\n+        for (Map.Entry<String, Mapper.TypeParser> mappedType : mapperRegistry.getMapperParsers().entrySet()) {\n+\n+            // Some field types should not be tested, or require more work and are not ready yet\n+            if (TYPE_TEST_BLACKLIST.contains(mappedType.getKey())) {\n+                continue;\n+            }\n+\n+            Map<String, Object> source = new HashMap<>();\n+            source.put(\"type\", mappedType.getKey());\n+            source.put(\"doc_values\", \"true\");\n+\n+            Mapper.Builder builder = mappedType.getValue().parse(fieldName, source, new MockParserContext());\n+            FieldMapper mapper = (FieldMapper) builder.build(new BuilderContext(settings, new ContentPath()));\n+\n+            MappedFieldType fieldType = mapper.fieldType();\n+\n+            try (Directory directory = newDirectory()) {\n+                RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory);\n+                writeTestDoc(fieldType, fieldName, indexWriter);\n+                indexWriter.close();\n+\n+                try (IndexReader indexReader = DirectoryReader.open(directory)) {\n+                    IndexSearcher indexSearcher = newSearcher(indexReader, true, true);\n+                    AggregationBuilder aggregationBuilder = createAggBuilderForTypeTest(fieldType, fieldName);\n+\n+                    // TODO in the future we can make this more explicit with expectThrows(), when the exceptions are standardized\n+                    try {\n+                        searchAndReduce(indexSearcher, new MatchAllDocsQuery(), aggregationBuilder, fieldType);\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType()) == false) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] should not support field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field did not throw an excetion\");\n+                        }\n+                    } catch (Exception e) {\n+                        if (supportedVSTypes.contains(fieldType.getValuesSourceType())) {\n+                            fail(\"Aggregator [\" + aggregationBuilder.getType() + \"] supports field type [\"\n+                                + fieldType.typeName() + \"] but executing against the field threw an exception: [\" + e.getMessage() + \"]\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to write a single document with a single value specific to the requested fieldType.\n+     *\n+     * Throws an exception if it encounters an unknown field type, to prevent new ones from sneaking in without\n+     * being tested.\n+     */\n+    private void writeTestDoc(MappedFieldType fieldType, String fieldName, RandomIndexWriter iw) throws IOException {\n+\n+        if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.NUMERIC)) {\n+            // TODO note: once VS refactor adds DATE/BOOLEAN, this conditional will go away\n+            if (fieldType.typeName().equals(DateFieldMapper.CONTENT_TYPE)\n+                || fieldType.typeName().equals(DateFieldMapper.DATE_NANOS_CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomNonNegativeLong())));\n+            } else if (fieldType.typeName().equals(BooleanFieldMapper.CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomBoolean() ? 0 : 1)));\n+            } else {\n+                iw.addDocument(singleton(new SortedNumericDocValuesField(fieldName, randomLong())));\n+            }\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.BYTES)) {\n+            if (fieldType.typeName().equals(BinaryFieldMapper.CONTENT_TYPE)) {\n+                iw.addDocument(singleton(new BinaryFieldMapper.CustomBinaryDocValuesField(fieldName, new BytesRef(\"a\").bytes)));\n+            } else if (fieldType.typeName().equals(IpFieldMapper.CONTENT_TYPE)) {\n+                // TODO note: once VS refactor adds IP, this conditional will go away\n+                boolean v4 = randomBoolean();\n+                iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(InetAddressPoint.encode(randomIp(v4))))));\n+            } else {\n+                iw.addDocument(singleton(new SortedSetDocValuesField(fieldName, new BytesRef(\"a\"))));\n+            }\n+        } else if (fieldType.getValuesSourceType().equals(CoreValuesSourceType.RANGE)) {\n+            Object start;\n+            Object end;\n+            RangeType rangeType;\n+\n+            if (fieldType.typeName().equals(RangeType.DOUBLE.typeName())) {\n+                start = randomDouble();\n+                end = RangeType.DOUBLE.nextUp(start);\n+                rangeType = RangeType.DOUBLE;\n+            } else if (fieldType.typeName().equals(RangeType.FLOAT.typeName())) {\n+                start = randomFloat();\n+                end = RangeType.FLOAT.nextUp(randomFloat());", "originalCommit": "f0973f97610cb8344fab357cedc98494fd0d2073", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24a62aa4479e5e31a869e030c754b6ad37b5bbbc", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\nindex cc22e5d4f69..f70396e2406 100644\n--- a/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\n@@ -701,7 +701,7 @@ public abstract class AggregatorTestCase extends ESTestCase {\n                 rangeType = RangeType.DOUBLE;\n             } else if (fieldType.typeName().equals(RangeType.FLOAT.typeName())) {\n                 start = randomFloat();\n-                end = RangeType.FLOAT.nextUp(randomFloat());\n+                end = RangeType.FLOAT.nextUp(start);\n                 rangeType = RangeType.DOUBLE;\n             } else if (fieldType.typeName().equals(RangeType.IP.typeName())) {\n                 boolean v4 = randomBoolean();\n"}}, {"oid": "24a62aa4479e5e31a869e030c754b6ad37b5bbbc", "url": "https://github.com/elastic/elasticsearch/commit/24a62aa4479e5e31a869e030c754b6ad37b5bbbc", "message": "Update test/framework/src/main/java/org/elasticsearch/search/aggregations/AggregatorTestCase.java\n\nCo-Authored-By: Mark Tozzi <mark.tozzi@gmail.com>", "committedDate": "2020-02-20T16:10:50Z", "type": "commit"}, {"oid": "5b587e4817055a849e8a40a0fc5a1f17a88bc012", "url": "https://github.com/elastic/elasticsearch/commit/5b587e4817055a849e8a40a0fc5a1f17a88bc012", "message": "Skip fields that are not aggregatable", "committedDate": "2020-02-20T16:15:25Z", "type": "commit"}, {"oid": "6df733fec39eb1df2e6b747663cf5d03d23c84ac", "url": "https://github.com/elastic/elasticsearch/commit/6df733fec39eb1df2e6b747663cf5d03d23c84ac", "message": "Merge remote-tracking branch 'origin/master' into agg_test_fieldmappers", "committedDate": "2020-02-20T16:15:40Z", "type": "commit"}, {"oid": "ce07da72a02ffcb8d2ad436bfe9d31d8146a1aeb", "url": "https://github.com/elastic/elasticsearch/commit/ce07da72a02ffcb8d2ad436bfe9d31d8146a1aeb", "message": "Merge remote-tracking branch 'origin/master' into agg_test_fieldmappers", "committedDate": "2020-02-20T17:40:31Z", "type": "commit"}]}