{"pr_number": 51256, "pr_title": "Simplify Snapshot Initialization", "pr_createdAt": "2020-01-21T15:38:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51256", "timeline": [{"oid": "233c746a0d9814c0748820fe8bdbe399bbdf8020", "url": "https://github.com/elastic/elasticsearch/commit/233c746a0d9814c0748820fe8bdbe399bbdf8020", "message": "Simplify Snapshot Initialization\n\nWe were loading `RepositoryData` twice during snapshot initialization,\nredundantly checking if a snapshot existed already.\nThe first snapshot existence check is somewhat redundant because a snapshot could be\ncreated between loading `RepositoryData` and updating the cluster state with the `INIT`\nstate snapshot entry.\nAlso, it is much safer to do the subsequent checks for index existence in the repo and\nand the presence of old version snapshots once the `INIT` state entry prevents further\nsnapshots from being created concurrently.\nWhile the current state of things will never lead to corruption on a concurrent snapshot\ncreation, it could result in a situation (though unlikely) where all the snapshot's work\nis done on the data nodes, only to find out that the repository generation was off during\nsnapshot finalization, failing there and leaving a bunch of dead data in the repository\nthat won't be used in a subsequent snapshot (because the shard generation was never referenced\ndue to the failed snapshot finalization).\n\nNote: This is a step on the way to parallel repository operations by making snapshot related CS\nand repo related CS more tightly correlated.", "committedDate": "2020-01-21T15:31:03Z", "type": "commit"}, {"oid": "1ffd8077f85855380d341659b2ff53a373d2def6", "url": "https://github.com/elastic/elasticsearch/commit/1ffd8077f85855380d341659b2ff53a373d2def6", "message": "cs", "committedDate": "2020-01-21T15:40:40Z", "type": "commit"}, {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "url": "https://github.com/elastic/elasticsearch/commit/7ca5ef3d193a2bb5d45085ed085169d562b604d5", "message": "shorter", "committedDate": "2020-01-21T15:45:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMDAwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369630007", "bodyText": "I find this a bit more readable:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (snapshots == null || snapshots.entries().isEmpty()) {\n          \n          \n            \n                            if (snapshots != null && snapshots.entries().isEmpty() == false) {\n          \n          \n            \n                                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n          \n          \n            \n                            }\n          \n          \n            \n                            // Store newSnapshot here to be processed in clusterStateProcessed\n          \n          \n            \n                            ...", "author": "tlrx", "createdAt": "2020-01-22T15:31:13Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {", "originalCommit": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6da256517662d2c23df67dfac2d04d17ac0af9c2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\nindex 91f06316459..9762beac4ef 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n\n@@ -288,26 +288,25 @@ public class SnapshotsService extends AbstractLifecycleComponent implements Clus\n                         \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n                 }\n                 SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                if (snapshots == null || snapshots.entries().isEmpty()) {\n-                    // Store newSnapshot here to be processed in clusterStateProcessed\n-                    indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                        request.indicesOptions(), request.indices()));\n-                    logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                    newSnapshot = new SnapshotsInProgress.Entry(\n-                        new Snapshot(repositoryName, snapshotId),\n-                        request.includeGlobalState(), request.partial(),\n-                        State.INIT,\n-                        Collections.emptyList(),\n-                        threadPool.absoluteTimeInMillis(),\n-                        RepositoryData.UNKNOWN_REPO_GEN,\n-                        null,\n-                        request.userMetadata(), false\n-                    );\n-                    initializingSnapshots.add(newSnapshot.snapshot());\n-                    snapshots = new SnapshotsInProgress(newSnapshot);\n-                } else {\n+                if (snapshots != null && snapshots.entries().isEmpty() == false) {\n                     throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n                 }\n+                // Store newSnapshot here to be processed in clusterStateProcessed\n+                indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n+                    request.indicesOptions(), request.indices()));\n+                logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n+                newSnapshot = new SnapshotsInProgress.Entry(\n+                    new Snapshot(repositoryName, snapshotId),\n+                    request.includeGlobalState(), request.partial(),\n+                    State.INIT,\n+                    Collections.emptyList(), // We'll resolve the list of indices when moving to the STARTED state in #beginSnapshot\n+                    threadPool.absoluteTimeInMillis(),\n+                    RepositoryData.UNKNOWN_REPO_GEN,\n+                    null,\n+                    request.userMetadata(), false\n+                );\n+                initializingSnapshots.add(newSnapshot.snapshot());\n+                snapshots = new SnapshotsInProgress(newSnapshot);\n                 return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMjkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369632925", "bodyText": "Maybe add a comment on why the list is empty here? Something like\n// list of snapshot indices will be resolved later", "author": "tlrx", "createdAt": "2020-01-22T15:35:59Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {\n+                    // Store newSnapshot here to be processed in clusterStateProcessed\n+                    indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n+                        request.indicesOptions(), request.indices()));\n+                    logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n+                    newSnapshot = new SnapshotsInProgress.Entry(\n+                        new Snapshot(repositoryName, snapshotId),\n+                        request.includeGlobalState(), request.partial(),\n+                        State.INIT,\n+                        Collections.emptyList(),", "originalCommit": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6da256517662d2c23df67dfac2d04d17ac0af9c2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\nindex 91f06316459..9762beac4ef 100644\n--- a/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n+++ b/server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n\n@@ -288,26 +288,25 @@ public class SnapshotsService extends AbstractLifecycleComponent implements Clus\n                         \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n                 }\n                 SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                if (snapshots == null || snapshots.entries().isEmpty()) {\n-                    // Store newSnapshot here to be processed in clusterStateProcessed\n-                    indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                        request.indicesOptions(), request.indices()));\n-                    logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                    newSnapshot = new SnapshotsInProgress.Entry(\n-                        new Snapshot(repositoryName, snapshotId),\n-                        request.includeGlobalState(), request.partial(),\n-                        State.INIT,\n-                        Collections.emptyList(),\n-                        threadPool.absoluteTimeInMillis(),\n-                        RepositoryData.UNKNOWN_REPO_GEN,\n-                        null,\n-                        request.userMetadata(), false\n-                    );\n-                    initializingSnapshots.add(newSnapshot.snapshot());\n-                    snapshots = new SnapshotsInProgress(newSnapshot);\n-                } else {\n+                if (snapshots != null && snapshots.entries().isEmpty() == false) {\n                     throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n                 }\n+                // Store newSnapshot here to be processed in clusterStateProcessed\n+                indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n+                    request.indicesOptions(), request.indices()));\n+                logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n+                newSnapshot = new SnapshotsInProgress.Entry(\n+                    new Snapshot(repositoryName, snapshotId),\n+                    request.includeGlobalState(), request.partial(),\n+                    State.INIT,\n+                    Collections.emptyList(), // We'll resolve the list of indices when moving to the STARTED state in #beginSnapshot\n+                    threadPool.absoluteTimeInMillis(),\n+                    RepositoryData.UNKNOWN_REPO_GEN,\n+                    null,\n+                    request.userMetadata(), false\n+                );\n+                initializingSnapshots.add(newSnapshot.snapshot());\n+                snapshots = new SnapshotsInProgress(newSnapshot);\n                 return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n             }\n \n"}}, {"oid": "ae7c2a68c910cf3f79c976229a9396e2068ae373", "url": "https://github.com/elastic/elasticsearch/commit/ae7c2a68c910cf3f79c976229a9396e2068ae373", "message": "Merge remote-tracking branch 'elastic/master' into make-snapshot-delete-order-deterministic", "committedDate": "2020-01-22T16:29:09Z", "type": "commit"}, {"oid": "6da256517662d2c23df67dfac2d04d17ac0af9c2", "url": "https://github.com/elastic/elasticsearch/commit/6da256517662d2c23df67dfac2d04d17ac0af9c2", "message": "CR comments", "committedDate": "2020-01-22T16:33:22Z", "type": "commit"}]}