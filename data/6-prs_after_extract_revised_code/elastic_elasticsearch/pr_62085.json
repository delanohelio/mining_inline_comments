{"pr_number": 62085, "pr_title": "Wildcard field bug fix for term queries. Wildcard syntax should not be supported in plain term queries.", "pr_createdAt": "2020-09-08T10:23:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62085", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMTY4NA==", "url": "https://github.com/elastic/elasticsearch/pull/62085#discussion_r484831684", "bodyText": "I don't think we need the link on the issue. The test name is descriptive enough imo.", "author": "jimczi", "createdAt": "2020-09-08T11:00:49Z", "path": "x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapperTests.java", "diffHunk": "@@ -179,6 +179,41 @@ public void testTooBigQueryField() throws IOException {\n         reader.close();\n         dir.close();\n     }\n+    \n+    \n+    public void testTermQueryIgnoresWildcardSyntax() throws IOException {\n+        // Test for bug https://github.com/elastic/elasticsearch/issues/62081\n+        // where term queries honoured wildcard quwery syntax", "originalCommit": "8895eddbec6e113f6d3e36f25ee62325524c32c5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d66f4c8d65ec182358da5d59d31eec2ed9bb132b", "chunk": "diff --git a/x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapperTests.java b/x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapperTests.java\nindex 5c4fbca8660..a0d6d57c72e 100644\n--- a/x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapperTests.java\n+++ b/x-pack/plugin/wildcard/src/test/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapperTests.java\n\n@@ -191,29 +191,37 @@ public class WildcardFieldMapperTests extends ESTestCase {\n \n         Document doc = new Document();\n         ParseContext.Document parseDoc = new ParseContext.Document();\n-        addFields(parseDoc, doc, \"foo?\");\n+        addFields(parseDoc, doc, \"f*oo?\");\n         indexDoc(parseDoc, doc, iw);\n \n         iw.forceMerge(1);\n         DirectoryReader reader = iw.getReader();\n         IndexSearcher searcher = newSearcher(reader);\n         iw.close();\n-\n         \n-        expectMatch(searcher, \"foo*\", 0);\n-        expectMatch(searcher, \"foo?\", 1);\n-        expectMatch(searcher, \"?oo?\", 0);\n+        expectTermMatch(searcher, \"f*oo*\", 0);\n+        expectTermMatch(searcher, \"f*oo?\", 1);\n+        expectTermMatch(searcher, \"*oo?\", 0);\n+\n+        expectPrefixMatch(searcher, \"f*o\", 1);\n+        expectPrefixMatch(searcher, \"f*oo?\", 1);\n+        expectPrefixMatch(searcher, \"f??o\", 0);\n         \n         reader.close();\n         dir.close();\n     }\n     \n-    private void expectMatch(IndexSearcher searcher, String term,long count) throws IOException {\n+    private void expectTermMatch(IndexSearcher searcher, String term,long count) throws IOException {\n         Query q = wildcardFieldType.fieldType().termQuery(term, MOCK_QSC);\n         TopDocs td = searcher.search(q, 10, Sort.RELEVANCE);\n         assertThat(td.totalHits.value, equalTo(count));        \n     }\n     \n+    private void expectPrefixMatch(IndexSearcher searcher, String term,long count) throws IOException {\n+        Query q = wildcardFieldType.fieldType().prefixQuery(term, null, MOCK_QSC);\n+        TopDocs td = searcher.search(q, 10, Sort.RELEVANCE);\n+        assertThat(td.totalHits.value, equalTo(count));        \n+    }    \n \n \n     public void testSearchResultsVersusKeywordField() throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMjUzNA==", "url": "https://github.com/elastic/elasticsearch/pull/62085#discussion_r484832534", "bodyText": "Isn't it the same problem with prefix query ? Maybe we can just escape ? and * in the value and continue to use the wildcardQuery ?", "author": "jimczi", "createdAt": "2020-09-08T11:02:36Z", "path": "x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java", "diffHunk": "@@ -844,7 +845,36 @@ public Query existsQuery(QueryShardContext context) {\n \n         @Override\n         public Query termQuery(Object value, QueryShardContext context) {\n-            return wildcardQuery(BytesRefs.toString(value), MultiTermQuery.CONSTANT_SCORE_REWRITE, context);", "originalCommit": "8895eddbec6e113f6d3e36f25ee62325524c32c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg5NjA5NA==", "url": "https://github.com/elastic/elasticsearch/pull/62085#discussion_r484896094", "bodyText": "Good point. I'll try that approach.", "author": "markharwood", "createdAt": "2020-09-08T13:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "d66f4c8d65ec182358da5d59d31eec2ed9bb132b", "chunk": "diff --git a/x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java b/x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java\nindex 8eba31e3e41..d2469afc430 100644\n--- a/x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java\n+++ b/x-pack/plugin/wildcard/src/main/java/org/elasticsearch/xpack/wildcard/mapper/WildcardFieldMapper.java\n\n@@ -846,40 +846,27 @@ public class WildcardFieldMapper extends FieldMapper {\n         @Override\n         public Query termQuery(Object value, QueryShardContext context) {\n             String searchTerm = BytesRefs.toString(value);\n-            String ngramIndexPattern = addLineEndChars(searchTerm);\n-            \n-            // Break search term into tokens\n-            Set<String> tokens = new LinkedHashSet<>();\n-            getNgramTokens(tokens, ngramIndexPattern);\n-            BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n-            int clauseCount = 0;\n-            for (String string : tokens) {\n-                if (clauseCount >= MAX_CLAUSES_IN_APPROXIMATION_QUERY) {\n-                    break;\n+            return wildcardQuery(escapeWildcardSyntax(searchTerm),  MultiTermQuery.CONSTANT_SCORE_REWRITE, context);\n+        }\n+        \n+        private String escapeWildcardSyntax(String term) {\n+            StringBuilder result = new StringBuilder();\n+            for (int i = 0; i < term.length();) {\n+                final int c = term.codePointAt(i);\n+                int length = Character.charCount(c);\n+                // Escape any reserved characters\n+                if (c == WildcardQuery.WILDCARD_STRING || c == WildcardQuery.WILDCARD_CHAR || c == WildcardQuery.WILDCARD_ESCAPE) {\n+                    result.append(\"\\\\\");\n                 }\n-                addClause(string, rewritten, Occur.MUST);\n-                clauseCount++;\n-            }\n-            Supplier<Automaton> deferredAutomatonSupplier = () -> {\n-                return Automata.makeString(searchTerm);\n-            };\n-            AutomatonQueryOnBinaryDv verifyingQuery = new AutomatonQueryOnBinaryDv(name(), searchTerm, deferredAutomatonSupplier);\n-            if (clauseCount > 0) {\n-                // We can accelerate execution with the ngram query\n-                BooleanQuery approxQuery = rewritten.build();\n-                BooleanQuery.Builder verifyingBuilder = new BooleanQuery.Builder();\n-                verifyingBuilder.add(new BooleanClause(approxQuery, Occur.MUST));\n-                verifyingBuilder.add(new BooleanClause(verifyingQuery, Occur.MUST));\n-                return verifyingBuilder.build();\n-            } else  {\n-                // We have no concrete characters\n-                return new MatchNoDocsQuery();\n+                result.appendCodePoint(c);\n+                i += length;\n             }\n+            return result.toString();\n         }\n \n         @Override\n         public Query prefixQuery(String value, MultiTermQuery.RewriteMethod method, QueryShardContext context) {\n-            return wildcardQuery(value + \"*\", method, context);\n+            return wildcardQuery(escapeWildcardSyntax(value) + \"*\", method, context);\n         }\n \n         @Override\n"}}, {"oid": "03225727b47e4c89539d4f831a4c108e26063fb2", "url": "https://github.com/elastic/elasticsearch/commit/03225727b47e4c89539d4f831a4c108e26063fb2", "message": "Wildcard field bug fix for term queries. Wildcard syntax should not have special treatment in plain term queries.\nReplaced the simple logic that delegated to wildcardQuery() method with dedicated exact-match query logic for term queries.\n\nCloses #62081", "committedDate": "2020-09-09T08:14:37Z", "type": "commit"}, {"oid": "d66f4c8d65ec182358da5d59d31eec2ed9bb132b", "url": "https://github.com/elastic/elasticsearch/commit/d66f4c8d65ec182358da5d59d31eec2ed9bb132b", "message": "Opted to escape any wildcard syntax in term and prefix queries to keep the one search implementation", "committedDate": "2020-09-09T08:14:37Z", "type": "commit"}, {"oid": "8c67667ffe1639ce03f6bb3c03f51734c67a610f", "url": "https://github.com/elastic/elasticsearch/commit/8c67667ffe1639ce03f6bb3c03f51734c67a610f", "message": "Removed comment", "committedDate": "2020-09-09T08:14:37Z", "type": "commit"}, {"oid": "0ddbaacbcc4357e5718dca5e79cec3f4bc5888f4", "url": "https://github.com/elastic/elasticsearch/commit/0ddbaacbcc4357e5718dca5e79cec3f4bc5888f4", "message": "Unused import", "committedDate": "2020-09-09T08:14:37Z", "type": "commit"}, {"oid": "56304a8433696990066e5db286b54fb52751c3e8", "url": "https://github.com/elastic/elasticsearch/commit/56304a8433696990066e5db286b54fb52751c3e8", "message": "Fix test", "committedDate": "2020-09-09T08:14:37Z", "type": "commit"}, {"oid": "56304a8433696990066e5db286b54fb52751c3e8", "url": "https://github.com/elastic/elasticsearch/commit/56304a8433696990066e5db286b54fb52751c3e8", "message": "Fix test", "committedDate": "2020-09-09T08:14:37Z", "type": "forcePushed"}]}