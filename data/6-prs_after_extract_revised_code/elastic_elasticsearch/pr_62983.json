{"pr_number": 62983, "pr_title": "Make Rounding.nextRoundingValue consistent", "pr_createdAt": "2020-09-28T20:43:39Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62983", "timeline": [{"oid": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "url": "https://github.com/elastic/elasticsearch/commit/def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "message": "Make Rounding.nextRoundingValue consistent\n\n\"interval\" style roundings were implementing `nextRoundingValue` in a\nfairly inconsistent way - it'd produce a value, but sometimes that\nvalue would be the same as the previous rounding value. This makes it\nconsistently the next value that `rounding` would make.", "committedDate": "2020-09-28T20:44:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496221050", "bodyText": "I'm not sure I need to keep these. They failed on some of my other attempts at implementing this method.", "author": "nik9000", "createdAt": "2020-09-28T20:44:11Z", "path": "server/src/test/java/org/elasticsearch/common/RoundingTests.java", "diffHunk": "@@ -469,6 +469,20 @@ public void testRandomTimeIntervalRounding() {\n         }\n     }\n \n+    public void testFoo() {\n+        Rounding rounding = new Rounding.TimeIntervalRounding(960000, ZoneId.of(\"Europe/Minsk\"));\n+        long rounded = rounding.prepareForUnknown().round(877824908400L);\n+        long next = rounding.prepareForUnknown().nextRoundingValue(rounded);\n+        assertThat(next, greaterThan(rounded));\n+    }\n+\n+    public void testBar() {\n+        Rounding rounding = new Rounding.TimeIntervalRounding(480000, ZoneId.of(\"Portugal\"));\n+        long rounded = rounding.prepareJavaTime().round(972780720000L);\n+        long next = rounding.prepareJavaTime().nextRoundingValue(rounded);\n+        assertThat(next, greaterThan(rounded));\n+    }", "originalCommit": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496225286", "bodyText": "I'd keep them in, personally.  Could just put a note that those specific values caused problems for some implementations, so we're keeping them around for regression testing, or something like that.", "author": "not-napoleon", "createdAt": "2020-09-28T20:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1ODgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497558807", "bodyText": "I know we don't use them much, but this would be an excellent candidate for junit parameterized testing.", "author": "not-napoleon", "createdAt": "2020-09-30T14:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "70f107388be6d4caabf47cbf8be7d5fee0e4113c", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/RoundingTests.java b/server/src/test/java/org/elasticsearch/common/RoundingTests.java\nindex 7a52ba2de48..a30c9da9875 100644\n--- a/server/src/test/java/org/elasticsearch/common/RoundingTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/RoundingTests.java\n\n@@ -469,20 +469,48 @@ public class RoundingTests extends ESTestCase {\n         }\n     }\n \n-    public void testFoo() {\n+    /**\n+     * Check a {@link Rounding.Prepared#nextRoundingValue} that was difficult\n+     * to build well with the java.time APIs.\n+     */\n+    public void testHardNextRoundingValue() {\n         Rounding rounding = new Rounding.TimeIntervalRounding(960000, ZoneId.of(\"Europe/Minsk\"));\n         long rounded = rounding.prepareForUnknown().round(877824908400L);\n         long next = rounding.prepareForUnknown().nextRoundingValue(rounded);\n         assertThat(next, greaterThan(rounded));\n     }\n \n-    public void testBar() {\n+    /**\n+     * Check a {@link Rounding.Prepared#nextRoundingValue} that was difficult\n+     * to build well with the java.time APIs.\n+     */\n+    public void testOtherHardNextRoundingValue() {\n         Rounding rounding = new Rounding.TimeIntervalRounding(480000, ZoneId.of(\"Portugal\"));\n         long rounded = rounding.prepareJavaTime().round(972780720000L);\n         long next = rounding.prepareJavaTime().nextRoundingValue(rounded);\n         assertThat(next, greaterThan(rounded));\n     }\n \n+    /**\n+     * Check a {@link Rounding.Prepared#nextRoundingValue} that was difficult\n+     * to build well our janky Newton's Method/binary search hybrid.\n+     */\n+    public void testHardNewtonsMethod() {\n+        ZoneId tz = ZoneId.of(\"Asia/Jerusalem\");\n+        Rounding rounding = new Rounding.TimeIntervalRounding(19800000, tz);\n+        assertThat(rounding.prepareJavaTime().nextRoundingValue(1824929914182L), isDate(time(\"2027-10-31T01:30:00\", tz), tz));\n+    }\n+\n+    /**\n+     * Check a {@link Rounding.Prepared#nextRoundingValue} that was difficult\n+     * to build well with the java.time APIs.\n+     */\n+    public void testOtherHardNewtonsMethod() {\n+        ZoneId tz = ZoneId.of(\"America/Glace_Bay\");\n+        Rounding rounding = new Rounding.TimeIntervalRounding(13800000, tz);\n+        assertThat(rounding.prepareJavaTime().nextRoundingValue(1383463147373L), isDate(time(\"2013-11-03T03:40:00\", tz), tz));\n+    }\n+\n     /**\n      * Test that rounded values are always greater or equal to last rounded value if date is increasing.\n      * The example covers an interval around 2011-10-30T02:10:00+01:00, time zone CET, interval: 2700000ms\n"}}, {"oid": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "url": "https://github.com/elastic/elasticsearch/commit/def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "message": "Make Rounding.nextRoundingValue consistent\n\n\"interval\" style roundings were implementing `nextRoundingValue` in a\nfairly inconsistent way - it'd produce a value, but sometimes that\nvalue would be the same as the previous rounding value. This makes it\nconsistently the next value that `rounding` would make.", "committedDate": "2020-09-28T20:44:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyODM1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496228351", "bodyText": "So I'm just glancing at this, and haven't read the whole class, but, it looks like the old implementation was using interval as a number of seconds, and this is using it as a number of milliseconds?  Is that correct?  Or am I misunderstanding something here?", "author": "not-napoleon", "createdAt": "2020-09-28T20:58:26Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1118,16 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                long from = utcMillis + interval; // TODO this implementation makes me very upset", "originalCommit": "def11bbbf9a8cdf81f9657d50d9eed5a56ce0785", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc0MTM5MA==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r496741390", "bodyText": "The old implementation had the zone's offset in seconds but the interval was in millis.", "author": "nik9000", "createdAt": "2020-09-29T14:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyODM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "70f107388be6d4caabf47cbf8be7d5fee0e4113c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 992e8dc3705..080757f1d1c 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -1119,15 +1123,60 @@ public abstract class Rounding implements Writeable {\n \n             @Override\n             public long nextRoundingValue(long utcMillis) {\n-                long from = utcMillis + interval; // TODO this implementation makes me very upset\n-                while (from > utcMillis) {\n+                /*\n+                 * Ok. I'm not proud of this, but it gets the job done. So here is the deal:\n+                 * its super important that nextRoundingValue be *exactly* the next rounding\n+                 * value. And I can't come up with a nice way to use the java time API to figure\n+                 * it out. Thus, we treat \"round\" like a black box here and run a kind of whacky\n+                 * binary search, newton's method hybrid. We don't have a \"slope\" so we can't do\n+                 * a \"real\" newton's method, so we just sort of cut the diff in half. As janky\n+                 * as it looks, it tends to get the job done in under four iterations. Frankly,\n+                 * `round(round(utcMillis) + interval)` is usually a good guess so we mostly get\n+                 * it in a single iteration. But daylight savings time and other janky stuff can\n+                 * make it less likely.\n+                 */\n+                long prevRound = round(utcMillis);\n+                long increment = interval;\n+                long from = prevRound;\n+                int iterations = 0;\n+                while (++iterations < 100) {\n+                    from += increment;\n                     long rounded = round(from);\n-                    if (rounded > utcMillis) {\n-                        return rounded;\n+                    boolean highEnough = rounded > prevRound;\n+                    if (false == highEnough) {\n+                        if (increment < 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    long roundedRoundedDown = round(rounded - 1);\n+                    boolean tooHigh = roundedRoundedDown > prevRound;\n+                    if (tooHigh) {\n+                        if (increment > 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    assert highEnough && false == tooHigh;\n+                    assert roundedRoundedDown == prevRound;\n+                    if (iterations > 3 && logger.isDebugEnabled()) {\n+                        logger.debug(\"Iterated {} time for {} using {}\", iterations, utcMillis, TimeIntervalRounding.this.toString());\n                     }\n-                    from += 60000;\n+                    return rounded;\n                 }\n-                throw new IllegalArgumentException(\"No rounding available after [\" + utcMillis + \"] in [\" + timeZone + \"]\");\n+                assert false : String.format(\n+                    Locale.ROOT,\n+                    \"Expected to find the rounding in 100 iterations but didn't for [%d] with [%s]\",\n+                    utcMillis,\n+                    TimeIntervalRounding.this.toString()\n+                );\n+                logger.debug(\n+                    \"Expected to find the rounding in 100 iterations but didn't for {} using {}\",\n+                    iterations,\n+                    utcMillis,\n+                    TimeIntervalRounding.this.toString()\n+                );\n+                return round(from);\n             }\n         }\n     }\n"}}, {"oid": "70f107388be6d4caabf47cbf8be7d5fee0e4113c", "url": "https://github.com/elastic/elasticsearch/commit/70f107388be6d4caabf47cbf8be7d5fee0e4113c", "message": "binary search/newton's method thing", "committedDate": "2020-09-29T15:08:43Z", "type": "commit"}, {"oid": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "url": "https://github.com/elastic/elasticsearch/commit/17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "message": "Logger", "committedDate": "2020-09-29T15:43:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1MjA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497552047", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                assert highEnough && false == tooHigh;\n          \n          \n            \n                                assert highEnough && (false == tooHigh);\n          \n      \n    \n    \n  \n\nI know it's redundant, but I think it's more readable to add parenthesis than have to remember the precedence order.", "author": "not-napoleon", "createdAt": "2020-09-30T14:24:41Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1122,60 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                /*\n+                 * Ok. I'm not proud of this, but it gets the job done. So here is the deal:\n+                 * its super important that nextRoundingValue be *exactly* the next rounding\n+                 * value. And I can't come up with a nice way to use the java time API to figure\n+                 * it out. Thus, we treat \"round\" like a black box here and run a kind of whacky\n+                 * binary search, newton's method hybrid. We don't have a \"slope\" so we can't do\n+                 * a \"real\" newton's method, so we just sort of cut the diff in half. As janky\n+                 * as it looks, it tends to get the job done in under four iterations. Frankly,\n+                 * `round(round(utcMillis) + interval)` is usually a good guess so we mostly get\n+                 * it in a single iteration. But daylight savings time and other janky stuff can\n+                 * make it less likely.\n+                 */\n+                long prevRound = round(utcMillis);\n+                long increment = interval;\n+                long from = prevRound;\n+                int iterations = 0;\n+                while (++iterations < 100) {\n+                    from += increment;\n+                    long rounded = round(from);\n+                    boolean highEnough = rounded > prevRound;\n+                    if (false == highEnough) {\n+                        if (increment < 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    long roundedRoundedDown = round(rounded - 1);\n+                    boolean tooHigh = roundedRoundedDown > prevRound;\n+                    if (tooHigh) {\n+                        if (increment > 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    assert highEnough && false == tooHigh;", "originalCommit": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 89f1c67e5f7..c52f95b9da5 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -1157,7 +1157,7 @@ public abstract class Rounding implements Writeable {\n                         }\n                         continue;\n                     }\n-                    assert highEnough && false == tooHigh;\n+                    assert highEnough && (false == tooHigh);\n                     assert roundedRoundedDown == prevRound;\n                     if (iterations > 3 && logger.isDebugEnabled()) {\n                         logger.debug(\"Iterated {} time for {} using {}\", iterations, utcMillis, TimeIntervalRounding.this.toString());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NTg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497555896", "bodyText": "I think you're using assert false here so this throws in testing but not in production.  If that's the case, please just put a note for why we want the behavior to be different in prod, and maybe what will actually be returned in that case.  And if not, please throw an actual exception.", "author": "not-napoleon", "createdAt": "2020-09-30T14:29:02Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -1119,12 +1122,60 @@ public long round(long utcMillis) {\n             }\n \n             @Override\n-            public long nextRoundingValue(long time) {\n-                int offsetSeconds = timeZone.getRules().getOffset(Instant.ofEpochMilli(time)).getTotalSeconds();\n-                long millis = time + interval + offsetSeconds * 1000;\n-                return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC)\n-                    .withZoneSameLocal(timeZone)\n-                    .toInstant().toEpochMilli();\n+            public long nextRoundingValue(long utcMillis) {\n+                /*\n+                 * Ok. I'm not proud of this, but it gets the job done. So here is the deal:\n+                 * its super important that nextRoundingValue be *exactly* the next rounding\n+                 * value. And I can't come up with a nice way to use the java time API to figure\n+                 * it out. Thus, we treat \"round\" like a black box here and run a kind of whacky\n+                 * binary search, newton's method hybrid. We don't have a \"slope\" so we can't do\n+                 * a \"real\" newton's method, so we just sort of cut the diff in half. As janky\n+                 * as it looks, it tends to get the job done in under four iterations. Frankly,\n+                 * `round(round(utcMillis) + interval)` is usually a good guess so we mostly get\n+                 * it in a single iteration. But daylight savings time and other janky stuff can\n+                 * make it less likely.\n+                 */\n+                long prevRound = round(utcMillis);\n+                long increment = interval;\n+                long from = prevRound;\n+                int iterations = 0;\n+                while (++iterations < 100) {\n+                    from += increment;\n+                    long rounded = round(from);\n+                    boolean highEnough = rounded > prevRound;\n+                    if (false == highEnough) {\n+                        if (increment < 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    long roundedRoundedDown = round(rounded - 1);\n+                    boolean tooHigh = roundedRoundedDown > prevRound;\n+                    if (tooHigh) {\n+                        if (increment > 0) {\n+                            increment = -increment / 2;\n+                        }\n+                        continue;\n+                    }\n+                    assert highEnough && false == tooHigh;\n+                    assert roundedRoundedDown == prevRound;\n+                    if (iterations > 3 && logger.isDebugEnabled()) {\n+                        logger.debug(\"Iterated {} time for {} using {}\", iterations, utcMillis, TimeIntervalRounding.this.toString());\n+                    }\n+                    return rounded;\n+                }\n+                assert false : String.format(", "originalCommit": "17cc7d38729f4dd4b728a967bbd1db1834cd7f5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MDUwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62983#discussion_r497560506", "bodyText": "Sure!", "author": "nik9000", "createdAt": "2020-09-30T14:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NTg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 89f1c67e5f7..c52f95b9da5 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -1157,7 +1157,7 @@ public abstract class Rounding implements Writeable {\n                         }\n                         continue;\n                     }\n-                    assert highEnough && false == tooHigh;\n+                    assert highEnough && (false == tooHigh);\n                     assert roundedRoundedDown == prevRound;\n                     if (iterations > 3 && logger.isDebugEnabled()) {\n                         logger.debug(\"Iterated {} time for {} using {}\", iterations, utcMillis, TimeIntervalRounding.this.toString());\n"}}, {"oid": "3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "url": "https://github.com/elastic/elasticsearch/commit/3a7fc015858e89d3963ce240cec7d3f80c4bdc71", "message": "Apply suggestions from code review\n\nCo-authored-by: Mark Tozzi <mark.tozzi@gmail.com>", "committedDate": "2020-09-30T14:35:08Z", "type": "commit"}, {"oid": "3dc048338c151a960e3f6ac50c55e9aed0311707", "url": "https://github.com/elastic/elasticsearch/commit/3dc048338c151a960e3f6ac50c55e9aed0311707", "message": "Explain", "committedDate": "2020-09-30T17:11:47Z", "type": "commit"}]}