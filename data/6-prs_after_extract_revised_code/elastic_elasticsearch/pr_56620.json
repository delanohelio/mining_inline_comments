{"pr_number": 56620, "pr_title": "Cancel task and descendants on channel disconnects", "pr_createdAt": "2020-05-12T17:19:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56620", "timeline": [{"oid": "59f50a020e072f8813b7367ed6e9fd0284de8e22", "url": "https://github.com/elastic/elasticsearch/commit/59f50a020e072f8813b7367ed6e9fd0284de8e22", "message": "Cancel task and descendants on channel disconnects", "committedDate": "2020-05-12T16:54:33Z", "type": "commit"}, {"oid": "d92ef102c68b753266218518de777c02d15d1cf9", "url": "https://github.com/elastic/elasticsearch/commit/d92ef102c68b753266218518de777c02d15d1cf9", "message": "Merge branch 'master' into cancel-on-disconnect", "committedDate": "2020-05-12T18:08:15Z", "type": "commit"}, {"oid": "22b28fa81d4dae04cb1c44a38296a9cea8c58490", "url": "https://github.com/elastic/elasticsearch/commit/22b28fa81d4dae04cb1c44a38296a9cea8c58490", "message": "fix test", "committedDate": "2020-05-12T18:09:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjU1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r423976557", "bodyText": "I think we need to clean these up when the channel closes. Maybe slightly tricky, we might close the channel concurrently with calling this method too.", "author": "DaveCTurner", "createdAt": "2020-05-12T19:22:01Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -607,4 +602,41 @@ void unregisterChildNode(DiscoveryNode node) {\n         }\n     }\n \n+    /**\n+     * Start tracking a cancellable task with its tcp channel, so if the channel gets closed we can get a set of\n+     * pending tasks associated that channel and cancel them as these results won't be retrieved by the parent task.\n+     *\n+     * @return a releasable that should be called when this pending task is completed\n+     */\n+    public Releasable startTrackingCancellableChannelTask(TcpChannel channel, CancellableTask task) {\n+        assert cancellableTasks.containsKey(task.getId()) : \"task [\" + task.getId() + \"] is not registered yet\";\n+        final ChannelPendingTaskTracker tracker = channelPendingTaskTrackers.computeIfAbsent(channel, k -> new ChannelPendingTaskTracker());", "originalCommit": "22b28fa81d4dae04cb1c44a38296a9cea8c58490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNjgzMg==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424026832", "bodyText": "Good catch. I pushed cbe02c7.", "author": "dnhatn", "createdAt": "2020-05-12T20:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cbe02c7eae5f3aa58f1a6757ac7697da7e95242f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex ed79b2d1cb9..324edb20669 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -615,6 +615,8 @@ public class TaskManager implements ClusterStateApplier {\n         if (tracker.registered.compareAndSet(false, true)) {\n             channel.addCloseListener(ActionListener.wrap(\n                 r -> {\n+                    final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n+                    assert removedTracker == tracker;\n                     final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n                     for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n                         listener.accept(pendingTasks);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r423976923", "bodyText": "Can we assert it was removed?", "author": "DaveCTurner", "createdAt": "2020-05-12T19:22:42Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -607,4 +602,41 @@ void unregisterChildNode(DiscoveryNode node) {\n         }\n     }\n \n+    /**\n+     * Start tracking a cancellable task with its tcp channel, so if the channel gets closed we can get a set of\n+     * pending tasks associated that channel and cancel them as these results won't be retrieved by the parent task.\n+     *\n+     * @return a releasable that should be called when this pending task is completed\n+     */\n+    public Releasable startTrackingCancellableChannelTask(TcpChannel channel, CancellableTask task) {\n+        assert cancellableTasks.containsKey(task.getId()) : \"task [\" + task.getId() + \"] is not registered yet\";\n+        final ChannelPendingTaskTracker tracker = channelPendingTaskTrackers.computeIfAbsent(channel, k -> new ChannelPendingTaskTracker());\n+        tracker.pendingTasks.add(task);\n+        if (tracker.registered.compareAndSet(false, true)) {\n+            channel.addCloseListener(ActionListener.wrap(\n+                r -> {\n+                    final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n+                    for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n+                        listener.accept(pendingTasks);\n+                    }\n+                },\n+                e -> {\n+                    assert false : new AssertionError(\"must not be here\", e);\n+                }));\n+        }\n+        return () -> tracker.pendingTasks.remove(task);", "originalCommit": "22b28fa81d4dae04cb1c44a38296a9cea8c58490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNjk4OA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424026988", "bodyText": "++. Adjusted in 09a612e.", "author": "dnhatn", "createdAt": "2020-05-12T20:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk3NjkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "cbe02c7eae5f3aa58f1a6757ac7697da7e95242f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex ed79b2d1cb9..324edb20669 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -615,6 +615,8 @@ public class TaskManager implements ClusterStateApplier {\n         if (tracker.registered.compareAndSet(false, true)) {\n             channel.addCloseListener(ActionListener.wrap(\n                 r -> {\n+                    final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n+                    assert removedTracker == tracker;\n                     final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n                     for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n                         listener.accept(pendingTasks);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4NzU2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r423987569", "bodyText": "I wasn't expecting this to be included here, although perhaps it makes sense as a separate change. It's reasonable if the node is shut down but today we also cancel these tasks if the node is temporarily partitioned from the master, and perhaps we want to keep that behaviour.\nThe issue is that we don't tell the partitioned node that it has been dropped from the cluster so it won't close its outgoing channels, which means we won't cancel those tasks any more if we remove this.\nAlso looks like the tests around this are quite weak, since this change doesn't seem to have a corresponding change to the tests.", "author": "DaveCTurner", "createdAt": "2020-05-12T19:40:42Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -442,17 +448,6 @@ public void applyClusterState(ClusterChangedEvent event) {\n                     }\n                 }\n             }\n-            // Cancel cancellable tasks for the nodes that are gone", "originalCommit": "22b28fa81d4dae04cb1c44a38296a9cea8c58490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyODY0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424028642", "bodyText": "This has become an issue for us in the context of cross clusters. A subtask on the remote cluster will get canceled if any node in that cluster leaves. The reason is that the node with the parent task is from another cluster. This blocks the work to support cancellation cross clusters in #55779. We would like to replace it with the task heartbeat, but I found your proposal is much better.\n\nAlso looks like the tests around this are quite weak, since this change doesn't seem to have a corresponding change to the tests.\n\nYeah, we only test when a node leaves the cluster.", "author": "dnhatn", "createdAt": "2020-05-12T20:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4NzU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MjcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424042718", "bodyText": "I see, in which case this change is ok with me. Could we make that test stronger? It seems very artificial that the tasks are only cancelled on testNodes[0].close();.", "author": "DaveCTurner", "createdAt": "2020-05-12T21:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4NzU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1NDc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424054744", "bodyText": "The issue is that we don't tell the partitioned node that it has been dropped from the cluster so it won't close its outgoing channels, which means we won't cancel those tasks any more if we remove this.\n\nThat looks like an enhancement to me. If the channel is still active we should give a chance for the task to finish ?", "author": "jimczi", "createdAt": "2020-05-12T21:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4NzU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424140006", "bodyText": "ok, I pushed 8ae7042.", "author": "dnhatn", "createdAt": "2020-05-13T02:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4NzU2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODE2NA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r423988164", "bodyText": "Maybe log a warning here?", "author": "DaveCTurner", "createdAt": "2020-05-12T19:41:51Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -276,4 +279,23 @@ public void messageReceived(final BanParentTaskRequest request, final TransportC\n         }\n     }\n \n+    void cancelOrphanedTasks(Set<CancellableTask> orphanedTasks) {\n+        if (orphanedTasks.isEmpty() == false) {\n+            transportService.getThreadPool().generic().execute(new AbstractRunnable() {\n+                @Override\n+                public void onFailure(Exception e) {\n+", "originalCommit": "22b28fa81d4dae04cb1c44a38296a9cea8c58490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNzA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424027074", "bodyText": "added in d4f7586", "author": "dnhatn", "createdAt": "2020-05-12T20:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk4ODE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "d4f7586c16d83ffea09b3f080e3a3d0a418ffeb3", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex dc667c19e3e..a24e20e9b49 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -284,7 +284,7 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n             transportService.getThreadPool().generic().execute(new AbstractRunnable() {\n                 @Override\n                 public void onFailure(Exception e) {\n-\n+                    logger.warn(\"failed to cancel tasks on channel closed\", e);\n                 }\n \n                 @Override\n"}}, {"oid": "92bbcf2227e6efb9fe5d501dac2850bb8c2e75d8", "url": "https://github.com/elastic/elasticsearch/commit/92bbcf2227e6efb9fe5d501dac2850bb8c2e75d8", "message": "Merge branch 'master' into cancel-on-disconnect", "committedDate": "2020-05-12T20:38:12Z", "type": "commit"}, {"oid": "d4f7586c16d83ffea09b3f080e3a3d0a418ffeb3", "url": "https://github.com/elastic/elasticsearch/commit/d4f7586c16d83ffea09b3f080e3a3d0a418ffeb3", "message": "warning log", "committedDate": "2020-05-12T20:44:45Z", "type": "commit"}, {"oid": "cbe02c7eae5f3aa58f1a6757ac7697da7e95242f", "url": "https://github.com/elastic/elasticsearch/commit/cbe02c7eae5f3aa58f1a6757ac7697da7e95242f", "message": "remove tracker on close", "committedDate": "2020-05-12T20:50:54Z", "type": "commit"}, {"oid": "09a612eb067c2173fa060e3e2bea3bbedabfde8e", "url": "https://github.com/elastic/elasticsearch/commit/09a612eb067c2173fa060e3e2bea3bbedabfde8e", "message": "assertion", "committedDate": "2020-05-12T20:52:02Z", "type": "commit"}, {"oid": "3b4e3bef9e1d36b9188b5b5451c8b643e648ba23", "url": "https://github.com/elastic/elasticsearch/commit/3b4e3bef9e1d36b9188b5b5451c8b643e648ba23", "message": "wording", "committedDate": "2020-05-12T20:59:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MTQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424041480", "bodyText": "What if the channel is closed (and the close listener executes completely) just before this line executes? I think that means we never cancel the task added in this line.\nCould we have a test with some concurrency to pick this up?", "author": "DaveCTurner", "createdAt": "2020-05-12T21:22:32Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -607,4 +602,53 @@ void unregisterChildNode(DiscoveryNode node) {\n         }\n     }\n \n+    /**\n+     * Start tracking a cancellable task with its tcp channel, so if the channel gets closed we can get a set of\n+     * pending tasks associated that channel and cancel them as these results won't be retrieved by the parent task.\n+     *\n+     * @return a releasable that should be called when this pending task is completed\n+     */\n+    public Releasable startTrackingCancellableChannelTask(TcpChannel channel, CancellableTask task) {\n+        assert cancellableTasks.containsKey(task.getId()) : \"task [\" + task.getId() + \"] is not registered yet\";\n+        final ChannelPendingTaskTracker tracker = channelPendingTaskTrackers.computeIfAbsent(channel, k -> new ChannelPendingTaskTracker());\n+        tracker.addTask(task);", "originalCommit": "3b4e3bef9e1d36b9188b5b5451c8b643e648ba23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzOTg0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424139843", "bodyText": "Good catch. I added a test and strengthen this logic in bdfa4f2.", "author": "dnhatn", "createdAt": "2020-05-13T02:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MTQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "1d2de32dde9b1ab7b73c483670a45b9666878cb7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 50c9f8481bc..ad5bbcb9f63 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -617,9 +617,11 @@ public class TaskManager implements ClusterStateApplier {\n                 r -> {\n                     final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n                     assert removedTracker == tracker;\n-                    final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n-                    for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n-                        listener.accept(pendingTasks);\n+                    final Consumer<Set<CancellableTask>> listener = onChannelCloseListener.get();\n+                    if (listener != null) {\n+                        listener.accept(Collections.unmodifiableSet(tracker.pendingTasks));\n+                    } else {\n+                        assert false : \"onChannelCloseListener was not set\";\n                     }\n                 },\n                 e -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1Njc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424056753", "bodyText": "Do we need to add multiple listeners ? I think  it would be cleaner to move the logic to cancel a task directly in the TaskManager and call it from TransportCancelTasksAction ?", "author": "jimczi", "createdAt": "2020-05-12T21:55:32Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -607,4 +602,53 @@ void unregisterChildNode(DiscoveryNode node) {\n         }\n     }\n \n+    /**\n+     * Start tracking a cancellable task with its tcp channel, so if the channel gets closed we can get a set of\n+     * pending tasks associated that channel and cancel them as these results won't be retrieved by the parent task.\n+     *\n+     * @return a releasable that should be called when this pending task is completed\n+     */\n+    public Releasable startTrackingCancellableChannelTask(TcpChannel channel, CancellableTask task) {\n+        assert cancellableTasks.containsKey(task.getId()) : \"task [\" + task.getId() + \"] is not registered yet\";\n+        final ChannelPendingTaskTracker tracker = channelPendingTaskTrackers.computeIfAbsent(channel, k -> new ChannelPendingTaskTracker());\n+        tracker.addTask(task);\n+        if (tracker.registered.compareAndSet(false, true)) {\n+            channel.addCloseListener(ActionListener.wrap(\n+                r -> {\n+                    final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n+                    assert removedTracker == tracker;\n+                    final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n+                    for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n+                        listener.accept(pendingTasks);\n+                    }\n+                },\n+                e -> {\n+                    assert false : new AssertionError(\"must not be here\", e);\n+                }));\n+        }\n+        return () -> tracker.removeTask(task);\n+    }\n+\n+    /**\n+     * Register a callback which will be called when a transport channel is closed and there're some pending orphaned\n+     * tasks associate with that transport channel.\n+     */\n+    public void registerOrphanedTasksOnChannelCloseListener(Consumer<Set<CancellableTask>> listener) {\n+        onChannelCloseListeners.add(listener);", "originalCommit": "3b4e3bef9e1d36b9188b5b5451c8b643e648ba23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDMwNg==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424140306", "bodyText": "We need a single listener - I switched to SetOnce in 1d2de32. I exposed this method so we can cancel child tasks.", "author": "dnhatn", "createdAt": "2020-05-13T02:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1Njc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1d2de32dde9b1ab7b73c483670a45b9666878cb7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 50c9f8481bc..ad5bbcb9f63 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -617,9 +617,11 @@ public class TaskManager implements ClusterStateApplier {\n                 r -> {\n                     final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n                     assert removedTracker == tracker;\n-                    final Set<CancellableTask> pendingTasks = Collections.unmodifiableSet(tracker.pendingTasks);\n-                    for (Consumer<Set<CancellableTask>> listener : onChannelCloseListeners) {\n-                        listener.accept(pendingTasks);\n+                    final Consumer<Set<CancellableTask>> listener = onChannelCloseListener.get();\n+                    if (listener != null) {\n+                        listener.accept(Collections.unmodifiableSet(tracker.pendingTasks));\n+                    } else {\n+                        assert false : \"onChannelCloseListener was not set\";\n                     }\n                 },\n                 e -> {\n"}}, {"oid": "1d2de32dde9b1ab7b73c483670a45b9666878cb7", "url": "https://github.com/elastic/elasticsearch/commit/1d2de32dde9b1ab7b73c483670a45b9666878cb7", "message": "single listener", "committedDate": "2020-05-13T00:16:21Z", "type": "commit"}, {"oid": "bdfa4f24a4fd99a819ada8db4580e84bbdd12a22", "url": "https://github.com/elastic/elasticsearch/commit/bdfa4f24a4fd99a819ada8db4580e84bbdd12a22", "message": "track and close concurrently", "committedDate": "2020-05-13T02:17:41Z", "type": "commit"}, {"oid": "8ae70421eaffc6fc67f4fcaf74030099c9c01668", "url": "https://github.com/elastic/elasticsearch/commit/8ae70421eaffc6fc67f4fcaf74030099c9c01668", "message": "simulate other condition", "committedDate": "2020-05-13T02:34:04Z", "type": "commit"}, {"oid": "ebcd4fabf1696a086bf9ac63ce6b19574598a962", "url": "https://github.com/elastic/elasticsearch/commit/ebcd4fabf1696a086bf9ac63ce6b19574598a962", "message": "Merge branch 'master' into cancel-on-disconnect", "committedDate": "2020-05-13T02:47:42Z", "type": "commit"}, {"oid": "37a77d618ec2ca3e2661dd21363a6eadeec9c958", "url": "https://github.com/elastic/elasticsearch/commit/37a77d618ec2ca3e2661dd21363a6eadeec9c958", "message": "stylecheck", "committedDate": "2020-05-13T03:30:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzOTgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424239834", "bodyText": "I think we should move this code (cancelTaskAndDescendants) in the TaskManager and expose a simple TaskManager#cancel method that this action can call. That would remove the need to have public methods in  the TaskManager around bans and orphaned tasks. They should be private and solely used by the TaskManager to cancel a task internally ?", "author": "jimczi", "createdAt": "2020-05-13T07:50:11Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -276,4 +279,23 @@ public void messageReceived(final BanParentTaskRequest request, final TransportC\n         }\n     }\n \n+    void cancelOrphanedTasks(Set<CancellableTask> orphanedTasks) {", "originalCommit": "37a77d618ec2ca3e2661dd21363a6eadeec9c958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTMyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424535325", "bodyText": "Thanks for pushing this \ud83d\udc4d . I've moved the cancellation to TaskManager in bd29504.", "author": "dnhatn", "createdAt": "2020-05-13T15:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzOTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "bd2950455daec1e115a0cbbdafb986c51bc77585", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 88cfd61e40d..273d245ec57 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -111,191 +86,8 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n     @Override\n     protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        cancelTaskAndDescendants(cancellableTask, request.getReason(), request.waitForCompletion(),\n+        taskManager.cancelTaskAndDescendants(cancellableTask, request.getReason(), request.waitForCompletion(),\n             ActionListener.map(listener, r -> cancellableTask.taskInfo(nodeId, false)));\n     }\n-\n-    void cancelTaskAndDescendants(CancellableTask task, String reason, boolean waitForCompletion, ActionListener<Void> listener) {\n-        final TaskId taskId = task.taskInfo(clusterService.localNode().getId(), false).getTaskId();\n-        if (task.shouldCancelChildrenOnCancellation()) {\n-            logger.trace(\"cancelling task [{}] and its descendants\", taskId);\n-            StepListener<Void> completedListener = new StepListener<>();\n-            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n-            Collection<DiscoveryNode> childrenNodes = taskManager.startBanOnChildrenNodes(task.getId(), () -> {\n-                logger.trace(\"child tasks of parent [{}] are completed\", taskId);\n-                groupedListener.onResponse(null);\n-            });\n-            taskManager.cancel(task, reason, () -> {\n-                logger.trace(\"task [{}] is cancelled\", taskId);\n-                groupedListener.onResponse(null);\n-            });\n-            StepListener<Void> banOnNodesListener = new StepListener<>();\n-            setBanOnNodes(reason, waitForCompletion, task, childrenNodes, banOnNodesListener);\n-            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n-            // If we start unbanning when the last child task completed and that child task executed with a specific user, then unban\n-            // requests are denied because internal requests can't run with a user. We need to remove bans with the current thread context.\n-            final Runnable removeBansRunnable = transportService.getThreadPool().getThreadContext()\n-                .preserveContext(() -> removeBanOnNodes(task, childrenNodes));\n-            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basis.\n-            completedListener.whenComplete(r -> removeBansRunnable.run(), e -> removeBansRunnable.run());\n-            // if wait_for_completion is true, then only return when (1) bans are placed on child nodes, (2) child tasks are\n-            // completed or failed, (3) the main task is cancelled. Otherwise, return after bans are placed on child nodes.\n-            if (waitForCompletion) {\n-                completedListener.whenComplete(r -> listener.onResponse(null), listener::onFailure);\n-            } else {\n-                banOnNodesListener.whenComplete(r -> listener.onResponse(null), listener::onFailure);\n-            }\n-        } else {\n-            logger.trace(\"task [{}] doesn't have any children that should be cancelled\", taskId);\n-            if (waitForCompletion) {\n-                taskManager.cancel(task, reason, () -> listener.onResponse(null));\n-            } else {\n-                taskManager.cancel(task, reason, () -> {});\n-                listener.onResponse(null);\n-            }\n-        }\n-    }\n-\n-    private void setBanOnNodes(String reason, boolean waitForCompletion, CancellableTask task,\n-                               Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n-        if (childNodes.isEmpty()) {\n-            listener.onResponse(null);\n-            return;\n-        }\n-        final TaskId taskId = new TaskId(clusterService.localNode().getId(), task.getId());\n-        logger.trace(\"cancelling child tasks of [{}] on child nodes {}\", taskId, childNodes);\n-        GroupedActionListener<Void> groupedListener =\n-            new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n-        final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(taskId, reason, waitForCompletion);\n-        for (DiscoveryNode node : childNodes) {\n-            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, banRequest,\n-                new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n-                    @Override\n-                    public void handleResponse(TransportResponse.Empty response) {\n-                        logger.trace(\"sent ban for tasks with the parent [{}] to the node [{}]\", taskId, node);\n-                        groupedListener.onResponse(null);\n-                    }\n-\n-                    @Override\n-                    public void handleException(TransportException exp) {\n-                        assert ExceptionsHelper.unwrapCause(exp) instanceof ElasticsearchSecurityException == false;\n-                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", taskId, node);\n-                        groupedListener.onFailure(exp);\n-                    }\n-                });\n-        }\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, Collection<DiscoveryNode> childNodes) {\n-        final BanParentTaskRequest request =\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()));\n-        for (DiscoveryNode node : childNodes) {\n-            logger.trace(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node);\n-            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, request, new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n-                @Override\n-                public void handleException(TransportException exp) {\n-                    assert ExceptionsHelper.unwrapCause(exp) instanceof ElasticsearchSecurityException == false;\n-                    logger.info(\"failed to remove the parent ban for task {} on node {}\", request.parentTaskId, node);\n-                }\n-            });\n-        }\n-    }\n-\n-    private static class BanParentTaskRequest extends TransportRequest {\n-\n-        private final TaskId parentTaskId;\n-        private final boolean ban;\n-        private final boolean waitForCompletion;\n-        private final String reason;\n-\n-        static BanParentTaskRequest createSetBanParentTaskRequest(TaskId parentTaskId, String reason, boolean waitForCompletion) {\n-            return new BanParentTaskRequest(parentTaskId, reason, waitForCompletion);\n-        }\n-\n-        static BanParentTaskRequest createRemoveBanParentTaskRequest(TaskId parentTaskId) {\n-            return new BanParentTaskRequest(parentTaskId);\n-        }\n-\n-        private BanParentTaskRequest(TaskId parentTaskId, String reason, boolean waitForCompletion) {\n-            this.parentTaskId = parentTaskId;\n-            this.ban = true;\n-            this.reason = reason;\n-            this.waitForCompletion = waitForCompletion;\n-        }\n-\n-        private BanParentTaskRequest(TaskId parentTaskId) {\n-            this.parentTaskId = parentTaskId;\n-            this.ban = false;\n-            this.reason = null;\n-            this.waitForCompletion = false;\n-        }\n-\n-        private BanParentTaskRequest(StreamInput in) throws IOException {\n-            super(in);\n-            parentTaskId = TaskId.readFromStream(in);\n-            ban = in.readBoolean();\n-            reason = ban ? in.readString() : null;\n-            if (in.getVersion().onOrAfter(Version.V_7_8_0)) {\n-                waitForCompletion = in.readBoolean();\n-            } else {\n-                waitForCompletion = false;\n-            }\n-        }\n-\n-        @Override\n-        public void writeTo(StreamOutput out) throws IOException {\n-            super.writeTo(out);\n-            parentTaskId.writeTo(out);\n-            out.writeBoolean(ban);\n-            if (ban) {\n-                out.writeString(reason);\n-            }\n-            if (out.getVersion().onOrAfter(Version.V_7_8_0)) {\n-                out.writeBoolean(waitForCompletion);\n-            }\n-        }\n-    }\n-\n-    class BanParentRequestHandler implements TransportRequestHandler<BanParentTaskRequest> {\n-        @Override\n-        public void messageReceived(final BanParentTaskRequest request, final TransportChannel channel, Task task) throws Exception {\n-            if (request.ban) {\n-                logger.debug(\"Received ban for the parent [{}] on the node [{}], reason: [{}]\", request.parentTaskId,\n-                    clusterService.localNode().getId(), request.reason);\n-                final List<CancellableTask> childTasks = taskManager.setBan(request.parentTaskId, request.reason);\n-                final GroupedActionListener<Void> listener = new GroupedActionListener<>(ActionListener.map(\n-                    new ChannelActionListener<>(channel, BAN_PARENT_ACTION_NAME, request), r -> TransportResponse.Empty.INSTANCE),\n-                    childTasks.size() + 1);\n-                for (CancellableTask childTask : childTasks) {\n-                    cancelTaskAndDescendants(childTask, request.reason, request.waitForCompletion, listener);\n-                }\n-                listener.onResponse(null);\n-            } else {\n-                logger.debug(\"Removing ban for the parent [{}] on the node [{}]\", request.parentTaskId,\n-                    clusterService.localNode().getId());\n-                taskManager.removeBan(request.parentTaskId);\n-                channel.sendResponse(TransportResponse.Empty.INSTANCE);\n-            }\n-        }\n-    }\n-\n-    void cancelOrphanedTasks(Set<CancellableTask> orphanedTasks) {\n-        if (orphanedTasks.isEmpty() == false) {\n-            transportService.getThreadPool().generic().execute(new AbstractRunnable() {\n-                @Override\n-                public void onFailure(Exception e) {\n-                    logger.warn(\"failed to cancel tasks on channel closed\", e);\n-                }\n-\n-                @Override\n-                protected void doRun() {\n-                    for (Task task : orphanedTasks) {\n-                        cancelTaskAndDescendants((CancellableTask) task, \"channel is closed\", false, ActionListener.wrap(() -> {}));\n-                    }\n-                }\n-            });\n-        }\n-    }\n-\n }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjczNw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424242737", "bodyText": "Looks like there is a race condition that leads to an AssertionError. See my comment below, I think the logic to cancel a task and its children/descendants should be entirely in the TaskManager.", "author": "jimczi", "createdAt": "2020-05-13T07:54:57Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -70,6 +72,7 @@ public TransportCancelTasksAction(ClusterService clusterService, TransportServic\n             CancelTasksRequest::new, CancelTasksResponse::new, TaskInfo::new, ThreadPool.Names.MANAGEMENT);\n         transportService.registerRequestHandler(BAN_PARENT_ACTION_NAME, ThreadPool.Names.SAME, BanParentTaskRequest::new,\n             new BanParentRequestHandler());\n+        taskManager.setOrphanedTasksOnChannelCloseListener(this::cancelOrphanedTasks);", "originalCommit": "37a77d618ec2ca3e2661dd21363a6eadeec9c958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUzNTQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424535489", "bodyText": "Should be fixed in bd29504", "author": "dnhatn", "createdAt": "2020-05-13T15:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MjczNw=="}], "type": "inlineReview", "revised_code": {"commit": "bd2950455daec1e115a0cbbdafb986c51bc77585", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 88cfd61e40d..273d245ec57 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -64,15 +44,10 @@ import java.util.function.Consumer;\n  */\n public class TransportCancelTasksAction extends TransportTasksAction<CancellableTask, CancelTasksRequest, CancelTasksResponse, TaskInfo> {\n \n-    public static final String BAN_PARENT_ACTION_NAME = \"internal:admin/tasks/ban\";\n-\n     @Inject\n     public TransportCancelTasksAction(ClusterService clusterService, TransportService transportService, ActionFilters actionFilters) {\n         super(CancelTasksAction.NAME, clusterService, transportService, actionFilters,\n             CancelTasksRequest::new, CancelTasksResponse::new, TaskInfo::new, ThreadPool.Names.MANAGEMENT);\n-        transportService.registerRequestHandler(BAN_PARENT_ACTION_NAME, ThreadPool.Names.SAME, BanParentTaskRequest::new,\n-            new BanParentRequestHandler());\n-        taskManager.setOrphanedTasksOnChannelCloseListener(this::cancelOrphanedTasks);\n     }\n \n     @Override\n"}}, {"oid": "bd2950455daec1e115a0cbbdafb986c51bc77585", "url": "https://github.com/elastic/elasticsearch/commit/bd2950455daec1e115a0cbbdafb986c51bc77585", "message": "Move cancellation descendants to cancellation service", "committedDate": "2020-05-13T15:30:51Z", "type": "commit"}, {"oid": "8e78fadb8de84a805b6499f1b8c06c71456cd042", "url": "https://github.com/elastic/elasticsearch/commit/8e78fadb8de84a805b6499f1b8c06c71456cd042", "message": "Merge branch 'master' into cancel-on-disconnect", "committedDate": "2020-05-13T15:34:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyNzQ3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424727475", "bodyText": "\ud83d\udcaf", "author": "jimczi", "createdAt": "2020-05-13T20:59:16Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -607,4 +608,98 @@ void unregisterChildNode(DiscoveryNode node) {\n         }\n     }\n \n+    /**\n+     * Start tracking a cancellable task with its tcp channel, so if the channel gets closed we can get a set of\n+     * pending tasks associated that channel and cancel them as these results won't be retrieved by the parent task.\n+     *\n+     * @return a releasable that should be called when this pending task is completed\n+     */\n+    public Releasable startTrackingCancellableChannelTask(TcpChannel channel, CancellableTask task) {\n+        assert cancellableTasks.containsKey(task.getId()) : \"task [\" + task.getId() + \"] is not registered yet\";\n+        final ChannelPendingTaskTracker tracker = channelPendingTaskTrackers.compute(channel, (k, curr) -> {\n+            if (curr == null) {\n+                curr = new ChannelPendingTaskTracker();\n+            }\n+            curr.addTask(task);\n+            return curr;\n+        });\n+        if (tracker.registered.compareAndSet(false, true)) {\n+            channel.addCloseListener(ActionListener.wrap(\n+                r -> {\n+                    final ChannelPendingTaskTracker removedTracker = channelPendingTaskTrackers.remove(channel);\n+                    assert removedTracker == tracker;\n+                    cancelTasksOnChannelClosed(tracker.drainTasks());\n+                },\n+                e -> {\n+                    assert false : new AssertionError(\"must not be here\", e);\n+                }));\n+        }\n+        return () -> tracker.removeTask(task);\n+    }\n+\n+    // for testing\n+    final int numberOfChannelPendingTaskTrackers() {\n+        return channelPendingTaskTrackers.size();\n+    }\n+\n+    private static class ChannelPendingTaskTracker {\n+        final AtomicBoolean registered = new AtomicBoolean();\n+        final Semaphore permits = Assertions.ENABLED ? new Semaphore(Integer.MAX_VALUE) : null;\n+        final Set<CancellableTask> pendingTasks = ConcurrentCollections.newConcurrentSet();\n+\n+        void addTask(CancellableTask task) {\n+            assert permits.tryAcquire() : \"tracker was drained\";\n+            final boolean added = pendingTasks.add(task);\n+            assert added : \"task \" + task.getId() + \" is in the pending list already\";\n+            assert releasePermit();\n+        }\n+\n+        boolean acquireAllPermits() {\n+            permits.acquireUninterruptibly(Integer.MAX_VALUE);\n+            return true;\n+        }\n+\n+        boolean releasePermit() {\n+            permits.release();\n+            return true;\n+        }\n+\n+        Set<CancellableTask> drainTasks() {\n+            assert acquireAllPermits(); // do not release permits so we can't add tasks to this tracker after draining\n+            return Collections.unmodifiableSet(pendingTasks);\n+        }\n+\n+        void removeTask(CancellableTask task) {\n+            final boolean removed = pendingTasks.remove(task);\n+            assert removed : \"task \" + task.getId() + \" is not in the pending list\";\n+        }\n+    }\n+\n+    private void cancelTasksOnChannelClosed(Set<CancellableTask> tasks) {\n+        if (tasks.isEmpty() == false) {\n+            threadPool.generic().execute(new AbstractRunnable() {\n+                @Override\n+                public void onFailure(Exception e) {\n+                    logger.warn(\"failed to cancel tasks on channel closed\", e);\n+                }\n+\n+                @Override\n+                protected void doRun() {\n+                    for (CancellableTask task : tasks) {\n+                        cancelTaskAndDescendants(task, \"channel was closed\", false, ActionListener.wrap(() -> {}));\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    public void cancelTaskAndDescendants(CancellableTask task, String reason, boolean waitForCompletion, ActionListener<Void> listener) {", "originalCommit": "8e78fadb8de84a805b6499f1b8c06c71456cd042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424729531", "bodyText": "why isn't it instantiated when we create the TaskManager (TransportService#createTaskManager) ?", "author": "jimczi", "createdAt": "2020-05-13T21:03:17Z", "path": "server/src/main/java/org/elasticsearch/node/Node.java", "diffHunk": "@@ -717,6 +718,7 @@ public Node start() throws NodeValidationException {\n         // Start the transport service now so the publish address will be added to the local disco node in ClusterService\n         TransportService transportService = injector.getInstance(TransportService.class);\n         transportService.getTaskManager().setTaskResultsService(injector.getInstance(TaskResultsService.class));\n+        transportService.getTaskManager().setTaskCancellationService(new TaskCancellationService(transportService));", "originalCommit": "8e78fadb8de84a805b6499f1b8c06c71456cd042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzU1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56620#discussion_r424753553", "bodyText": "I tried to avoid exposing TransportService when it's not fully initialized yet. Also, there are several circular dependencies between TransportService, RequestHandlerRegistry, TaskCancellationService, and TaskManager. I will look into how to pass TaskCancellationService to the constructor of TaskManager.", "author": "dnhatn", "createdAt": "2020-05-13T21:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTUzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "956859c5033377cd44393907832c688fed98228c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/node/Node.java b/server/src/main/java/org/elasticsearch/node/Node.java\nindex dd33a2bb6b7..05c6daaa192 100644\n--- a/server/src/main/java/org/elasticsearch/node/Node.java\n+++ b/server/src/main/java/org/elasticsearch/node/Node.java\n\n@@ -718,7 +717,6 @@ public class Node implements Closeable {\n         // Start the transport service now so the publish address will be added to the local disco node in ClusterService\n         TransportService transportService = injector.getInstance(TransportService.class);\n         transportService.getTaskManager().setTaskResultsService(injector.getInstance(TaskResultsService.class));\n-        transportService.getTaskManager().setTaskCancellationService(new TaskCancellationService(transportService));\n         transportService.start();\n         assert localNodeFactory.getNode() != null;\n         assert transportService.getLocalNode().equals(localNodeFactory.getNode())\n"}}, {"oid": "9329a105a9c77bb155218a1cd1d6a984b6e941b3", "url": "https://github.com/elastic/elasticsearch/commit/9329a105a9c77bb155218a1cd1d6a984b6e941b3", "message": "Merge branch 'master' into cancel-on-disconnect", "committedDate": "2020-05-13T21:08:56Z", "type": "commit"}, {"oid": "956859c5033377cd44393907832c688fed98228c", "url": "https://github.com/elastic/elasticsearch/commit/956859c5033377cd44393907832c688fed98228c", "message": "assign earlier", "committedDate": "2020-05-13T21:48:04Z", "type": "commit"}, {"oid": "fd94b9798e021dbbdba3b074631163469dbbe44c", "url": "https://github.com/elastic/elasticsearch/commit/fd94b9798e021dbbdba3b074631163469dbbe44c", "message": "Revert \"assign earlier\"\n\nThis reverts commit 956859c5033377cd44393907832c688fed98228c.", "committedDate": "2020-05-13T21:51:36Z", "type": "commit"}]}