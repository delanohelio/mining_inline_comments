{"pr_number": 59113, "pr_title": "Support prefix search for API key names", "pr_createdAt": "2020-07-07T04:16:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59113", "timeline": [{"oid": "8bcd51f7c26ca1366acdf1cf6162d6774ae3b3e7", "url": "https://github.com/elastic/elasticsearch/commit/8bcd51f7c26ca1366acdf1cf6162d6774ae3b3e7", "message": "Minimal support for prefix search with API key names", "committedDate": "2020-07-07T02:27:52Z", "type": "commit"}, {"oid": "f5f6b061515c249a83074e6650a41cd95c8fb20e", "url": "https://github.com/elastic/elasticsearch/commit/f5f6b061515c249a83074e6650a41cd95c8fb20e", "message": "Minor update to docs", "committedDate": "2020-07-07T04:04:29Z", "type": "commit"}, {"oid": "c3766814086130c1889cb843616d9918b68f9a85", "url": "https://github.com/elastic/elasticsearch/commit/c3766814086130c1889cb843616d9918b68f9a85", "message": "Checkstyle", "committedDate": "2020-07-07T09:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5MzQ3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59113#discussion_r451993472", "bodyText": "Can we have a non-match wildcard as well?\n        PlainActionFuture<GetApiKeyResponse> listener4 = new PlainActionFuture<>();\n        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"not-test-key*\", false), listener4);\n        assertThat(listener4.get().getApiKeyInfos(), arrayWithSize(0));\n\nIdeally a subset match (find 2 out of the 3 keys) would be nice, but the test infrastructure in this class doesn't make that easy.", "author": "tvernum", "createdAt": "2020-07-09T06:34:28Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -532,13 +532,21 @@ public void testGetApiKeysForApiKeyId() throws InterruptedException, ExecutionEx\n     }\n \n     public void testGetApiKeysForApiKeyName() throws InterruptedException, ExecutionException {\n-        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        List<CreateApiKeyResponse> responses = createApiKeys(3, null);\n         Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n                 .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n         PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n         client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(responses.get(0).getName(), false), listener);\n         GetApiKeyResponse response = listener.get();\n         verifyGetResponse(1, responses, response, Collections.singleton(responses.get(0).getId()), null);\n+\n+        PlainActionFuture<GetApiKeyResponse> listener2 = new PlainActionFuture<>();\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"test-key*\", false), listener2);\n+        verifyGetResponse(3, responses, listener2.get(), responses.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n+\n+        PlainActionFuture<GetApiKeyResponse> listener3 = new PlainActionFuture<>();\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"*\", false), listener2);\n+        verifyGetResponse(3, responses, listener2.get(), responses.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);", "originalCommit": "c3766814086130c1889cb843616d9918b68f9a85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMTExOQ==", "url": "https://github.com/elastic/elasticsearch/pull/59113#discussion_r452111119", "bodyText": "Thanks. Added tests for both \"non-matching wildcard\" and \"subset match\".", "author": "ywangd", "createdAt": "2020-07-09T10:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5MzQ3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "254afe173e4c38b1fe2f3057664cd78af6ce4c22", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\nindex 8b096a966573..8ca220457977 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n\n@@ -532,21 +532,42 @@ public class ApiKeyIntegTests extends SecurityIntegTestCase {\n     }\n \n     public void testGetApiKeysForApiKeyName() throws InterruptedException, ExecutionException {\n-        List<CreateApiKeyResponse> responses = createApiKeys(3, null);\n-        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n-                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        final Map<String, String> headers = Collections.singletonMap(\n+            \"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(\n+                SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING));\n+\n+        final int noOfApiKeys = randomIntBetween(1, 3);\n+        final List<CreateApiKeyResponse> createApiKeyResponses1 = createApiKeys(noOfApiKeys, null);\n+        final List<CreateApiKeyResponse> createApiKeyResponses2 = createApiKeys(\n+            headers, noOfApiKeys, \"another-test-key-\", null, \"monitor\");\n+\n+        Client client = client().filterWithHeader(headers);\n         PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        List<CreateApiKeyResponse> responses = randomFrom(createApiKeyResponses1, createApiKeyResponses2);\n         client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(responses.get(0).getName(), false), listener);\n-        GetApiKeyResponse response = listener.get();\n-        verifyGetResponse(1, responses, response, Collections.singleton(responses.get(0).getId()), null);\n+        verifyGetResponse(1, responses, listener.get(), Collections.singleton(responses.get(0).getId()), null);\n \n         PlainActionFuture<GetApiKeyResponse> listener2 = new PlainActionFuture<>();\n         client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"test-key*\", false), listener2);\n-        verifyGetResponse(3, responses, listener2.get(), responses.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n+        verifyGetResponse(noOfApiKeys, createApiKeyResponses1, listener2.get(),\n+            createApiKeyResponses1.stream().map(CreateApiKeyResponse::getId).collect(Collectors.toSet()), null);\n \n         PlainActionFuture<GetApiKeyResponse> listener3 = new PlainActionFuture<>();\n-        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"*\", false), listener2);\n-        verifyGetResponse(3, responses, listener2.get(), responses.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"*\", false), listener3);\n+        responses = Stream.concat(createApiKeyResponses1.stream(), createApiKeyResponses2.stream()).collect(Collectors.toList());\n+        verifyGetResponse(2 * noOfApiKeys, responses, listener3.get(),\n+            responses.stream().map(CreateApiKeyResponse::getId).collect(Collectors.toSet()), null);\n+\n+        PlainActionFuture<GetApiKeyResponse> listener4 = new PlainActionFuture<>();\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"does-not-exist*\", false), listener4);\n+        verifyGetResponse(0, Collections.emptyList(), listener4.get(), Collections.emptySet(), null);\n+\n+        PlainActionFuture<GetApiKeyResponse> listener5 = new PlainActionFuture<>();\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.usingApiKeyName(\"another-test-key*\", false), listener5);\n+        verifyGetResponse(noOfApiKeys, createApiKeyResponses2, listener5.get(),\n+            createApiKeyResponses2.stream().map(CreateApiKeyResponse::getId).collect(Collectors.toSet()), null);\n     }\n \n     public void testGetApiKeysOwnedByCurrentAuthenticatedUser() throws InterruptedException, ExecutionException {\n"}}, {"oid": "254afe173e4c38b1fe2f3057664cd78af6ce4c22", "url": "https://github.com/elastic/elasticsearch/commit/254afe173e4c38b1fe2f3057664cd78af6ce4c22", "message": "Address feedback", "committedDate": "2020-07-09T10:09:21Z", "type": "commit"}, {"oid": "3a7cdad561d07c13fb7524ca78027e5ead8f3fce", "url": "https://github.com/elastic/elasticsearch/commit/3a7cdad561d07c13fb7524ca78027e5ead8f3fce", "message": "Merge remote-tracking branch 'origin/master' into es-57638-apikey-name-prefix-search", "committedDate": "2020-07-09T10:09:27Z", "type": "commit"}, {"oid": "7c6c510455c29a92acd27ef98905d75795c1557b", "url": "https://github.com/elastic/elasticsearch/commit/7c6c510455c29a92acd27ef98905d75795c1557b", "message": "Merge remote-tracking branch 'origin/master' into es-57638-apikey-name-prefix-search", "committedDate": "2020-07-14T09:49:44Z", "type": "commit"}]}