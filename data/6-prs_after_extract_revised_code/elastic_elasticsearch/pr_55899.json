{"pr_number": 55899, "pr_title": "Prevent stack overflow for numerous grok patterns.", "pr_createdAt": "2020-04-28T22:24:23Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55899", "timeline": [{"oid": "21432812729b550dcd4c0b358274c6a17fefed01", "url": "https://github.com/elastic/elasticsearch/commit/21432812729b550dcd4c0b358274c6a17fefed01", "message": "Prevent stack overflow for numerous grok patterns.\n\nThis was noticed for a pipeline that was defining hundreds of\ngrok patterns inline with a single grok processor.\n\nThe recursive call used to translate a Grok pattern to a regular\nexpression can overflow the stack. This commit adds a synchronous\nthread to process the recursive call after 500 iterations. Since\nthe thread blocked by a synchronous get on the future, at most\nonly 1 thread is ever spawned per 500 iterations and only 1\nadditional thread is running at any given time. Note - this section\nof code is executed when the pipeline is created, not at runtime\nfor the processor so this will be rarely executed.", "committedDate": "2020-04-28T22:15:06Z", "type": "commit"}, {"oid": "b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389", "url": "https://github.com/elastic/elasticsearch/commit/b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389", "message": "fix test", "committedDate": "2020-04-28T23:11:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTgwNw==", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417161807", "bodyText": "I think we should remove recursion here altogether, that way we can avoid stack overflows without using additional threads and context switching. As this is tail recursion it is fairly easy and straightforward:\npublic String toRegex(String grokPattern) {\n    StringBuilder res= new StringBuilder();\n    while (true) {\n        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n\n        int result;\n        try {\n            matcherWatchdog.register(matcher);\n            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n        } finally {\n            matcherWatchdog.unregister(matcher);\n        }\n\n        if (result < 0) {\n            return res.append(grokPattern).toString();\n        }\n\n        Region region = matcher.getEagerRegion();\n        String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n        String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);// TODO(tal): Support definitions\n        @SuppressWarnings(\"unused\")\n        String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n        String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n        String pattern = patternBank.get(patternName);\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"Unable to find pattern [\" + patternName + \"] in Grok's pattern dictionary\");\n        }\n        if (pattern.contains(\"%{\" + patternName + \"}\") || pattern.contains(\"%{\" + patternName + \":\")) {\n            throw new IllegalArgumentException(\"circular reference in pattern back [\" + patternName + \"]\");\n        }\n        String grokPart;\n        if (namedCaptures && subName != null) {\n            grokPart = String.format(Locale.US, \"(?<%s>%s)\", namedPatternRef, pattern);\n        } else if (namedCaptures) {\n            grokPart = String.format(Locale.US, \"(?:%s)\", pattern);\n        } else {\n            grokPart = String.format(Locale.US, \"(?<%s>%s)\", patternName + \"_\" + result, pattern);\n        }\n        String start = new String(grokPatternBytes, 0, result, StandardCharsets.UTF_8);\n        String rest = new String(grokPatternBytes, region.end[0], grokPatternBytes.length - region.end[0], StandardCharsets.UTF_8);\n        grokPattern = grokPart+rest;\n        res.append(start);\n    }\n}", "author": "probakowski", "createdAt": "2020-04-29T08:51:11Z", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -162,49 +164,63 @@ public String groupMatch(String name, Region region, String pattern) {\n      *\n      * @return named regex expression\n      */\n-    public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n-\n-        int result;\n-        try {\n-            matcherWatchdog.register(matcher);\n-            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-        } finally {\n-            matcherWatchdog.unregister(matcher);\n-        }\n-        if (result >= 0) {\n-            Region region = matcher.getEagerRegion();\n-            String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-            // TODO(tal): Support definitions\n-            @SuppressWarnings(\"unused\")\n-            String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n-            String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n+    public String toRegex(String grokPattern, int recurseCount) {", "originalCommit": "b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyMDY2MA==", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417320660", "bodyText": "thanks @probakowski I will switch the implementation based on this.", "author": "jakelandis", "createdAt": "2020-04-29T13:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2591837475fba5eb40f17a2e6d8bd112bdb41596", "chunk": "diff --git a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\nindex 65798a7c034..5d5dc5d56f5 100644\n--- a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n+++ b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n\n@@ -164,63 +162,49 @@ public final class Grok {\n      *\n      * @return named regex expression\n      */\n-    public String toRegex(String grokPattern, int recurseCount) {\n-        Callable<String> recurse = () -> {\n-            byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-            Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n-\n-            int result;\n-            try {\n-                matcherWatchdog.register(matcher);\n-                result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-            } finally {\n-                matcherWatchdog.unregister(matcher);\n-            }\n-            if (result >= 0) {\n-                Region region = matcher.getEagerRegion();\n-                String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-                String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-                // TODO(tal): Support definitions\n-                @SuppressWarnings(\"unused\")\n-                String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n-                String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n-\n-                String pattern = patternBank.get(patternName);\n-                if (pattern == null) {\n-                    throw new IllegalArgumentException(\"Unable to find pattern [\" + patternName + \"] in Grok's pattern dictionary\");\n-                }\n-                if (pattern.contains(\"%{\" + patternName + \"}\") || pattern.contains(\"%{\" + patternName + \":\")) {\n-                    throw new IllegalArgumentException(\"circular reference in pattern back [\" + patternName + \"]\");\n-                }\n+    public String toRegex(String grokPattern) {\n+        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n+        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n \n-                String grokPart;\n-                if (namedCaptures && subName != null) {\n-                    grokPart = String.format(Locale.US, \"(?<%s>%s)\", namedPatternRef, pattern);\n-                } else if (!namedCaptures) {\n-                    grokPart = String.format(Locale.US, \"(?<%s>%s)\", patternName + \"_\" + String.valueOf(result), pattern);\n-                } else {\n-                    grokPart = String.format(Locale.US, \"(?:%s)\", pattern);\n-                }\n+        int result;\n+        try {\n+            matcherWatchdog.register(matcher);\n+            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n+        } finally {\n+            matcherWatchdog.unregister(matcher);\n+        }\n+        if (result >= 0) {\n+            Region region = matcher.getEagerRegion();\n+            String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n+            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n+            // TODO(tal): Support definitions\n+            @SuppressWarnings(\"unused\")\n+            String definition = groupMatch(DEFINITION_GROUP, region, grokPattern);\n+            String patternName = groupMatch(PATTERN_GROUP, region, grokPattern);\n \n-                String start = new String(grokPatternBytes, 0, result, StandardCharsets.UTF_8);\n-                String rest = new String(grokPatternBytes, region.end[0], grokPatternBytes.length - region.end[0], StandardCharsets.UTF_8);\n-                return start + toRegex(grokPart + rest, recurseCount + 1);\n+            String pattern = patternBank.get(patternName);\n+            if (pattern == null) {\n+                throw new IllegalArgumentException(\"Unable to find pattern [\" + patternName + \"] in Grok's pattern dictionary\");\n             }\n-            return grokPattern;\n-        };\n-        try {\n-            //fork to another thread to prevent stack overflow. 500 is a guesstimate based on observation\n-            if (recurseCount % 500 == 0) {\n-                FutureTask<String> future = new FutureTask<>(recurse);\n-                new Thread(null, future, \"elasticsearch[grok][toRegex]\").start();\n-                return future.get();\n+            if (pattern.contains(\"%{\" + patternName + \"}\") || pattern.contains(\"%{\" + patternName + \":\")) {\n+                throw new IllegalArgumentException(\"circular reference in pattern back [\" + patternName + \"]\");\n+            }\n+\n+            String grokPart;\n+            if (namedCaptures && subName != null) {\n+                grokPart = String.format(Locale.US, \"(?<%s>%s)\", namedPatternRef, pattern);\n+            } else if (!namedCaptures) {\n+                grokPart = String.format(Locale.US, \"(?<%s>%s)\", patternName + \"_\" + String.valueOf(result), pattern);\n             } else {\n-                return recurse.call();\n+                grokPart = String.format(Locale.US, \"(?:%s)\", pattern);\n             }\n-        } catch (Exception e) {\n-            //yuk, but Callable.call() throws Exception\n-            throw new RuntimeException(e);\n+\n+            String start = new String(grokPatternBytes, 0, result, StandardCharsets.UTF_8);\n+            String rest = new String(grokPatternBytes, region.end[0], grokPatternBytes.length - region.end[0], StandardCharsets.UTF_8);\n+            return start + toRegex(grokPart + rest);\n         }\n+\n+        return grokPattern;\n     }\n \n     /**\n"}}, {"oid": "144b8f5da62b05493695b8a3f3d504621f3dfc0e", "url": "https://github.com/elastic/elasticsearch/commit/144b8f5da62b05493695b8a3f3d504621f3dfc0e", "message": "Revert \"fix test\"\n\nThis reverts commit b9ebfd4cfc02eed53e6bbd09a22a20dae56e9389.", "committedDate": "2020-04-29T17:51:09Z", "type": "commit"}, {"oid": "2591837475fba5eb40f17a2e6d8bd112bdb41596", "url": "https://github.com/elastic/elasticsearch/commit/2591837475fba5eb40f17a2e6d8bd112bdb41596", "message": "Revert \"Prevent stack overflow for numerous grok patterns.\"\n\nThis reverts commit 21432812729b550dcd4c0b358274c6a17fefed01.", "committedDate": "2020-04-29T17:51:22Z", "type": "commit"}, {"oid": "78b6fa43f8dd0b3e2db1a4d7a74e4ca631669f87", "url": "https://github.com/elastic/elasticsearch/commit/78b6fa43f8dd0b3e2db1a4d7a74e4ca631669f87", "message": "use iterative approach", "committedDate": "2020-04-29T19:24:39Z", "type": "commit"}, {"oid": "13266fdc89322f8307dd77c5453d1cea8044fa0d", "url": "https://github.com/elastic/elasticsearch/commit/13266fdc89322f8307dd77c5453d1cea8044fa0d", "message": "up the sanity limit", "committedDate": "2020-04-29T19:37:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3Mzk4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417573989", "bodyText": "consider changing this to for loop instead of while and moving exception to the end of the method\nfor (int i = 0; i < MAX_TO_REGEX_ITERATIONS; i++) {\n    ...\n}\nthrow new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");", "author": "probakowski", "createdAt": "2020-04-29T19:57:00Z", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -163,48 +164,53 @@ public String groupMatch(String name, Region region, String pattern) {\n      * @return named regex expression\n      */\n     public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+        StringBuilder res = new StringBuilder();\n+        int i = 0;\n+        while (true) {", "originalCommit": "13266fdc89322f8307dd77c5453d1cea8044fa0d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "476d7d803fa9a480530c5c9c380750c4f83a421d", "chunk": "diff --git a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\nindex 3f59c2aca1f..2792b40df5c 100644\n--- a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n+++ b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n\n@@ -165,11 +165,7 @@ public final class Grok {\n      */\n     public String toRegex(String grokPattern) {\n         StringBuilder res = new StringBuilder();\n-        int i = 0;\n-        while (true) {\n-            if (i++ >= MAX_TO_REGEX_ITERATIONS) {\n-                throw new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");\n-            }\n+        for (int i = 0; i < MAX_TO_REGEX_ITERATIONS; i++) {\n             byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n             Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3NDMzOA==", "url": "https://github.com/elastic/elasticsearch/pull/55899#discussion_r417574338", "bodyText": "This TODO should be moved to new line like it was before (sorry, this was unintentional change in my comment)", "author": "probakowski", "createdAt": "2020-04-29T19:57:37Z", "path": "libs/grok/src/main/java/org/elasticsearch/grok/Grok.java", "diffHunk": "@@ -163,48 +164,53 @@ public String groupMatch(String name, Region region, String pattern) {\n      * @return named regex expression\n      */\n     public String toRegex(String grokPattern) {\n-        byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n-        Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+        StringBuilder res = new StringBuilder();\n+        int i = 0;\n+        while (true) {\n+            if (i++ >= MAX_TO_REGEX_ITERATIONS) {\n+                throw new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");\n+            }\n+            byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n+            Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n+\n+            int result;\n+            try {\n+                matcherWatchdog.register(matcher);\n+                result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n+            } finally {\n+                matcherWatchdog.unregister(matcher);\n+            }\n+\n+            if (result < 0) {\n+                return res.append(grokPattern).toString();\n+            }\n \n-        int result;\n-        try {\n-            matcherWatchdog.register(matcher);\n-            result = matcher.search(0, grokPatternBytes.length, Option.NONE);\n-        } finally {\n-            matcherWatchdog.unregister(matcher);\n-        }\n-        if (result >= 0) {\n             Region region = matcher.getEagerRegion();\n             String namedPatternRef = groupMatch(NAME_GROUP, region, grokPattern);\n-            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);\n-            // TODO(tal): Support definitions\n+            String subName = groupMatch(SUBNAME_GROUP, region, grokPattern);// TODO(tal): Support definitions", "originalCommit": "13266fdc89322f8307dd77c5453d1cea8044fa0d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "476d7d803fa9a480530c5c9c380750c4f83a421d", "chunk": "diff --git a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\nindex 3f59c2aca1f..2792b40df5c 100644\n--- a/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n+++ b/libs/grok/src/main/java/org/elasticsearch/grok/Grok.java\n\n@@ -165,11 +165,7 @@ public final class Grok {\n      */\n     public String toRegex(String grokPattern) {\n         StringBuilder res = new StringBuilder();\n-        int i = 0;\n-        while (true) {\n-            if (i++ >= MAX_TO_REGEX_ITERATIONS) {\n-                throw new IllegalArgumentException(\"Can not convert grok patterns to regular expression\");\n-            }\n+        for (int i = 0; i < MAX_TO_REGEX_ITERATIONS; i++) {\n             byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n             Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n \n"}}, {"oid": "476d7d803fa9a480530c5c9c380750c4f83a421d", "url": "https://github.com/elastic/elasticsearch/commit/476d7d803fa9a480530c5c9c380750c4f83a421d", "message": "minor cleanup", "committedDate": "2020-04-29T22:27:30Z", "type": "commit"}, {"oid": "739dd05f637b95ebbfbb6100bb406c9ab848d565", "url": "https://github.com/elastic/elasticsearch/commit/739dd05f637b95ebbfbb6100bb406c9ab848d565", "message": "Merge branch 'master' into grok_so", "committedDate": "2020-04-30T22:21:49Z", "type": "commit"}]}