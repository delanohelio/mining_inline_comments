{"pr_number": 58381, "pr_title": "Mirror privileges over data streams to their backing indices", "pr_createdAt": "2020-06-19T14:26:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58381", "timeline": [{"oid": "d30476cf8a3f0d5e3fa3c4c26aaf1ddc112b7c60", "url": "https://github.com/elastic/elasticsearch/commit/d30476cf8a3f0d5e3fa3c4c26aaf1ddc112b7c60", "message": "Change IndicesPermission::authorize to check parent data stream if requested index is a backing index", "committedDate": "2020-06-18T13:44:04Z", "type": "commit"}, {"oid": "bc0e9b11185e83b4dd99d01ffb581d9bf1b054ef", "url": "https://github.com/elastic/elasticsearch/commit/bc0e9b11185e83b4dd99d01ffb581d9bf1b054ef", "message": "add REST test", "committedDate": "2020-06-18T21:10:52Z", "type": "commit"}, {"oid": "1f03278b02565d823bee652d06db9d2b2d8ca9f5", "url": "https://github.com/elastic/elasticsearch/commit/1f03278b02565d823bee652d06db9d2b2d8ca9f5", "message": "add comment to test", "committedDate": "2020-06-19T14:29:11Z", "type": "commit"}, {"oid": "3c6bac89aa2e8829acd96054c5ca21ab0eededf3", "url": "https://github.com/elastic/elasticsearch/commit/3c6bac89aa2e8829acd96054c5ca21ab0eededf3", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-06-19T14:49:04Z", "type": "commit"}, {"oid": "bd716a5a53c661f1a893b2c2c7c0ff677b082a14", "url": "https://github.com/elastic/elasticsearch/commit/bd716a5a53c661f1a893b2c2c7c0ff677b082a14", "message": "Merge branch 'grant_privs_to_backing_indices' of https://github.com/danhermann/elasticsearch into grant_privs_to_backing_indices", "committedDate": "2020-06-19T14:51:59Z", "type": "commit"}, {"oid": "6073197d756a55dcc7094cfdcc35dee43997cfec", "url": "https://github.com/elastic/elasticsearch/commit/6073197d756a55dcc7094cfdcc35dee43997cfec", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-06-23T13:41:02Z", "type": "commit"}, {"oid": "948209e2a75db030a3fe5d6275dd6c94754ca9f4", "url": "https://github.com/elastic/elasticsearch/commit/948209e2a75db030a3fe5d6275dd6c94754ca9f4", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-06-26T21:02:34Z", "type": "commit"}, {"oid": "e0965e45666c9dda29a6011d42fc8693b37bb9f7", "url": "https://github.com/elastic/elasticsearch/commit/e0965e45666c9dda29a6011d42fc8693b37bb9f7", "message": "recommended security integration implementation", "committedDate": "2020-06-27T20:13:56Z", "type": "commit"}, {"oid": "80d7caf7114ce6bfa8a30fef59eff276d47078f4", "url": "https://github.com/elastic/elasticsearch/commit/80d7caf7114ce6bfa8a30fef59eff276d47078f4", "message": "add tests for isIndexVisible", "committedDate": "2020-06-28T18:56:45Z", "type": "commit"}, {"oid": "6caaa1ec2afd849a1be80f77045b8b3173393a28", "url": "https://github.com/elastic/elasticsearch/commit/6caaa1ec2afd849a1be80f77045b8b3173393a28", "message": "add test for resolveAuthorizedIndicesFromRole", "committedDate": "2020-06-28T19:33:40Z", "type": "commit"}, {"oid": "f8305c01b34ba0b8a6ca878c0ce589e83f224b18", "url": "https://github.com/elastic/elasticsearch/commit/f8305c01b34ba0b8a6ca878c0ce589e83f224b18", "message": "add test for IndicesPermission::authorize", "committedDate": "2020-06-28T20:05:31Z", "type": "commit"}, {"oid": "233c0431e7125497e72f974554c4d6b1fecc0788", "url": "https://github.com/elastic/elasticsearch/commit/233c0431e7125497e72f974554c4d6b1fecc0788", "message": "checkstyle!", "committedDate": "2020-06-28T20:31:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MDIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/58381#discussion_r447150200", "bodyText": "Suggestion: I would work on the naming and/or javadoc for this to make it clear that such requests over wildcards are meant to (not) expand to data stream names too.", "author": "albertzaharovits", "createdAt": "2020-06-29T17:54:54Z", "path": "server/src/main/java/org/elasticsearch/action/IndicesRequest.java", "diffHunk": "@@ -40,6 +40,13 @@\n      */\n     IndicesOptions indicesOptions();\n \n+    /**\n+     * Determines whether the action should be applied to data streams\n+     */", "originalCommit": "233c0431e7125497e72f974554c4d6b1fecc0788", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd8794fc6434f8d8c6556583ea0942b60b73551d", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/IndicesRequest.java b/server/src/main/java/org/elasticsearch/action/IndicesRequest.java\nindex 6fc46815564..bd6421ad0fc 100644\n--- a/server/src/main/java/org/elasticsearch/action/IndicesRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/IndicesRequest.java\n\n@@ -41,7 +41,9 @@ public interface IndicesRequest {\n     IndicesOptions indicesOptions();\n \n     /**\n-     * Determines whether the action should be applied to data streams\n+     * Determines whether the request should be applied to data streams. When {@code false}, none of the names or\n+     * wildcard expressions in {@link #indices} should be applied to or expanded to any data streams. All layers\n+     * involved in the request's fulfillment including security, name resolution, etc., should respect this flag.\n      */\n     default boolean includeDataStreams() {\n         return false;\n"}}, {"oid": "dd8794fc6434f8d8c6556583ea0942b60b73551d", "url": "https://github.com/elastic/elasticsearch/commit/dd8794fc6434f8d8c6556583ea0942b60b73551d", "message": "improve javadoc", "committedDate": "2020-06-29T23:46:54Z", "type": "commit"}, {"oid": "79c5e0936687905f5965dc4fc40c6b7e1d08a2c5", "url": "https://github.com/elastic/elasticsearch/commit/79c5e0936687905f5965dc4fc40c6b7e1d08a2c5", "message": "add test case for requests not supporting data streams", "committedDate": "2020-06-30T02:42:47Z", "type": "commit"}, {"oid": "b26c8747166524215540695d6e1e67b09f610ab6", "url": "https://github.com/elastic/elasticsearch/commit/b26c8747166524215540695d6e1e67b09f610ab6", "message": "add includeDataStreams flag to fix failing test", "committedDate": "2020-06-30T12:56:39Z", "type": "commit"}, {"oid": "2988f7a1625c747761728cd7c4ee64650c4a3406", "url": "https://github.com/elastic/elasticsearch/commit/2988f7a1625c747761728cd7c4ee64650c4a3406", "message": "unit test fix", "committedDate": "2020-06-30T13:53:06Z", "type": "commit"}, {"oid": "c3800315a164a6c86ba15720b0feb3f488392fe0", "url": "https://github.com/elastic/elasticsearch/commit/c3800315a164a6c86ba15720b0feb3f488392fe0", "message": "remove tests that are no longer valid", "committedDate": "2020-06-30T15:03:33Z", "type": "commit"}, {"oid": "64919133afc6b0c8adfd37f452f307822a77f266", "url": "https://github.com/elastic/elasticsearch/commit/64919133afc6b0c8adfd37f452f307822a77f266", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-06-30T15:03:59Z", "type": "commit"}, {"oid": "fa0d1d66c2c0f975358a8748ba447d37a03dc52b", "url": "https://github.com/elastic/elasticsearch/commit/fa0d1d66c2c0f975358a8748ba447d37a03dc52b", "message": "fix failing test", "committedDate": "2020-06-30T17:10:55Z", "type": "commit"}, {"oid": "12466c5f99e2a117ff36670452d23f6d4334ed0c", "url": "https://github.com/elastic/elasticsearch/commit/12466c5f99e2a117ff36670452d23f6d4334ed0c", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-06-30T17:11:46Z", "type": "commit"}, {"oid": "129d01c3d84f46845a9521363c7f6f4ae44024b4", "url": "https://github.com/elastic/elasticsearch/commit/129d01c3d84f46845a9521363c7f6f4ae44024b4", "message": "fix merge conflict", "committedDate": "2020-06-30T17:22:32Z", "type": "commit"}, {"oid": "8f1d8ee5fe739718ef06e5bf203d19f0c09f5982", "url": "https://github.com/elastic/elasticsearch/commit/8f1d8ee5fe739718ef06e5bf203d19f0c09f5982", "message": "Merge branch 'master' into grant_privs_to_backing_indices", "committedDate": "2020-07-02T15:44:46Z", "type": "commit"}, {"oid": "98f222b28177ce33826e932e4642747bb2c4eea4", "url": "https://github.com/elastic/elasticsearch/commit/98f222b28177ce33826e932e4642747bb2c4eea4", "message": "fix test", "committedDate": "2020-07-02T17:10:15Z", "type": "commit"}, {"oid": "022c7c14dd66072ecb20d58b6a3f78c032e3962c", "url": "https://github.com/elastic/elasticsearch/commit/022c7c14dd66072ecb20d58b6a3f78c032e3962c", "message": "fix another test", "committedDate": "2020-07-02T18:44:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxOTY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/58381#discussion_r449219641", "bodyText": "I would make it an IllegalStateException.", "author": "albertzaharovits", "createdAt": "2020-07-02T19:15:27Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java", "diffHunk": "@@ -412,13 +413,17 @@ private boolean containsWildcards(IndicesRequest indicesRequest) {\n         return finalIndices;\n     }\n \n-    private static boolean isIndexVisible(String expression, String index, IndicesOptions indicesOptions, Metadata metadata) {\n-        return isIndexVisible(expression, index, indicesOptions, metadata, false);\n+    private static boolean isIndexVisible(String expression, String index, IndicesOptions indicesOptions, Metadata metadata,\n+                                          boolean includeDataStreams) {\n+        return isIndexVisible(expression, index, indicesOptions, metadata, includeDataStreams, false);\n     }\n \n     private static boolean isIndexVisible(String expression, String index, IndicesOptions indicesOptions, Metadata metadata,\n-                                          boolean dateMathExpression) {\n+                                          boolean includeDataStreams, boolean dateMathExpression) {\n         IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index);\n+        if (indexAbstraction == null) {\n+            return false;", "originalCommit": "022c7c14dd66072ecb20d58b6a3f78c032e3962c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2ba65c932f003ff01d7398b9f40f559951f33970", "chunk": "diff --git a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java\nindex d12325debad..5b0042ab6a4 100644\n--- a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java\n+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolver.java\n\n@@ -422,7 +422,7 @@ class IndicesAndAliasesResolver {\n                                           boolean includeDataStreams, boolean dateMathExpression) {\n         IndexAbstraction indexAbstraction = metadata.getIndicesLookup().get(index);\n         if (indexAbstraction == null) {\n-            return false;\n+            throw new IllegalStateException(\"could not resolve index abstraction [\" + index + \"]\");\n         }\n         final boolean isHidden = indexAbstraction.isHidden();\n         if (indexAbstraction.getType() == IndexAbstraction.Type.ALIAS) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2MDgxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/58381#discussion_r449260819", "bodyText": "We need to test that RBACEngine.resolveAuthorizedIndicesFromRole:\n\nreturns the list containing the backing indices if the role grants access to a data stream (granting as part of a wildcard or a simple name)\nindices which are not backing indices are not returned when some data stream is covered by the role permission\ngranting access to backing indices (as a wildcard or simple name) does not include the data stream in the list of authorised names\n\nWe need to repeat the tests for when the request works with data streams or not.", "author": "albertzaharovits", "createdAt": "2020-07-02T20:53:21Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/AuthorizedIndicesTests.java", "diffHunk": "@@ -35,7 +37,7 @@\n ", "originalCommit": "022c7c14dd66072ecb20d58b6a3f78c032e3962c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NTI0OA==", "url": "https://github.com/elastic/elasticsearch/pull/58381#discussion_r449265248", "bodyText": "no backing indices as well.\nBut regular indices and aliases are visible. Same with backing indices.\n(I would expand the namespace granted to by the role to ensure those entities are OK - i.e. I'm not suggesting another test, just a more complete one).\nBut I would also test a simple (not wildcard) data stream name.", "author": "albertzaharovits", "createdAt": "2020-07-02T21:04:47Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java", "diffHunk": "@@ -1551,25 +1554,54 @@ public void testDataStreamResolution() {\n             assertThat(resolvedIndices.getRemote(), emptyIterable());\n         }\n         {\n-            final User user = new User(\"data-steam-tester2\", \"data_stream_test2\");\n-            final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME);\n+            final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n \n             // Resolve *all* data streams:\n             SearchRequest searchRequest = new SearchRequest();\n             searchRequest.indices(\"logs-*\");\n             searchRequest.indicesOptions(IndicesOptions.fromOptions(false, false, true, false, false, true, true, true, true));\n+            final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, searchRequest);\n             ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(searchRequest, metadata, authorizedIndices);\n             assertThat(resolvedIndices.getLocal(), containsInAnyOrder(\"logs-foo\", \"logs-foobar\"));\n             assertThat(resolvedIndices.getRemote(), emptyIterable());\n         }\n     }\n \n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequest() {\n+        final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n+        GetAliasesRequest request = new GetAliasesRequest(\"*\");\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foo\")));\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));", "originalCommit": "022c7c14dd66072ecb20d58b6a3f78c032e3962c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2ba65c932f003ff01d7398b9f40f559951f33970", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\nindex 95e2e3bf04e..16e5505a286 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\n\n@@ -1567,28 +1588,268 @@ public class IndicesAndAliasesResolverTests extends ESTestCase {\n         }\n     }\n \n-    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequest() {\n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequestWithWildcard() {\n         final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n         GetAliasesRequest request = new GetAliasesRequest(\"*\");\n         assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n         assertThat(request.includeDataStreams(), is(false));\n \n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // do not match the requested pattern\n+        List<String> dataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n         final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        for (String dsName : dataStreams) {\n+            assertThat(authorizedIndices, not(hasItem(dsName)));\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, not(hasItem(i.getName())));\n+            }\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list unless the backing indices matched the requested\n+        // pattern\n         ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n-        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foo\")));\n-        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        for (String dsName : dataStreams) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+            }\n+        }\n     }\n \n-    public void testDataStreamsAreVisibleWhenIncludedByRequest() {\n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequestWithoutWildcard() {\n         final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n-        SearchRequest request = new SearchRequest(\"*\");\n+        String dataStreamName = \"logs-foobar\";\n+        GetAliasesRequest request = new GetAliasesRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // do not match the requested name\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, not(hasItem(i.getName())));\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list since the backing indices do not match the\n+        // requested name(s)\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testDataStreamsAreVisibleWhenIncludedByRequestWithWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        SearchRequest request = new SearchRequest(\"logs*\");\n         assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n         assertThat(request.includeDataStreams(), is(true));\n \n+        // data streams and their backing indices should be in the authorized list\n+        List<String> expectedDataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n         final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, hasItem(dsName));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, hasItem(i.getName()));\n+            }\n+        }\n+\n+        // data streams without their backing indices will be in the resolved list since the backing indices do not match the requested\n+        // pattern\n         ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n         assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foo\"));\n         assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foobar\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00001\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00002\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00003\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-alias\"));\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertNotNull(dataStream);\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+            }\n+        }\n+    }\n+\n+    public void testDataStreamsAreVisibleWhenIncludedByRequestWithoutWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        String dataStreamName = \"logs-foobar\";\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        SearchRequest request = new SearchRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        // data streams and their backing indices should be in the authorized list\n+        assertThat(authorizedIndices, hasItem(dataStreamName));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        // data streams without their backing indices will be in the resolved list since the backing indices do not match the requested\n+        // name\n+        assertThat(resolvedIndices.getLocal(), hasItem(dataStreamName));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testBackingIndicesAreVisibleWhenIncludedByRequestWithWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        SearchRequest request = new SearchRequest(\".ds-logs*\");\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams and their backing indices should be included in the authorized list\n+        List<String> expectedDataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, hasItem(dsName));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, hasItem(i.getName()));\n+            }\n+        }\n+\n+        // data streams should _not_ be included in the resolved list because they do not match the pattern but their backing indices\n+        // should be in the resolved list because they match the pattern and are authorized via extension from their parent data stream\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), hasItem(i.getName()));\n+            }\n+        }\n+    }\n+\n+    public void testBackingIndicesAreNotVisibleWhenNotIncludedByRequestWithoutWildcard() {\n+        final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n+        String dataStreamName = \"logs-foobar\";\n+        GetAliasesRequest request = new GetAliasesRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // did not match the requested pattern and the request does not support data streams\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, not(hasItem(i.getName())));\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list since the request does not support data streams\n+        // and the backing indices do not match the requested name\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaWildcardAndRequestThatIncludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_wildcards\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        SearchRequest request = new SearchRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams should _not_ be in the authorized list but their backing indices that matched both the requested pattern\n+        // and the authorized pattern should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        DataStream dataStream = metadata.dataStreams().get(\"logs-foobar\");\n+        assertThat(authorizedIndices, not(hasItem(indexName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        // only the backing indices will be in the resolved list since the request does not support data streams\n+        // but the backing indices match the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStream.getName())));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaNameAndRequestThatIncludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_name\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        SearchRequest request = new SearchRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams should _not_ be in the authorized list but a single backing index that matched the requested pattern\n+        // and the authorized name should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        assertThat(authorizedIndices, contains(\".ds-logs-foobar-000001\"));\n+\n+        // only the single backing index will be in the resolved list since the request does not support data streams\n+        // but one of the backing indices matched the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        assertThat(resolvedIndices.getLocal(), contains(\".ds-logs-foobar-000001\"));\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaWildcardAndRequestThatExcludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_wildcards\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        GetAliasesRequest request = new GetAliasesRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams should _not_ be in the authorized list but their backing indices that matched both the requested pattern\n+        // and the authorized pattern should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        DataStream dataStream = metadata.dataStreams().get(\"logs-foobar\");\n+        assertThat(authorizedIndices, not(hasItem(indexName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        // only the backing indices will be in the resolved list since the request does not support data streams\n+        // but the backing indices match the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStream.getName())));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaNameAndRequestThatExcludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_name\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        GetAliasesRequest request = new GetAliasesRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams should _not_ be in the authorized list but a single backing index that matched the requested pattern\n+        // and the authorized name should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        assertThat(authorizedIndices, contains(\".ds-logs-foobar-000001\"));\n+\n+        // only the single backing index will be in the resolved list since the request does not support data streams\n+        // but one of the backing indices matched the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        assertThat(resolvedIndices.getLocal(), contains(\".ds-logs-foobar-000001\"));\n     }\n \n     private List<String> buildAuthorizedIndices(User user, String action) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NTM5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58381#discussion_r449265396", "bodyText": "Should include the backing indices as well, right?", "author": "albertzaharovits", "createdAt": "2020-07-02T21:05:09Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java", "diffHunk": "@@ -1551,25 +1554,54 @@ public void testDataStreamResolution() {\n             assertThat(resolvedIndices.getRemote(), emptyIterable());\n         }\n         {\n-            final User user = new User(\"data-steam-tester2\", \"data_stream_test2\");\n-            final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME);\n+            final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n \n             // Resolve *all* data streams:\n             SearchRequest searchRequest = new SearchRequest();\n             searchRequest.indices(\"logs-*\");\n             searchRequest.indicesOptions(IndicesOptions.fromOptions(false, false, true, false, false, true, true, true, true));\n+            final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, searchRequest);\n             ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(searchRequest, metadata, authorizedIndices);\n             assertThat(resolvedIndices.getLocal(), containsInAnyOrder(\"logs-foo\", \"logs-foobar\"));\n             assertThat(resolvedIndices.getRemote(), emptyIterable());\n         }\n     }\n \n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequest() {\n+        final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n+        GetAliasesRequest request = new GetAliasesRequest(\"*\");\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foo\")));\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+    }\n+\n+    public void testDataStreamsAreVisibleWhenIncludedByRequest() {\n+        final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n+        SearchRequest request = new SearchRequest(\"*\");\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foo\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foobar\"));", "originalCommit": "022c7c14dd66072ecb20d58b6a3f78c032e3962c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2ba65c932f003ff01d7398b9f40f559951f33970", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\nindex 95e2e3bf04e..16e5505a286 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java\n\n@@ -1567,28 +1588,268 @@ public class IndicesAndAliasesResolverTests extends ESTestCase {\n         }\n     }\n \n-    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequest() {\n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequestWithWildcard() {\n         final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n         GetAliasesRequest request = new GetAliasesRequest(\"*\");\n         assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n         assertThat(request.includeDataStreams(), is(false));\n \n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // do not match the requested pattern\n+        List<String> dataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n         final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        for (String dsName : dataStreams) {\n+            assertThat(authorizedIndices, not(hasItem(dsName)));\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, not(hasItem(i.getName())));\n+            }\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list unless the backing indices matched the requested\n+        // pattern\n         ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n-        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foo\")));\n-        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        for (String dsName : dataStreams) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+            }\n+        }\n     }\n \n-    public void testDataStreamsAreVisibleWhenIncludedByRequest() {\n+    public void testDataStreamsAreNotVisibleWhenNotIncludedByRequestWithoutWildcard() {\n         final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n-        SearchRequest request = new SearchRequest(\"*\");\n+        String dataStreamName = \"logs-foobar\";\n+        GetAliasesRequest request = new GetAliasesRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // do not match the requested name\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, not(hasItem(i.getName())));\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list since the backing indices do not match the\n+        // requested name(s)\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testDataStreamsAreVisibleWhenIncludedByRequestWithWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        SearchRequest request = new SearchRequest(\"logs*\");\n         assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n         assertThat(request.includeDataStreams(), is(true));\n \n+        // data streams and their backing indices should be in the authorized list\n+        List<String> expectedDataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n         final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, hasItem(dsName));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, hasItem(i.getName()));\n+            }\n+        }\n+\n+        // data streams without their backing indices will be in the resolved list since the backing indices do not match the requested\n+        // pattern\n         ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n         assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foo\"));\n         assertThat(resolvedIndices.getLocal(), hasItem(\"logs-foobar\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00001\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00002\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-00003\"));\n+        assertThat(resolvedIndices.getLocal(), hasItem(\"logs-alias\"));\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertNotNull(dataStream);\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+            }\n+        }\n+    }\n+\n+    public void testDataStreamsAreVisibleWhenIncludedByRequestWithoutWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        String dataStreamName = \"logs-foobar\";\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        SearchRequest request = new SearchRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        // data streams and their backing indices should be in the authorized list\n+        assertThat(authorizedIndices, hasItem(dataStreamName));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        // data streams without their backing indices will be in the resolved list since the backing indices do not match the requested\n+        // name\n+        assertThat(resolvedIndices.getLocal(), hasItem(dataStreamName));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testBackingIndicesAreVisibleWhenIncludedByRequestWithWildcard() {\n+        final User user = new User(\"data-stream-tester3\", \"data_stream_test3\");\n+        SearchRequest request = new SearchRequest(\".ds-logs*\");\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams and their backing indices should be included in the authorized list\n+        List<String> expectedDataStreams = List.of(\"logs-foo\", \"logs-foobar\");\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, SearchAction.NAME, request);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(authorizedIndices, hasItem(dsName));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(authorizedIndices, hasItem(i.getName()));\n+            }\n+        }\n+\n+        // data streams should _not_ be included in the resolved list because they do not match the pattern but their backing indices\n+        // should be in the resolved list because they match the pattern and are authorized via extension from their parent data stream\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        for (String dsName : expectedDataStreams) {\n+            DataStream dataStream = metadata.dataStreams().get(dsName);\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(dsName)));\n+            for (Index i : dataStream.getIndices()) {\n+                assertThat(resolvedIndices.getLocal(), hasItem(i.getName()));\n+            }\n+        }\n+    }\n+\n+    public void testBackingIndicesAreNotVisibleWhenNotIncludedByRequestWithoutWildcard() {\n+        final User user = new User(\"data-stream-tester2\", \"data_stream_test2\");\n+        String dataStreamName = \"logs-foobar\";\n+        GetAliasesRequest request = new GetAliasesRequest(dataStreamName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams and their backing indices should _not_ be in the authorized list since the backing indices\n+        // did not match the requested pattern and the request does not support data streams\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        DataStream dataStream = metadata.dataStreams().get(dataStreamName);\n+        assertThat(authorizedIndices, not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, not(hasItem(i.getName())));\n+        }\n+\n+        // neither data streams nor their backing indices will be in the resolved list since the request does not support data streams\n+        // and the backing indices do not match the requested name\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStreamName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(resolvedIndices.getLocal(), not(hasItem(i.getName())));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaWildcardAndRequestThatIncludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_wildcards\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        SearchRequest request = new SearchRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams should _not_ be in the authorized list but their backing indices that matched both the requested pattern\n+        // and the authorized pattern should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        DataStream dataStream = metadata.dataStreams().get(\"logs-foobar\");\n+        assertThat(authorizedIndices, not(hasItem(indexName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        // only the backing indices will be in the resolved list since the request does not support data streams\n+        // but the backing indices match the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStream.getName())));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaNameAndRequestThatIncludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_name\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        SearchRequest request = new SearchRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(true));\n+\n+        // data streams should _not_ be in the authorized list but a single backing index that matched the requested pattern\n+        // and the authorized name should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        assertThat(authorizedIndices, contains(\".ds-logs-foobar-000001\"));\n+\n+        // only the single backing index will be in the resolved list since the request does not support data streams\n+        // but one of the backing indices matched the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        assertThat(resolvedIndices.getLocal(), contains(\".ds-logs-foobar-000001\"));\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaWildcardAndRequestThatExcludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_wildcards\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        GetAliasesRequest request = new GetAliasesRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams should _not_ be in the authorized list but their backing indices that matched both the requested pattern\n+        // and the authorized pattern should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        DataStream dataStream = metadata.dataStreams().get(\"logs-foobar\");\n+        assertThat(authorizedIndices, not(hasItem(indexName)));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+\n+        // only the backing indices will be in the resolved list since the request does not support data streams\n+        // but the backing indices match the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(dataStream.getName())));\n+        for (Index i : dataStream.getIndices()) {\n+            assertThat(authorizedIndices, hasItem(i.getName()));\n+        }\n+    }\n+\n+    public void testDataStreamNotAuthorizedWhenBackingIndicesAreAuthorizedViaNameAndRequestThatExcludesDataStreams() {\n+        final User user = new User(\"data-stream-tester2\", \"backing_index_test_name\");\n+        String indexName = \".ds-logs-foobar-*\";\n+        GetAliasesRequest request = new GetAliasesRequest(indexName);\n+        assertThat(request, instanceOf(IndicesRequest.Replaceable.class));\n+        assertThat(request.includeDataStreams(), is(false));\n+\n+        // data streams should _not_ be in the authorized list but a single backing index that matched the requested pattern\n+        // and the authorized name should be in the list\n+        final List<String> authorizedIndices = buildAuthorizedIndices(user, GetAliasesAction.NAME, request);\n+        assertThat(authorizedIndices, not(hasItem(\"logs-foobar\")));\n+        assertThat(authorizedIndices, contains(\".ds-logs-foobar-000001\"));\n+\n+        // only the single backing index will be in the resolved list since the request does not support data streams\n+        // but one of the backing indices matched the requested pattern\n+        ResolvedIndices resolvedIndices = defaultIndicesResolver.resolveIndicesAndAliases(request, metadata, authorizedIndices);\n+        assertThat(resolvedIndices.getLocal(), not(hasItem(\"logs-foobar\")));\n+        assertThat(resolvedIndices.getLocal(), contains(\".ds-logs-foobar-000001\"));\n     }\n \n     private List<String> buildAuthorizedIndices(User user, String action) {\n"}}, {"oid": "2ba65c932f003ff01d7398b9f40f559951f33970", "url": "https://github.com/elastic/elasticsearch/commit/2ba65c932f003ff01d7398b9f40f559951f33970", "message": "review comments", "committedDate": "2020-07-03T01:41:01Z", "type": "commit"}]}