{"pr_number": 53127, "pr_title": "Mask wildcard query special characters on keyword queries", "pr_createdAt": "2020-03-04T17:21:55Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53127", "timeline": [{"oid": "ec7ecf71282a8b8b191da275aacb386094e657e0", "url": "https://github.com/elastic/elasticsearch/commit/ec7ecf71282a8b8b191da275aacb386094e657e0", "message": "Mask wildcard query special characters on keyword queries\n\nWildcard queries on keyword fields get normalized, however this normalization\nstep should exclude the two special characters * and ? in order to keep the\nwildcard query itself intact.\n\nCloses #46300", "committedDate": "2020-03-04T17:16:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTI4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r387825286", "bodyText": "We should do that only for wildcard queries. For other term-based queries these characters should remain in the normalization so I'd move this code to StringFieldType#wildcardQuery ?", "author": "jimczi", "createdAt": "2020-03-04T17:38:18Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java", "diffHunk": "@@ -305,6 +310,31 @@ protected BytesRef indexedValueForSearch(Object value) {\n             if (value instanceof BytesRef) {\n                 value = ((BytesRef) value).utf8ToString();\n             }\n+            if (value instanceof String) {\n+                // best effort to not pass the wildcard characters and escaped characters through #normalize", "originalCommit": "ec7ecf71282a8b8b191da275aacb386094e657e0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e3fc34cd60508efe961a6a35d8eec84bdfb2c84", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\nindex 3cd3d3d3a3a..524a1eb79f1 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/KeywordFieldMapper.java\n\n@@ -310,31 +306,6 @@ public final class KeywordFieldMapper extends FieldMapper {\n             if (value instanceof BytesRef) {\n                 value = ((BytesRef) value).utf8ToString();\n             }\n-            if (value instanceof String) {\n-                // best effort to not pass the wildcard characters and escaped characters through #normalize\n-                String termStr = (String) value;\n-                Matcher wildcardMatcher = WILDCARD_PATTERN.matcher(termStr);\n-                BytesRefBuilder sb = new BytesRefBuilder();\n-                int last = 0;\n-\n-                while (wildcardMatcher.find()) {\n-                    if (wildcardMatcher.start() > 0) {\n-                        String chunk = termStr.substring(last, wildcardMatcher.start());\n-                        BytesRef normalized = searchAnalyzer().normalize(name(), chunk);\n-                        sb.append(normalized);\n-                    }\n-                    // append the matched group - without normalizing\n-                    sb.append(new BytesRef(wildcardMatcher.group()));\n-\n-                    last = wildcardMatcher.end();\n-                }\n-                if (last < termStr.length()) {\n-                    String chunk = termStr.substring(last);\n-                    BytesRef normalized = searchAnalyzer().normalize(name(), chunk);\n-                    sb.append(normalized);\n-                }\n-                return sb.toBytesRef();\n-            }\n             return searchAnalyzer().normalize(name(), value.toString());\n         }\n     }\n"}}, {"oid": "1e3fc34cd60508efe961a6a35d8eec84bdfb2c84", "url": "https://github.com/elastic/elasticsearch/commit/1e3fc34cd60508efe961a6a35d8eec84bdfb2c84", "message": "Moving masking code to StringFieldType#wildcardQuery", "committedDate": "2020-03-05T17:54:27Z", "type": "commit"}, {"oid": "8cf6a71a189ada752741fd8b1744d6c44450098e", "url": "https://github.com/elastic/elasticsearch/commit/8cf6a71a189ada752741fd8b1744d6c44450098e", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-05T17:54:36Z", "type": "commit"}, {"oid": "f0da91d9b8e125ab5fa91b880d110a71c0ec6642", "url": "https://github.com/elastic/elasticsearch/commit/f0da91d9b8e125ab5fa91b880d110a71c0ec6642", "message": "iter", "committedDate": "2020-03-06T10:40:35Z", "type": "commit"}, {"oid": "c4529d1172c897342ad3fb9c37c403302affa098", "url": "https://github.com/elastic/elasticsearch/commit/c4529d1172c897342ad3fb9c37c403302affa098", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-10T14:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMzc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r390813783", "bodyText": "We don't want to create a wildcard query for the _type field, this is not needed.\nIt should be possible to extend the new ConstantFieldType now that _type can have a single value (or none) ?\nCurrently TypeFieldType#termQuery can return Queries.newNonNestedFilter() and that's not handled in the code below. Although, I don't think this is needed since we exclude nested docs for the entire query at the end of the query parsing so it should be safe to remove. IMO the _type field should solely return MatchNoDocsQuery and MatchAllDocsQuery, that's exactly what the ConstantFieldType provides :).\n@romseygeek what do you think ?", "author": "jimczi", "createdAt": "2020-03-11T08:38:39Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -156,6 +162,24 @@ public Query termsQuery(List<?> values, QueryShardContext context) {\n             }\n         }\n \n+        @Override\n+        public Query wildcardQuery(String value, MultiTermQuery.RewriteMethod method, QueryShardContext context) {\n+            Query termQuery = termQuery(value, context);\n+            if (termQuery instanceof MatchNoDocsQuery || termQuery instanceof MatchAllDocsQuery) {\n+                return termQuery;\n+            }\n+", "originalCommit": "c4529d1172c897342ad3fb9c37c403302affa098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyMzI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r390823257", "bodyText": "It should be possible to extend the new ConstantFieldType now that _type can have a single value (or none) ?\n\n+1", "author": "romseygeek", "createdAt": "2020-03-11T08:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMzc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e727b91d02d9c9dd5a48ee700227e8be684bac46", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\nindex 52c5ef17fb8..30500624387 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n\n@@ -127,79 +121,12 @@ public class TypeFieldMapper extends MetadataFieldMapper {\n         }\n \n         @Override\n-        public boolean isSearchable() {\n-            return true;\n-        }\n-\n-        @Override\n-        public Query existsQuery(QueryShardContext context) {\n-            return new MatchAllDocsQuery();\n-        }\n-\n-        @Override\n-        public Query termQuery(Object value, QueryShardContext context) {\n-            return termsQuery(Arrays.asList(value), context);\n-        }\n-\n-        @Override\n-        public Query termsQuery(List<?> values, QueryShardContext context) {\n-            DocumentMapper mapper = context.getMapperService().documentMapper();\n-            if (mapper == null) {\n-                return new MatchNoDocsQuery(\"No types\");\n-            }\n-            BytesRef indexType = indexedValueForSearch(mapper.type());\n-            if (values.stream()\n-                    .map(this::indexedValueForSearch)\n-                    .anyMatch(indexType::equals)) {\n-                if (context.getMapperService().hasNested()) {\n-                    // type filters are expected not to match nested docs\n-                    return Queries.newNonNestedFilter();\n-                } else {\n-                    return new MatchAllDocsQuery();\n-                }\n-            } else {\n-                return new MatchNoDocsQuery(\"Type list does not contain the index type\");\n-            }\n-        }\n-\n-        @Override\n-        public Query wildcardQuery(String value, MultiTermQuery.RewriteMethod method, QueryShardContext context) {\n-            Query termQuery = termQuery(value, context);\n-            if (termQuery instanceof MatchNoDocsQuery || termQuery instanceof MatchAllDocsQuery) {\n-                return termQuery;\n-            }\n-\n-            if (context.allowExpensiveQueries() == false) {\n-                throw new ElasticsearchException(\"[wildcard] queries cannot be executed when '\" +\n-                        ALLOW_EXPENSIVE_QUERIES.getKey() + \"' is set to false.\");\n-            }\n-            Term term = MappedFieldType.extractTerm(termQuery);\n-\n-            WildcardQuery query = new WildcardQuery(term);\n-            QueryParsers.setRewriteMethod(query, method);\n-            return query;\n-        }\n-\n-        @Override\n-        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n-            Query result = new MatchAllDocsQuery();\n-            String type = context.getMapperService().documentMapper().type();\n-            if (type != null) {\n-                BytesRef typeBytes = new BytesRef(type);\n-                if (lowerTerm != null) {\n-                    int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes);\n-                    if (comp > 0 || (comp == 0 && includeLower == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically smaller than lower bound of range\");\n-                    }\n-                }\n-                if (upperTerm != null) {\n-                    int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes);\n-                    if (comp < 0 || (comp == 0 && includeUpper == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically greater than upper bound of range\");\n-                    }\n-                }\n+        protected boolean matches(String pattern, QueryShardContext context) {\n+            if (pattern.contains(\"?\") == false) {\n+                return Regex.simpleMatch(pattern, MapperService.SINGLE_MAPPING_NAME);\n             }\n-            return result;\n+            boolean matches = Pattern.matches(pattern.replace(\"?\", \".\"), MapperService.SINGLE_MAPPING_NAME);\n+            return matches;\n         }\n     }\n \n"}}, {"oid": "e727b91d02d9c9dd5a48ee700227e8be684bac46", "url": "https://github.com/elastic/elasticsearch/commit/e727b91d02d9c9dd5a48ee700227e8be684bac46", "message": "Change TypeFieldType to extend ConstantFieldType", "committedDate": "2020-03-11T13:47:57Z", "type": "commit"}, {"oid": "a59ea3e62f690e0e84de30b2b52f8443439f88ce", "url": "https://github.com/elastic/elasticsearch/commit/a59ea3e62f690e0e84de30b2b52f8443439f88ce", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-11T14:08:31Z", "type": "commit"}, {"oid": "ddf828c25f28854551edd45589339965924fc46f", "url": "https://github.com/elastic/elasticsearch/commit/ddf828c25f28854551edd45589339965924fc46f", "message": "iter", "committedDate": "2020-03-11T14:32:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391022980", "bodyText": "I think you can use context.getMapperService().type() here, instead of SINGLE_MAPPING_NAME, and it will then backport easily.", "author": "romseygeek", "createdAt": "2020-03-11T14:44:16Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -121,61 +121,12 @@ public ValuesSourceType getValuesSourceType() {\n         }\n \n         @Override\n-        public boolean isSearchable() {\n-            return true;\n-        }\n-\n-        @Override\n-        public Query existsQuery(QueryShardContext context) {\n-            return new MatchAllDocsQuery();\n-        }\n-\n-        @Override\n-        public Query termQuery(Object value, QueryShardContext context) {\n-            return termsQuery(Arrays.asList(value), context);\n-        }\n-\n-        @Override\n-        public Query termsQuery(List<?> values, QueryShardContext context) {\n-            DocumentMapper mapper = context.getMapperService().documentMapper();\n-            if (mapper == null) {\n-                return new MatchNoDocsQuery(\"No types\");\n-            }\n-            BytesRef indexType = indexedValueForSearch(mapper.type());\n-            if (values.stream()\n-                    .map(this::indexedValueForSearch)\n-                    .anyMatch(indexType::equals)) {\n-                if (context.getMapperService().hasNested()) {\n-                    // type filters are expected not to match nested docs\n-                    return Queries.newNonNestedFilter();\n-                } else {\n-                    return new MatchAllDocsQuery();\n-                }\n-            } else {\n-                return new MatchNoDocsQuery(\"Type list does not contain the index type\");\n-            }\n-        }\n-\n-        @Override\n-        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n-            Query result = new MatchAllDocsQuery();\n-            String type = context.getMapperService().documentMapper().type();\n-            if (type != null) {\n-                BytesRef typeBytes = new BytesRef(type);\n-                if (lowerTerm != null) {\n-                    int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes);\n-                    if (comp > 0 || (comp == 0 && includeLower == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically smaller than lower bound of range\");\n-                    }\n-                }\n-                if (upperTerm != null) {\n-                    int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes);\n-                    if (comp < 0 || (comp == 0 && includeUpper == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically greater than upper bound of range\");\n-                    }\n-                }\n+        protected boolean matches(String pattern, QueryShardContext context) {\n+            if (pattern.contains(\"?\") == false) {\n+                return Regex.simpleMatch(pattern, MapperService.SINGLE_MAPPING_NAME);", "originalCommit": "ddf828c25f28854551edd45589339965924fc46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMjc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391032784", "bodyText": "context.getMapperService().type()\n\nDoesn't seem to be there on master? Or am I missing sth? I can sure use this when backporting...", "author": "cbuescher", "createdAt": "2020-03-11T14:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNDI4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391034281", "bodyText": "Sorry, I mean context.getMapperService().documentMapper().type()", "author": "romseygeek", "createdAt": "2020-03-11T14:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyMjk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c555c4390835569a8de639642e28920f4129c73b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\nindex 30500624387..3de77d88204 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n\n@@ -123,7 +123,7 @@ public class TypeFieldMapper extends MetadataFieldMapper {\n         @Override\n         protected boolean matches(String pattern, QueryShardContext context) {\n             if (pattern.contains(\"?\") == false) {\n-                return Regex.simpleMatch(pattern, MapperService.SINGLE_MAPPING_NAME);\n+                return Regex.simpleMatch(pattern, context.getMapperService().documentMapper().type());\n             }\n             boolean matches = Pattern.matches(pattern.replace(\"?\", \".\"), MapperService.SINGLE_MAPPING_NAME);\n             return matches;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391024590", "bodyText": "Is this for backwards compatibility? Nested fields are defined using a different field in 8x", "author": "romseygeek", "createdAt": "2020-03-11T14:46:20Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java", "diffHunk": "@@ -79,6 +79,10 @@ private static String valueToString(Object value) {\n     public final Query termQuery(Object value, QueryShardContext context) {\n         String pattern = valueToString(value);\n         if (matches(pattern, context)) {\n+            if (context != null && context.getMapperService().hasNested()) {", "originalCommit": "ddf828c25f28854551edd45589339965924fc46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391031326", "bodyText": "Yes, I wasn't sure about this, there was a test failing without it here: https://github.com/elastic/elasticsearch/blob/master/server/src/test/java/org/elasticsearch/index/mapper/TypeFieldTypeTests.java#L70, so I assumed its still valid. If this is not the case I'm happy to remove this together with the test, but I wasn't sure about the implications.", "author": "cbuescher", "createdAt": "2020-03-11T14:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MzA4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391043086", "bodyText": "Yes, I don't think this applies any more, as nested queries are always built via the NestedPathFieldMapper, so you should be able to remove this block and those few lines of the test.", "author": "romseygeek", "createdAt": "2020-03-11T15:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAyNDU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java b/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\nindex 148936faf8d..779e8f91350 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\n\n@@ -79,10 +79,6 @@ public abstract class ConstantFieldType extends MappedFieldType {\n     public final Query termQuery(Object value, QueryShardContext context) {\n         String pattern = valueToString(value);\n         if (matches(pattern, context)) {\n-            if (context != null && context.getMapperService().hasNested()) {\n-                // type filters are expected not to match nested docs\n-                return Queries.newNonNestedFilter();\n-            }\n             return Queries.newMatchAllQuery();\n         } else {\n             return new MatchNoDocsQuery();\n"}}, {"oid": "c555c4390835569a8de639642e28920f4129c73b", "url": "https://github.com/elastic/elasticsearch/commit/c555c4390835569a8de639642e28920f4129c73b", "message": "iter", "committedDate": "2020-03-11T15:02:59Z", "type": "commit"}, {"oid": "db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "url": "https://github.com/elastic/elasticsearch/commit/db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "message": "Fix mocks in test", "committedDate": "2020-03-11T15:38:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU3MDg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53127#discussion_r391570882", "bodyText": "I don't think we need to handle wildcard and prefixes here ? We don't support prefix and wildcard queries on the _type field today and since _type are now a thing from the past I don't think we should add this ability. Just checking that the pattern exactly matches the internal type should be enough.", "author": "jimczi", "createdAt": "2020-03-12T11:55:32Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java", "diffHunk": "@@ -121,61 +121,12 @@ public ValuesSourceType getValuesSourceType() {\n         }\n \n         @Override\n-        public boolean isSearchable() {\n-            return true;\n-        }\n-\n-        @Override\n-        public Query existsQuery(QueryShardContext context) {\n-            return new MatchAllDocsQuery();\n-        }\n-\n-        @Override\n-        public Query termQuery(Object value, QueryShardContext context) {\n-            return termsQuery(Arrays.asList(value), context);\n-        }\n-\n-        @Override\n-        public Query termsQuery(List<?> values, QueryShardContext context) {\n-            DocumentMapper mapper = context.getMapperService().documentMapper();\n-            if (mapper == null) {\n-                return new MatchNoDocsQuery(\"No types\");\n-            }\n-            BytesRef indexType = indexedValueForSearch(mapper.type());\n-            if (values.stream()\n-                    .map(this::indexedValueForSearch)\n-                    .anyMatch(indexType::equals)) {\n-                if (context.getMapperService().hasNested()) {\n-                    // type filters are expected not to match nested docs\n-                    return Queries.newNonNestedFilter();\n-                } else {\n-                    return new MatchAllDocsQuery();\n-                }\n-            } else {\n-                return new MatchNoDocsQuery(\"Type list does not contain the index type\");\n-            }\n-        }\n-\n-        @Override\n-        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n-            Query result = new MatchAllDocsQuery();\n-            String type = context.getMapperService().documentMapper().type();\n-            if (type != null) {\n-                BytesRef typeBytes = new BytesRef(type);\n-                if (lowerTerm != null) {\n-                    int comp = indexedValueForSearch(lowerTerm).compareTo(typeBytes);\n-                    if (comp > 0 || (comp == 0 && includeLower == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically smaller than lower bound of range\");\n-                    }\n-                }\n-                if (upperTerm != null) {\n-                    int comp = indexedValueForSearch(upperTerm).compareTo(typeBytes);\n-                    if (comp < 0 || (comp == 0 && includeUpper == false)) {\n-                        result = new MatchNoDocsQuery(\"[_type] was lexicographically greater than upper bound of range\");\n-                    }\n-                }\n+        protected boolean matches(String pattern, QueryShardContext context) {", "originalCommit": "db5ea54bfed5867e1bf8e8bd3324ab36adf2473b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4dfe63df8a9f020f3c39c024292c7f221fd58527", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\nindex 3de77d88204..d32d4fa9d3f 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/TypeFieldMapper.java\n\n@@ -122,11 +120,7 @@ public class TypeFieldMapper extends MetadataFieldMapper {\n \n         @Override\n         protected boolean matches(String pattern, QueryShardContext context) {\n-            if (pattern.contains(\"?\") == false) {\n-                return Regex.simpleMatch(pattern, context.getMapperService().documentMapper().type());\n-            }\n-            boolean matches = Pattern.matches(pattern.replace(\"?\", \".\"), MapperService.SINGLE_MAPPING_NAME);\n-            return matches;\n+            return pattern.equals(MapperService.SINGLE_MAPPING_NAME);\n         }\n     }\n \n"}}, {"oid": "4dfe63df8a9f020f3c39c024292c7f221fd58527", "url": "https://github.com/elastic/elasticsearch/commit/4dfe63df8a9f020f3c39c024292c7f221fd58527", "message": "TypeFieldType#matches only needs to support exact match", "committedDate": "2020-03-12T14:23:03Z", "type": "commit"}, {"oid": "e466513ca9a5b9a02e124e14b84ddc67192dd2a9", "url": "https://github.com/elastic/elasticsearch/commit/e466513ca9a5b9a02e124e14b84ddc67192dd2a9", "message": "Merge branch 'master' into fix-46300", "committedDate": "2020-03-12T16:25:29Z", "type": "commit"}]}