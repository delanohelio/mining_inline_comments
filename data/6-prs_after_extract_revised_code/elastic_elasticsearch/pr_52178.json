{"pr_number": 52178, "pr_title": "Respect runas realm for ApiKey security operations", "pr_createdAt": "2020-02-11T02:02:46Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52178", "timeline": [{"oid": "9712caf5c06b14dac4858db50aed15f3b4b74f9d", "url": "https://github.com/elastic/elasticsearch/commit/9712caf5c06b14dac4858db50aed15f3b4b74f9d", "message": "Initial fix for elastic/elasticsearch#51975", "committedDate": "2020-02-11T01:54:48Z", "type": "commit"}, {"oid": "3899fcc0d5e28e93c9e6c3e973dfb40dd0e592bc", "url": "https://github.com/elastic/elasticsearch/commit/3899fcc0d5e28e93c9e6c3e973dfb40dd0e592bc", "message": "Update manage own api key to always use source realm", "committedDate": "2020-02-12T00:45:37Z", "type": "commit"}, {"oid": "e264109c4a613d0d1e7fddd8213b4faac7f32760", "url": "https://github.com/elastic/elasticsearch/commit/e264109c4a613d0d1e7fddd8213b4faac7f32760", "message": "Add integration tests for runas API key ops", "committedDate": "2020-02-12T02:50:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNTgyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378015820", "bodyText": "This is not strictly necessary since API key cannot impersonate another API key. But changed anyhow for consistency.", "author": "ywangd", "createdAt": "2020-02-12T02:52:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java", "diffHunk": "@@ -78,22 +78,22 @@ private boolean checkIfUserIsOwnerOfApiKeys(Authentication authentication, Strin\n                  * TODO bizybot we need to think on how we can propagate appropriate error message to the end user when username, realm name\n                  *   is missing. This is similar to the problem of propagating right error messages in case of access denied.\n                  */\n-                if (authentication.getAuthenticatedBy().getType().equals(API_KEY_REALM_TYPE)) {\n+                if (authentication.getSourceRealm().getType().equals(API_KEY_REALM_TYPE)) {", "originalCommit": "e264109c4a613d0d1e7fddd8213b4faac7f32760", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTIwMDA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381200085", "bodyText": "I don't take issue with your change, but ApiKeyService#getCreatorRealmType uses the getAuthenticatedBy realm, so the consistency argument is weak.\nDeep inside I prefer:\nif (Authentication.AuthenticationType.API_KEY == authentication.getAuthenticationType()) { \n\nand that ApiKeyService#getCreatorRealmType/Name be refactored under Authentication .\nBut this is out of scope for this PR.", "author": "albertzaharovits", "createdAt": "2020-02-19T10:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNTgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0ODczMw==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381248733", "bodyText": "I mean consistency within the same class, i.e. the following line in the same file.\nI agree with your analysis. The logic in ApiKeyService#getCreatorRealmXxx is inconsistent. Since API key cannot impersonate another API key, it works with both authenticatedBy and lookedUpBy. But I think it's better to keep them consistent. Also worthwhile to change the authentication type test as you suggested. I created a new issue #52511 for these changes. Thanks", "author": "ywangd", "createdAt": "2020-02-19T12:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNTgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\nindex 93147be9b21..b1e6c117a04 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\n\n@@ -84,9 +84,9 @@ public class ManageOwnApiKeyClusterPrivilege implements NamedClusterPrivilege {\n                 } else if (ownedByAuthenticatedUser) {\n                     return true;\n                 } else if (Strings.hasText(username) && Strings.hasText(realmName)) {\n-                    final String authenticatedUserPrincipal = authentication.getUser().authenticatedUser().principal();\n-                    final String authenticatedUserRealm = authentication.getSourceRealm().getName();\n-                    return username.equals(authenticatedUserPrincipal) && realmName.equals(authenticatedUserRealm);\n+                    final String sourceUserPrincipal = authentication.getUser().principal();\n+                    final String sourceRealmName = authentication.getSourceRealm().getName();\n+                    return username.equals(sourceUserPrincipal) && realmName.equals(sourceRealmName);\n                 }\n             }\n             return false;\n"}}, {"oid": "455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "url": "https://github.com/elastic/elasticsearch/commit/455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "message": "Merge remote-tracking branch 'origin/master' into es-51975-runas-for-apikey-ops", "committedDate": "2020-02-12T03:08:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTQ1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378749450", "bodyText": "I don't think the \"authenticated\" user and realm are the ones required here.\nThis check must verify that the username and realm request parameters match the user's name and realm. This is because the value of the request parameters are the ones actually used when retrieving/invalidating the API keys.\nFor example, this ought to be possible if user jacknich has only the manage_own_api_keys privilege.\ncurl -u tomcruise -H \"es-security-runas-user: jacknich\" -X DELETE \"localhost:9200/_security/api_key?pretty\" -H 'Content-Type: application/json' -d'\n{\n  \"username\" : \"jacknich\"\n}\n'\n\nBut it would not work with your changes because the check here compares the \"username\" request parameter to the user that authenticated, i.e. tomcruise.", "author": "albertzaharovits", "createdAt": "2020-02-13T09:42:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java", "diffHunk": "@@ -78,22 +78,22 @@ private boolean checkIfUserIsOwnerOfApiKeys(Authentication authentication, Strin\n                  * TODO bizybot we need to think on how we can propagate appropriate error message to the end user when username, realm name\n                  *   is missing. This is similar to the problem of propagating right error messages in case of access denied.\n                  */\n-                if (authentication.getAuthenticatedBy().getType().equals(API_KEY_REALM_TYPE)) {\n+                if (authentication.getSourceRealm().getType().equals(API_KEY_REALM_TYPE)) {\n                     // API key cannot own any other API key so deny access\n                     return false;\n                 } else if (ownedByAuthenticatedUser) {\n                     return true;\n                 } else if (Strings.hasText(username) && Strings.hasText(realmName)) {\n-                    final String authenticatedUserPrincipal = authentication.getUser().principal();\n-                    final String authenticatedUserRealm = authentication.getAuthenticatedBy().getName();\n+                    final String authenticatedUserPrincipal = authentication.getUser().authenticatedUser().principal();\n+                    final String authenticatedUserRealm = authentication.getSourceRealm().getName();\n                     return username.equals(authenticatedUserPrincipal) && realmName.equals(authenticatedUserRealm);\n                 }", "originalCommit": "455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc3MTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378771122", "bodyText": "Thanks Albert. This is a good catch! Really appreciated.\nI thought I understood how User object was designed. But somehow I got it wrong. Thanks for catching this.", "author": "ywangd", "createdAt": "2020-02-13T10:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgxOTMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378819313", "bodyText": "Updated", "author": "ywangd", "createdAt": "2020-02-13T12:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0OTQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\nindex 93147be9b21..b1e6c117a04 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilege.java\n\n@@ -84,9 +84,9 @@ public class ManageOwnApiKeyClusterPrivilege implements NamedClusterPrivilege {\n                 } else if (ownedByAuthenticatedUser) {\n                     return true;\n                 } else if (Strings.hasText(username) && Strings.hasText(realmName)) {\n-                    final String authenticatedUserPrincipal = authentication.getUser().authenticatedUser().principal();\n-                    final String authenticatedUserRealm = authentication.getSourceRealm().getName();\n-                    return username.equals(authenticatedUserPrincipal) && realmName.equals(authenticatedUserRealm);\n+                    final String sourceUserPrincipal = authentication.getUser().principal();\n+                    final String sourceRealmName = authentication.getSourceRealm().getName();\n+                    return username.equals(sourceUserPrincipal) && realmName.equals(sourceRealmName);\n                 }\n             }\n             return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MDA1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378760057", "bodyText": "add a test when the owned flag is not set, but the username and realm are.", "author": "albertzaharovits", "createdAt": "2020-02-13T10:02:39Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -540,6 +544,25 @@ public void testGetApiKeysOwnedByCurrentAuthenticatedUser() throws InterruptedEx\n             response, userWithManageApiKeyRoleApiKeys.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n     }\n \n+    public void testGetApiKeysOwnedByRunAsUser() throws ExecutionException, InterruptedException {\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        final String userWithManageOwnApiKeyRole = \"user_with_manage_own_api_key_role\";\n+        final String userWithRunAsRole = \"user_with_run_as_role\";\n+        List<CreateApiKeyResponse> userWithManageOwnApiKeyRoleApiKeys = createApiKeys(userWithManageOwnApiKeyRole,\n+            userWithRunAsRole, noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        final Client client = client().filterWithHeader(Map.of(\"Authorization\", UsernamePasswordToken\n+            .basicAuthHeaderValue(userWithRunAsRole, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n+            \"es-security-runas-user\", userWithManageOwnApiKeyRole));\n+\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.forOwnedApiKeys(), listener);", "originalCommit": "455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc3MjA0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378772045", "bodyText": "I was meant do test without the \"owner\" flag since the updated logic won't get executed with its presense. Somehow I ended up forgetting it. Will update. Thanks", "author": "ywangd", "createdAt": "2020-02-13T10:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNDM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378824346", "bodyText": "Add tests for get and invalidate API key without \"owner=true\"", "author": "ywangd", "createdAt": "2020-02-13T12:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MDA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\nindex 0d2cec4afd0..8a56689e8e3 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n\n@@ -544,25 +546,54 @@ public class ApiKeyIntegTests extends SecurityIntegTestCase {\n             response, userWithManageApiKeyRoleApiKeys.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n     }\n \n-    public void testGetApiKeysOwnedByRunAsUser() throws ExecutionException, InterruptedException {\n+    public void testGetApiKeysOwnedByRunAsUserWhenOwnerIsTrue() throws ExecutionException, InterruptedException {\n+        createUserWithRunAsRole();\n         int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n         int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n         createApiKeys(noOfSuperuserApiKeys, null);\n-        final String userWithManageOwnApiKeyRole = \"user_with_manage_own_api_key_role\";\n-        final String userWithRunAsRole = \"user_with_run_as_role\";\n-        List<CreateApiKeyResponse> userWithManageOwnApiKeyRoleApiKeys = createApiKeys(userWithManageOwnApiKeyRole,\n-            userWithRunAsRole, noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n-        final Client client = client().filterWithHeader(Map.of(\"Authorization\", UsernamePasswordToken\n-            .basicAuthHeaderValue(userWithRunAsRole, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n-            \"es-security-runas-user\", userWithManageOwnApiKeyRole));\n+        List<CreateApiKeyResponse> userWithManageOwnApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        getClientForRunAsUser().execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.forOwnedApiKeys(), listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(\"user_with_manage_own_api_key_role\", noOfApiKeysForUserWithManageApiKeyRole, userWithManageOwnApiKeyRoleApiKeys,\n+            response, userWithManageOwnApiKeyRoleApiKeys.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n+    }\n \n+    public void testGetApiKeysOwnedByRunAsUserWhenRunAsUserInfoIsGiven() throws ExecutionException, InterruptedException {\n+        createUserWithRunAsRole();\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        List<CreateApiKeyResponse> userWithManageOwnApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n         PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n-        client.execute(GetApiKeyAction.INSTANCE, GetApiKeyRequest.forOwnedApiKeys(), listener);\n+        getClientForRunAsUser().execute(GetApiKeyAction.INSTANCE,\n+            GetApiKeyRequest.usingRealmAndUserName(\"file\", \"user_with_manage_own_api_key_role\"), listener);\n         GetApiKeyResponse response = listener.get();\n-        verifyGetResponse(userWithManageOwnApiKeyRole, noOfApiKeysForUserWithManageApiKeyRole, userWithManageOwnApiKeyRoleApiKeys,\n+        verifyGetResponse(\"user_with_manage_own_api_key_role\", noOfApiKeysForUserWithManageApiKeyRole, userWithManageOwnApiKeyRoleApiKeys,\n             response, userWithManageOwnApiKeyRoleApiKeys.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n     }\n \n+    public void testGetApiKeysOwnedByRunAsUserWillNotWorkWhenAuthUserInfoIsGiven() throws ExecutionException, InterruptedException {\n+        createUserWithRunAsRole();\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        final List<CreateApiKeyResponse> userWithManageOwnApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        final Tuple<String,String> invalidRealmAndUserPair = randomFrom(\n+            new Tuple<>(\"file\", \"user_with_run_as_role\"),\n+            new Tuple<>(\"index\", \"user_with_manage_own_api_key_role\"),\n+            new Tuple<>(\"index\", \"user_with_run_as_role\"));\n+        getClientForRunAsUser().execute(GetApiKeyAction.INSTANCE,\n+            GetApiKeyRequest.usingRealmAndUserName(invalidRealmAndUserPair.v1(), invalidRealmAndUserPair.v2()), listener);\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, listener::actionGet);\n+        assertThat(e.getMessage(), containsString(\n+            \"unauthorized for user [user_with_run_as_role] run as [user_with_manage_own_api_key_role]\"));\n+    }\n+\n     public void testGetAllApiKeys() throws InterruptedException, ExecutionException {\n         int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n         int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MTkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378761923", "bodyText": "same as above, we should also test without the owner flag toggled but with the concrete username and realm set.\nI would also add a negative test, but this is usually better to do in unit tests, but I sometimes sneak in a negative test in integ tests as well.", "author": "albertzaharovits", "createdAt": "2020-02-13T10:06:12Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -600,6 +623,25 @@ public void testInvalidateApiKeysOwnedByCurrentAuthenticatedUser() throws Interr\n         verifyInvalidateResponse(noOfApiKeysForUserWithManageApiKeyRole, userWithManageApiKeyRoleApiKeys, invalidateResponse);\n     }\n \n+    public void testInvalidateApiKeysOwnedByRunAsUser() throws InterruptedException, ExecutionException {\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        final String userWithManageOwnApiKeyRole = \"user_with_manage_own_api_key_role\";\n+        final String userWithRunAsRole = \"user_with_run_as_role\";\n+        List<CreateApiKeyResponse> userWithManageApiKeyRoleApiKeys = createApiKeys(userWithManageOwnApiKeyRole,\n+            userWithRunAsRole, noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        final Client client = client().filterWithHeader(Map.of(\"Authorization\", UsernamePasswordToken\n+            .basicAuthHeaderValue(userWithRunAsRole, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n+            \"es-security-runas-user\", userWithManageOwnApiKeyRole));\n+\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        client.execute(InvalidateApiKeyAction.INSTANCE, InvalidateApiKeyRequest.forOwnedApiKeys(), listener);", "originalCommit": "455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNDYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378824609", "bodyText": "Added negative tests for calling get and invalidate API key with mismatching username and/or realm name.", "author": "ywangd", "createdAt": "2020-02-13T12:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2MTkyMw=="}], "type": "inlineReview", "revised_code": {"commit": "f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\nindex 0d2cec4afd0..8a56689e8e3 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n\n@@ -623,25 +654,52 @@ public class ApiKeyIntegTests extends SecurityIntegTestCase {\n         verifyInvalidateResponse(noOfApiKeysForUserWithManageApiKeyRole, userWithManageApiKeyRoleApiKeys, invalidateResponse);\n     }\n \n-    public void testInvalidateApiKeysOwnedByRunAsUser() throws InterruptedException, ExecutionException {\n+    public void testInvalidateApiKeysOwnedByRunAsUserWhenOwnerIsTrue() throws InterruptedException, ExecutionException {\n+        createUserWithRunAsRole();\n         int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n         int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n         createApiKeys(noOfSuperuserApiKeys, null);\n-        final String userWithManageOwnApiKeyRole = \"user_with_manage_own_api_key_role\";\n-        final String userWithRunAsRole = \"user_with_run_as_role\";\n-        List<CreateApiKeyResponse> userWithManageApiKeyRoleApiKeys = createApiKeys(userWithManageOwnApiKeyRole,\n-            userWithRunAsRole, noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n-        final Client client = client().filterWithHeader(Map.of(\"Authorization\", UsernamePasswordToken\n-            .basicAuthHeaderValue(userWithRunAsRole, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n-            \"es-security-runas-user\", userWithManageOwnApiKeyRole));\n-\n+        List<CreateApiKeyResponse> userWithManageApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n         PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n-        client.execute(InvalidateApiKeyAction.INSTANCE, InvalidateApiKeyRequest.forOwnedApiKeys(), listener);\n+        getClientForRunAsUser().execute(InvalidateApiKeyAction.INSTANCE, InvalidateApiKeyRequest.forOwnedApiKeys(), listener);\n         InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(noOfApiKeysForUserWithManageApiKeyRole, userWithManageApiKeyRoleApiKeys, invalidateResponse);\n+    }\n \n+    public void testInvalidateApiKeysOwnedByRunAsUserWhenRunAsUserInfoIsGiven() throws InterruptedException, ExecutionException {\n+        createUserWithRunAsRole();\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        List<CreateApiKeyResponse> userWithManageApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        getClientForRunAsUser().execute(InvalidateApiKeyAction.INSTANCE,\n+            InvalidateApiKeyRequest.usingRealmAndUserName(\"file\", \"user_with_manage_own_api_key_role\"), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n         verifyInvalidateResponse(noOfApiKeysForUserWithManageApiKeyRole, userWithManageApiKeyRoleApiKeys, invalidateResponse);\n     }\n \n+    public void testInvalidateApiKeysOwnedByRunAsUserWillNotWorkWhenAuthUserInfoIsGiven() throws InterruptedException, ExecutionException {\n+        createUserWithRunAsRole();\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);\n+        List<CreateApiKeyResponse> userWithManageApiKeyRoleApiKeys = createApiKeys(\"user_with_manage_own_api_key_role\",\n+            \"user_with_run_as_role\", noOfApiKeysForUserWithManageApiKeyRole, null, \"monitor\");\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        final Tuple<String,String> invalidRealmAndUserPair = randomFrom(\n+            new Tuple<>(\"file\", \"user_with_run_as_role\"),\n+            new Tuple<>(\"index\", \"user_with_manage_own_api_key_role\"),\n+            new Tuple<>(\"index\", \"user_with_run_as_role\"));\n+        getClientForRunAsUser().execute(InvalidateApiKeyAction.INSTANCE,\n+            InvalidateApiKeyRequest.usingRealmAndUserName(invalidRealmAndUserPair.v1(), invalidRealmAndUserPair.v2()), listener);\n+        final ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, listener::actionGet);\n+        assertThat(e.getMessage(), containsString(\n+            \"unauthorized for user [user_with_run_as_role] run as [user_with_manage_own_api_key_role]\"));\n+    }\n+\n     public void testApiKeyAuthorizationApiKeyMustBeAbleToRetrieveItsOwnInformationButNotAnyOtherKeysCreatedBySameOwner()\n         throws InterruptedException, ExecutionException {\n         List<CreateApiKeyResponse> responses = createApiKeys(SecuritySettingsSource.TEST_SUPERUSER,2, null, (String[]) null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2NTExNA==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378765114", "bodyText": "^ This is why the inversion is not caught up by tests\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final User user = new User(username, new String[0], new User(runAsUsername));\n          \n          \n            \n                    final User user = new User(runAsUsername, new String[0], new User(username));", "author": "albertzaharovits", "createdAt": "2020-02-13T10:12:07Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java", "diffHunk": "@@ -96,15 +96,47 @@ public void testAuthenticationWithUserDeniesAccessToApiKeyActionsWhenItIsNotOwne\n         assertFalse(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\", invalidateApiKeyRequest, authentication));\n     }\n \n+    public void testGetAndInvalidateApiKeyWillRespectRunAsUser() {\n+        final ClusterPermission clusterPermission =\n+            ManageOwnApiKeyClusterPrivilege.INSTANCE.buildPermission(ClusterPermission.builder()).build();\n+\n+        final Authentication authentication = createMockRunAsAuthentication(\n+            \"user_a\", \"realm_a\", \"realm_a_type\",\n+            \"user_b\", \"realm_b\", \"realm_b_type\");\n+\n+        final TransportRequest getApiKeyRequest = GetApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n+        final TransportRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n+\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/get\", getApiKeyRequest, authentication));\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\", invalidateApiKeyRequest, authentication));\n+    }\n+\n     private Authentication createMockAuthentication(String username, String realmName, String realmType, Map<String, Object> metadata) {\n         final User user = new User(username);\n         final Authentication authentication = mock(Authentication.class);\n         final Authentication.RealmRef authenticatedBy = mock(Authentication.RealmRef.class);\n         when(authentication.getUser()).thenReturn(user);\n-        when(authentication.getAuthenticatedBy()).thenReturn(authenticatedBy);\n+        when(authentication.getSourceRealm()).thenReturn(authenticatedBy);\n         when(authenticatedBy.getName()).thenReturn(realmName);\n         when(authenticatedBy.getType()).thenReturn(realmType);\n         when(authentication.getMetadata()).thenReturn(metadata);\n         return authentication;\n     }\n+\n+    private Authentication createMockRunAsAuthentication(String username, String realmName, String realmType,\n+        String runAsUsername, String runAsRealmName, String runAsRealmType) {\n+        final Authentication.RealmRef authenticatedBy = mock(Authentication.RealmRef.class);\n+        when(authenticatedBy.getName()).thenReturn(realmName);\n+        when(authenticatedBy.getType()).thenReturn(realmType);\n+        final Authentication.RealmRef lookedUpBy = mock(Authentication.RealmRef.class);\n+        when(lookedUpBy.getName()).thenReturn(runAsRealmName);\n+        when(lookedUpBy.getType()).thenReturn(runAsRealmType);\n+        final User user = new User(username, new String[0], new User(runAsUsername));", "originalCommit": "455a6d6c74cbbf4bc4c3d7323a33e693b985dded", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f966f4ddd07ebe60b7d7912033ca69a8278c79c0", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\nindex f686b85a5e5..c378e801f73 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\n\n@@ -131,7 +131,7 @@ public class ManageOwnApiKeyClusterPrivilegeTests extends ESTestCase {\n         final Authentication.RealmRef lookedUpBy = mock(Authentication.RealmRef.class);\n         when(lookedUpBy.getName()).thenReturn(runAsRealmName);\n         when(lookedUpBy.getType()).thenReturn(runAsRealmType);\n-        final User user = new User(username, new String[0], new User(runAsUsername));\n+        final User user = new User(runAsUsername, new String[0], new User(username));\n         final Authentication authentication = mock(Authentication.class);\n         when(authentication.getUser()).thenReturn(user);\n         when(authentication.getAuthenticatedBy()).thenReturn(authenticatedBy);\n"}}, {"oid": "f966f4ddd07ebe60b7d7912033ca69a8278c79c0", "url": "https://github.com/elastic/elasticsearch/commit/f966f4ddd07ebe60b7d7912033ca69a8278c79c0", "message": "Update x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\n\nCo-Authored-By: Albert Zaharovits <albert.zaharovits@gmail.com>", "committedDate": "2020-02-13T10:25:44Z", "type": "commit"}, {"oid": "f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "url": "https://github.com/elastic/elasticsearch/commit/f3cd6ff31dfbd8f1e85922211cf5b3db517e4816", "message": "Address feedback", "committedDate": "2020-02-13T12:01:22Z", "type": "commit"}, {"oid": "584343aedd7ff71d94a27e05a0a6f12d0ba88227", "url": "https://github.com/elastic/elasticsearch/commit/584343aedd7ff71d94a27e05a0a6f12d0ba88227", "message": "Merge remote-tracking branch 'origin/master' into es-51975-runas-for-apikey-ops", "committedDate": "2020-02-13T12:01:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNDAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r378824002", "bodyText": "In order to have negative tests for realm name mismatch, user_with_run_as_role needs to be created in a different realm other than file (which is handled by configureUsers()). This new helper method creates the user in the native realm.", "author": "ywangd", "createdAt": "2020-02-13T12:14:35Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -715,6 +829,26 @@ private void verifyGetResponse(String[] user, int expectedNumberOfApiKeys, List<\n         return responses;\n     }\n \n+    private void createUserWithRunAsRole() throws ExecutionException, InterruptedException {\n+        final PutUserRequest putUserRequest = new PutUserRequest();\n+        putUserRequest.username(\"user_with_run_as_role\");\n+        putUserRequest.roles(\"run_as_role\");\n+        putUserRequest.passwordHash(SecuritySettingsSource.TEST_PASSWORD_HASHED.toCharArray());\n+        PlainActionFuture<PutUserResponse> listener = new PlainActionFuture<>();\n+        final Client client = client().filterWithHeader(Map.of(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        client.execute(PutUserAction.INSTANCE, putUserRequest, listener);\n+        final PutUserResponse putUserResponse = listener.get();\n+        assertTrue(putUserResponse.created());\n+    }", "originalCommit": "584343aedd7ff71d94a27e05a0a6f12d0ba88227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r382346305", "bodyText": "Can we add that explanation to the code?", "author": "tvernum", "createdAt": "2020-02-21T01:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r382363375", "bodyText": "Added", "author": "ywangd", "createdAt": "2020-02-21T02:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyNDAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "57b5b06b8b1a7d886229dc2b4bedbfdf8c512886", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\nindex 8a56689e8e3..2bbb09e1c1f 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n\n@@ -829,6 +829,15 @@ public class ApiKeyIntegTests extends SecurityIntegTestCase {\n         return responses;\n     }\n \n+    /**\n+     * Create an user in native realm who has run_as privilege. It allows the user to run-as\n+     * the other user who has manage_own_api_key privilege. This user is to help ensure all\n+     * API key security operations should respect the run-as authentication info.\n+     *\n+     * Note that the user with run_as privilege is created in native realm which is different\n+     * from all other users (created in file realm). This is necessary for us to perform negative\n+     * assertions when there are mismatching information, e.g. realm name, username.\n+     */\n     private void createUserWithRunAsRole() throws ExecutionException, InterruptedException {\n         final PutUserRequest putUserRequest = new PutUserRequest();\n         putUserRequest.username(\"user_with_run_as_role\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTIwMTQ0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381201442", "bodyText": "Is this line needed?", "author": "albertzaharovits", "createdAt": "2020-02-19T10:23:08Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -540,6 +546,54 @@ public void testGetApiKeysOwnedByCurrentAuthenticatedUser() throws InterruptedEx\n             response, userWithManageApiKeyRoleApiKeys.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n     }\n \n+    public void testGetApiKeysOwnedByRunAsUserWhenOwnerIsTrue() throws ExecutionException, InterruptedException {\n+        createUserWithRunAsRole();\n+        int noOfSuperuserApiKeys = randomIntBetween(3, 5);\n+        int noOfApiKeysForUserWithManageApiKeyRole = randomIntBetween(3, 5);\n+        createApiKeys(noOfSuperuserApiKeys, null);", "originalCommit": "584343aedd7ff71d94a27e05a0a6f12d0ba88227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0MzIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381243202", "bodyText": "Not strictly needed. I copied it from the existing test and my understanding is that it adds some noise during test setup. After a series of API key operations, the verification step makes sure the operations touch only designated keys and not the noise. I'll just leave them as is since it has some (marginal) value.", "author": "ywangd", "createdAt": "2020-02-19T11:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTIwMTQ0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTIxMDYyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381210621", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                    assertFalse(clusterPermission.check(\"cluster:admin/xpack/security/api_key/get\", GetApiKeyRequest.usingRealmAndUserName(\"realm_a\",\n          \n          \n            \n                            \"user_a\"), authentication));\n          \n          \n            \n                    assertFalse(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\",\n          \n          \n            \n                            InvalidateApiKeyRequest.usingRealmAndUserName(\"realm_a\", \"user_a\"), authentication));\n          \n          \n            \n                }", "author": "albertzaharovits", "createdAt": "2020-02-19T10:39:49Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java", "diffHunk": "@@ -96,15 +96,47 @@ public void testAuthenticationWithUserDeniesAccessToApiKeyActionsWhenItIsNotOwne\n         assertFalse(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\", invalidateApiKeyRequest, authentication));\n     }\n \n+    public void testGetAndInvalidateApiKeyWillRespectRunAsUser() {\n+        final ClusterPermission clusterPermission =\n+            ManageOwnApiKeyClusterPrivilege.INSTANCE.buildPermission(ClusterPermission.builder()).build();\n+\n+        final Authentication authentication = createMockRunAsAuthentication(\n+            \"user_a\", \"realm_a\", \"realm_a_type\",\n+            \"user_b\", \"realm_b\", \"realm_b_type\");\n+\n+        final TransportRequest getApiKeyRequest = GetApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n+        final TransportRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n+\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/get\", getApiKeyRequest, authentication));\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\", invalidateApiKeyRequest, authentication));\n+    }", "originalCommit": "584343aedd7ff71d94a27e05a0a6f12d0ba88227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0MzMxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r381243315", "bodyText": "I'll inline these. Thanks", "author": "ywangd", "createdAt": "2020-02-19T11:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTIxMDYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "df9cf5d89dbebb07861efa1f41de244603bd239e", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\nindex c378e801f73..0f043035b79 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/privilege/ManageOwnApiKeyClusterPrivilegeTests.java\n\n@@ -104,11 +104,10 @@ public class ManageOwnApiKeyClusterPrivilegeTests extends ESTestCase {\n             \"user_a\", \"realm_a\", \"realm_a_type\",\n             \"user_b\", \"realm_b\", \"realm_b_type\");\n \n-        final TransportRequest getApiKeyRequest = GetApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n-        final TransportRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\");\n-\n-        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/get\", getApiKeyRequest, authentication));\n-        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\", invalidateApiKeyRequest, authentication));\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/get\",\n+            GetApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\"), authentication));\n+        assertTrue(clusterPermission.check(\"cluster:admin/xpack/security/api_key/invalidate\",\n+            InvalidateApiKeyRequest.usingRealmAndUserName(\"realm_b\", \"user_b\"), authentication));\n     }\n \n     private Authentication createMockAuthentication(String username, String realmName, String realmType, Map<String, Object> metadata) {\n"}}, {"oid": "df9cf5d89dbebb07861efa1f41de244603bd239e", "url": "https://github.com/elastic/elasticsearch/commit/df9cf5d89dbebb07861efa1f41de244603bd239e", "message": "Address feedback", "committedDate": "2020-02-19T12:09:39Z", "type": "commit"}, {"oid": "b7bdd03bea71e5fe30068e4b75c768d6d43e1816", "url": "https://github.com/elastic/elasticsearch/commit/b7bdd03bea71e5fe30068e4b75c768d6d43e1816", "message": "Merge remote-tracking branch 'origin/master' into es-51975-runas-for-apikey-ops", "committedDate": "2020-02-19T12:09:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r382345906", "bodyText": "These seem backwards to me. You authenticate as runAsUser but run-as user.\nI assume the parameters are just strangely named, but it probably makes sense to have authenticatingUser and owningUser or something like that.", "author": "tvernum", "createdAt": "2020-02-21T01:04:11Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java", "diffHunk": "@@ -699,14 +799,28 @@ private void verifyGetResponse(String[] user, int expectedNumberOfApiKeys, List<\n     }\n \n     private List<CreateApiKeyResponse> createApiKeys(String user, int noOfApiKeys, TimeValue expiration, String... clusterPrivileges) {\n+        final Map<String, String> headers = Collections.singletonMap(\n+                \"Authorization\", UsernamePasswordToken.basicAuthHeaderValue(user, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING));\n+        return createApiKeys(headers, noOfApiKeys, expiration, clusterPrivileges);\n+    }\n+\n+    private List<CreateApiKeyResponse> createApiKeys(String user, String runAsUser,\n+        int noOfApiKeys, TimeValue expiration, String... clusterPrivileges) {\n+        final Map<String, String> headers = Map.of(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(runAsUser, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n+            \"es-security-runas-user\", user);", "originalCommit": "b7bdd03bea71e5fe30068e4b75c768d6d43e1816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzY5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52178#discussion_r382363697", "bodyText": "Good point. It does read awkward. Updated.", "author": "ywangd", "createdAt": "2020-02-21T02:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "57b5b06b8b1a7d886229dc2b4bedbfdf8c512886", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\nindex 8a56689e8e3..2bbb09e1c1f 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java\n\n@@ -804,11 +804,11 @@ public class ApiKeyIntegTests extends SecurityIntegTestCase {\n         return createApiKeys(headers, noOfApiKeys, expiration, clusterPrivileges);\n     }\n \n-    private List<CreateApiKeyResponse> createApiKeys(String user, String runAsUser,\n+    private List<CreateApiKeyResponse> createApiKeys(String owningUser, String authenticatingUser,\n         int noOfApiKeys, TimeValue expiration, String... clusterPrivileges) {\n         final Map<String, String> headers = Map.of(\"Authorization\",\n-            UsernamePasswordToken.basicAuthHeaderValue(runAsUser, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n-            \"es-security-runas-user\", user);\n+            UsernamePasswordToken.basicAuthHeaderValue(authenticatingUser, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING),\n+            \"es-security-runas-user\", owningUser);\n         return createApiKeys(headers, noOfApiKeys, expiration, clusterPrivileges);\n     }\n \n"}}, {"oid": "57b5b06b8b1a7d886229dc2b4bedbfdf8c512886", "url": "https://github.com/elastic/elasticsearch/commit/57b5b06b8b1a7d886229dc2b4bedbfdf8c512886", "message": "Address feedback", "committedDate": "2020-02-21T02:09:38Z", "type": "commit"}, {"oid": "b1bce896f4446ca9cd8c79c99fd4e82b1f89b70f", "url": "https://github.com/elastic/elasticsearch/commit/b1bce896f4446ca9cd8c79c99fd4e82b1f89b70f", "message": "Merge remote-tracking branch 'origin/master' into es-51975-runas-for-apikey-ops", "committedDate": "2020-02-21T02:09:44Z", "type": "commit"}, {"oid": "a05fdebe09c818a7d18d9d0bf37bd0b80742de02", "url": "https://github.com/elastic/elasticsearch/commit/a05fdebe09c818a7d18d9d0bf37bd0b80742de02", "message": "Update", "committedDate": "2020-02-21T02:12:51Z", "type": "commit"}]}