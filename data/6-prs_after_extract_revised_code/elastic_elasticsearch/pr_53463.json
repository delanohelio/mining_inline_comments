{"pr_number": 53463, "pr_title": "Only link fd* files during source-only snapshot", "pr_createdAt": "2020-03-12T09:43:12Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53463", "timeline": [{"oid": "975cf63424536d6fe622b6670d3051857a41cace", "url": "https://github.com/elastic/elasticsearch/commit/975cf63424536d6fe622b6670d3051857a41cace", "message": "Only link fd* files during source-only snapshot", "committedDate": "2020-03-12T09:27:28Z", "type": "commit"}, {"oid": "0b0f91e599cbbdc60674ad8a1176eecf52f64fa0", "url": "https://github.com/elastic/elasticsearch/commit/0b0f91e599cbbdc60674ad8a1176eecf52f64fa0", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files", "committedDate": "2020-03-12T13:02:14Z", "type": "commit"}, {"oid": "1633d8e10febe82276d1268be599ee403eda0aef", "url": "https://github.com/elastic/elasticsearch/commit/1633d8e10febe82276d1268be599ee403eda0aef", "message": "checkstyle", "committedDate": "2020-03-12T13:03:15Z", "type": "commit"}, {"oid": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "url": "https://github.com/elastic/elasticsearch/commit/a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files", "committedDate": "2020-03-13T09:45:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTIxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589219", "bodyText": "NIT: files.toArray(Strings.EMPTY_ARRAY)?", "author": "original-brownbear", "createdAt": "2020-03-14T13:40:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589901", "bodyText": "NIT:\n            Collections.addAll(files, wrapped.listAll());\n            files.addAll(linkedFiles.keySet());", "author": "original-brownbear", "createdAt": "2020-03-14T13:50:38Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4OTk5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r392589996", "bodyText": "NIT:\n                try (directory) {\n                    wrapped.deleteFile(name);\n                } catch (NoSuchFileException | FileNotFoundException e) {\n                    // ignore\n                }", "author": "original-brownbear", "createdAt": "2020-03-14T13:51:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5MTA2MA==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395691060", "bodyText": "Add the name to the exception message?", "author": "original-brownbear", "createdAt": "2020-03-20T14:54:47Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MDY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395760640", "bodyText": "NIT: replace with assert newInfo.getDelCount() == 0 || assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);?", "author": "original-brownbear", "createdAt": "2020-03-20T16:42:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -191,63 +199,80 @@ DirectoryReader wrapReader(DirectoryReader reader) throws IOException {\n \n     private SegmentCommitInfo syncSegment(SegmentCommitInfo segmentCommitInfo, LiveDocs liveDocs, FieldInfos fieldInfos,\n                                           Map<BytesRef, SegmentCommitInfo> existingSegments, List<String> createdFiles) throws IOException {\n-        SegmentInfo si = segmentCommitInfo.info;\n-        Codec codec = si.getCodec();\n-        final String segmentSuffix = \"\";\n-        SegmentCommitInfo newInfo;\n-        final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(targetDirectory);\n-        BytesRef segmentId = new BytesRef(si.getId());\n-        boolean exists = existingSegments.containsKey(segmentId);\n-        if (exists == false) {\n-            SegmentInfo newSegmentInfo = new SegmentInfo(si.dir, si.getVersion(), si.getMinVersion(), si.name, si.maxDoc(), false,\n-                si.getCodec(), si.getDiagnostics(), si.getId(), si.getAttributes(), null);\n-            // we drop the sort on purpose since the field we sorted on doesn't exist in the target index anymore.\n-            newInfo = new SegmentCommitInfo(newSegmentInfo, 0, 0, -1, -1, -1);\n-            List<FieldInfo> fieldInfoCopy = new ArrayList<>(fieldInfos.size());\n-            for (FieldInfo fieldInfo : fieldInfos) {\n-                fieldInfoCopy.add(new FieldInfo(fieldInfo.name, fieldInfo.number,\n-                    false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, fieldInfo.attributes(), 0, 0, 0,\n-                    fieldInfo.isSoftDeletesField()));\n-            }\n-            FieldInfos newFieldInfos = new FieldInfos(fieldInfoCopy.toArray(new FieldInfo[0]));\n-            codec.fieldInfosFormat().write(trackingDir, newSegmentInfo, segmentSuffix, newFieldInfos, IOContext.DEFAULT);\n-            newInfo.setFieldInfosFiles(trackingDir.getCreatedFiles());\n-            String idxFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_INDEX_EXTENSION);\n-            String dataFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_EXTENSION);\n-            String metaFile = IndexFileNames.segmentFileName(newSegmentInfo.name, segmentSuffix, FIELDS_META_EXTENSION);\n-            Directory sourceDir = newSegmentInfo.dir;\n+        Directory toClose = null;\n+        try {\n+            SegmentInfo si = segmentCommitInfo.info;\n+            Codec codec = si.getCodec();\n+            Directory sourceDir = si.dir;\n             if (si.getUseCompoundFile()) {\n-                sourceDir = codec.compoundFormat().getCompoundReader(sourceDir, si, IOContext.DEFAULT);\n+                sourceDir = new LinkedFilesDirectory.CloseMePleaseWrapper(\n+                    codec.compoundFormat().getCompoundReader(sourceDir, si, IOContext.DEFAULT));\n+                toClose = sourceDir;\n+            }\n+            final String segmentSuffix = \"\";\n+            SegmentCommitInfo newInfo;\n+            final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(targetDirectory);\n+            BytesRef segmentId = new BytesRef(si.getId());\n+            boolean exists = existingSegments.containsKey(segmentId);\n+            if (exists == false) {\n+                SegmentInfo newSegmentInfo = new SegmentInfo(targetDirectory, si.getVersion(), si.getMinVersion(), si.name, si.maxDoc(),\n+                    false, si.getCodec(), si.getDiagnostics(), si.getId(), si.getAttributes(), null);\n+                // we drop the sort on purpose since the field we sorted on doesn't exist in the target index anymore.\n+                newInfo = new SegmentCommitInfo(newSegmentInfo, 0, 0, -1, -1, -1);\n+                List<FieldInfo> fieldInfoCopy = new ArrayList<>(fieldInfos.size());\n+                for (FieldInfo fieldInfo : fieldInfos) {\n+                    fieldInfoCopy.add(new FieldInfo(fieldInfo.name, fieldInfo.number,\n+                        false, false, false, IndexOptions.NONE, DocValuesType.NONE, -1, fieldInfo.attributes(), 0, 0, 0,\n+                        fieldInfo.isSoftDeletesField()));\n+                }\n+                FieldInfos newFieldInfos = new FieldInfos(fieldInfoCopy.toArray(new FieldInfo[0]));\n+                codec.fieldInfosFormat().write(trackingDir, newSegmentInfo, segmentSuffix, newFieldInfos, IOContext.DEFAULT);\n+                newInfo.setFieldInfosFiles(trackingDir.getCreatedFiles());\n+            } else {\n+                newInfo = existingSegments.get(segmentId);\n+                assert newInfo.info.getUseCompoundFile() == false;\n             }\n+\n+            // link files for stored fields to target directory\n+            final String idxFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_INDEX_EXTENSION);\n+            final String dataFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_EXTENSION);\n+            final String metaFile = IndexFileNames.segmentFileName(newInfo.info.name, segmentSuffix, FIELDS_META_EXTENSION);\n             trackingDir.copyFrom(sourceDir, idxFile, idxFile, IOContext.DEFAULT);\n+            assert targetDirectory.linkedFiles.containsKey(idxFile);\n+            assert trackingDir.getCreatedFiles().contains(idxFile);\n             trackingDir.copyFrom(sourceDir, dataFile, dataFile, IOContext.DEFAULT);\n-             if (Arrays.asList(sourceDir.listAll()).contains(metaFile)) { // only exists for Lucene 8.5+ indices\n-                 trackingDir.copyFrom(sourceDir, metaFile, metaFile, IOContext.DEFAULT);\n-             }\n-            if (sourceDir != newSegmentInfo.dir) {\n-                sourceDir.close();\n+            assert targetDirectory.linkedFiles.containsKey(dataFile);\n+            assert trackingDir.getCreatedFiles().contains(dataFile);\n+            if (Arrays.asList(sourceDir.listAll()).contains(metaFile)) { // only exists for Lucene 8.5+ indices\n+                trackingDir.copyFrom(sourceDir, metaFile, metaFile, IOContext.DEFAULT);\n+                assert targetDirectory.linkedFiles.containsKey(metaFile);\n+                assert trackingDir.getCreatedFiles().contains(metaFile);\n             }\n-        } else {\n-            newInfo = existingSegments.get(segmentId);\n-            assert newInfo.info.getUseCompoundFile() == false;\n-        }\n-        if (liveDocs.bits != null && liveDocs.numDeletes != 0 && liveDocs.numDeletes != newInfo.getDelCount()) {\n-            if (newInfo.getDelCount() != 0) {\n-                assert assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);\n+\n+            if (liveDocs.bits != null && liveDocs.numDeletes != 0 && liveDocs.numDeletes != newInfo.getDelCount()) {\n+                if (newInfo.getDelCount() != 0) {\n+                    assert assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -250,9 +251,7 @@ public class SourceOnlySnapshot {\n             }\n \n             if (liveDocs.bits != null && liveDocs.numDeletes != 0 && liveDocs.numDeletes != newInfo.getDelCount()) {\n-                if (newInfo.getDelCount() != 0) {\n-                    assert assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);\n-                }\n+                assert newInfo.getDelCount() == 0 || assertLiveDocs(liveDocs.bits, liveDocs.numDeletes);\n                 codec.liveDocsFormat().writeLiveDocs(liveDocs.bits, trackingDir, newInfo, liveDocs.numDeletes - newInfo.getDelCount(),\n                     IOContext.DEFAULT);\n                 SegmentCommitInfo info = new SegmentCommitInfo(newInfo.info, liveDocs.numDeletes, 0, newInfo.getNextDelGen(), -1, -1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NTA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395765079", "bodyText": "NIT: Save 2 lines via IOUtils.close(previous);?", "author": "original-brownbear", "createdAt": "2020-03-20T16:49:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                return wrapped.createOutput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n+            return wrapped.createTempOutput(prefix, suffix, context);\n+        }\n+\n+        @Override\n+        public void sync(Collection<String> names) throws IOException {\n+            final List<String> primaryNames = new ArrayList<>();\n+\n+            for (String name : names) {\n+                if (linkedFiles.containsKey(name) == false) {\n+                    primaryNames.add(name);\n+                }\n+            }\n+\n+            if (primaryNames.isEmpty() == false) {\n+                wrapped.sync(primaryNames);\n+            }\n+        }\n+\n+        @Override\n+        public void syncMetaData() throws IOException {\n+            wrapped.syncMetaData();\n+        }\n+\n+        @Override\n+        public void rename(String source, String dest) throws IOException {\n+            if (linkedFiles.containsKey(source) || linkedFiles.containsKey(dest)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                wrapped.rename(source, dest);\n+            }\n+        }\n+\n+        @Override\n+        public IndexInput openInput(String name, IOContext context) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.openInput(name, context);\n+            } else {\n+                return wrapped.openInput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public Lock obtainLock(String name) throws IOException {\n+            return wrapped.obtainLock(name);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            IOUtils.close(linkedFiles.values());\n+            linkedFiles.clear();\n+            wrapped.close();\n+        }\n+\n+        @Override\n+        public void copyFrom(Directory from, String src, String dest, IOContext context) throws IOException {\n+            if (src.equals(dest) == false) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                final Directory previous;\n+                if (from instanceof CloseMePleaseWrapper) {\n+                    ((CloseMePleaseWrapper) from).incRef();\n+                    previous = linkedFiles.put(src, from);\n+                } else {\n+                    previous = linkedFiles.put(src, new FilterDirectory(from) {\n+                        @Override\n+                        public void close() {\n+                            // ignore\n+                        }\n+                    });\n+                }\n+                if (previous != null) {", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2NzM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/53463#discussion_r395767389", "bodyText": "NIT: Maybe make it safer/shorter via IOUtils.close(() -> IOUtils.close(linkedFiles.values()), linkedFiles::clear, wrapped);?", "author": "original-brownbear", "createdAt": "2020-03-20T16:53:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java", "diffHunk": "@@ -270,4 +295,172 @@ private boolean assertLiveDocs(Bits liveDocs, int deletes) {\n             this.bits = bits;\n         }\n     }\n+\n+    public static class LinkedFilesDirectory extends Directory {\n+\n+        private final Directory wrapped;\n+        private final Map<String, Directory> linkedFiles = new HashMap<>();\n+\n+        public LinkedFilesDirectory(Directory wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public Directory getWrapped() {\n+            return wrapped;\n+        }\n+\n+        @Override\n+        public String[] listAll() throws IOException {\n+            Set<String> files = new HashSet<>();\n+            for (String f : wrapped.listAll()) {\n+                files.add(f);\n+            }\n+            for (String f : linkedFiles.keySet()) {\n+                files.add(f);\n+            }\n+            String[] result = files.toArray(new String[files.size()]);\n+            Arrays.sort(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public void deleteFile(String name) throws IOException {\n+            final Directory directory = linkedFiles.remove(name);\n+            if (directory == null) {\n+                wrapped.deleteFile(name);\n+            } else {\n+                try {\n+                    wrapped.deleteFile(name);\n+                } catch (NoSuchFileException | FileNotFoundException e) {\n+                    // ignore\n+                } finally {\n+                    directory.close();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public long fileLength(String name) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.fileLength(name);\n+            } else {\n+                return wrapped.fileLength(name);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createOutput(String name, IOContext context) throws IOException {\n+            if (linkedFiles.containsKey(name)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                return wrapped.createOutput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n+            return wrapped.createTempOutput(prefix, suffix, context);\n+        }\n+\n+        @Override\n+        public void sync(Collection<String> names) throws IOException {\n+            final List<String> primaryNames = new ArrayList<>();\n+\n+            for (String name : names) {\n+                if (linkedFiles.containsKey(name) == false) {\n+                    primaryNames.add(name);\n+                }\n+            }\n+\n+            if (primaryNames.isEmpty() == false) {\n+                wrapped.sync(primaryNames);\n+            }\n+        }\n+\n+        @Override\n+        public void syncMetaData() throws IOException {\n+            wrapped.syncMetaData();\n+        }\n+\n+        @Override\n+        public void rename(String source, String dest) throws IOException {\n+            if (linkedFiles.containsKey(source) || linkedFiles.containsKey(dest)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                wrapped.rename(source, dest);\n+            }\n+        }\n+\n+        @Override\n+        public IndexInput openInput(String name, IOContext context) throws IOException {\n+            final Directory linkedDir = linkedFiles.get(name);\n+            if (linkedDir != null) {\n+                return linkedDir.openInput(name, context);\n+            } else {\n+                return wrapped.openInput(name, context);\n+            }\n+        }\n+\n+        @Override\n+        public Lock obtainLock(String name) throws IOException {\n+            return wrapped.obtainLock(name);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            IOUtils.close(linkedFiles.values());", "originalCommit": "a6e52ba3c8d6ff1ed13e41a19726b39807cee3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\nindex c2708a9ef7a..ba47939481b 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/snapshots/SourceOnlySnapshot.java\n\n@@ -312,13 +311,9 @@ public class SourceOnlySnapshot {\n         @Override\n         public String[] listAll() throws IOException {\n             Set<String> files = new HashSet<>();\n-            for (String f : wrapped.listAll()) {\n-                files.add(f);\n-            }\n-            for (String f : linkedFiles.keySet()) {\n-                files.add(f);\n-            }\n-            String[] result = files.toArray(new String[files.size()]);\n+            Collections.addAll(files, wrapped.listAll());\n+            files.addAll(linkedFiles.keySet());\n+            String[] result = files.toArray(Strings.EMPTY_ARRAY);\n             Arrays.sort(result);\n             return result;\n         }\n"}}, {"oid": "0687b50f18bd8b9649864dd9c8514301cd9134b3", "url": "https://github.com/elastic/elasticsearch/commit/0687b50f18bd8b9649864dd9c8514301cd9134b3", "message": "Merge remote-tracking branch 'elastic/master' into source-only-linked-files", "committedDate": "2020-03-23T08:32:15Z", "type": "commit"}, {"oid": "10db9ab80ba396b9cdb635c75d679e5bf838f298", "url": "https://github.com/elastic/elasticsearch/commit/10db9ab80ba396b9cdb635c75d679e5bf838f298", "message": "nits", "committedDate": "2020-03-23T08:43:43Z", "type": "commit"}]}