{"pr_number": 54186, "pr_title": "EQL: implement cidrMatch function", "pr_createdAt": "2020-03-25T13:48:42Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54186", "timeline": [{"oid": "aff0389bb6da7b0423260f8df577a0b2df728017", "url": "https://github.com/elastic/elasticsearch/commit/aff0389bb6da7b0423260f8df577a0b2df728017", "message": "EQL: implement cidrMatch function", "committedDate": "2020-03-25T13:43:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NzQ2MA==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397867460", "bodyText": "Needed mapping to IP type, this creating the index with mapping.", "author": "aleksmaus", "createdAt": "2020-03-25T13:49:29Z", "path": "x-pack/plugin/eql/qa/common/src/main/java/org/elasticsearch/test/eql/CommonEqlActionTestCase.java", "diffHunk": "@@ -55,6 +57,12 @@ private static void setupData(CommonEqlActionTestCase tc) throws Exception {\n             return;\n         }\n \n+        CreateIndexRequest request = new CreateIndexRequest(testIndexName)", "originalCommit": "aff0389bb6da7b0423260f8df577a0b2df728017", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397868342", "bodyText": "The current enum for error messages doesn't work great for variadic type of function. Open to suggestions.", "author": "aleksmaus", "createdAt": "2020-03-25T13:50:40Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);", "originalCommit": "aff0389bb6da7b0423260f8df577a0b2df728017", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMDM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397910378", "bodyText": "I added a method here in my wildcard PR:\n\n  \n    \n      elasticsearch/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/Expressions.java\n    \n    \n        Lines 36 to 44\n      in\n      d482c47\n    \n    \n    \n    \n\n        \n          \n           public static ParamOrdinal fromIndex(int index) { \n        \n\n        \n          \n               switch (index) { \n        \n\n        \n          \n                   case 0: return ParamOrdinal.FIRST; \n        \n\n        \n          \n                   case 1: return ParamOrdinal.SECOND; \n        \n\n        \n          \n                   case 2: return ParamOrdinal.THIRD; \n        \n\n        \n          \n                   case 3: return ParamOrdinal.FOURTH; \n        \n\n        \n          \n                   default: return ParamOrdinal.DEFAULT; \n        \n\n        \n          \n               } \n        \n\n        \n          \n           }", "author": "rw-access", "createdAt": "2020-03-25T14:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMTUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397911525", "bodyText": "Also, should these fields also be isStringAndExact? and an isFoldable check?\nHere's how I approached that\n\n  \n    \n      elasticsearch/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java\n    \n    \n        Lines 80 to 83\n      in\n      d482c47\n    \n    \n    \n    \n\n        \n          \n           lastResolution = isFoldable(p, sourceText(), ParamOrdinal.fromIndex(index)); \n        \n\n        \n          \n           if (lastResolution.unresolved()) { \n        \n\n        \n          \n               break; \n        \n\n        \n          \n           }", "author": "rw-access", "createdAt": "2020-03-25T14:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxNjY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397916669", "bodyText": "Cool! Will update after your PR merges.\nThe ParamOrdinal falls back to ParamOrdinal.DEFAULT after 4 params anyways. Maybe make enum longer if we still want to use enum there?", "author": "aleksmaus", "createdAt": "2020-03-25T14:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU2NTU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398565546", "bodyText": "For how to handle functions that deal with a variable list of parameters, I suggest having a look at org.elasticsearch.xpack.sql.expression.predicate.conditional.Case or org.elasticsearch.xpack.sql.expression.predicate.conditional.Coalesce since these are functions that have a variable list of parameters.", "author": "astefan", "createdAt": "2020-03-26T13:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512991", "bodyText": "Relying on the same def builder here that was merged with wildcard function for now.\nUpdated to align with wildcard impl usage of ParamOrdinal.", "author": "aleksmaus", "createdAt": "2020-04-04T20:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2ODM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "16ff57dbcef47a5a8003265b2d69d8b579cfc931", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\nindex be020a3e991..8d99e9ffea6 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n\n@@ -22,11 +22,14 @@ import org.elasticsearch.xpack.ql.util.CollectionUtils;\n import java.util.List;\n \n import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n \n /**\n  * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n  */\n public class CIDRMatch extends ScalarFunction {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r397912377", "bodyText": "I think field.foldable() will be included as part of super?", "author": "rw-access", "createdAt": "2020-03-25T14:46:38Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return super.foldable() && field.foldable() && asFunction().foldable();", "originalCommit": "aff0389bb6da7b0423260f8df577a0b2df728017", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMzE4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403513181", "bodyText": "Removed super.foldable()", "author": "aleksmaus", "createdAt": "2020-04-04T20:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkxMjM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "16ff57dbcef47a5a8003265b2d69d8b579cfc931", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\nindex be020a3e991..8d99e9ffea6 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n\n@@ -22,11 +22,14 @@ import org.elasticsearch.xpack.ql.util.CollectionUtils;\n import java.util.List;\n \n import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n \n /**\n  * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n  */\n public class CIDRMatch extends ScalarFunction {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1ODIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398558202", "bodyText": "I prefer listing the functions in alphabetical order.", "author": "astefan", "createdAt": "2020-03-26T13:09:50Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -24,6 +25,7 @@ public EqlFunctionRegistry() {\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n+                def(CIDRMatch.class, CIDRMatch::new, \"cidrmatch\"),", "originalCommit": "aff0389bb6da7b0423260f8df577a0b2df728017", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjI0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512241", "bodyText": "Yep. Updated.", "author": "aleksmaus", "createdAt": "2020-04-04T20:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1ODIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "439cbc2ed2e8e4d059059d406537d6476942df8b", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java\nindex 92aaf603355..9e8c33b87cf 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java\n\n@@ -18,15 +22,19 @@ public class EqlFunctionRegistry extends FunctionRegistry {\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n-                def(Substring.class, Substring::new, \"substring\"),\n                 def(CIDRMatch.class, CIDRMatch::new, \"cidrmatch\"),\n-            },\n+                def(EndsWith.class, EndsWith::new, \"endswith\"),\n+                def(Length.class, Length::new, \"length\"),\n+                def(StartsWith.class, StartsWith::new, \"startswith\"),\n+                def(Substring.class, Substring::new, \"substring\"),\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),\n+            }\n         };\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1OTg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r398559855", "bodyText": "Personal preference, but I would like to see a useful description of the function. Not even the original EQL documentation is clear imo: https://eql.readthedocs.io/en/latest/query-guide/functions.html", "author": "astefan", "createdAt": "2020-03-26T13:12:25Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function", "originalCommit": "aff0389bb6da7b0423260f8df577a0b2df728017", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMjQ0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r403512443", "bodyText": "Added a couple of more lines with a link to the EQL doc.", "author": "aleksmaus", "createdAt": "2020-04-04T20:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1OTg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "16ff57dbcef47a5a8003265b2d69d8b579cfc931", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\nindex be020a3e991..8d99e9ffea6 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n\n@@ -22,11 +22,14 @@ import org.elasticsearch.xpack.ql.util.CollectionUtils;\n import java.util.List;\n \n import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n \n /**\n  * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n  */\n public class CIDRMatch extends ScalarFunction {\n \n"}}, {"oid": "ee76e7c83fe521bfa3e6fe325dd37ae8e6199f42", "url": "https://github.com/elastic/elasticsearch/commit/ee76e7c83fe521bfa3e6fe325dd37ae8e6199f42", "message": "Merge branch 'master' into feature/cidrmatch", "committedDate": "2020-03-28T19:05:43Z", "type": "commit"}, {"oid": "439cbc2ed2e8e4d059059d406537d6476942df8b", "url": "https://github.com/elastic/elasticsearch/commit/439cbc2ed2e8e4d059059d406537d6476942df8b", "message": "Merge branch 'master' into feature/cidrmatch", "committedDate": "2020-04-04T20:16:51Z", "type": "commit"}, {"oid": "16ff57dbcef47a5a8003265b2d69d8b579cfc931", "url": "https://github.com/elastic/elasticsearch/commit/16ff57dbcef47a5a8003265b2d69d8b579cfc931", "message": "Address code review comments", "committedDate": "2020-04-04T20:40:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NjA4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r404376081", "bodyText": "Please update to take into account #54795 - reduces the class and removes a separate optimizer rule.", "author": "costin", "createdAt": "2020-04-06T20:43:44Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.ql.util.CollectionUtils;\n+\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isIPAndExact;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL specific cidrMatch function\n+ * Returns true if the source address matches any of the provided CIDR blocks.\n+ * Refer to: https://eql.readthedocs.io/en/latest/query-guide/functions.html#cidrMatch\n+ */\n+public class CIDRMatch extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> addresses;\n+\n+    public CIDRMatch(Source source, Expression field, List<Expression> addresses) {\n+        super(source, CollectionUtils.combine(singletonList(field), addresses));\n+        this.field = field;\n+        this.addresses = addresses;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution resolution = isIPAndExact(field, sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        for (Expression addr: addresses) {\n+            // Currently we have limited enum for ordinal numbers\n+            // So just using default here for error messaging\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.DEFAULT);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n+        int index = 1;\n+\n+        for (Expression addr: addresses) {\n+\n+            resolution = isFoldable(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            resolution = isStringAndExact(addr, sourceText(), ParamOrdinal.fromIndex(index));\n+            if (resolution.unresolved()) {\n+                break;\n+            }\n+\n+            index++;\n+        }\n+\n+        return resolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return field.foldable() && asFunction().foldable();\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asFunction().fold();\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, CIDRMatch::new, field, addresses);\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+        return new CIDRMatch(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    public ScalarFunction asFunction() {", "originalCommit": "16ff57dbcef47a5a8003265b2d69d8b579cfc931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4MjIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54186#discussion_r404382225", "bodyText": "Sure, will do once #54795 is merged.", "author": "aleksmaus", "createdAt": "2020-04-06T20:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NjA4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b1342e7dacb822a2f13feeabfc3a1db3232955d3", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\nindex 8d99e9ffea6..b7d5ea88ba3 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/CIDRMatch.java\n\n@@ -9,8 +9,8 @@ package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BaseSurrogateFunction;\n import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n import org.elasticsearch.xpack.ql.expression.predicate.operator.comparison.Equals;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n"}}, {"oid": "0e4280d4d7972b04b9c6c6df7b457f7bc632ca72", "url": "https://github.com/elastic/elasticsearch/commit/0e4280d4d7972b04b9c6c6df7b457f7bc632ca72", "message": "Merge branch 'master' into feature/cidrmatch", "committedDate": "2020-04-07T20:14:26Z", "type": "commit"}, {"oid": "5056054a74bc8e3f64a7f096477886f555199535", "url": "https://github.com/elastic/elasticsearch/commit/5056054a74bc8e3f64a7f096477886f555199535", "message": "Merge branch 'master' into feature/cidrmatch", "committedDate": "2020-04-07T20:50:43Z", "type": "commit"}, {"oid": "b1342e7dacb822a2f13feeabfc3a1db3232955d3", "url": "https://github.com/elastic/elasticsearch/commit/b1342e7dacb822a2f13feeabfc3a1db3232955d3", "message": "Convert to SurrogateFunction", "committedDate": "2020-04-07T21:11:46Z", "type": "commit"}]}