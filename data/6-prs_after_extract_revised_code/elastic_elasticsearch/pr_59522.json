{"pr_number": 59522, "pr_title": "Fix handling of final pipelines when destination is changed", "pr_createdAt": "2020-07-14T11:52:47Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59522", "timeline": [{"oid": "d645a903e981fe043667ee4ba44b15ef79c7b30d", "url": "https://github.com/elastic/elasticsearch/commit/d645a903e981fe043667ee4ba44b15ef79c7b30d", "message": "Fix handling of final pipelines when destination is changed", "committedDate": "2020-07-14T11:46:02Z", "type": "commit"}, {"oid": "9d6b5f030ffa6f6a376a208a70154a31328e36a7", "url": "https://github.com/elastic/elasticsearch/commit/9d6b5f030ffa6f6a376a208a70154a31328e36a7", "message": "cleanup", "committedDate": "2020-07-14T11:54:27Z", "type": "commit"}, {"oid": "506bdb856dc4238997d6212e2c515add170851d8", "url": "https://github.com/elastic/elasticsearch/commit/506bdb856dc4238997d6212e2c515add170851d8", "message": "Fix checkstyle", "committedDate": "2020-07-14T12:13:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MDM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r454850346", "bodyText": "I think this field should be volatile? A different thread sets this field and a different thread reads this field.", "author": "martijnvg", "createdAt": "2020-07-15T07:32:52Z", "path": "server/src/main/java/org/elasticsearch/ingest/IngestService.java", "diffHunk": "@@ -89,6 +95,7 @@\n     private final ThreadPool threadPool;\n     private final IngestMetric totalMetrics = new IngestMetric();\n     private final List<Consumer<ClusterState>> ingestClusterStateListeners = new CopyOnWriteArrayList<>();\n+    private ClusterState state;", "originalCommit": "506bdb856dc4238997d6212e2c515add170851d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2OTY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r455669693", "bodyText": "Good catch, I fixed it", "author": "probakowski", "createdAt": "2020-07-16T09:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MDM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "70d238daa416a5d5233ceeeaed0ae0fea33b50cc", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ingest/IngestService.java b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\nindex c90b1c96df8..f2dfb0daed6 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n\n@@ -95,7 +95,7 @@ public class IngestService implements ClusterStateApplier, ReportingService<Inge\n     private final ThreadPool threadPool;\n     private final IngestMetric totalMetrics = new IngestMetric();\n     private final List<Consumer<ClusterState>> ingestClusterStateListeners = new CopyOnWriteArrayList<>();\n-    private ClusterState state;\n+    private volatile ClusterState state;\n \n     public IngestService(ClusterService clusterService, ThreadPool threadPool,\n                          Environment env, ScriptService scriptService, AnalysisRegistry analysisRegistry,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r454853420", "bodyText": "I think if state is null then an error should be returned? If a node has been started and is ready to accept requests then all components like IngestService should have been provided a cluster state.", "author": "martijnvg", "createdAt": "2020-07-15T07:38:56Z", "path": "server/src/main/java/org/elasticsearch/ingest/IngestService.java", "diffHunk": "@@ -408,13 +522,39 @@ private void executePipelines(\n                     throw new IllegalArgumentException(\"pipeline with id [\" + pipelineId + \"] does not exist\");\n                 }\n                 Pipeline pipeline = holder.pipeline;\n+                String oldIndex = indexRequest.indices()[0];\n                 innerExecute(slot, indexRequest, pipeline, onDropped, e -> {\n                     if (e != null) {\n                         onFailure.accept(slot, e);\n                     }\n \n-                    if (it.hasNext()) {\n-                        executePipelines(slot, it, indexRequest, onDropped, onFailure, counter, onCompletion, originalThread);\n+                    String newIndex = indexRequest.indices()[0];\n+                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n+                        totalMetrics.ingestFailed();\n+                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n+                            \"] can't change the target index\"));\n+                    }\n+\n+                    Iterator<String> newIt = it;\n+                    boolean newHasFinalPipeline = hasFinalPipeline;\n+\n+                    if (oldIndex.equals(indexRequest.indices()[0]) == false && state != null) {", "originalCommit": "506bdb856dc4238997d6212e2c515add170851d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2OTU5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r455669597", "bodyText": "I removed the check, as you said state should be always filled, if not we have deeper problem here. WDYT?", "author": "probakowski", "createdAt": "2020-07-16T09:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3MTU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r456071563", "bodyText": "Yes, then there is a deeper problem elsewhere.\nBut that is not related to ingest or bulk.", "author": "martijnvg", "createdAt": "2020-07-16T20:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg1MzQyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c3353012b806e01290f29ba9babad8ef20b4cb08", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ingest/IngestService.java b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\nindex c90b1c96df8..3ff7bdf4ca7 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n\n@@ -528,23 +528,24 @@ public class IngestService implements ClusterStateApplier, ReportingService<Inge\n                         onFailure.accept(slot, e);\n                     }\n \n-                    String newIndex = indexRequest.indices()[0];\n-                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n-                        totalMetrics.ingestFailed();\n-                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n-                            \"] can't change the target index\"));\n-                    }\n-\n                     Iterator<String> newIt = it;\n                     boolean newHasFinalPipeline = hasFinalPipeline;\n+                    String newIndex = indexRequest.indices()[0];\n+\n+                    if (Objects.equals(oldIndex, newIndex) == false) {\n+                        if (hasFinalPipeline && it.hasNext() == false) {\n+                            totalMetrics.ingestFailed();\n+                            onFailure.accept(slot, new IllegalStateException(\"final pipeline [\" + pipelineId +\n+                                \"] can't change the target index\"));\n+                            return;\n+                        }\n \n-                    if (oldIndex.equals(indexRequest.indices()[0]) == false && state != null) {\n                         //Drain old it so it's not looped over\n                         it.forEachRemaining($ -> {\n                         });\n                         indexRequest.isPipelineResolved(false);\n                         resolvePipelines(null, indexRequest, state.metadata());\n-                        if(IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false){\n+                        if (IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false) {\n                             newIt = Collections.singleton(indexRequest.getFinalPipeline()).iterator();\n                             newHasFinalPipeline = true;\n                         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MzMxOA==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r454863318", "bodyText": "a return statement is missing here.", "author": "martijnvg", "createdAt": "2020-07-15T07:56:50Z", "path": "server/src/main/java/org/elasticsearch/ingest/IngestService.java", "diffHunk": "@@ -408,13 +522,39 @@ private void executePipelines(\n                     throw new IllegalArgumentException(\"pipeline with id [\" + pipelineId + \"] does not exist\");\n                 }\n                 Pipeline pipeline = holder.pipeline;\n+                String oldIndex = indexRequest.indices()[0];\n                 innerExecute(slot, indexRequest, pipeline, onDropped, e -> {\n                     if (e != null) {\n                         onFailure.accept(slot, e);\n                     }\n \n-                    if (it.hasNext()) {\n-                        executePipelines(slot, it, indexRequest, onDropped, onFailure, counter, onCompletion, originalThread);\n+                    String newIndex = indexRequest.indices()[0];\n+                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n+                        totalMetrics.ingestFailed();\n+                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n+                            \"] can't change the target index\"));", "originalCommit": "506bdb856dc4238997d6212e2c515add170851d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r455668834", "bodyText": "Fixed", "author": "probakowski", "createdAt": "2020-07-16T09:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2MzMxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c3353012b806e01290f29ba9babad8ef20b4cb08", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ingest/IngestService.java b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\nindex c90b1c96df8..3ff7bdf4ca7 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n\n@@ -528,23 +528,24 @@ public class IngestService implements ClusterStateApplier, ReportingService<Inge\n                         onFailure.accept(slot, e);\n                     }\n \n-                    String newIndex = indexRequest.indices()[0];\n-                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n-                        totalMetrics.ingestFailed();\n-                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n-                            \"] can't change the target index\"));\n-                    }\n-\n                     Iterator<String> newIt = it;\n                     boolean newHasFinalPipeline = hasFinalPipeline;\n+                    String newIndex = indexRequest.indices()[0];\n+\n+                    if (Objects.equals(oldIndex, newIndex) == false) {\n+                        if (hasFinalPipeline && it.hasNext() == false) {\n+                            totalMetrics.ingestFailed();\n+                            onFailure.accept(slot, new IllegalStateException(\"final pipeline [\" + pipelineId +\n+                                \"] can't change the target index\"));\n+                            return;\n+                        }\n \n-                    if (oldIndex.equals(indexRequest.indices()[0]) == false && state != null) {\n                         //Drain old it so it's not looped over\n                         it.forEachRemaining($ -> {\n                         });\n                         indexRequest.isPipelineResolved(false);\n                         resolvePipelines(null, indexRequest, state.metadata());\n-                        if(IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false){\n+                        if (IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false) {\n                             newIt = Collections.singleton(indexRequest.getFinalPipeline()).iterator();\n                             newHasFinalPipeline = true;\n                         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjQ5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r454866497", "bodyText": "Maybe Objects.equal(oldIndex, newIndex) == false instead of newIndex != null && oldIndex.equals(newIndex) == false", "author": "martijnvg", "createdAt": "2020-07-15T08:02:33Z", "path": "server/src/main/java/org/elasticsearch/ingest/IngestService.java", "diffHunk": "@@ -408,13 +522,39 @@ private void executePipelines(\n                     throw new IllegalArgumentException(\"pipeline with id [\" + pipelineId + \"] does not exist\");\n                 }\n                 Pipeline pipeline = holder.pipeline;\n+                String oldIndex = indexRequest.indices()[0];\n                 innerExecute(slot, indexRequest, pipeline, onDropped, e -> {\n                     if (e != null) {\n                         onFailure.accept(slot, e);\n                     }\n \n-                    if (it.hasNext()) {\n-                        executePipelines(slot, it, indexRequest, onDropped, onFailure, counter, onCompletion, originalThread);\n+                    String newIndex = indexRequest.indices()[0];\n+                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {", "originalCommit": "506bdb856dc4238997d6212e2c515add170851d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODczNA==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r455668734", "bodyText": "Yep, this is good idea, I've changed it", "author": "probakowski", "createdAt": "2020-07-16T09:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c3353012b806e01290f29ba9babad8ef20b4cb08", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ingest/IngestService.java b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\nindex c90b1c96df8..3ff7bdf4ca7 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n\n@@ -528,23 +528,24 @@ public class IngestService implements ClusterStateApplier, ReportingService<Inge\n                         onFailure.accept(slot, e);\n                     }\n \n-                    String newIndex = indexRequest.indices()[0];\n-                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n-                        totalMetrics.ingestFailed();\n-                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n-                            \"] can't change the target index\"));\n-                    }\n-\n                     Iterator<String> newIt = it;\n                     boolean newHasFinalPipeline = hasFinalPipeline;\n+                    String newIndex = indexRequest.indices()[0];\n+\n+                    if (Objects.equals(oldIndex, newIndex) == false) {\n+                        if (hasFinalPipeline && it.hasNext() == false) {\n+                            totalMetrics.ingestFailed();\n+                            onFailure.accept(slot, new IllegalStateException(\"final pipeline [\" + pipelineId +\n+                                \"] can't change the target index\"));\n+                            return;\n+                        }\n \n-                    if (oldIndex.equals(indexRequest.indices()[0]) == false && state != null) {\n                         //Drain old it so it's not looped over\n                         it.forEachRemaining($ -> {\n                         });\n                         indexRequest.isPipelineResolved(false);\n                         resolvePipelines(null, indexRequest, state.metadata());\n-                        if(IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false){\n+                        if (IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false) {\n                             newIt = Collections.singleton(indexRequest.getFinalPipeline()).iterator();\n                             newHasFinalPipeline = true;\n                         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2ODE4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r454868186", "bodyText": "maybe rename oldIndex to originalIndex?", "author": "martijnvg", "createdAt": "2020-07-15T08:05:45Z", "path": "server/src/main/java/org/elasticsearch/ingest/IngestService.java", "diffHunk": "@@ -408,13 +522,39 @@ private void executePipelines(\n                     throw new IllegalArgumentException(\"pipeline with id [\" + pipelineId + \"] does not exist\");\n                 }\n                 Pipeline pipeline = holder.pipeline;\n+                String oldIndex = indexRequest.indices()[0];", "originalCommit": "506bdb856dc4238997d6212e2c515add170851d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/59522#discussion_r455668020", "bodyText": "Done", "author": "probakowski", "createdAt": "2020-07-16T09:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2ODE4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c3353012b806e01290f29ba9babad8ef20b4cb08", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ingest/IngestService.java b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\nindex c90b1c96df8..3ff7bdf4ca7 100644\n--- a/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n+++ b/server/src/main/java/org/elasticsearch/ingest/IngestService.java\n\n@@ -528,23 +528,24 @@ public class IngestService implements ClusterStateApplier, ReportingService<Inge\n                         onFailure.accept(slot, e);\n                     }\n \n-                    String newIndex = indexRequest.indices()[0];\n-                    if (newIndex != null && oldIndex.equals(newIndex) == false && hasFinalPipeline && it.hasNext() == false) {\n-                        totalMetrics.ingestFailed();\n-                        onFailure.accept(slot, new IllegalStateException(\"final pipeline [\"+ pipelineId +\n-                            \"] can't change the target index\"));\n-                    }\n-\n                     Iterator<String> newIt = it;\n                     boolean newHasFinalPipeline = hasFinalPipeline;\n+                    String newIndex = indexRequest.indices()[0];\n+\n+                    if (Objects.equals(oldIndex, newIndex) == false) {\n+                        if (hasFinalPipeline && it.hasNext() == false) {\n+                            totalMetrics.ingestFailed();\n+                            onFailure.accept(slot, new IllegalStateException(\"final pipeline [\" + pipelineId +\n+                                \"] can't change the target index\"));\n+                            return;\n+                        }\n \n-                    if (oldIndex.equals(indexRequest.indices()[0]) == false && state != null) {\n                         //Drain old it so it's not looped over\n                         it.forEachRemaining($ -> {\n                         });\n                         indexRequest.isPipelineResolved(false);\n                         resolvePipelines(null, indexRequest, state.metadata());\n-                        if(IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false){\n+                        if (IngestService.NOOP_PIPELINE_NAME.equals(indexRequest.getFinalPipeline()) == false) {\n                             newIt = Collections.singleton(indexRequest.getFinalPipeline()).iterator();\n                             newHasFinalPipeline = true;\n                         } else {\n"}}, {"oid": "c3353012b806e01290f29ba9babad8ef20b4cb08", "url": "https://github.com/elastic/elasticsearch/commit/c3353012b806e01290f29ba9babad8ef20b4cb08", "message": "Fixed null checks", "committedDate": "2020-07-16T09:51:51Z", "type": "commit"}, {"oid": "70d238daa416a5d5233ceeeaed0ae0fea33b50cc", "url": "https://github.com/elastic/elasticsearch/commit/70d238daa416a5d5233ceeeaed0ae0fea33b50cc", "message": "volatile", "committedDate": "2020-07-16T09:52:04Z", "type": "commit"}, {"oid": "71c53fa5acdddafb12fd68d5d5616bf7970bb583", "url": "https://github.com/elastic/elasticsearch/commit/71c53fa5acdddafb12fd68d5d5616bf7970bb583", "message": "originalIndex", "committedDate": "2020-07-16T09:53:35Z", "type": "commit"}, {"oid": "fed7c6fbd1057c05b86702289a4df9d50824bdd1", "url": "https://github.com/elastic/elasticsearch/commit/fed7c6fbd1057c05b86702289a4df9d50824bdd1", "message": "revert debug changes", "committedDate": "2020-07-16T09:59:43Z", "type": "commit"}, {"oid": "cf5c1dbf607ee2bb6ba7b6d1209ab6719bc0b91e", "url": "https://github.com/elastic/elasticsearch/commit/cf5c1dbf607ee2bb6ba7b6d1209ab6719bc0b91e", "message": "additional test", "committedDate": "2020-07-16T10:05:55Z", "type": "commit"}, {"oid": "09780271211ccb41a18fdc27dddce44d4f6c965a", "url": "https://github.com/elastic/elasticsearch/commit/09780271211ccb41a18fdc27dddce44d4f6c965a", "message": "Merge branch 'master' into final-pipeline", "committedDate": "2020-07-16T10:15:24Z", "type": "commit"}, {"oid": "0df296caaf806f12d9db34dd6e58350d9df8f551", "url": "https://github.com/elastic/elasticsearch/commit/0df296caaf806f12d9db34dd6e58350d9df8f551", "message": "fix test", "committedDate": "2020-07-16T14:18:26Z", "type": "commit"}]}