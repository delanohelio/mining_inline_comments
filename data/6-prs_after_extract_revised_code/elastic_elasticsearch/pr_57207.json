{"pr_number": 57207, "pr_title": "Fix casting of scaled_float in sorts", "pr_createdAt": "2020-05-27T12:47:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57207", "timeline": [{"oid": "572f090b9cb4cf57db599ef9243cc25fd8a58218", "url": "https://github.com/elastic/elasticsearch/commit/572f090b9cb4cf57db599ef9243cc25fd8a58218", "message": "Fix casting of scaled_float in sorts\n\nPreviously we'd get a `ClassCastException` when you tried to use\n`numeric_type` on `scaled_float`. Oops! This cleans up the CCE and moves\nsome code around so the casting actually works.", "committedDate": "2020-05-27T12:41:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzkyOA==", "url": "https://github.com/elastic/elasticsearch/pull/57207#discussion_r432623928", "bodyText": "Maybe leave a comment in here about why half_floats need a custom comparator?  I'm assuming their encoding makes them non-ordered or something?", "author": "polyfractal", "createdAt": "2020-05-29T17:10:59Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/plain/SortedNumericIndexFieldData.java", "diffHunk": "@@ -113,95 +101,29 @@ public final Index index() {\n         return index;\n     }\n \n-    /**\n-     * Returns the {@link SortField} to used for sorting.\n-     * Values are casted to the provided <code>targetNumericType</code> type if it doesn't\n-     * match the field's <code>numericType</code>.\n-     */\n-    public SortField sortField(NumericType targetNumericType, Object missingValue, MultiValueMode sortMode,\n-                               Nested nested, boolean reverse) {\n-        final XFieldComparatorSource source = comparatorSource(targetNumericType, missingValue, sortMode, nested);\n-\n-        /**\n-         * Check if we can use a simple {@link SortedNumericSortField} compatible with index sorting and\n-         * returns a custom sort field otherwise.\n-         */\n-        if (nested != null\n-                || (sortMode != MultiValueMode.MAX && sortMode != MultiValueMode.MIN)\n-                || numericType == NumericType.HALF_FLOAT\n-                || targetNumericType != numericType) {\n-            return new SortField(fieldName, source, reverse);\n-        }\n-\n-        final SortField sortField;\n-        final SortedNumericSelector.Type selectorType = sortMode == MultiValueMode.MAX ?\n-            SortedNumericSelector.Type.MAX : SortedNumericSelector.Type.MIN;\n-        switch (numericType) {\n-            case FLOAT:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.FLOAT, reverse, selectorType);\n-                break;\n-\n-            case DOUBLE:\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.DOUBLE, reverse, selectorType);\n-                break;\n-\n-            default:\n-                assert !numericType.isFloatingPoint();\n-                sortField = new SortedNumericSortField(fieldName, SortField.Type.LONG, reverse, selectorType);\n-                break;\n-        }\n-        sortField.setMissingValue(source.missingObject(missingValue, reverse));\n-        return sortField;\n-    }\n-\n     @Override\n-    public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {\n-        return sortField(numericType, missingValue, sortMode, nested, reverse);\n-    }\n-\n-    /**\n-     * Builds a {@linkplain BucketedSort} for the {@code targetNumericType},\n-     * casting the values if their native type doesn't match.\n-     */\n-    public BucketedSort newBucketedSort(NumericType targetNumericType, BigArrays bigArrays, @Nullable Object missingValue,\n-            MultiValueMode sortMode, Nested nested, SortOrder sortOrder, DocValueFormat format,\n-            int bucketSize, BucketedSort.ExtraData extra) {\n-        return comparatorSource(targetNumericType, missingValue, sortMode, nested)\n-                .newBucketedSort(bigArrays, sortOrder, format, bucketSize, extra);\n+    protected boolean sortRequiresCustomComparator() {\n+        return numericType == NumericType.HALF_FLOAT;", "originalCommit": "572f090b9cb4cf57db599ef9243cc25fd8a58218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4ODQ2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57207#discussion_r432688462", "bodyText": "I believe that is so. I'll dig and leave a comment.", "author": "nik9000", "createdAt": "2020-05-29T19:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzkyOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "d0b549cb0edbd85a7a6b4f696fa212fd16ea8ddc", "url": "https://github.com/elastic/elasticsearch/commit/d0b549cb0edbd85a7a6b4f696fa212fd16ea8ddc", "message": "Explain why custom comparator", "committedDate": "2020-05-29T19:29:38Z", "type": "commit"}, {"oid": "42c9090b8977fe2d74752d382689950b8c1f1706", "url": "https://github.com/elastic/elasticsearch/commit/42c9090b8977fe2d74752d382689950b8c1f1706", "message": "Merge branch 'master' into fix_scaled_float_sort_casting", "committedDate": "2020-05-29T20:07:19Z", "type": "commit"}]}