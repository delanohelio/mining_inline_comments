{"pr_number": 52642, "pr_title": "Address MinAndMax generics warnings", "pr_createdAt": "2020-02-21T14:23:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52642", "timeline": [{"oid": "409f76059279a0e952bb743ced3472ef9da3c6ac", "url": "https://github.com/elastic/elasticsearch/commit/409f76059279a0e952bb743ced3472ef9da3c6ac", "message": "Address MinAndMax generics warnings\n\nThe MinAndMax encapsulates min and max values for a shard. It uses generics to make sure that the values are of the same type and are also comparable. Though there are warnings whenever this class is currently used, which are addressed with this commit.\n\nRelates to #49092", "committedDate": "2020-02-21T14:21:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52642#discussion_r382657150", "bodyText": "should it be a Function<byte[], ? extends T> to avoid the unchecked cast?", "author": "jpountz", "createdAt": "2020-02-21T15:50:37Z", "path": "server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java", "diffHunk": "@@ -520,6 +518,14 @@ public static FieldSortBuilder getPrimaryFieldSortOrNull(SearchSourceBuilder sou\n         return null;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    private static <T extends Comparable<T>> MinAndMax<T> extractMinAndMax(IndexReader reader, String fieldName,\n+                                                              Function<byte[], Comparable<?>> converter) throws IOException {", "originalCommit": "409f76059279a0e952bb743ced3472ef9da3c6ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MjQzOA==", "url": "https://github.com/elastic/elasticsearch/pull/52642#discussion_r382662438", "bodyText": "great point, I missed this", "author": "javanna", "createdAt": "2020-02-21T15:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "38c03edbc319482799c5375aab6167fa0681f351", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java b/server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java\nindex d4ff2b66259..efd359538ac 100644\n--- a/server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java\n+++ b/server/src/main/java/org/elasticsearch/search/sort/FieldSortBuilder.java\n\n@@ -485,45 +445,71 @@ public class FieldSortBuilder extends SortBuilder<FieldSortBuilder> {\n         if (reader == null || (fieldType == null || fieldType.indexOptions() == IndexOptions.NONE)) {\n             return null;\n         }\n-        String fieldName = fieldType.name();\n         switch (IndexSortConfig.getSortFieldType(sortField)) {\n             case LONG:\n             case INT:\n             case DOUBLE:\n             case FLOAT:\n-                final Function<byte[], Comparable<?>> converter;\n-                if (fieldType instanceof NumberFieldType) {\n-                    converter = numericPointConverter(sortField, (NumberFieldType) fieldType);\n-                } else if (fieldType instanceof DateFieldType) {\n-                    converter = datePointConverter((DateFieldType) fieldType, sortBuilder.getNumericType());\n-                } else {\n-                    return null;\n-                }\n-                if (PointValues.size(reader, fieldName) == 0) {\n-                    return null;\n-                }\n-                return extractMinAndMax(reader, fieldName, converter);\n-\n+                return extractNumericMinAndMax(reader, sortField, fieldType, sortBuilder);\n             case STRING:\n             case STRING_VAL:\n                 if (fieldType instanceof KeywordFieldMapper.KeywordFieldType) {\n-                    Terms terms = MultiTerms.getTerms(reader, fieldName);\n+                    Terms terms = MultiTerms.getTerms(reader, fieldType.name());\n                     if (terms == null) {\n                         return null;\n                     }\n-                    return terms.getMin() != null ? MinAndMax.newMinMax(terms.getMin(), terms.getMax()) : null;\n+                    return terms.getMin() != null ? new MinAndMax<>(terms.getMin(), terms.getMax()) : null;\n                 }\n                 break;\n         }\n         return null;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private static <T extends Comparable<T>> MinAndMax<T> extractMinAndMax(IndexReader reader, String fieldName,\n-                                                              Function<byte[], Comparable<?>> converter) throws IOException {\n-        final T min = (T)converter.apply(PointValues.getMinPackedValue(reader, fieldName));\n-        final T max = (T)converter.apply(PointValues.getMaxPackedValue(reader, fieldName));\n-        return MinAndMax.newMinMax(min, max);\n+    private static MinAndMax<?> extractNumericMinAndMax(IndexReader reader,\n+                                                        SortField sortField,\n+                                                        MappedFieldType fieldType,\n+                                                        FieldSortBuilder sortBuilder) throws IOException {\n+        String fieldName = fieldType.name();\n+        if (PointValues.size(reader, fieldName) == 0) {\n+            return null;\n+        }\n+        if (fieldType instanceof NumberFieldType) {\n+            NumberFieldType numberFieldType = (NumberFieldType) fieldType;\n+            Number minPoint = numberFieldType.parsePoint(PointValues.getMinPackedValue(reader, fieldName));\n+            Number maxPoint = numberFieldType.parsePoint(PointValues.getMaxPackedValue(reader, fieldName));\n+            switch (IndexSortConfig.getSortFieldType(sortField)) {\n+                case LONG:\n+                    return new MinAndMax<>(minPoint.longValue(), maxPoint.longValue());\n+                case INT:\n+                    return new MinAndMax<>(minPoint.intValue(), maxPoint.intValue());\n+                case DOUBLE:\n+                    return new MinAndMax<>(minPoint.doubleValue(), maxPoint.doubleValue());\n+                case FLOAT:\n+                    return new MinAndMax<>(minPoint.floatValue(), maxPoint.floatValue());\n+                default:\n+                    return null;\n+            }\n+        } else if (fieldType instanceof DateFieldType) {\n+            DateFieldType dateFieldType = (DateFieldType) fieldType;\n+            Function<byte[], Long> dateConverter = createDateConverter(sortBuilder, dateFieldType);\n+            Long min = dateConverter.apply(PointValues.getMinPackedValue(reader, fieldName));\n+            Long max = dateConverter.apply(PointValues.getMaxPackedValue(reader, fieldName));\n+            return new MinAndMax<>(min, max);\n+        }\n+        return null;\n+    }\n+\n+    private static Function<byte[], Long> createDateConverter(FieldSortBuilder sortBuilder, DateFieldType dateFieldType) {\n+        String numericTypeStr = sortBuilder.getNumericType();\n+        if (numericTypeStr != null) {\n+            NumericType numericType = resolveNumericType(numericTypeStr);\n+            if (dateFieldType.resolution() == MILLISECONDS && numericType == NumericType.DATE_NANOSECONDS) {\n+                return v -> DateUtils.toNanoSeconds(LongPoint.decodeDimension(v, 0));\n+            } else if (dateFieldType.resolution() == NANOSECONDS && numericType == NumericType.DATE) {\n+                return v -> DateUtils.toMilliSeconds(LongPoint.decodeDimension(v, 0));\n+            }\n+        }\n+        return v -> LongPoint.decodeDimension(v, 0);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52642#discussion_r382658139", "bodyText": "In general this is the right way to use generics with Comparable?", "author": "jpountz", "createdAt": "2020-02-21T15:52:13Z", "path": "server/src/main/java/org/elasticsearch/search/sort/MinAndMax.java", "diffHunk": "@@ -29,9 +29,9 @@\n import java.util.Objects;\n \n /**\n- * A class that encapsulates a minimum and a maximum {@link Comparable}.\n+ * A class that encapsulates a minimum and a maximum, that are of the same type and {@link Comparable}.\n  */\n-public class MinAndMax<T extends Comparable<? super T>> implements Writeable {\n+public class MinAndMax<T extends Comparable<T>> implements Writeable {", "originalCommit": "409f76059279a0e952bb743ced3472ef9da3c6ac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "38c03edbc319482799c5375aab6167fa0681f351", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/sort/MinAndMax.java b/server/src/main/java/org/elasticsearch/search/sort/MinAndMax.java\nindex 942f572cb37..19986f171f5 100644\n--- a/server/src/main/java/org/elasticsearch/search/sort/MinAndMax.java\n+++ b/server/src/main/java/org/elasticsearch/search/sort/MinAndMax.java\n\n@@ -35,7 +35,7 @@ public class MinAndMax<T extends Comparable<T>> implements Writeable {\n     private final T minValue;\n     private final T maxValue;\n \n-    private MinAndMax(T minValue, T maxValue) {\n+    public MinAndMax(T minValue, T maxValue) {\n         this.minValue = Objects.requireNonNull(minValue);\n         this.maxValue = Objects.requireNonNull(maxValue);\n     }\n"}}, {"oid": "38c03edbc319482799c5375aab6167fa0681f351", "url": "https://github.com/elastic/elasticsearch/commit/38c03edbc319482799c5375aab6167fa0681f351", "message": "iter", "committedDate": "2020-02-25T11:17:56Z", "type": "commit"}, {"oid": "7ab696bc5ea8842148b395d3f60f5f25b5b3031a", "url": "https://github.com/elastic/elasticsearch/commit/7ab696bc5ea8842148b395d3f60f5f25b5b3031a", "message": "fix compile", "committedDate": "2020-02-25T16:41:32Z", "type": "commit"}, {"oid": "4a3123cdbf39ba31e133cc56746415a6c402ee45", "url": "https://github.com/elastic/elasticsearch/commit/4a3123cdbf39ba31e133cc56746415a6c402ee45", "message": "iter", "committedDate": "2020-02-28T12:46:20Z", "type": "commit"}, {"oid": "2a66855d857960bbe77132cf23fc0d4808b5772d", "url": "https://github.com/elastic/elasticsearch/commit/2a66855d857960bbe77132cf23fc0d4808b5772d", "message": "Merge branch 'master' into enhancement/minmax_generics", "committedDate": "2020-02-28T15:08:03Z", "type": "commit"}, {"oid": "2d6261b3cdad0bcb17e0c2cc3df3b646cd35d86c", "url": "https://github.com/elastic/elasticsearch/commit/2d6261b3cdad0bcb17e0c2cc3df3b646cd35d86c", "message": "Merge branch 'master' into enhancement/minmax_generics", "committedDate": "2020-02-28T16:15:24Z", "type": "commit"}]}