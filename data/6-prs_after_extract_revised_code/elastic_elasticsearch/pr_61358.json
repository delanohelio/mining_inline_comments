{"pr_number": 61358, "pr_title": "Speed up Compression Logic by Pooling Resources", "pr_createdAt": "2020-08-20T08:17:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61358", "timeline": [{"oid": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "url": "https://github.com/elastic/elasticsearch/commit/d717a47cdb6d00c023cf1d04f02438beed19a4c6", "message": "Speed up Compression Logic by Pooling Resources\n\nThis is mostly motivated by the performance issues we are seeing around the GET mappings\nREST API which (in case of a large number of indices) will create decompressing streams in a hot loop\nwhich takes a significant amount of time for the system calls involved in instantiating deflaters\nand inflaters.\nAlso, this fixes a leaked deflater when deserializing cached repository data.", "committedDate": "2020-08-20T08:09:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MTgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473751816", "bodyText": "No need for this kind of extra atomic boolean+check, the BufferedOutputStream is a filter output stream that will only close once.", "author": "original-brownbear", "createdAt": "2020-08-20T08:20:38Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +142,64 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (current.inUse) {\n+            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        } else {\n+            inflater = current.get();\n+            releasable = current;\n+        }\n+        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    releasable.close();\n                 }\n             }\n         };\n+        return new InputStreamStreamInput(new BufferedInputStream(decompressedIn, BUFFER_SIZE));\n     }\n \n     @Override\n     public StreamOutput streamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n-        final boolean nowrap = true;\n-        final Deflater deflater = new Deflater(LEVEL, nowrap);\n+        final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Deflater deflater;\n+        if (current.inUse) {\n+            // Nested compression streams should not happen but we still handle them safely by using a fresh Deflater\n+            deflater = new Deflater(LEVEL, true);\n+            releasable = deflater::end;\n+        } else {\n+            deflater = current.get();\n+            releasable = current;\n+        }\n         final boolean syncFlush = true;\n-        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush);\n-        OutputStream compressedOut = new BufferedOutputStream(deflaterOutputStream, BUFFER_SIZE);\n-        return new OutputStreamStreamOutput(compressedOut) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        deflater.end();\n-                    }\n+                    releasable.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODE3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474108177", "bodyText": "Let's add this as a code comment", "author": "jaymode", "createdAt": "2020-08-20T16:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MTgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\nindex 28824936e97..c57b2bfd120 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n\n@@ -142,32 +156,38 @@ public class DeflateCompressor implements Compressor {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n         final Releasable releasable;\n         final Inflater inflater;\n-        if (current.inUse) {\n-            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+        if (threadLocal) {\n+            final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+            if (current.inUse) {\n+                // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+                inflater = new Inflater(true);\n+                releasable = inflater::end;\n+            } else {\n+                inflater = current.get();\n+                releasable = current;\n+            }\n+        } else {\n             inflater = new Inflater(true);\n             releasable = inflater::end;\n-        } else {\n-            inflater = current.get();\n-            releasable = current;\n         }\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+        return new BufferedInputStream(new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n             @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n+                    // We are ensured to only call this once since we wrap this stream in a BufferedInputStream that will only close\n+                    // its delegate once\n                     releasable.close();\n                 }\n             }\n-        };\n-        return new InputStreamStreamInput(new BufferedInputStream(decompressedIn, BUFFER_SIZE));\n+        }, BUFFER_SIZE);\n     }\n \n     @Override\n-    public StreamOutput streamOutput(OutputStream out) throws IOException {\n+    public StreamOutput threadLocalStreamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n         final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n         final Releasable releasable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MjQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473752484", "bodyText": "No need for this kind of extra atomic boolean+check, the BufferedInputStream will only close once.", "author": "original-brownbear", "createdAt": "2020-08-20T08:21:21Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +142,64 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (current.inUse) {\n+            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        } else {\n+            inflater = current.get();\n+            releasable = current;\n+        }\n+        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    releasable.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwODAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474108008", "bodyText": "Let's add this as a code comment", "author": "jaymode", "createdAt": "2020-08-20T16:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MjQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\nindex 28824936e97..c57b2bfd120 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n\n@@ -142,32 +156,38 @@ public class DeflateCompressor implements Compressor {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n         final Releasable releasable;\n         final Inflater inflater;\n-        if (current.inUse) {\n-            // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+        if (threadLocal) {\n+            final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+            if (current.inUse) {\n+                // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+                inflater = new Inflater(true);\n+                releasable = inflater::end;\n+            } else {\n+                inflater = current.get();\n+                releasable = current;\n+            }\n+        } else {\n             inflater = new Inflater(true);\n             releasable = inflater::end;\n-        } else {\n-            inflater = current.get();\n-            releasable = current;\n         }\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+        return new BufferedInputStream(new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n             @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n+                    // We are ensured to only call this once since we wrap this stream in a BufferedInputStream that will only close\n+                    // its delegate once\n                     releasable.close();\n                 }\n             }\n-        };\n-        return new InputStreamStreamInput(new BufferedInputStream(decompressedIn, BUFFER_SIZE));\n+        }, BUFFER_SIZE);\n     }\n \n     @Override\n-    public StreamOutput streamOutput(OutputStream out) throws IOException {\n+    public StreamOutput threadLocalStreamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n         final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n         final Releasable releasable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1MzM1OA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473753358", "bodyText": "This was just a bug where we failed to close the stream and that became visible with the changes in this PR.", "author": "original-brownbear", "createdAt": "2020-08-20T08:22:21Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -1331,10 +1332,11 @@ private void cacheRepositoryData(BytesReference updated, long generation) {\n     }\n \n     private RepositoryData repositoryDataFromCachedEntry(Tuple<Long, BytesReference> cacheEntry) throws IOException {\n-        return RepositoryData.snapshotsFromXContent(\n-            XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY,\n-                LoggingDeprecationHandler.INSTANCE,\n-                CompressorFactory.COMPRESSOR.streamInput(cacheEntry.v2().streamInput())), cacheEntry.v1(), false);\n+        try (StreamInput input = CompressorFactory.COMPRESSOR.streamInput(cacheEntry.v2().streamInput())) {", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java b/server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java\nindex a34e60a3acc..bfc04017c6c 100644\n--- a/server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java\n+++ b/server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java\n\n@@ -1332,7 +1332,7 @@ public abstract class BlobStoreRepository extends AbstractLifecycleComponent imp\n     }\n \n     private RepositoryData repositoryDataFromCachedEntry(Tuple<Long, BytesReference> cacheEntry) throws IOException {\n-        try (StreamInput input = CompressorFactory.COMPRESSOR.streamInput(cacheEntry.v2().streamInput())) {\n+        try (StreamInput input = CompressorFactory.COMPRESSOR.threadLocalStreamInput(cacheEntry.v2().streamInput())) {\n             return RepositoryData.snapshotsFromXContent(\n                     XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY,\n                             LoggingDeprecationHandler.INSTANCE, input), cacheEntry.v1(), false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc1NDc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r473754749", "bodyText": "We do have compressed mapping sources in the cluster state that itself comes to us in compressed form so not closing here would actually lead to not having nested decompression streams so I added the early close.", "author": "original-brownbear", "createdAt": "2020-08-20T08:23:51Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -145,6 +145,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                 final ClusterState incomingState;\n                 try {\n                     incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n+                    // Close early to release resources used by the de-compression as early as possible\n+                    in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\nindex 3899881a789..db711955263 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n\n@@ -136,17 +136,16 @@ public class PublicationTransportHandler {\n         StreamInput in = request.bytes().streamInput();\n         try {\n             if (compressor != null) {\n-                in = compressor.streamInput(in);\n+                in = compressor.threadLocalStreamInput(in);\n             }\n             in = new NamedWriteableAwareStreamInput(in, namedWriteableRegistry);\n             in.setVersion(request.version());\n             // If true we received full cluster state - otherwise diffs\n             if (in.readBoolean()) {\n                 final ClusterState incomingState;\n-                try {\n-                    incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n-                    // Close early to release resources used by the de-compression as early as possible\n-                    in.close();\n+                // Close early to release resources used by the de-compression as early as possible\n+                try (StreamInput input = in) {\n+                    incomingState = ClusterState.readFrom(input, transportService.getLocalNode());\n                 } catch (Exception e){\n                     logger.warn(\"unexpected error while deserializing an incoming cluster state\", e);\n                     throw e;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474100977", "bodyText": "How about using try with resources?", "author": "jaymode", "createdAt": "2020-08-20T16:08:42Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -145,6 +145,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                 final ClusterState incomingState;\n                 try {\n                     incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n+                    // Close early to release resources used by the de-compression as early as possible\n+                    in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\nindex 3899881a789..db711955263 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n\n@@ -136,17 +136,16 @@ public class PublicationTransportHandler {\n         StreamInput in = request.bytes().streamInput();\n         try {\n             if (compressor != null) {\n-                in = compressor.streamInput(in);\n+                in = compressor.threadLocalStreamInput(in);\n             }\n             in = new NamedWriteableAwareStreamInput(in, namedWriteableRegistry);\n             in.setVersion(request.version());\n             // If true we received full cluster state - otherwise diffs\n             if (in.readBoolean()) {\n                 final ClusterState incomingState;\n-                try {\n-                    incomingState = ClusterState.readFrom(in, transportService.getLocalNode());\n-                    // Close early to release resources used by the de-compression as early as possible\n-                    in.close();\n+                // Close early to release resources used by the de-compression as early as possible\n+                try (StreamInput input = in) {\n+                    incomingState = ClusterState.readFrom(input, transportService.getLocalNode());\n                 } catch (Exception e){\n                     logger.warn(\"unexpected error while deserializing an incoming cluster state\", e);\n                     throw e;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTYzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474101637", "bodyText": "Is it that important to close before applying the diff here? Otherwise you could use try with resources", "author": "jaymode", "createdAt": "2020-08-20T16:09:38Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -165,6 +167,8 @@ private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportReque\n                     ClusterState incomingState;\n                     try {\n                         Diff<ClusterState> diff = ClusterState.readDiffFrom(in, lastSeen.nodes().getLocalNode());\n+                        // Close early to release resources used by the de-compression as early as possible\n+                        in.close();", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MDc5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474190795", "bodyText": "Yea we want to get the handle for the Inflater before because index metadata operations will use it potentially, but just closing here is pretty lazy admittedly, I'll make it nicer using try-with-resources.", "author": "original-brownbear", "createdAt": "2020-08-20T18:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\nindex 3899881a789..db711955263 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java\n\n@@ -166,9 +165,11 @@ public class PublicationTransportHandler {\n                 } else {\n                     ClusterState incomingState;\n                     try {\n-                        Diff<ClusterState> diff = ClusterState.readDiffFrom(in, lastSeen.nodes().getLocalNode());\n-                        // Close early to release resources used by the de-compression as early as possible\n-                        in.close();\n+                        final Diff<ClusterState> diff;\n+                        // Close stream early to release resources used by the de-compression as early as possible\n+                        try (StreamInput input = in) {\n+                            diff = ClusterState.readDiffFrom(input, lastSeen.nodes().getLocalNode());\n+                        }\n                         incomingState = diff.apply(lastSeen); // might throw IncompatibleClusterStateVersionException\n                     } catch (IncompatibleClusterStateVersionException e) {\n                         incompatibleClusterStateDiffReceivedCount.incrementAndGet();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMTg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474101880", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Creates a new stream input that decompresses the contents read from teh provided stream input.\n          \n          \n            \n                 * Creates a new stream input that decompresses the contents read from the provided stream input.", "author": "jaymode", "createdAt": "2020-08-20T16:10:00Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\nindex 0d8856c6614..970ab1706b3 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n\n@@ -33,12 +33,12 @@ public interface Compressor {\n     int headerLength();\n \n     /**\n-     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Creates a new stream input that decompresses the contents read from the provided stream input.\n      * Closing the returned {@link StreamInput} will close the provided stream input.\n      * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n      * closed after use\n      */\n-    StreamInput streamInput(StreamInput in) throws IOException;\n+    StreamInput threadLocalStreamInput(StreamInput in) throws IOException;\n \n     /**\n      * Creates a new stream output that compresses the contents and writes to the provided stream\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474103028", "bodyText": "Maybe name this method something like unsafeStreamInput or threadLocalStreamInput?", "author": "jaymode", "createdAt": "2020-08-20T16:11:43Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Closing the returned {@link StreamInput} will close the provided stream input.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n+     */\n     StreamInput streamInput(StreamInput in) throws IOException;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\nindex 0d8856c6614..970ab1706b3 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n\n@@ -33,12 +33,12 @@ public interface Compressor {\n     int headerLength();\n \n     /**\n-     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Creates a new stream input that decompresses the contents read from the provided stream input.\n      * Closing the returned {@link StreamInput} will close the provided stream input.\n      * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n      * closed after use\n      */\n-    StreamInput streamInput(StreamInput in) throws IOException;\n+    StreamInput threadLocalStreamInput(StreamInput in) throws IOException;\n \n     /**\n      * Creates a new stream output that compresses the contents and writes to the provided stream\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzYwMw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474103603", "bodyText": "Maybe name this method something like unsafeStreamOutput or threadLocalStreamOutput?", "author": "jaymode", "createdAt": "2020-08-20T16:12:36Z", "path": "server/src/main/java/org/elasticsearch/common/compress/Compressor.java", "diffHunk": "@@ -32,11 +32,19 @@\n \n     int headerLength();\n \n+    /**\n+     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Closing the returned {@link StreamInput} will close the provided stream input.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n+     */\n     StreamInput streamInput(StreamInput in) throws IOException;\n \n     /**\n      * Creates a new stream output that compresses the contents and writes to the provided stream\n      * output. Closing the returned {@link StreamOutput} will close the provided stream output.\n+     * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n+     * closed after use\n      */\n     StreamOutput streamOutput(OutputStream out) throws IOException;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5OTAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474199008", "bodyText": "edited: nevermind my previous comment unsafeStreamOutput is fine :) I'll special case the http exporter situation another way :)", "author": "original-brownbear", "createdAt": "2020-08-20T18:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMzYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\nindex 0d8856c6614..970ab1706b3 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/Compressor.java\n\n@@ -33,12 +33,12 @@ public interface Compressor {\n     int headerLength();\n \n     /**\n-     * Creates a new stream input that decompresses the contents read from teh provided stream input.\n+     * Creates a new stream input that decompresses the contents read from the provided stream input.\n      * Closing the returned {@link StreamInput} will close the provided stream input.\n      * Note: The returned stream may only be used on the thread that created it as it might use thread-local resources and must be safely\n      * closed after use\n      */\n-    StreamInput streamInput(StreamInput in) throws IOException;\n+    StreamInput threadLocalStreamInput(StreamInput in) throws IOException;\n \n     /**\n      * Creates a new stream output that compresses the contents and writes to the provided stream\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwNTIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474105217", "bodyText": "s/user/thread ?\nAlso maybe add a note that this is only used when assertions are enabled?", "author": "jaymode", "createdAt": "2020-08-20T16:15:14Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -73,6 +74,59 @@ public int headerLength() {\n         return HEADER.length;\n     }\n \n+    // Reusable inflater reference for streaming decompression\n+    private static final ThreadLocal<ReleasableReference<Inflater>> inflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Inflater inflater = new Inflater(true);\n+        return new ReleasableReference<>(inflater, inflater::reset);\n+    });\n+\n+    // Reusable deflater reference for streaming compression\n+    private static final ThreadLocal<ReleasableReference<Deflater>> deflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Deflater deflater = new Deflater(LEVEL, true);\n+        return new ReleasableReference<>(deflater, deflater::reset);\n+    });\n+\n+    // Reference to a deflater or inflater that is used to make sure we do not use the same stream twice when nesting streams.\n+    private static final class ReleasableReference<T> implements Releasable {\n+\n+        protected final T resource;\n+\n+        private final Releasable releasable;\n+\n+        // Thread that is currently using this reference\n+        private Thread user = null;", "originalCommit": "d717a47cdb6d00c023cf1d04f02438beed19a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\nindex 28824936e97..c57b2bfd120 100644\n--- a/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n+++ b/server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java\n\n@@ -93,8 +93,8 @@ public class DeflateCompressor implements Compressor {\n \n         private final Releasable releasable;\n \n-        // Thread that is currently using this reference\n-        private Thread user = null;\n+        // Thread that is currently using this reference. Only used for assertions and only assigned if assertions are enabled.\n+        private Thread thread = null;\n \n         // true if this reference is currently in use and is not available for re-use\n         boolean inUse;\n"}}, {"oid": "f10df36ad024f50bc236d152c016e00bbe09974c", "url": "https://github.com/elastic/elasticsearch/commit/f10df36ad024f50bc236d152c016e00bbe09974c", "message": "Merge remote-tracking branch 'elastic/master' into faster-compression-2", "committedDate": "2020-08-20T18:31:00Z", "type": "commit"}, {"oid": "24afec1e19db5daaa45f52fce3f1218cbc667300", "url": "https://github.com/elastic/elasticsearch/commit/24afec1e19db5daaa45f52fce3f1218cbc667300", "message": "Merge remote-tracking branch 'elastic/master' into faster-compression-2", "committedDate": "2020-08-21T05:30:27Z", "type": "commit"}, {"oid": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "url": "https://github.com/elastic/elasticsearch/commit/44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "message": "CR: comments", "committedDate": "2020-08-21T06:39:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0OTMxOA==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r474549318", "bodyText": "I know this is breaking with the style of the Compressor interface a little but I figured it was the simplest to just expose this as a static utility directly.\nAlso, I wonder if we shouldn't just make all the methods on this class static and do away with the Compressor interface. We only have one implementation that we use via its singleton, so there isn't much point in doing in having that interface around?", "author": "original-brownbear", "createdAt": "2020-08-21T09:00:28Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -73,8 +74,75 @@ public int headerLength() {\n         return HEADER.length;\n     }\n \n+    // Reusable inflater reference for streaming decompression\n+    private static final ThreadLocal<ReleasableReference<Inflater>> inflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Inflater inflater = new Inflater(true);\n+        return new ReleasableReference<>(inflater, inflater::reset);\n+    });\n+\n+    // Reusable deflater reference for streaming compression\n+    private static final ThreadLocal<ReleasableReference<Deflater>> deflaterForStreamRef = ThreadLocal.withInitial(() -> {\n+        final Deflater deflater = new Deflater(LEVEL, true);\n+        return new ReleasableReference<>(deflater, deflater::reset);\n+    });\n+\n+    // Reference to a deflater or inflater that is used to make sure we do not use the same stream twice when nesting streams.\n+    private static final class ReleasableReference<T> implements Releasable {\n+\n+        protected final T resource;\n+\n+        private final Releasable releasable;\n+\n+        // Thread that is currently using this reference. Only used for assertions and only assigned if assertions are enabled.\n+        private Thread thread = null;\n+\n+        // true if this reference is currently in use and is not available for re-use\n+        boolean inUse;\n+\n+        protected ReleasableReference(T resource, Releasable releasable) {\n+            this.resource = resource;\n+            this.releasable = releasable;\n+        }\n+\n+        T get() {\n+            if (Assertions.ENABLED) {\n+                assert thread == null;\n+                thread = Thread.currentThread();\n+            }\n+            assert inUse == false;\n+            inUse = true;\n+            return resource;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (Assertions.ENABLED) {\n+                assert thread == Thread.currentThread() :\n+                        \"Opened on [\" + thread.getName() + \"] but closed on [\" + Thread.currentThread().getName() + \"]\";\n+                thread = null;\n+            }\n+            assert inUse;\n+            inUse = false;\n+            releasable.close();\n+        }\n+    }\n+\n     @Override\n-    public StreamInput streamInput(StreamInput in) throws IOException {\n+    public StreamInput threadLocalStreamInput(StreamInput in) throws IOException {\n+        return new InputStreamStreamInput(inputStream(in, true));\n+    }\n+\n+    /**\n+     * Creates a new input stream that decompresses the contents read from the provided input stream.\n+     * Closing the returned stream will close the provided input stream.\n+     * Optionally uses thread-local, pooled resources to save off-heap allocations if the stream is guaranteed to not escape the current\n+     * thread.\n+     *\n+     * @param in           input stream to wrap\n+     * @param threadLocal  whether this stream will only be used on the current thread or not\n+     * @return             decompressing stream\n+     */\n+    public static InputStream inputStream(InputStream in, boolean threadLocal) throws IOException {", "originalCommit": "44b01fcb285e7ef40bbd4d735d0b1306053b9d02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNzUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61358#discussion_r475707531", "bodyText": "I'm fine with this as a one-off special case.\n\nAlso, I wonder if we shouldn't just make all the methods on this class static and do away with the Compressor interface. We only have one implementation that we use via its singleton, so there isn't much point in doing in having that interface around?\n\nThis is a good point; there was a time when both DEFLATE and LZF were available. I hesitate on removing the interface since there may be a desire to allow other compression algorithms in the future; I'm not aware of any specific effort but that doesn't mean there won't be one to investigate/add something else like Zstd.", "author": "jaymode", "createdAt": "2020-08-24T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0OTMxOA=="}], "type": "inlineReview", "revised_code": null}]}