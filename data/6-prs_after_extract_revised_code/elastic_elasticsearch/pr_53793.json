{"pr_number": 53793, "pr_title": "Try to save memory on aggregations", "pr_createdAt": "2020-03-19T13:18:56Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53793", "timeline": [{"oid": "39d604cff634a2f92206f0c4a9be264a4a73e7aa", "url": "https://github.com/elastic/elasticsearch/commit/39d604cff634a2f92206f0c4a9be264a4a73e7aa", "message": "Try to save memory on aggregations\n\nThis delays deserializing the aggregation response try until *right*\nbefore we merge the objects.", "committedDate": "2020-03-19T12:25:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MDk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395050941", "bodyText": "We're only using this for InternalAggregations, but it is a heck of a lot simpler to test if it is generic.", "author": "nik9000", "createdAt": "2020-03-19T14:06:49Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.io.stream;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+\n+import java.io.IOException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A holder for {@link Writeable}s that can delays reading the underlying\n+ * {@linkplain Writeable} when it is read from a remote node.\n+ */\n+public abstract class DelayableWriteable<T extends Writeable> implements Supplier<T>, Writeable {", "originalCommit": "39d604cff634a2f92206f0c4a9be264a4a73e7aa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8cddcab12893bf65530a33f4e59c89cc89bdbfdb", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java b/server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java\nindex 9f87fde0490..e75b81fff4e 100644\n--- a/server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java\n+++ b/server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java\n\n@@ -91,7 +91,23 @@ public abstract class DelayableWriteable<T extends Writeable> implements Supplie\n \n         @Override\n         public void writeTo(StreamOutput out) throws IOException {\n-            throw new UnsupportedOperationException();\n+            if (out.getVersion() == remoteVersion) {\n+                /*\n+                 * If the version *does* line up we can just copy the bytes\n+                 * which is good because this is how shard request caching\n+                 * works.\n+                 */\n+                out.writeBytesReference(serialized);\n+            } else {\n+                /*\n+                 * If the version doesn't line up then we have to deserialize\n+                 * into the Writeable and re-serialize it against the new\n+                 * output stream so it can apply any backwards compatibility\n+                 * differences in the wire protocol. This ain't efficient but\n+                 * it should be quite rare.\n+                 */\n+                referencing(get()).writeTo(out);\n+            }\n         }\n \n         @Override\n"}}, {"oid": "8cddcab12893bf65530a33f4e59c89cc89bdbfdb", "url": "https://github.com/elastic/elasticsearch/commit/8cddcab12893bf65530a33f4e59c89cc89bdbfdb", "message": "Fix request cache", "committedDate": "2020-03-19T14:27:48Z", "type": "commit"}, {"oid": "04dba53ec8c645086e8d2de1cf0f139764931197", "url": "https://github.com/elastic/elasticsearch/commit/04dba53ec8c645086e8d2de1cf0f139764931197", "message": "Merge branch 'master' into agg_await_deserialization", "committedDate": "2020-03-19T14:28:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395307225", "bodyText": "should we nullify the rest of the array to make the reduced aggs eligible for gc ?", "author": "jimczi", "createdAt": "2020-03-19T20:41:03Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -665,10 +671,11 @@ private synchronized void consumeInternal(QuerySearchResult querySearchResult) {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n                     if (hasAggs) {\n-                        ReduceContext reduceContext = aggReduceContextBuilder.forPartialReduction();\n-                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(Arrays.asList(aggsBuffer), reduceContext);\n+                        InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n+                                Arrays.stream(aggsBuffer).map(Supplier::get).collect(toList()),\n+                                aggReduceContextBuilder.forPartialReduction());\n                         Arrays.fill(aggsBuffer, null);\n-                        aggsBuffer[0] = reducedAggs;\n+                        aggsBuffer[0] = () -> reducedAggs;", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxODIwNw==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395318207", "bodyText": "++", "author": "nik9000", "createdAt": "2020-03-19T21:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1ODY5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395658695", "bodyText": "Actually the line right above does that.", "author": "nik9000", "createdAt": "2020-03-20T14:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3Mjc3MA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395672770", "bodyText": "Right but we keep the serialized + deserialized form until after the partial reduce. We can try to release the serialized form early with:\n List<InternalAggregations> toReduce = Arrays.stream(aggsBuffer).map(Supplier::get).collect(toList());\n Arrays.fill(aggsBuffer, null);\n InternalAggregaions reducedAggs = InternalAggregations.topLevelReduce(toReduce, aggReduceContextBuilder.forPartialReduction());\n aggsBuffer[0] = () -> reducedAggs;\n\nOr we can nullify the serialized form when the supplier is called like discussed below.", "author": "jimczi", "createdAt": "2020-03-20T14:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395762723", "bodyText": "Right! I noticed that right after I sent this. I'm playing with nulling the cell in the array as soon as I call get. That feels a little safer than nulling the bytes.", "author": "nik9000", "createdAt": "2020-03-20T16:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb37343d15675e1941a240befc21a85d356694ea", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\nindex 674119b2fbe..1f4ce71cacd 100644\n--- a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n+++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n\n@@ -671,10 +687,13 @@ public final class SearchPhaseController {\n             if (querySearchResult.isNull() == false) {\n                 if (index == bufferSize) {\n                     if (hasAggs) {\n+                        List<InternalAggregations> aggs = new ArrayList<>(aggsBuffer.length);\n+                        for (int i = 0; i < aggsBuffer.length; i++) {\n+                            aggs.add(aggsBuffer[i].get());\n+                            aggsBuffer[i] = null; // null the buffer so it can be GCed now.\n+                        }\n                         InternalAggregations reducedAggs = InternalAggregations.topLevelReduce(\n-                                Arrays.stream(aggsBuffer).map(Supplier::get).collect(toList()),\n-                                aggReduceContextBuilder.forPartialReduction());\n-                        Arrays.fill(aggsBuffer, null);\n+                                aggs, aggReduceContextBuilder.forPartialReduction());\n                         aggsBuffer[0] = () -> reducedAggs;\n                     }\n                     if (hasTopDocs) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395307994", "bodyText": "Should we nullify the bytes ref before returning the deserialized aggs ? We could also protect against multiple calls by keeping the deserialized aggs internally on the first call ?", "author": "jimczi", "createdAt": "2020-03-19T20:42:40Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/DelayableWriteable.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.io.stream;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.bytes.BytesReference;\n+\n+import java.io.IOException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A holder for {@link Writeable}s that can delays reading the underlying\n+ * {@linkplain Writeable} when it is read from a remote node.\n+ */\n+public abstract class DelayableWriteable<T extends Writeable> implements Supplier<T>, Writeable {\n+    /**\n+     * Build a {@linkplain DelayableWriteable} that wraps an existing object\n+     * but is serialized so that deserializing it can be delayed.\n+     */\n+    public static <T extends Writeable> DelayableWriteable<T> referencing(T reference) {\n+        return new Referencing<>(reference);\n+    }\n+    /**\n+     * Build a {@linkplain DelayableWriteable} that copies a buffer from\n+     * the provided {@linkplain StreamInput} and deserializes the buffer\n+     * when {@link Supplier#get()} is called.\n+     */\n+    public static <T extends Writeable> DelayableWriteable<T> delayed(Writeable.Reader<T> reader, StreamInput in) throws IOException {\n+        return new Delayed<>(reader, in);\n+    }\n+\n+    private DelayableWriteable() {}\n+\n+    public abstract boolean isDelayed();\n+\n+    private static class Referencing<T extends Writeable> extends DelayableWriteable<T> {\n+        private T reference;\n+\n+        Referencing(T reference) {\n+            this.reference = reference;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            try (BytesStreamOutput buffer = new BytesStreamOutput()) {\n+                reference.writeTo(buffer);\n+                out.writeBytesReference(buffer.bytes());\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            return reference;\n+        }\n+\n+        @Override\n+        public boolean isDelayed() {\n+            return false;\n+        }\n+    }\n+\n+    private static class Delayed<T extends Writeable> extends DelayableWriteable<T> {\n+        private final Writeable.Reader<T> reader;\n+        private final Version remoteVersion;\n+        private final BytesReference serialized;\n+        private final NamedWriteableRegistry registry;\n+\n+        Delayed(Writeable.Reader<T> reader, StreamInput in) throws IOException {\n+            this.reader = reader;\n+            remoteVersion = in.getVersion();\n+            serialized = in.readBytesReference();\n+            registry = in.namedWriteableRegistry();\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            if (out.getVersion() == remoteVersion) {\n+                /*\n+                 * If the version *does* line up we can just copy the bytes\n+                 * which is good because this is how shard request caching\n+                 * works.\n+                 */\n+                out.writeBytesReference(serialized);\n+            } else {\n+                /*\n+                 * If the version doesn't line up then we have to deserialize\n+                 * into the Writeable and re-serialize it against the new\n+                 * output stream so it can apply any backwards compatibility\n+                 * differences in the wire protocol. This ain't efficient but\n+                 * it should be quite rare.\n+                 */\n+                referencing(get()).writeTo(out);\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            try {\n+                try (StreamInput in = registry == null ?\n+                        serialized.streamInput() : new NamedWriteableAwareStreamInput(serialized.streamInput(), registry)) {\n+                    in.setVersion(remoteVersion);\n+                    return reader.read(in);", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjEyNA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395312124", "bodyText": "I'm worried about race conditions with that. The way it is it is fairly simple the look at and say \"there are no race conditions.\" I think nulifying the other references would be good enough from a GC perspective. Do you?", "author": "nik9000", "createdAt": "2020-03-19T20:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNTUzMA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395315530", "bodyText": "yep nullifying the reference should be enough but it would be better if we can nullify after each deserialization. Otherwise you'd need to keep the deserialized aggs and their bytes representation during the entire partial reduce which defeats the purpose of saving memories here ?", "author": "jimczi", "createdAt": "2020-03-19T20:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwNzk5NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395309409", "bodyText": "we can maybe get the aggs once if the remote node is in a version before v8 (instead of calling get here and below to get the pipeline aggs) ?", "author": "jimczi", "createdAt": "2020-03-19T20:45:30Z", "path": "server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java", "diffHunk": "@@ -366,7 +371,11 @@ public void writeToNoId(StreamOutput out) throws IOException {\n             out.writeBoolean(false);\n         } else {\n             out.writeBoolean(true);\n-            aggregations.writeTo(out);\n+            if (out.getVersion().before(Version.V_8_0_0)) {\n+                aggregations.get().writeTo(out);", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0NDQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396444405", "bodyText": "@nik9000 ? should we avoid the double deserialization if we need the pipeline aggs below ?", "author": "jimczi", "createdAt": "2020-03-23T13:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MDAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396450025", "bodyText": "Darn it. I twisted the other side around but missed this comment. Of course!", "author": "nik9000", "createdAt": "2020-03-23T13:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MTUzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r396451539", "bodyText": "Mostly these are going to be the \"referencing\" ones anyway. But I'll turn it around.", "author": "nik9000", "createdAt": "2020-03-23T13:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c6162ff446abe15844130d23e7f74f8e3f241018", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java b/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\nindex d065a74d4f6..2863f45de85 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\n\n@@ -369,24 +384,39 @@ public final class QuerySearchResult extends SearchPhaseResult {\n         writeTopDocs(out, topDocsAndMaxScore);\n         if (aggregations == null) {\n             out.writeBoolean(false);\n+            if (out.getVersion().before(Version.V_7_2_0)) {\n+                /*\n+                 * Earlier versions expect sibling pipeline aggs separately\n+                 * as they used to be set to QuerySearchResult directly, while\n+                 * later versions expect them in InternalAggregations. Note\n+                 * that despite serializing sibling pipeline aggs as part of\n+                 * InternalAggregations is supported since 6.7.0, the shards\n+                 * set sibling pipeline aggs to InternalAggregations only from\n+                 * 7.1 on.\n+                 */\n+                out.writeNamedWriteableList(emptyList());\n+            }\n         } else {\n             out.writeBoolean(true);\n             if (out.getVersion().before(Version.V_8_0_0)) {\n-                aggregations.get().writeTo(out);\n+                InternalAggregations aggs = aggregations.get();\n+                aggs.writeTo(out);\n+                if (out.getVersion().before(Version.V_7_2_0)) {\n+                    /*\n+                     * Earlier versions expect sibling pipeline aggs separately\n+                     * as they used to be set to QuerySearchResult directly, while\n+                     * later versions expect them in InternalAggregations. Note\n+                     * that despite serializing sibling pipeline aggs as part of\n+                     * InternalAggregations is supported since 6.7.0, the shards\n+                     * set sibling pipeline aggs to InternalAggregations only from\n+                     * 7.1 on.\n+                     */\n+                    out.writeNamedWriteableList(aggs.getTopLevelPipelineAggregators());\n+                }\n             } else {\n                 aggregations.writeTo(out);\n             }\n         }\n-        if (out.getVersion().before(Version.V_7_2_0)) {\n-            //Earlier versions expect sibling pipeline aggs separately as they used to be set to QuerySearchResult directly,\n-            //while later versions expect them in InternalAggregations. Note that despite serializing sibling pipeline aggs as part of\n-            //InternalAggregations is supported since 6.7.0, the shards set sibling pipeline aggs to InternalAggregations only from 7.1 on.\n-            if (aggregations == null) {\n-                out.writeNamedWriteableList(Collections.emptyList());\n-            } else {\n-                out.writeNamedWriteableList(aggregations.get().getTopLevelPipelineAggregators());\n-            }\n-        }\n         if (suggest == null) {\n             out.writeBoolean(false);\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMDQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395310458", "bodyText": "Can you add a comment here to explain why we use a delayable writable ?", "author": "jimczi", "createdAt": "2020-03-19T20:47:39Z", "path": "server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java", "diffHunk": "@@ -54,7 +55,7 @@\n     private TotalHits totalHits;\n     private float maxScore = Float.NaN;\n     private DocValueFormat[] sortValueFormats;\n-    private InternalAggregations aggregations;", "originalCommit": "04dba53ec8c645086e8d2de1cf0f139764931197", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjMxNg==", "url": "https://github.com/elastic/elasticsearch/pull/53793#discussion_r395312316", "bodyText": "++", "author": "nik9000", "createdAt": "2020-03-19T20:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMDQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "6921c8ca514d26fb94b97f1e02bd69c4264f30c1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java b/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\nindex d065a74d4f6..334ea7fc692 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QuerySearchResult.java\n\n@@ -55,6 +55,13 @@ public final class QuerySearchResult extends SearchPhaseResult {\n     private TotalHits totalHits;\n     private float maxScore = Float.NaN;\n     private DocValueFormat[] sortValueFormats;\n+    /**\n+     * Aggregation results. We wrap them in\n+     * {@linkplain DelayableWriteable} because\n+     * {@link InternalAggregation} is usually made up of many small objects\n+     * which have a fairly high overhead in the JVM. So we delay deserializing\n+     * them until just before we need them.\n+     */\n     private DelayableWriteable<InternalAggregations> aggregations;\n     private boolean hasAggs;\n     private Suggest suggest;\n"}}, {"oid": "6921c8ca514d26fb94b97f1e02bd69c4264f30c1", "url": "https://github.com/elastic/elasticsearch/commit/6921c8ca514d26fb94b97f1e02bd69c4264f30c1", "message": "Explain", "committedDate": "2020-03-19T22:18:44Z", "type": "commit"}, {"oid": "76b077db6cf90e12147eefd38110ad78616aa59a", "url": "https://github.com/elastic/elasticsearch/commit/76b077db6cf90e12147eefd38110ad78616aa59a", "message": "Rework read", "committedDate": "2020-03-19T22:54:43Z", "type": "commit"}, {"oid": "eb37343d15675e1941a240befc21a85d356694ea", "url": "https://github.com/elastic/elasticsearch/commit/eb37343d15675e1941a240befc21a85d356694ea", "message": "clear asap", "committedDate": "2020-03-20T20:02:40Z", "type": "commit"}, {"oid": "80e31ad697584c9126a0e55b061fb9a5d5b91b9f", "url": "https://github.com/elastic/elasticsearch/commit/80e31ad697584c9126a0e55b061fb9a5d5b91b9f", "message": "Checkstyle", "committedDate": "2020-03-20T20:10:10Z", "type": "commit"}, {"oid": "c6162ff446abe15844130d23e7f74f8e3f241018", "url": "https://github.com/elastic/elasticsearch/commit/c6162ff446abe15844130d23e7f74f8e3f241018", "message": "Twist", "committedDate": "2020-03-23T13:32:50Z", "type": "commit"}]}