{"pr_number": 54467, "pr_title": "Create first backing index when creating data stream", "pr_createdAt": "2020-03-30T21:09:25Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54467", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3MTA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400671040", "bodyText": "I think I remember @dakrone mentioning something about not starting from 0, rather from 1 like described in the ILM getting started guide. I am OK either way.", "author": "henningandersen", "createdAt": "2020-03-31T06:28:34Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -161,16 +167,24 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                 });\n         }\n \n-        static ClusterState createDataStream(ClusterState currentState, Request request) {\n+        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+                                             ClusterState currentState,\n+                                             Request request) throws Exception {\n             if (currentState.metaData().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n             MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n+            String firstBackingIndexName = request.name + \"-000000\";", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4NDg3OA==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400884878", "bodyText": "Good point. I think we should be consistent with what ILM does.", "author": "danhermann", "createdAt": "2020-03-31T12:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3MTA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0ae87c538ad078773fc66cc07abce9dae57f1656", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\nindex eac90aa1547..aca6494773b 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n\n@@ -167,26 +167,26 @@ public class CreateDataStreamAction extends ActionType<AcknowledgedResponse> {\n                 });\n         }\n \n-        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+        static ClusterState createDataStream(MetadataCreateIndexService metadataCreateIndexService,\n                                              ClusterState currentState,\n                                              Request request) throws Exception {\n-            if (currentState.metaData().dataStreams().containsKey(request.name)) {\n+            if (currentState.metadata().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n-            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n+            MetadataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n             String firstBackingIndexName = request.name + \"-000000\";\n             CreateIndexClusterStateUpdateRequest createIndexRequest =\n                 new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName);\n-            currentState = metaDataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n-            IndexMetaData firstBackingIndex = currentState.metaData().index(firstBackingIndexName);\n+            currentState = metadataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n+            IndexMetadata firstBackingIndex = currentState.metadata().index(firstBackingIndexName);\n \n-            MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(\n+            Metadata.Builder builder = Metadata.builder(currentState.metadata()).put(\n                 new DataStream(request.name, request.timestampFieldName, List.of(firstBackingIndex.getIndex())));\n             logger.info(\"adding data stream [{}]\", request.name);\n-            return ClusterState.builder(currentState).metaData(builder).build();\n+            return ClusterState.builder(currentState).metadata(builder).build();\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3MzE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400673148", "bodyText": "It would be good to add:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            assert firstBackingIndex != null;\n          \n      \n    \n    \n  \n\nsince that is guaranteed to fail tests (the NPE occurring further down could be swallowed).", "author": "henningandersen", "createdAt": "2020-03-31T06:33:54Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -161,16 +167,24 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                 });\n         }\n \n-        static ClusterState createDataStream(ClusterState currentState, Request request) {\n+        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+                                             ClusterState currentState,\n+                                             Request request) throws Exception {\n             if (currentState.metaData().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n             MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n+            String firstBackingIndexName = request.name + \"-000000\";\n+            CreateIndexClusterStateUpdateRequest createIndexRequest =\n+                new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName);\n+            currentState = metaDataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n+            IndexMetaData firstBackingIndex = currentState.metaData().index(firstBackingIndexName);\n+", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ae87c538ad078773fc66cc07abce9dae57f1656", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\nindex eac90aa1547..aca6494773b 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n\n@@ -167,26 +167,26 @@ public class CreateDataStreamAction extends ActionType<AcknowledgedResponse> {\n                 });\n         }\n \n-        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+        static ClusterState createDataStream(MetadataCreateIndexService metadataCreateIndexService,\n                                              ClusterState currentState,\n                                              Request request) throws Exception {\n-            if (currentState.metaData().dataStreams().containsKey(request.name)) {\n+            if (currentState.metadata().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n-            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n+            MetadataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n             String firstBackingIndexName = request.name + \"-000000\";\n             CreateIndexClusterStateUpdateRequest createIndexRequest =\n                 new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName);\n-            currentState = metaDataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n-            IndexMetaData firstBackingIndex = currentState.metaData().index(firstBackingIndexName);\n+            currentState = metadataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n+            IndexMetadata firstBackingIndex = currentState.metadata().index(firstBackingIndexName);\n \n-            MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(\n+            Metadata.Builder builder = Metadata.builder(currentState.metadata()).put(\n                 new DataStream(request.name, request.timestampFieldName, List.of(firstBackingIndex.getIndex())));\n             logger.info(\"adding data stream [{}]\", request.name);\n-            return ClusterState.builder(currentState).metaData(builder).build();\n+            return ClusterState.builder(currentState).metadata(builder).build();\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3ODU1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400678555", "bodyText": "This looks unused? I think it makes more sense to add this when also building the indicesLookup.", "author": "henningandersen", "createdAt": "2020-03-31T06:47:32Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -250,4 +252,42 @@ private boolean isNonEmpty(List<IndexMetaData> idxMetas) {\n             return (Objects.isNull(idxMetas) || idxMetas.isEmpty()) == false;\n         }\n     }\n+\n+    class DataStream implements IndexAbstraction {", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ae87c538ad078773fc66cc07abce9dae57f1656", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\nindex bddd91346ee..72ba82ea557 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n\n@@ -248,7 +248,7 @@ public interface IndexAbstraction {\n             }\n         }\n \n-        private boolean isNonEmpty(List<IndexMetaData> idxMetas) {\n+        private boolean isNonEmpty(List<IndexMetadata> idxMetas) {\n             return (Objects.isNull(idxMetas) || idxMetas.isEmpty()) == false;\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3OTA5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400679093", "bodyText": "We should end up asserting that existing != null, but that can be done in a followup together with populating indicesLookup", "author": "henningandersen", "createdAt": "2020-03-31T06:48:52Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1377,12 +1379,27 @@ private void validateDataStreams(SortedMap<String, IndexAbstraction> indicesLook\n             DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n             if (dsMetadata != null) {\n                 for (DataStream ds : dsMetadata.dataStreams().values()) {\n-                    if (indicesLookup.containsKey(ds.getName())) {\n+                    IndexAbstraction existing = indicesLookup.get(ds.getName());\n+                    if (existing != null && existing.getType() != IndexAbstraction.Type.DATA_STREAM) {", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df1bf0542d1c3486ed0bc8e0b84797a062aee9cf", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nsimilarity index 81%\nrename from server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nrename to server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nindex 927a0d6700b..a09f552974c 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\n\n@@ -1384,68 +1384,66 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n                         throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n                     }\n \n-                    SortedMap<String, IndexAbstraction> map =\n+                    SortedMap<String, IndexAbstraction> potentialConflicts =\n                         indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n-                    if (map.size() != 0) {\n-                        if (map.size() == ds.getIndices().size()) {\n-                            int numValidIndices = 0;\n-                            for (int i = 0; i < map.size(); i++) {\n-                                IndexAbstraction space =  map.get(String.format(Locale.ROOT, \"%s-%06d\", ds.getName(), i));\n-                                if (space != null && space.getType() == IndexAbstraction.Type.CONCRETE_INDEX) {\n-                                    numValidIndices++;\n-                                }\n-                            }\n-                            if (numValidIndices == map.size()) {\n-                                continue;\n+                    if (potentialConflicts.size() != 0) {\n+                        List<String> indexNames = ds.getIndices().stream().map(Index::getName).collect(Collectors.toList());\n+                        List<String> conflicts = new ArrayList<>();\n+                        for (Map.Entry<String, IndexAbstraction> entry : potentialConflicts.entrySet()) {\n+                            if (entry.getValue().getType() != IndexAbstraction.Type.CONCRETE_INDEX ||\n+                                indexNames.contains(entry.getKey()) == false) {\n+                                conflicts.add(entry.getKey());\n                             }\n                         }\n \n-                        throw new IllegalStateException(\"data stream [\" + ds.getName() +\n-                            \"] could create backing indices that conflict with \" + map.size() + \" existing index(s) or alias(s)\" +\n-                            \" including '\" + map.firstKey() + \"'\");\n+                        if (conflicts.size() > 0) {\n+                            throw new IllegalStateException(\"data stream [\" + ds.getName() +\n+                                \"] could create backing indices that conflict with \" + conflicts.size() + \" existing index(s) or alias(s)\" +\n+                                \" including '\" + conflicts.get(0) + \"'\");\n+                        }\n                     }\n                 }\n             }\n         }\n \n-        public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n+        public static void toXContent(Metadata metadata, XContentBuilder builder, ToXContent.Params params) throws IOException {\n             XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, CONTEXT_MODE_API));\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"metadata\");\n             } else {\n                 builder.startObject(\"meta-data\");\n-                builder.field(\"version\", metaData.version());\n+                builder.field(\"version\", metadata.version());\n             }\n \n-            builder.field(\"cluster_uuid\", metaData.clusterUUID);\n-            builder.field(\"cluster_uuid_committed\", metaData.clusterUUIDCommitted);\n+            builder.field(\"cluster_uuid\", metadata.clusterUUID);\n+            builder.field(\"cluster_uuid_committed\", metadata.clusterUUIDCommitted);\n \n             builder.startObject(\"cluster_coordination\");\n-            metaData.coordinationMetaData().toXContent(builder, params);\n+            metadata.coordinationMetadata().toXContent(builder, params);\n             builder.endObject();\n \n-            if (context != XContentContext.API && !metaData.persistentSettings().isEmpty()) {\n+            if (context != XContentContext.API && !metadata.persistentSettings().isEmpty()) {\n                 builder.startObject(\"settings\");\n-                metaData.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+                metadata.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n                 builder.endObject();\n             }\n \n             builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {\n-                IndexTemplateMetaData.Builder.toXContentWithTypes(cursor.value, builder, params);\n+            for (ObjectCursor<IndexTemplateMetadata> cursor : metadata.templates().values()) {\n+                IndexTemplateMetadata.Builder.toXContentWithTypes(cursor.value, builder, params);\n             }\n             builder.endObject();\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"indices\");\n-                for (IndexMetaData indexMetaData : metaData) {\n-                    IndexMetaData.Builder.toXContent(indexMetaData, builder, params);\n+                for (IndexMetadata indexMetadata : metadata) {\n+                    IndexMetadata.Builder.toXContent(indexMetadata, builder, params);\n                 }\n                 builder.endObject();\n             }\n \n-            for (ObjectObjectCursor<String, Custom> cursor : metaData.customs()) {\n+            for (ObjectObjectCursor<String, Custom> cursor : metadata.customs()) {\n                 if (cursor.value.context().contains(context)) {\n                     builder.startObject(cursor.key);\n                     cursor.value.toXContent(builder, params);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTAxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400681011", "bodyText": "I think this should instead validate that the entries in map are the same as those in ds.getIndices().\nRight now it works in the initial create case, but not after we have deleted the first index.\nAlso it would be good to add a MetaDataTests test that validates that a data-stream pointing to backing indices (with random suffix number) works.", "author": "henningandersen", "createdAt": "2020-03-31T06:53:27Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1377,12 +1379,27 @@ private void validateDataStreams(SortedMap<String, IndexAbstraction> indicesLook\n             DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n             if (dsMetadata != null) {\n                 for (DataStream ds : dsMetadata.dataStreams().values()) {\n-                    if (indicesLookup.containsKey(ds.getName())) {\n+                    IndexAbstraction existing = indicesLookup.get(ds.getName());\n+                    if (existing != null && existing.getType() != IndexAbstraction.Type.DATA_STREAM) {\n                         throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n                     }\n \n-                    SortedMap<?, ?> map = indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n+                    SortedMap<String, IndexAbstraction> map =\n+                        indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n                     if (map.size() != 0) {\n+                        if (map.size() == ds.getIndices().size()) {\n+                            int numValidIndices = 0;\n+                            for (int i = 0; i < map.size(); i++) {", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df1bf0542d1c3486ed0bc8e0b84797a062aee9cf", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nsimilarity index 81%\nrename from server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nrename to server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nindex 927a0d6700b..a09f552974c 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\n\n@@ -1384,68 +1384,66 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n                         throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n                     }\n \n-                    SortedMap<String, IndexAbstraction> map =\n+                    SortedMap<String, IndexAbstraction> potentialConflicts =\n                         indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n-                    if (map.size() != 0) {\n-                        if (map.size() == ds.getIndices().size()) {\n-                            int numValidIndices = 0;\n-                            for (int i = 0; i < map.size(); i++) {\n-                                IndexAbstraction space =  map.get(String.format(Locale.ROOT, \"%s-%06d\", ds.getName(), i));\n-                                if (space != null && space.getType() == IndexAbstraction.Type.CONCRETE_INDEX) {\n-                                    numValidIndices++;\n-                                }\n-                            }\n-                            if (numValidIndices == map.size()) {\n-                                continue;\n+                    if (potentialConflicts.size() != 0) {\n+                        List<String> indexNames = ds.getIndices().stream().map(Index::getName).collect(Collectors.toList());\n+                        List<String> conflicts = new ArrayList<>();\n+                        for (Map.Entry<String, IndexAbstraction> entry : potentialConflicts.entrySet()) {\n+                            if (entry.getValue().getType() != IndexAbstraction.Type.CONCRETE_INDEX ||\n+                                indexNames.contains(entry.getKey()) == false) {\n+                                conflicts.add(entry.getKey());\n                             }\n                         }\n \n-                        throw new IllegalStateException(\"data stream [\" + ds.getName() +\n-                            \"] could create backing indices that conflict with \" + map.size() + \" existing index(s) or alias(s)\" +\n-                            \" including '\" + map.firstKey() + \"'\");\n+                        if (conflicts.size() > 0) {\n+                            throw new IllegalStateException(\"data stream [\" + ds.getName() +\n+                                \"] could create backing indices that conflict with \" + conflicts.size() + \" existing index(s) or alias(s)\" +\n+                                \" including '\" + conflicts.get(0) + \"'\");\n+                        }\n                     }\n                 }\n             }\n         }\n \n-        public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n+        public static void toXContent(Metadata metadata, XContentBuilder builder, ToXContent.Params params) throws IOException {\n             XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, CONTEXT_MODE_API));\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"metadata\");\n             } else {\n                 builder.startObject(\"meta-data\");\n-                builder.field(\"version\", metaData.version());\n+                builder.field(\"version\", metadata.version());\n             }\n \n-            builder.field(\"cluster_uuid\", metaData.clusterUUID);\n-            builder.field(\"cluster_uuid_committed\", metaData.clusterUUIDCommitted);\n+            builder.field(\"cluster_uuid\", metadata.clusterUUID);\n+            builder.field(\"cluster_uuid_committed\", metadata.clusterUUIDCommitted);\n \n             builder.startObject(\"cluster_coordination\");\n-            metaData.coordinationMetaData().toXContent(builder, params);\n+            metadata.coordinationMetadata().toXContent(builder, params);\n             builder.endObject();\n \n-            if (context != XContentContext.API && !metaData.persistentSettings().isEmpty()) {\n+            if (context != XContentContext.API && !metadata.persistentSettings().isEmpty()) {\n                 builder.startObject(\"settings\");\n-                metaData.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+                metadata.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n                 builder.endObject();\n             }\n \n             builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {\n-                IndexTemplateMetaData.Builder.toXContentWithTypes(cursor.value, builder, params);\n+            for (ObjectCursor<IndexTemplateMetadata> cursor : metadata.templates().values()) {\n+                IndexTemplateMetadata.Builder.toXContentWithTypes(cursor.value, builder, params);\n             }\n             builder.endObject();\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"indices\");\n-                for (IndexMetaData indexMetaData : metaData) {\n-                    IndexMetaData.Builder.toXContent(indexMetaData, builder, params);\n+                for (IndexMetadata indexMetadata : metadata) {\n+                    IndexMetadata.Builder.toXContent(indexMetadata, builder, params);\n                 }\n                 builder.endObject();\n             }\n \n-            for (ObjectObjectCursor<String, Custom> cursor : metaData.customs()) {\n+            for (ObjectObjectCursor<String, Custom> cursor : metadata.customs()) {\n                 if (cursor.value.context().contains(context)) {\n                     builder.startObject(cursor.key);\n                     cursor.value.toXContent(builder, params);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTY5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400681696", "bodyText": "Let's add this in another change as well.", "author": "martijnvg", "createdAt": "2020-03-31T06:54:55Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1377,12 +1379,27 @@ private void validateDataStreams(SortedMap<String, IndexAbstraction> indicesLook\n             DataStreamMetadata dsMetadata = (DataStreamMetadata) customs.get(DataStreamMetadata.TYPE);\n             if (dsMetadata != null) {\n                 for (DataStream ds : dsMetadata.dataStreams().values()) {\n-                    if (indicesLookup.containsKey(ds.getName())) {\n+                    IndexAbstraction existing = indicesLookup.get(ds.getName());\n+                    if (existing != null && existing.getType() != IndexAbstraction.Type.DATA_STREAM) {\n                         throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n                     }\n \n-                    SortedMap<?, ?> map = indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n+                    SortedMap<String, IndexAbstraction> map =", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4NzA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400887065", "bodyText": "Never mind this comment. This change is necessary otherwise the first backing index of data stream can't be created.", "author": "martijnvg", "createdAt": "2020-03-31T12:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "df1bf0542d1c3486ed0bc8e0b84797a062aee9cf", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nsimilarity index 81%\nrename from server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nrename to server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\nindex 927a0d6700b..a09f552974c 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/Metadata.java\n\n@@ -1384,68 +1384,66 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n                         throw new IllegalStateException(\"data stream [\" + ds.getName() + \"] conflicts with existing index or alias\");\n                     }\n \n-                    SortedMap<String, IndexAbstraction> map =\n+                    SortedMap<String, IndexAbstraction> potentialConflicts =\n                         indicesLookup.subMap(ds.getName() + \"-\", ds.getName() + \".\"); // '.' is the char after '-'\n-                    if (map.size() != 0) {\n-                        if (map.size() == ds.getIndices().size()) {\n-                            int numValidIndices = 0;\n-                            for (int i = 0; i < map.size(); i++) {\n-                                IndexAbstraction space =  map.get(String.format(Locale.ROOT, \"%s-%06d\", ds.getName(), i));\n-                                if (space != null && space.getType() == IndexAbstraction.Type.CONCRETE_INDEX) {\n-                                    numValidIndices++;\n-                                }\n-                            }\n-                            if (numValidIndices == map.size()) {\n-                                continue;\n+                    if (potentialConflicts.size() != 0) {\n+                        List<String> indexNames = ds.getIndices().stream().map(Index::getName).collect(Collectors.toList());\n+                        List<String> conflicts = new ArrayList<>();\n+                        for (Map.Entry<String, IndexAbstraction> entry : potentialConflicts.entrySet()) {\n+                            if (entry.getValue().getType() != IndexAbstraction.Type.CONCRETE_INDEX ||\n+                                indexNames.contains(entry.getKey()) == false) {\n+                                conflicts.add(entry.getKey());\n                             }\n                         }\n \n-                        throw new IllegalStateException(\"data stream [\" + ds.getName() +\n-                            \"] could create backing indices that conflict with \" + map.size() + \" existing index(s) or alias(s)\" +\n-                            \" including '\" + map.firstKey() + \"'\");\n+                        if (conflicts.size() > 0) {\n+                            throw new IllegalStateException(\"data stream [\" + ds.getName() +\n+                                \"] could create backing indices that conflict with \" + conflicts.size() + \" existing index(s) or alias(s)\" +\n+                                \" including '\" + conflicts.get(0) + \"'\");\n+                        }\n                     }\n                 }\n             }\n         }\n \n-        public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n+        public static void toXContent(Metadata metadata, XContentBuilder builder, ToXContent.Params params) throws IOException {\n             XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, CONTEXT_MODE_API));\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"metadata\");\n             } else {\n                 builder.startObject(\"meta-data\");\n-                builder.field(\"version\", metaData.version());\n+                builder.field(\"version\", metadata.version());\n             }\n \n-            builder.field(\"cluster_uuid\", metaData.clusterUUID);\n-            builder.field(\"cluster_uuid_committed\", metaData.clusterUUIDCommitted);\n+            builder.field(\"cluster_uuid\", metadata.clusterUUID);\n+            builder.field(\"cluster_uuid_committed\", metadata.clusterUUIDCommitted);\n \n             builder.startObject(\"cluster_coordination\");\n-            metaData.coordinationMetaData().toXContent(builder, params);\n+            metadata.coordinationMetadata().toXContent(builder, params);\n             builder.endObject();\n \n-            if (context != XContentContext.API && !metaData.persistentSettings().isEmpty()) {\n+            if (context != XContentContext.API && !metadata.persistentSettings().isEmpty()) {\n                 builder.startObject(\"settings\");\n-                metaData.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+                metadata.persistentSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n                 builder.endObject();\n             }\n \n             builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {\n-                IndexTemplateMetaData.Builder.toXContentWithTypes(cursor.value, builder, params);\n+            for (ObjectCursor<IndexTemplateMetadata> cursor : metadata.templates().values()) {\n+                IndexTemplateMetadata.Builder.toXContentWithTypes(cursor.value, builder, params);\n             }\n             builder.endObject();\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"indices\");\n-                for (IndexMetaData indexMetaData : metaData) {\n-                    IndexMetaData.Builder.toXContent(indexMetaData, builder, params);\n+                for (IndexMetadata indexMetadata : metadata) {\n+                    IndexMetadata.Builder.toXContent(indexMetadata, builder, params);\n                 }\n                 builder.endObject();\n             }\n \n-            for (ObjectObjectCursor<String, Custom> cursor : metaData.customs()) {\n+            for (ObjectObjectCursor<String, Custom> cursor : metadata.customs()) {\n                 if (cursor.value.context().contains(context)) {\n                     builder.startObject(cursor.key);\n                     cursor.value.toXContent(builder, params);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MjA2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400682068", "bodyText": "We need to set the index.hidden setting here and test in testCreateDataStream() that it has been set.", "author": "martijnvg", "createdAt": "2020-03-31T06:55:51Z", "path": "server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java", "diffHunk": "@@ -161,16 +167,24 @@ public void clusterStateProcessed(String source, ClusterState oldState, ClusterS\n                 });\n         }\n \n-        static ClusterState createDataStream(ClusterState currentState, Request request) {\n+        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+                                             ClusterState currentState,\n+                                             Request request) throws Exception {\n             if (currentState.metaData().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n             MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n+            String firstBackingIndexName = request.name + \"-000000\";\n+            CreateIndexClusterStateUpdateRequest createIndexRequest =", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ae87c538ad078773fc66cc07abce9dae57f1656", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\nindex eac90aa1547..aca6494773b 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamAction.java\n\n@@ -167,26 +167,26 @@ public class CreateDataStreamAction extends ActionType<AcknowledgedResponse> {\n                 });\n         }\n \n-        static ClusterState createDataStream(MetaDataCreateIndexService metaDataCreateIndexService,\n+        static ClusterState createDataStream(MetadataCreateIndexService metadataCreateIndexService,\n                                              ClusterState currentState,\n                                              Request request) throws Exception {\n-            if (currentState.metaData().dataStreams().containsKey(request.name)) {\n+            if (currentState.metadata().dataStreams().containsKey(request.name)) {\n                 throw new IllegalArgumentException(\"data_stream [\" + request.name + \"] already exists\");\n             }\n \n-            MetaDataCreateIndexService.validateIndexOrAliasName(request.name,\n+            MetadataCreateIndexService.validateIndexOrAliasName(request.name,\n                 (s1, s2) -> new IllegalArgumentException(\"data_stream [\" + s1 + \"] \" + s2));\n \n             String firstBackingIndexName = request.name + \"-000000\";\n             CreateIndexClusterStateUpdateRequest createIndexRequest =\n                 new CreateIndexClusterStateUpdateRequest(\"initialize_data_stream\", firstBackingIndexName, firstBackingIndexName);\n-            currentState = metaDataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n-            IndexMetaData firstBackingIndex = currentState.metaData().index(firstBackingIndexName);\n+            currentState = metadataCreateIndexService.applyCreateIndexRequest(currentState, createIndexRequest, false);\n+            IndexMetadata firstBackingIndex = currentState.metadata().index(firstBackingIndexName);\n \n-            MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(\n+            Metadata.Builder builder = Metadata.builder(currentState.metadata()).put(\n                 new DataStream(request.name, request.timestampFieldName, List.of(firstBackingIndex.getIndex())));\n             logger.info(\"adding data stream [{}]\", request.name);\n-            return ClusterState.builder(currentState).metaData(builder).build();\n+            return ClusterState.builder(currentState).metadata(builder).build();\n         }\n \n         @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4NDAwOA==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r400684008", "bodyText": "Let's add the data stream index abstraction in another change? We can use the get index api in the yaml test to check that the index has correctly been created.\n(the logic that adds data streams to the indicesLookup is missing here, which would need to be added too, but let's try to this pr small, so that it is easy to review)\n(also a number of if statements in the code base may need to be revised because a new data stream type is introduced)", "author": "martijnvg", "createdAt": "2020-03-31T07:00:14Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -250,4 +252,42 @@ private boolean isNonEmpty(List<IndexMetaData> idxMetas) {\n             return (Objects.isNull(idxMetas) || idxMetas.isEmpty()) == false;\n         }\n     }\n+\n+    class DataStream implements IndexAbstraction {", "originalCommit": "cff94c6212a0fa9efbbae74abb04e0bd1d82401e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0ae87c538ad078773fc66cc07abce9dae57f1656", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\nindex bddd91346ee..72ba82ea557 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n\n@@ -248,7 +248,7 @@ public interface IndexAbstraction {\n             }\n         }\n \n-        private boolean isNonEmpty(List<IndexMetaData> idxMetas) {\n+        private boolean isNonEmpty(List<IndexMetadata> idxMetas) {\n             return (Objects.isNull(idxMetas) || idxMetas.isEmpty()) == false;\n         }\n     }\n"}}, {"oid": "0ae87c538ad078773fc66cc07abce9dae57f1656", "url": "https://github.com/elastic/elasticsearch/commit/0ae87c538ad078773fc66cc07abce9dae57f1656", "message": "create first backing index", "committedDate": "2020-03-31T20:14:57Z", "type": "commit"}, {"oid": "806acc45f286f744e3fe6bd46e5385235649e2ff", "url": "https://github.com/elastic/elasticsearch/commit/806acc45f286f744e3fe6bd46e5385235649e2ff", "message": "update unit test", "committedDate": "2020-03-31T20:17:15Z", "type": "commit"}, {"oid": "078dae15dac3c8bcfb3d3ddee14d9ff5f481d0c5", "url": "https://github.com/elastic/elasticsearch/commit/078dae15dac3c8bcfb3d3ddee14d9ff5f481d0c5", "message": "temporarily restrict YML test", "committedDate": "2020-03-31T20:17:17Z", "type": "commit"}, {"oid": "1284b2b14ed867d6087cdf66beccab8099ea98c1", "url": "https://github.com/elastic/elasticsearch/commit/1284b2b14ed867d6087cdf66beccab8099ea98c1", "message": "wip on review comments", "committedDate": "2020-03-31T20:20:29Z", "type": "commit"}, {"oid": "1284b2b14ed867d6087cdf66beccab8099ea98c1", "url": "https://github.com/elastic/elasticsearch/commit/1284b2b14ed867d6087cdf66beccab8099ea98c1", "message": "wip on review comments", "committedDate": "2020-03-31T20:20:29Z", "type": "forcePushed"}, {"oid": "df1bf0542d1c3486ed0bc8e0b84797a062aee9cf", "url": "https://github.com/elastic/elasticsearch/commit/df1bf0542d1c3486ed0bc8e0b84797a062aee9cf", "message": "finish review comments and tests", "committedDate": "2020-03-31T23:26:40Z", "type": "commit"}, {"oid": "47e6b8802525f5aec6b1fbb6b2c8ce90c55e668f", "url": "https://github.com/elastic/elasticsearch/commit/47e6b8802525f5aec6b1fbb6b2c8ce90c55e668f", "message": "fix test", "committedDate": "2020-03-31T23:53:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM5MjA4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r401392087", "bodyText": "maybe add some java doc here?", "author": "martijnvg", "createdAt": "2020-04-01T06:52:39Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java", "diffHunk": "@@ -87,7 +87,9 @@\n          * An alias typically refers to many concrete indices and\n          * may have a write index.\n          */\n-        ALIAS(\"alias\");\n+        ALIAS(\"alias\"),\n+\n+        DATA_STREAM(\"data_stream\");", "originalCommit": "47e6b8802525f5aec6b1fbb6b2c8ce90c55e668f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c1856feb7e4aa13f2544347b339e89217da2b29", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\nindex 646dbc35e21..98c3dd31ffe 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexAbstraction.java\n\n@@ -89,6 +89,11 @@ public interface IndexAbstraction {\n          */\n         ALIAS(\"alias\"),\n \n+        /**\n+         * An index abstraction that refers to a data stream.\n+         * A data stream typically has multiple backing indices, the latest of which\n+         * is the target for index requests.\n+         */\n         DATA_STREAM(\"data_stream\");\n \n         private final String displayName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3MDgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54467#discussion_r401470801", "bodyText": "maybe instead of mock class use: Mockito#spy(...) and attach expected behaviour?", "author": "martijnvg", "createdAt": "2020-04-01T09:17:18Z", "path": "server/src/test/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamRequestTests.java", "diffHunk": "@@ -62,33 +68,60 @@ public void testValidateRequestWithoutTimestampField() {\n         assertThat(e.validationErrors().get(0), containsString(\"timestamp field name is missing\"));\n     }\n \n-    public void testCreateDataStream() {\n+    public void testCreateDataStream() throws Exception {\n+        final MetadataCreateIndexService metadataCreateIndexService = new MockMetadataCreateIndexService();\n         final String dataStreamName = \"my-data-stream\";\n         ClusterState cs = ClusterState.builder(new ClusterName(\"_name\")).build();\n         CreateDataStreamAction.Request req = new CreateDataStreamAction.Request(dataStreamName);\n-        ClusterState newState = CreateDataStreamAction.TransportAction.createDataStream(cs, req);\n+        ClusterState newState = CreateDataStreamAction.TransportAction.createDataStream(metadataCreateIndexService, cs, req);\n         assertThat(newState.metadata().dataStreams().size(), equalTo(1));\n         assertThat(newState.metadata().dataStreams().get(dataStreamName).getName(), equalTo(dataStreamName));\n+        assertThat(newState.metadata().index(dataStreamName + \"-000001\"), notNullValue());\n+        assertThat(newState.metadata().index(dataStreamName + \"-000001\").getSettings().get(\"index.hidden\"), equalTo(\"true\"));\n     }\n \n     public void testCreateDuplicateDataStream() {\n+        final MetadataCreateIndexService metadataCreateIndexService = new MockMetadataCreateIndexService();\n         final String dataStreamName = \"my-data-stream\";\n         DataStream existingDataStream = new DataStream(dataStreamName, \"timestamp\", Collections.emptyList());\n         ClusterState cs = ClusterState.builder(new ClusterName(\"_name\"))\n             .metadata(Metadata.builder().dataStreams(Map.of(dataStreamName, existingDataStream)).build()).build();\n         CreateDataStreamAction.Request req = new CreateDataStreamAction.Request(dataStreamName);\n \n         IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n-            () -> CreateDataStreamAction.TransportAction.createDataStream(cs, req));\n+            () -> CreateDataStreamAction.TransportAction.createDataStream(metadataCreateIndexService, cs, req));\n         assertThat(e.getMessage(), containsString(\"data_stream [\" + dataStreamName + \"] already exists\"));\n     }\n \n     public void testCreateDataStreamWithInvalidName() {\n+        final MetadataCreateIndexService metadataCreateIndexService = new MockMetadataCreateIndexService();\n         final String dataStreamName = \"_My-da#ta- ,stream-\";\n         ClusterState cs = ClusterState.builder(new ClusterName(\"_name\")).build();\n         CreateDataStreamAction.Request req = new CreateDataStreamAction.Request(dataStreamName);\n         IllegalArgumentException e = expectThrows(IllegalArgumentException.class,\n-            () -> CreateDataStreamAction.TransportAction.createDataStream(cs, req));\n+            () -> CreateDataStreamAction.TransportAction.createDataStream(metadataCreateIndexService, cs, req));\n         assertThat(e.getMessage(), containsString(\"must not contain the following characters\"));\n     }\n+\n+    private static class MockMetadataCreateIndexService extends MetadataCreateIndexService {", "originalCommit": "47e6b8802525f5aec6b1fbb6b2c8ce90c55e668f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c1856feb7e4aa13f2544347b339e89217da2b29", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamRequestTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamRequestTests.java\nindex 457d54fd7e3..40e1f813072 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamRequestTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/datastream/CreateDataStreamRequestTests.java\n\n@@ -69,7 +73,7 @@ public class CreateDataStreamRequestTests extends AbstractWireSerializingTestCas\n     }\n \n     public void testCreateDataStream() throws Exception {\n-        final MetadataCreateIndexService metadataCreateIndexService = new MockMetadataCreateIndexService();\n+        final MetadataCreateIndexService metadataCreateIndexService = getMetadataCreateIndexService();\n         final String dataStreamName = \"my-data-stream\";\n         ClusterState cs = ClusterState.builder(new ClusterName(\"_name\")).build();\n         CreateDataStreamAction.Request req = new CreateDataStreamAction.Request(dataStreamName);\n"}}, {"oid": "0bd4bd4df3e9a8fedfc181fe9a814053952b91d0", "url": "https://github.com/elastic/elasticsearch/commit/0bd4bd4df3e9a8fedfc181fe9a814053952b91d0", "message": "wip on review comments", "committedDate": "2020-04-01T17:20:13Z", "type": "commit"}, {"oid": "6c1856feb7e4aa13f2544347b339e89217da2b29", "url": "https://github.com/elastic/elasticsearch/commit/6c1856feb7e4aa13f2544347b339e89217da2b29", "message": "review comments", "committedDate": "2020-04-01T18:28:29Z", "type": "commit"}, {"oid": "fe2849dd98b97775cca9a730c95077b5161a0f4e", "url": "https://github.com/elastic/elasticsearch/commit/fe2849dd98b97775cca9a730c95077b5161a0f4e", "message": "Merge branch 'master' into create_first_backing_index", "committedDate": "2020-04-01T18:36:31Z", "type": "commit"}, {"oid": "9c9a42c0f8bed34165119b1fa2d7dce8f55a7d53", "url": "https://github.com/elastic/elasticsearch/commit/9c9a42c0f8bed34165119b1fa2d7dce8f55a7d53", "message": "fix test", "committedDate": "2020-04-01T19:10:16Z", "type": "commit"}]}