{"pr_number": 53525, "pr_title": "SQL: add support for index aliases for SYS COLUMNS command", "pr_createdAt": "2020-03-13T00:03:32Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53525", "timeline": [{"oid": "947e5010125f25a5f1ab8bf6f0494ea73fde14a6", "url": "https://github.com/elastic/elasticsearch/commit/947e5010125f25a5f1ab8bf6f0494ea73fde14a6", "message": "Add support for index aliases for SYS COLUMNS command", "committedDate": "2020-03-12T23:36:15Z", "type": "commit"}, {"oid": "dabcccf6804d2ebd8334c74ba2800d55bd054311", "url": "https://github.com/elastic/elasticsearch/commit/dabcccf6804d2ebd8334c74ba2800d55bd054311", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-12T23:38:34Z", "type": "commit"}, {"oid": "3aa01f30490b36d998aa965c3c23acb32e8717da", "url": "https://github.com/elastic/elasticsearch/commit/3aa01f30490b36d998aa965c3c23acb32e8717da", "message": "Update to test after branch update", "committedDate": "2020-03-12T23:52:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTEzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115136", "bodyText": "The IndicesOption depends on whether includeFrozen is true or not.", "author": "costin", "createdAt": "2020-03-13T09:28:04Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -461,30 +462,29 @@ public class IndexResolver {\n     public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, boolean includeFrozen,\n             ActionListener<List<EsIndex>> listener) {\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n-        client.fieldCaps(fieldRequest,\n-                ActionListener.wrap(\n-                        response -> {\n-                            String[] indicesList = response.getIndices();\n-                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n-                                    .local(true)\n-                                    .aliases(\"*\")\n-                                    .indices(indicesList)\n-                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n-                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n-                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n-                                        aliases.getAliases())),\n-                                ex -> {\n-                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n-                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n-                                    } else {\n-                                        listener.onFailure(ex);\n-                                    }\n-                                }));\n-                        },\n-                        listener::onFailure));\n+        client.fieldCaps(fieldRequest, wrap(response -> {\n+            client.admin().indices().getAliases(createGetAliasesRequest(response, includeFrozen), wrap(aliases ->\n+                listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), aliases.getAliases())),\n+                ex -> {\n+                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                        listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), null));\n+                    } else {\n+                        listener.onFailure(ex);\n+                    }\n+                }));\n+            },\n+            listener::onFailure));\n \n     }\n     \n+    private GetAliasesRequest createGetAliasesRequest(FieldCapabilitiesResponse response, boolean includeFrozen) {\n+        return new GetAliasesRequest()\n+                .local(true)\n+                .aliases(\"*\")\n+                .indices(response.getIndices())\n+                .indicesOptions(includeFrozen ? FIELD_CAPS_FROZEN_INDICES_OPTIONS : FIELD_CAPS_INDICES_OPTIONS);\n+    }\n+    \n     public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n             Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n         return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, aliases, Function.identity(), (s, cap) -> null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNTg3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392115876", "bodyText": "Maybe use static imports on ActionListener to make the code a bit more readable.", "author": "costin", "createdAt": "2020-03-13T09:29:27Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -461,30 +462,29 @@ public class IndexResolver {\n     public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, boolean includeFrozen,\n             ActionListener<List<EsIndex>> listener) {\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n-        client.fieldCaps(fieldRequest,\n-                ActionListener.wrap(\n-                        response -> {\n-                            String[] indicesList = response.getIndices();\n-                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n-                                    .local(true)\n-                                    .aliases(\"*\")\n-                                    .indices(indicesList)\n-                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n-                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n-                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n-                                        aliases.getAliases())),\n-                                ex -> {\n-                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n-                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n-                                    } else {\n-                                        listener.onFailure(ex);\n-                                    }\n-                                }));\n-                        },\n-                        listener::onFailure));\n+        client.fieldCaps(fieldRequest, wrap(response -> {\n+            client.admin().indices().getAliases(createGetAliasesRequest(response, includeFrozen), wrap(aliases ->\n+                listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), aliases.getAliases())),\n+                ex -> {\n+                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                        listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), null));\n+                    } else {\n+                        listener.onFailure(ex);\n+                    }\n+                }));\n+            },\n+            listener::onFailure));\n \n     }\n     \n+    private GetAliasesRequest createGetAliasesRequest(FieldCapabilitiesResponse response, boolean includeFrozen) {\n+        return new GetAliasesRequest()\n+                .local(true)\n+                .aliases(\"*\")\n+                .indices(response.getIndices())\n+                .indicesOptions(includeFrozen ? FIELD_CAPS_FROZEN_INDICES_OPTIONS : FIELD_CAPS_INDICES_OPTIONS);\n+    }\n+    \n     public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n             Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n         return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, aliases, Function.identity(), (s, cap) -> null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117147", "bodyText": "Small nit - maybe it makes sense to extract this method into a separate one - it's not reusable but it might make the call easier to read:\nclient.fieldCaps(fieldRequest, wrap(response -> getIndexAliases(response, wrap(aliases -> ...))", "author": "costin", "createdAt": "2020-03-13T09:32:03Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -461,30 +462,29 @@ public class IndexResolver {\n     public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, boolean includeFrozen,\n             ActionListener<List<EsIndex>> listener) {\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n-        client.fieldCaps(fieldRequest,\n-                ActionListener.wrap(\n-                        response -> {\n-                            String[] indicesList = response.getIndices();\n-                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n-                                    .local(true)\n-                                    .aliases(\"*\")\n-                                    .indices(indicesList)\n-                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n-                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n-                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n-                                        aliases.getAliases())),\n-                                ex -> {\n-                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n-                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n-                                    } else {\n-                                        listener.onFailure(ex);\n-                                    }\n-                                }));\n-                        },\n-                        listener::onFailure));\n+        client.fieldCaps(fieldRequest, wrap(response -> {\n+            client.admin().indices().getAliases(createGetAliasesRequest(response, includeFrozen), wrap(aliases ->\n+                listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), aliases.getAliases())),\n+                ex -> {\n+                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                        listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), null));\n+                    } else {\n+                        listener.onFailure(ex);\n+                    }\n+                }));\n+            },\n+            listener::onFailure));\n \n     }\n     \n+    private GetAliasesRequest createGetAliasesRequest(FieldCapabilitiesResponse response, boolean includeFrozen) {\n+        return new GetAliasesRequest()\n+                .local(true)\n+                .aliases(\"*\")\n+                .indices(response.getIndices())\n+                .indicesOptions(includeFrozen ? FIELD_CAPS_FROZEN_INDICES_OPTIONS : FIELD_CAPS_INDICES_OPTIONS);\n+    }\n+    \n     public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n             Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n         return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, aliases, Function.identity(), (s, cap) -> null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzQyOA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117428", "bodyText": "Why use ImmutableOpenMap instead of Map ?", "author": "costin", "createdAt": "2020-03-13T09:32:45Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -508,7 +508,7 @@ public class IndexResolver {\n             return emptyList();\n         }\n \n-        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        Set<String> resolvedAliases = new HashSet<>();\n         if (aliases != null) {\n             Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n             while (iterator.hasNext()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392117635", "bodyText": "What was wrong with Map ?", "author": "costin", "createdAt": "2020-03-13T09:33:08Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -460,15 +463,31 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n         client.fieldCaps(fieldRequest,\n                 ActionListener.wrap(\n-                        response -> listener.onResponse(\n-                                separateMappings(typeRegistry, indexWildcard, javaRegex, response.getIndices(), response.get())),\n+                        response -> {\n+                            String[] indicesList = response.getIndices();\n+                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n+                                    .local(true)\n+                                    .aliases(\"*\")\n+                                    .indices(indicesList)\n+                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n+                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n+                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n+                                        aliases.getAliases())),\n+                                ex -> {\n+                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n+                                    } else {\n+                                        listener.onFailure(ex);\n+                                    }\n+                                }));\n+                        },\n                         listener::onFailure));\n \n     }\n     \n-    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String indexPattern, String javaRegex, String[] indexNames,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps) {\n-        return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, Function.identity(), (s, cap) -> null);\n+    public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjQ0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352443", "bodyText": "ImmutableOpenMap is not actually a java.util.Map.", "author": "astefan", "createdAt": "2020-03-13T16:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExNzYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -461,30 +462,29 @@ public class IndexResolver {\n     public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, boolean includeFrozen,\n             ActionListener<List<EsIndex>> listener) {\n         FieldCapabilitiesRequest fieldRequest = createFieldCapsRequest(indexWildcard, includeFrozen);\n-        client.fieldCaps(fieldRequest,\n-                ActionListener.wrap(\n-                        response -> {\n-                            String[] indicesList = response.getIndices();\n-                            GetAliasesRequest aliasRequest = new GetAliasesRequest()\n-                                    .local(true)\n-                                    .aliases(\"*\")\n-                                    .indices(indicesList)\n-                                    .indicesOptions(IndicesOptions.lenientExpandOpen());\n-                            client.admin().indices().getAliases(aliasRequest, wrap(aliases ->\n-                                listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(),\n-                                        aliases.getAliases())),\n-                                ex -> {\n-                                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n-                                        listener.onResponse(separateMappings(typeRegistry, javaRegex, indicesList, response.get(), null));\n-                                    } else {\n-                                        listener.onFailure(ex);\n-                                    }\n-                                }));\n-                        },\n-                        listener::onFailure));\n+        client.fieldCaps(fieldRequest, wrap(response -> {\n+            client.admin().indices().getAliases(createGetAliasesRequest(response, includeFrozen), wrap(aliases ->\n+                listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), aliases.getAliases())),\n+                ex -> {\n+                    if (ex instanceof IndexNotFoundException || ex instanceof ElasticsearchSecurityException) {\n+                        listener.onResponse(separateMappings(typeRegistry, javaRegex, response.getIndices(), response.get(), null));\n+                    } else {\n+                        listener.onFailure(ex);\n+                    }\n+                }));\n+            },\n+            listener::onFailure));\n \n     }\n     \n+    private GetAliasesRequest createGetAliasesRequest(FieldCapabilitiesResponse response, boolean includeFrozen) {\n+        return new GetAliasesRequest()\n+                .local(true)\n+                .aliases(\"*\")\n+                .indices(response.getIndices())\n+                .indicesOptions(includeFrozen ? FIELD_CAPS_FROZEN_INDICES_OPTIONS : FIELD_CAPS_INDICES_OPTIONS);\n+    }\n+    \n     public static List<EsIndex> separateMappings(DataTypeRegistry typeRegistry, String javaRegex, String[] indexNames,\n             Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n         return buildIndices(typeRegistry, indexNames, javaRegex, fieldCaps, aliases, Function.identity(), (s, cap) -> null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExODY4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392118683", "bodyText": "The size is incorrect - use CollectionUtils.mapSize", "author": "costin", "createdAt": "2020-03-13T09:35:15Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {\n+                    resolvedAliases.add(alias.getAlias());\n+                }\n+            }\n+        }\n+\n+        List<String> resolvedIndices = new ArrayList<>(asList(indexNames));\n+        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size() + resolvedAliases.size());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -508,7 +508,7 @@ public class IndexResolver {\n             return emptyList();\n         }\n \n-        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        Set<String> resolvedAliases = new HashSet<>();\n         if (aliases != null) {\n             Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n             while (iterator.hasNext()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392119122", "bodyText": "Is it okay to put all aliases in the same map?", "author": "costin", "createdAt": "2020-03-13T09:36:08Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -481,16 +500,26 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new LinkedHashSet<>();", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjEyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392352121", "bodyText": "With this I wanted to count them and create a list of indices and aliases appropriately sized.", "author": "astefan", "createdAt": "2020-03-13T16:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjExOTEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -508,7 +508,7 @@ public class IndexResolver {\n             return emptyList();\n         }\n \n-        Set<String> resolvedAliases = new LinkedHashSet<>();\n+        Set<String> resolvedAliases = new HashSet<>();\n         if (aliases != null) {\n             Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n             while (iterator.hasNext()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r392120962", "bodyText": "this creates a HashSet regardless of the key presence - better to do the check", "author": "costin", "createdAt": "2020-03-13T09:39:58Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -590,4 +646,134 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                typesErrors.putIfAbsent(aliasName, new HashSet<>());", "originalCommit": "3aa01f30490b36d998aa965c3c23acb32e8717da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAyNzczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393027731", "bodyText": "Actually, this was intended like this.  See this line where the field type for this field belonging to this alias is added to the list of unique field types.  And here the size of the set is checked to see if there is more than one field type across all indices belonging to this alias. If there is more than one field type, then the field is considered \"invalid\" for this alias.", "author": "astefan", "createdAt": "2020-03-16T13:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NzIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393097217", "bodyText": "I don't follow - putIfAbsent does if (key == null) put(key, value) - I'm pointing out that a new HashSet is created every time.\nWhat I'm suggesting:\nif (key == null) {\n   put(key, new HashSet())\n}", "author": "costin", "createdAt": "2020-03-16T15:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDk3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393160977", "bodyText": "I am aware of the putIfAbsent functionality. I think I can simplify the logic a bit.", "author": "astefan", "createdAt": "2020-03-16T16:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEyMDk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "26bf119aaa30d170b7932116172326e7661b415c", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex 106c72c2e13..0b3a8de7c0e 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -681,7 +682,7 @@ public class IndexResolver {\n             return emptyMap();\n         }\n         Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n-        Map<String, Set<String>> typesErrors = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n         Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n         \n         Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n"}}, {"oid": "26bf119aaa30d170b7932116172326e7661b415c", "url": "https://github.com/elastic/elasticsearch/commit/26bf119aaa30d170b7932116172326e7661b415c", "message": "Address reviews", "committedDate": "2020-03-16T13:41:48Z", "type": "commit"}, {"oid": "93d8162de832826f1d920ee31a58c177ed51eb49", "url": "https://github.com/elastic/elasticsearch/commit/93d8162de832826f1d920ee31a58c177ed51eb49", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-16T13:46:15Z", "type": "commit"}, {"oid": "80f0b63a90d2db8032100b50659db27a9d787f05", "url": "https://github.com/elastic/elasticsearch/commit/80f0b63a90d2db8032100b50659db27a9d787f05", "message": "Fix one integration test after update branch", "committedDate": "2020-03-16T14:02:37Z", "type": "commit"}, {"oid": "d34271a85cae13da46deff6a1d20075f26ef156e", "url": "https://github.com/elastic/elasticsearch/commit/d34271a85cae13da46deff6a1d20075f26ef156e", "message": "Address further review", "committedDate": "2020-03-16T16:40:42Z", "type": "commit"}, {"oid": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "url": "https://github.com/elastic/elasticsearch/commit/bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-16T16:43:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI2MDYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393260619", "bodyText": "nit: s/accross/across.", "author": "bpintea", "createdAt": "2020-03-16T19:23:55Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex ab58810da8e..6c688b0a4bd 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -697,7 +697,7 @@ public class IndexResolver {\n             return emptyMap();\n         }\n         Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n-        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types across its indices\n         Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n         \n         Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393329168", "bodyText": "Use org.elasticsearch.common.util.CollectionUtils.isEmpty instead.", "author": "costin", "createdAt": "2020-03-16T21:49:42Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ1NTA0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393455047", "bodyText": "That's not possible unfortunately, because aliases is an ImmutableOpenMap, which is not a Collection.", "author": "astefan", "createdAt": "2020-03-17T05:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTE2OA=="}], "type": "inlineReview", "revised_code": {"commit": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex ab58810da8e..6c688b0a4bd 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -519,7 +519,7 @@ public class IndexResolver {\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.isEmpty())) {\n             return emptyList();\n         }\n \n"}}, {"oid": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "url": "https://github.com/elastic/elasticsearch/commit/9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "message": "Address more reviews", "committedDate": "2020-03-17T05:45:38Z", "type": "commit"}, {"oid": "cd6c420a37c8156d5fd6d2280c1b84ecda0f5492", "url": "https://github.com/elastic/elasticsearch/commit/cd6c420a37c8156d5fd6d2280c1b84ecda0f5492", "message": "Merge branch 'master' of https://github.com/elastic/elasticsearch into 31609_fix", "committedDate": "2020-03-17T05:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODUzNg==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393378536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            for(AliasMetaData alias : iterator.next().value) {\n          \n          \n            \n                            for (AliasMetaData alias : iterator.next().value) {", "author": "matriv", "createdAt": "2020-03-17T00:13:22Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -496,16 +515,27 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n      * each field.\n      */\n     private static List<EsIndex> buildIndices(DataTypeRegistry typeRegistry, String[] indexNames, String javaRegex,\n-            Map<String, Map<String, FieldCapabilities>> fieldCaps,\n+            Map<String, Map<String, FieldCapabilities>> fieldCaps, ImmutableOpenMap<String, List<AliasMetaData>> aliases,\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if (indexNames == null || indexNames.length == 0) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n             return emptyList();\n         }\n \n-        final List<String> resolvedIndices = asList(indexNames);\n-        Map<String, Fields> indices = new LinkedHashMap<>(resolvedIndices.size());\n+        Set<String> resolvedAliases = new HashSet<>();\n+        if (aliases != null) {\n+            Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iterator = aliases.iterator();\n+            while (iterator.hasNext()) {\n+                for(AliasMetaData alias : iterator.next().value) {", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex ab58810da8e..6c688b0a4bd 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -519,7 +519,7 @@ public class IndexResolver {\n             Function<String, String> indexNameProcessor,\n             BiFunction<String, Map<String, FieldCapabilities>, InvalidMappedField> validityVerifier) {\n \n-        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.size() == 0)) {\n+        if ((indexNames == null || indexNames.length == 0) && (aliases == null || aliases.isEmpty())) {\n             return emptyList();\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MTM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/53525#discussion_r393381394", "bodyText": "Can it be simply <>?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());\n          \n          \n            \n                            aliasToIndices.putIfAbsent(aliasName, new HashSet<>());", "author": "matriv", "createdAt": "2020-03-17T00:25:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java", "diffHunk": "@@ -605,4 +662,141 @@ public void resolveAsSeparateMappings(String indexWildcard, String javaRegex, bo\n         foundIndices.sort(Comparator.comparing(EsIndex::name));\n         return foundIndices;\n     }\n+\n+\n+    /*\n+     * Checks if the field is valid (same type and same capabilities - searchable/aggregatable) across indices belonging to a list\n+     * of aliases.\n+     * A field can look like the example below (generated by field_caps API).\n+     *   \"name\": {\n+     *       \"text\": {\n+     *           \"type\": \"text\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": false,\n+     *           \"indices\": [\n+     *               \"bar\",\n+     *               \"foo\"\n+     *           ],\n+     *           \"non_searchable_indices\": [\n+     *               \"foo\"\n+     *           ]\n+     *       },\n+     *       \"keyword\": {\n+     *           \"type\": \"keyword\",\n+     *           \"searchable\": false,\n+     *           \"aggregatable\": true,\n+     *           \"non_aggregatable_indices\": [\n+     *               \"bar\", \"baz\"\n+     *           ]\n+     *       }\n+     *   }\n+     */\n+    private static Map<String, InvalidMappedField> getInvalidFieldsForAliases(String fieldName, Map<String, FieldCapabilities> types,\n+            ImmutableOpenMap<String, List<AliasMetaData>> aliases) {\n+        if (aliases == null || aliases.isEmpty()) {\n+            return emptyMap();\n+        }\n+        Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n+        Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n+        \n+        Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n+        while (iter.hasNext()) {\n+            ObjectObjectCursor<String, List<AliasMetaData>> index = iter.next();\n+            for (AliasMetaData aliasMetaData : index.value) {\n+                String aliasName = aliasMetaData.alias();\n+                aliasToIndices.putIfAbsent(aliasName, new HashSet<String>());", "originalCommit": "bf8df94ecfcbd9a66f9e9077c7a2886dfc671331", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ed8fa2667d18e3be724fa8c3857ea0aeb87f864", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\nindex ab58810da8e..6c688b0a4bd 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/index/IndexResolver.java\n\n@@ -697,7 +697,7 @@ public class IndexResolver {\n             return emptyMap();\n         }\n         Map<String, InvalidMappedField> invalidFields = new HashMap<>();\n-        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types accross its indices\n+        Map<String, Set<String>> typesErrors = new HashMap<>(); // map holding aliases and a list of unique field types across its indices\n         Map<String, Set<String>> aliasToIndices = new HashMap<>(); // map with aliases and their list of indices\n         \n         Iterator<ObjectObjectCursor<String, List<AliasMetaData>>> iter = aliases.iterator();\n"}}, {"oid": "079be6ba8fa806f4851be9af529bc72ede5e8d0e", "url": "https://github.com/elastic/elasticsearch/commit/079be6ba8fa806f4851be9af529bc72ede5e8d0e", "message": "Small updates", "committedDate": "2020-03-17T08:43:37Z", "type": "commit"}]}