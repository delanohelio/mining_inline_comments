{"pr_number": 62473, "pr_title": "Build local unreleased bwc versions more efficient for tests", "pr_createdAt": "2020-09-16T15:18:51Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62473", "timeline": [{"oid": "60a2c55508206909cba2d8481dafacb59be9e8df", "url": "https://github.com/elastic/elasticsearch/commit/60a2c55508206909cba2d8481dafacb59be9e8df", "message": "fix bwc jdbc build", "committedDate": "2020-09-21T16:11:03Z", "type": "forcePushed"}, {"oid": "f544a08bf99cc8f92c0b3437702901e42a75b9b2", "url": "https://github.com/elastic/elasticsearch/commit/f544a08bf99cc8f92c0b3437702901e42a75b9b2", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-23T13:25:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496939515", "bodyText": "What does the entirety of the lifecycle output look like? This comment on its own would be pretty cryptic", "author": "rjernst", "createdAt": "2020-09-29T18:09:01Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzOTM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497339348", "bodyText": "The overall lifecycle output here hasn't changed in this PR and would look e.g. like this:\n> Task :distribution:bwc:bugfix:checkoutBwcBranch\nCommit date of current: 'Wed, 30 Sep 2020 10:33:41 +0200'\nPerforming checkout of elastic/7.9...\nCheckout hash for :distribution:bwc:bugfix is c9534e03e8beae7e9b566cda7236532665c376e9", "author": "breskeby", "createdAt": "2020-09-30T08:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzOTUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942236", "bodyText": "We can just use Files.write:\nFiles.writeString(file.toPath(), content);", "author": "rjernst", "createdAt": "2020-09-29T18:13:41Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTcwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498079701", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MjIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496942844", "bodyText": "Let's not swallow any exceptions. This should cause the build to fail. If we can't let it propagate as is, then wrap it with UncheckedIOException?", "author": "rjernst", "createdAt": "2020-09-29T18:14:42Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062022", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0Mjg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943521", "bodyText": "If we need a git specific method, then the spec should set the executable to git? Otherwise how is this different than just a generic exec helper?", "author": "rjernst", "createdAt": "2020-09-29T18:15:51Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {\n+                    if (\"true\".equals(fetchProp)) {\n+                        return true;\n+                    }\n+                    if (\"false\".equals(fetchProp)) {\n+                        return false;\n+                    }\n+                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n+                });\n+            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n+            fetchLatest.dependsOn(addRemoteTaskProvider);\n+            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n+        });\n+\n+        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n+            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n+            checkoutBwcBranch.doLast(t -> {\n+                Logger logger = project.getLogger();\n+\n+                String bwcBranch = this.gitExtension.getBwcBranch().get();\n+                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n+                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n+                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n+\n+                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n+\n+                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n+                LoggedExec.exec(project, spec -> {\n+                    spec.workingDir(gitExtension.getCheckoutDir());\n+                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n+                });\n+\n+                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n+                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n+                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n+            });\n+        });\n+    }\n+\n+    public BwcGitExtension getGitExtension() {\n+        return gitExtension;\n+    }\n+\n+    /**\n+     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n+     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n+     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n+     * commit was made.\n+     * <p>\n+     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n+     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n+     * deterministic.\n+     * <p>\n+     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n+     * we are interested in.\n+     * <p>\n+     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n+     * passed as input. This means the results might not be deterministic in the current second, but this\n+     * should not matter in practice.\n+     */\n+    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n+        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n+            return defaultRefSpec;\n+        }\n+\n+        String timeOfCurrent = execGit(execSpec -> {\n+            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n+            execSpec.workingDir(project.getRootDir());\n+        });\n+\n+        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n+\n+        String mergeCommits = execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n+        );\n+        if (mergeCommits.isEmpty() == false) {\n+            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n+        }\n+        return execGit(\n+            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n+        );\n+    }\n+\n+    private void writeFile(File file, String content) {\n+        try {\n+            FileWriter myWriter = new FileWriter(file, false);\n+            myWriter.write(content);\n+            myWriter.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private String execGit(Action<ExecSpec> execSpecConfig) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062263", "bodyText": "I removed the git part of it. at the end its just about using the common working dir", "author": "breskeby", "createdAt": "2020-10-01T08:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r496943937", "bodyText": "nit: These -> these", "author": "rjernst", "createdAt": "2020-09-29T18:16:35Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MjMyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062329", "bodyText": "fixed", "author": "breskeby", "createdAt": "2020-10-01T08:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497063730", "bodyText": "Will this go away when these changes are backported?", "author": "mark-vieira", "createdAt": "2020-09-29T21:14:40Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java", "diffHunk": "@@ -94,14 +94,22 @@ private void registerInternalDistributionResolutions(NamedDomainObjectContainer<\n                             + \"without a bundled JDK is not supported.\"\n                     );\n                 }\n+                String distributionProjectName = distributionProjectName(distribution);\n+                String projectConfig = getProjectConfig(distributionProjectName, unreleasedInfo);\n                 return new ProjectBasedDistributionDependency(\n-                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, distributionProjectName(distribution))\n+                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, projectConfig)\n                 );\n             }\n             return null;\n         }));\n     }\n \n+    private static String getProjectConfig(String distributionProjectName, BwcVersions.UnreleasedVersionInfo info) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM2NDg2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497364866", "bodyText": "yes, adding a not. Though I think we can only backport this down to 7.x we will live with that for a while till bugfix and minor is actually taken from that branch.", "author": "breskeby", "createdAt": "2020-09-30T09:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzczMA=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java\nindex ee0493b5570..41f08763d75 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionDownloadPlugin.java\n\n@@ -94,22 +94,14 @@ public class InternalDistributionDownloadPlugin implements Plugin<Project> {\n                             + \"without a bundled JDK is not supported.\"\n                     );\n                 }\n-                String distributionProjectName = distributionProjectName(distribution);\n-                String projectConfig = getProjectConfig(distributionProjectName, unreleasedInfo);\n                 return new ProjectBasedDistributionDependency(\n-                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, projectConfig)\n+                    (config) -> projectDependency(project, unreleasedInfo.gradleProjectPath, distributionProjectName(distribution))\n                 );\n             }\n             return null;\n         }));\n     }\n \n-    private static String getProjectConfig(String distributionProjectName, BwcVersions.UnreleasedVersionInfo info) {\n-        return (info.gradleProjectPath.equals(\":distribution\") || info.version.before(\"7.10.0\"))\n-            ? distributionProjectName\n-            : \"expanded-\" + distributionProjectName;\n-    }\n-\n     private static String distributionProjectPath(ElasticsearchDistribution distribution) {\n         String projectPath = \":distribution\";\n         switch (distribution.getType()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497064898", "bodyText": "Can't this be injected as a constructor arg?", "author": "mark-vieira", "createdAt": "2020-09-29T21:17:02Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2Mjc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498062787", "bodyText": "done", "author": "breskeby", "createdAt": "2020-10-01T08:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NDg5OA=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497067033", "bodyText": "Does this only technically \"work\" since we are lazily configuring these tasks?", "author": "mark-vieira", "createdAt": "2020-09-29T21:21:10Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NTM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497385398", "bodyText": "yes. One clean solution could be to change the implementation of LoggedExec to not rely on the Exec Task", "author": "breskeby", "createdAt": "2020-09-30T09:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497068154", "bodyText": "Can we leverage Util.getBooleanProperty() here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:23:30Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.LoggedExec;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.Action;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.provider.ProviderFactory;\n+import org.gradle.api.tasks.TaskContainer;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.process.ExecResult;\n+import org.gradle.process.ExecSpec;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+\n+import static java.util.Arrays.asList;\n+\n+public class InternalBwcGitPlugin implements Plugin<Project> {\n+\n+    private BwcGitExtension gitExtension;\n+    private Project project;\n+\n+    @Override\n+    public void apply(Project project) {\n+        this.project = project;\n+        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n+        ProviderFactory providers = project.getProviders();\n+        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n+\n+        TaskContainer tasks = project.getTasks();\n+        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n+            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n+            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n+        });\n+\n+        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n+            findRemote.dependsOn(createCloneTaskProvider);\n+            // TODO Gradle should provide property based configuration here\n+            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+\n+            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            findRemote.setStandardOutput(output);\n+            findRemote.doLast(t -> {\n+                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n+                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n+            });\n+        });\n+\n+        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n+            addRemote.dependsOn(findRemoteTaskProvider);\n+            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n+            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n+            String remoteRepo = remote.get();\n+            // for testing only we can override the base remote url\n+            String remoteRepoUrl = project.getProviders()\n+                .systemProperty(\"testRemoteRepo\")\n+                .forUseAtConfigurationTime()\n+                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n+            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n+        });\n+\n+        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n+            var gitFetchLatest = project.getProviders()\n+                .systemProperty(\"tests.bwc.git_fetch_latest\")\n+                .forUseAtConfigurationTime()\n+                .orElse(\"true\")\n+                .map(fetchProp -> {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4NzM3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497387371", "bodyText": "Ideally we should move away from just using System.getProperty and therefore Util.getBooleanProperty as is as this is discouraged by gradle in order to support --configuration-cache. IMO we should actually deprecate Util.getBooleanProperty  or change its implementation to take a ProviderFactory", "author": "breskeby", "createdAt": "2020-09-30T09:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497654145", "bodyText": "Understood. Yeah, we do this pattern a lot so maybe we should later add some helper for returning a provider.", "author": "mark-vieira", "createdAt": "2020-09-30T16:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NTkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497655917", "bodyText": "Why not turn Util.getBooleanProperty() into that helper?", "author": "rjernst", "createdAt": "2020-09-30T16:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NjgwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497656801", "bodyText": "I don't believe everywhere we use that is setup to consume a Provider as-is. We'd have to do some refactoring there and it's significant to probably address in a separate PR.", "author": "mark-vieira", "createdAt": "2020-09-30T16:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2NzI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497667299", "bodyText": "Sorry, I was not suggesting changing in this PR, only changing the implementation of that method in a followup, rather than continuing to add any more uses of this pattern.", "author": "rjernst", "createdAt": "2020-09-30T17:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2ODE1NA=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\ndeleted file mode 100644\nindex b6f4dca38df..00000000000\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalBwcGitPlugin.java\n+++ /dev/null\n\n@@ -1,202 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.gradle.internal;\n-\n-import org.elasticsearch.gradle.LoggedExec;\n-import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.Action;\n-import org.gradle.api.GradleException;\n-import org.gradle.api.Plugin;\n-import org.gradle.api.Project;\n-import org.gradle.api.logging.Logger;\n-import org.gradle.api.plugins.ExtraPropertiesExtension;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.provider.ProviderFactory;\n-import org.gradle.api.tasks.TaskContainer;\n-import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.process.ExecResult;\n-import org.gradle.process.ExecSpec;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-\n-import static java.util.Arrays.asList;\n-\n-public class InternalBwcGitPlugin implements Plugin<Project> {\n-\n-    private BwcGitExtension gitExtension;\n-    private Project project;\n-\n-    @Override\n-    public void apply(Project project) {\n-        this.project = project;\n-        this.gitExtension = project.getExtensions().create(\"bwcGitConfig\", BwcGitExtension.class);\n-        ProviderFactory providers = project.getProviders();\n-        Provider<String> remote = project.getProviders().systemProperty(\"bwc.remote\").forUseAtConfigurationTime().orElse(\"elastic\");\n-\n-        TaskContainer tasks = project.getTasks();\n-        TaskProvider<LoggedExec> createCloneTaskProvider = tasks.register(\"createClone\", LoggedExec.class, createClone -> {\n-            createClone.onlyIf(task -> this.gitExtension.getCheckoutDir().get().exists() == false);\n-            createClone.setCommandLine(asList(\"git\", \"clone\", project.getRootDir(), gitExtension.getCheckoutDir().get()));\n-        });\n-\n-        TaskProvider<LoggedExec> findRemoteTaskProvider = tasks.register(\"findRemote\", LoggedExec.class, findRemote -> {\n-            findRemote.dependsOn(createCloneTaskProvider);\n-            // TODO Gradle should provide property based configuration here\n-            findRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-\n-            findRemote.setCommandLine(asList(\"git\", \"remote\", \"-v\"));\n-            ByteArrayOutputStream output = new ByteArrayOutputStream();\n-            findRemote.setStandardOutput(output);\n-            findRemote.doLast(t -> {\n-                ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();\n-                extraProperties.set(\"remoteExists\", isRemoteAvailable(remote, output));\n-            });\n-        });\n-\n-        TaskProvider<LoggedExec> addRemoteTaskProvider = tasks.register(\"addRemote\", LoggedExec.class, addRemote -> {\n-            addRemote.dependsOn(findRemoteTaskProvider);\n-            addRemote.onlyIf(task -> ((boolean) project.getExtensions().getExtraProperties().get(\"remoteExists\")) == false);\n-            addRemote.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            String remoteRepo = remote.get();\n-            // for testing only we can override the base remote url\n-            String remoteRepoUrl = project.getProviders()\n-                .systemProperty(\"testRemoteRepo\")\n-                .forUseAtConfigurationTime()\n-                .getOrElse(\"https://github.com/\" + remoteRepo + \"/elasticsearch.git\");\n-            addRemote.setCommandLine(asList(\"git\", \"remote\", \"add\", remoteRepo, remoteRepoUrl));\n-        });\n-\n-        TaskProvider<LoggedExec> fetchLatestTaskProvider = tasks.register(\"fetchLatest\", LoggedExec.class, fetchLatest -> {\n-            var gitFetchLatest = project.getProviders()\n-                .systemProperty(\"tests.bwc.git_fetch_latest\")\n-                .forUseAtConfigurationTime()\n-                .orElse(\"true\")\n-                .map(fetchProp -> {\n-                    if (\"true\".equals(fetchProp)) {\n-                        return true;\n-                    }\n-                    if (\"false\".equals(fetchProp)) {\n-                        return false;\n-                    }\n-                    throw new GradleException(\"tests.bwc.git_fetch_latest must be [true] or [false] but was [\" + fetchProp + \"]\");\n-                });\n-            fetchLatest.onlyIf(t -> project.getGradle().getStartParameter().isOffline() == false && gitFetchLatest.get());\n-            fetchLatest.dependsOn(addRemoteTaskProvider);\n-            fetchLatest.setWorkingDir(gitExtension.getCheckoutDir().get());\n-            fetchLatest.setCommandLine(asList(\"git\", \"fetch\", \"--all\"));\n-        });\n-\n-        tasks.register(\"checkoutBwcBranch\", checkoutBwcBranch -> {\n-            checkoutBwcBranch.dependsOn(fetchLatestTaskProvider);\n-            checkoutBwcBranch.doLast(t -> {\n-                Logger logger = project.getLogger();\n-\n-                String bwcBranch = this.gitExtension.getBwcBranch().get();\n-                final String refspec = providers.systemProperty(\"bwc.refspec.\" + bwcBranch)\n-                    .orElse(providers.systemProperty(\"tests.bwc.refspec.\" + bwcBranch))\n-                    .getOrElse(remote.get() + \"/\" + bwcBranch);\n-\n-                String effectiveRefSpec = maybeAlignedRefSpec(project, logger, refspec);\n-\n-                logger.lifecycle(\"Performing checkout of {}...\", refspec);\n-                LoggedExec.exec(project, spec -> {\n-                    spec.workingDir(gitExtension.getCheckoutDir());\n-                    spec.commandLine(\"git\", \"checkout\", effectiveRefSpec);\n-                });\n-\n-                String checkoutHash = GlobalBuildInfoPlugin.gitInfo(gitExtension.getCheckoutDir().get()).getRevision();\n-                logger.lifecycle(\"Checkout hash for {} is {}\", project.getPath(), checkoutHash);\n-                writeFile(new File(project.getBuildDir(), \"refspec\"), checkoutHash);\n-            });\n-        });\n-    }\n-\n-    public BwcGitExtension getGitExtension() {\n-        return gitExtension;\n-    }\n-\n-    /**\n-     * We use a time based approach to make the bwc versions built deterministic and compatible with the current hash.\n-     * Most of the time we want to test against latest, but when running delayed exhaustive tests or wanting\n-     * reproducible builds we want this to be deterministic by using a hash that was the latest when the current\n-     * commit was made.\n-     * <p>\n-     * This approach doesn't work with merge commits as these can introduce commits in the chronological order\n-     * after the fact e.x. a merge done today can add commits dated with yesterday so the result will no longer be\n-     * deterministic.\n-     * <p>\n-     * We don't use merge commits, but for additional safety we check that no such commits exist in the time period\n-     * we are interested in.\n-     * <p>\n-     * Timestamps are at seconds resolution. rev-parse --before and --after are inclusive w.r.t the second\n-     * passed as input. This means the results might not be deterministic in the current second, but this\n-     * should not matter in practice.\n-     */\n-    private String maybeAlignedRefSpec(Project project, Logger logger, String defaultRefSpec) {\n-        if (project.getProviders().systemProperty(\"bwc.checkout.align\").isPresent() == false) {\n-            return defaultRefSpec;\n-        }\n-\n-        String timeOfCurrent = execGit(execSpec -> {\n-            execSpec.commandLine(asList(\"git\", \"show\", \"--no-patch\", \"--no-notes\", \"--pretty='%cD'\"));\n-            execSpec.workingDir(project.getRootDir());\n-        });\n-\n-        logger.lifecycle(\"Commit date of current: {}\", timeOfCurrent);\n-\n-        String mergeCommits = execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"--after\", timeOfCurrent, \"--merges\"))\n-        );\n-        if (mergeCommits.isEmpty() == false) {\n-            throw new IllegalStateException(\"Found the following merge commits which prevent determining bwc commits: \" + mergeCommits);\n-        }\n-        return execGit(\n-            spec -> spec.commandLine(asList(\"git\", \"rev-list\", defaultRefSpec, \"-n\", \"1\", \"--before\", timeOfCurrent, \"--date-order\"))\n-        );\n-    }\n-\n-    private void writeFile(File file, String content) {\n-        try {\n-            FileWriter myWriter = new FileWriter(file, false);\n-            myWriter.write(content);\n-            myWriter.close();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private String execGit(Action<ExecSpec> execSpecConfig) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        ExecResult exec = project.exec(execSpec -> {\n-            execSpec.setStandardOutput(os);\n-            execSpec.workingDir(gitExtension.getCheckoutDir().get());\n-            execSpecConfig.execute(execSpec);\n-        });\n-        exec.assertNormalExitValue();\n-        return os.toString().trim();\n-    }\n-\n-    private static boolean isRemoteAvailable(Provider<String> remote, ByteArrayOutputStream output) {\n-        return new String(output.toByteArray()).lines().anyMatch(l -> l.contains(remote.get() + \"\\t\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497074649", "bodyText": "Looks like we aren't using bwcProject for anything?", "author": "mark-vieira", "createdAt": "2020-09-29T21:36:24Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM4ODczOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497388738", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-09-30T09:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NDY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497077188", "bodyText": "What's the purpose of passing unreleaseVersionInfo to the extension and then just grabbing it back out? Do we need the getUnreleaseVersionInfo() method on the extensions since we already have a handle to that here?", "author": "mark-vieira", "createdAt": "2020-09-29T21:42:06Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM5NjcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497396723", "bodyText": "actually just an oversight from refactoring. fixed", "author": "breskeby", "createdAt": "2020-09-30T10:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA3NzE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497080013", "bodyText": "I'm not sure ArchiveProject is the right name here since this includes deb and rpm packages. Our packaging nomenclature uses \"archive\" to mean specifically zip and tar.", "author": "mark-vieira", "createdAt": "2020-09-29T21:47:31Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzY4MA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063680", "bodyText": "changed to DistributionProject", "author": "breskeby", "createdAt": "2020-10-01T08:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MDAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497081919", "bodyText": "I think we can remove this condition given that we will never build a bwc branch prior to this version since the oldest active branch is 6.8.", "author": "mark-vieira", "createdAt": "2020-09-29T21:51:46Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {\n+            projects.addAll(asList(\"zip\"));\n+        }\n+\n+        return projects.stream().map(name -> {\n+            String baseDir = \"distribution\";\n+            if (bwcVersion.onOrAfter(\"6.3.0\")) {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzExNzMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497117308", "bodyText": "In master that is true, though we should be sure to add it back then in the backport to 7.x", "author": "rjernst", "createdAt": "2020-09-29T23:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyNTg3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497125873", "bodyText": "The oldest version of ES that 7.x will ever build from source is 6.8.x. This is definitely legacy logic that is no longer needed in any active development branch.", "author": "mark-vieira", "createdAt": "2020-09-29T23:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyODg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497128858", "bodyText": "Doh, you are absolutely right. Ignore me!", "author": "rjernst", "createdAt": "2020-09-29T23:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MTkxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497082406", "bodyText": "I think we can ditch this conditional branch. As mentioned below, we no longer will ever build versions prior to 6.8 from source for bwc.", "author": "mark-vieira", "createdAt": "2020-09-29T21:52:54Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n+    }\n+\n+    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n+        String projectName = archiveProject.name;\n+        String buildBwcTask = buildBwcTaskName(projectName);\n+\n+        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n+        if (archiveProject.getExpandedDistDirectory() != null) {\n+            String expandedDistConfiguration = \"expanded-\" + projectName;\n+            bwcProject.getConfigurations().create(expandedDistConfiguration);\n+            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n+                artifact.setName(\"elasticsearch\");\n+                artifact.builtBy(buildBwcTask);\n+                artifact.setType(\"directory\");\n+            });\n+        }\n+    }\n+\n+    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n+        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n+        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n+\n+        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n+        int archIndex = artifactFileName.indexOf(\"x86_64\");\n+\n+        bwcProject.getConfigurations().create(archiveProject.name);\n+        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n+            artifact.setName(artifactName);\n+            artifact.builtBy(buildBwcTask);\n+            artifact.setType(suffix);\n+\n+            String classifier = \"\";\n+            if (archIndex != -1) {\n+                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n+                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n+            }\n+            artifact.setClassifier(classifier);\n+        });\n+    }\n+\n+    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n+        List<String> projects = new ArrayList<>();\n+        projects.addAll(asList(\"deb\", \"rpm\"));\n+        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n+            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n+        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n+            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n+        } else {", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2MzczMw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r498063733", "bodyText": "removed", "author": "breskeby", "createdAt": "2020-10-01T08:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4MjQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497085593", "bodyText": "Here we zero out the task dependencies but above we actually disable the task. Should we do one or the other?", "author": "mark-vieira", "createdAt": "2020-09-29T22:00:04Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gradle.internal;\n+\n+import org.elasticsearch.gradle.BwcVersions;\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n+import org.gradle.api.InvalidUserDataException;\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.provider.Provider;\n+import org.gradle.api.tasks.TaskProvider;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n+ * For this we need to check out and build the unreleased versions.\n+ * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n+ * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n+ * and configure them to build various versions here.\n+ */\n+public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n+\n+    @Override\n+    public void apply(Project project) {\n+        project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n+\n+        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n+            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n+        });\n+    }\n+\n+    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n+        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n+        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n+        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n+        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n+        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n+        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n+        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n+        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n+        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n+\n+        project.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n+\n+        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n+        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n+\n+        for (ArchiveProject archiveProject : archiveProjects) {\n+            createBuildBwcTask(\n+                bwcSetupExtension,\n+                project,\n+                bwcVersion,\n+                archiveProject.name,\n+                archiveProject.getProjectPath(),\n+                archiveProject.getDistArchiveFile(),\n+                buildBwcTaskProvider\n+            );\n+\n+            registerBwcArtifacts(project, archiveProject);\n+        }\n+\n+        // Create build tasks for the JDBC driver used for compatibility testing\n+        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n+\n+        File jdbcProjectArtifact = new File(\n+            checkoutDir.get(),\n+            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n+        );\n+\n+        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n+\n+        // make sure no dependencies were added to assemble; we want it to be a no-op\n+        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));", "originalCommit": "9df3ee594a24c357bbf8028a317b7596f6e10c85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNzUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/62473#discussion_r497537525", "bodyText": "actually I took that over from the original bwc build.gradle script but I don't see the point. Assemble should build all artefacts of that project. if its referenced somewhere were we do not want that. we should fix it there. I'll remove this. Also I think the distribution plugin is not needed.", "author": "breskeby", "createdAt": "2020-09-30T14:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "aa2ac780e895911fd352a98a290ecb286e767626", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\nindex 57161676bfa..521b6577fc2 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/internal/InternalDistributionBwcSetupPlugin.java\n\n@@ -20,244 +20,36 @@\n package org.elasticsearch.gradle.internal;\n \n import org.elasticsearch.gradle.BwcVersions;\n-import org.elasticsearch.gradle.Version;\n import org.elasticsearch.gradle.info.BuildParams;\n import org.elasticsearch.gradle.info.GlobalBuildInfoPlugin;\n-import org.gradle.api.InvalidUserDataException;\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n-import org.gradle.api.Task;\n-import org.gradle.api.provider.Provider;\n-import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Arrays.stream;\n-\n-/**\n- * We want to be able to do BWC tests for unreleased versions without relying on and waiting for snapshots.\n- * For this we need to check out and build the unreleased versions.\n- * Since These depend on the current version, we can't name the Gradle projects statically, and don't know what the\n- * unreleased versions are when Gradle projects are set up, so we use \"build-unreleased-version-*\" as placeholders\n- * and configure them to build various versions here.\n- */\n public class InternalDistributionBwcSetupPlugin implements Plugin<Project> {\n \n     @Override\n     public void apply(Project project) {\n         project.getRootProject().getPluginManager().apply(GlobalBuildInfoPlugin.class);\n-\n-        BuildParams.getBwcVersions().forPreviousUnreleased((BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n-            Project bwcProject = project.project(unreleasedVersion.gradleProjectPath);\n-            configureBwcProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n-        });\n-    }\n-\n-    private void configureBwcProject(Project project, BwcVersions.UnreleasedVersionInfo unreleasedVersionInfo) {\n-        BwcSetupExtension bwcSetupExtension = project.getExtensions().create(\"bwcSetup\", BwcSetupExtension.class, project);\n-        bwcSetupExtension.setUnreleasedVersionInfo(project.provider(() -> unreleasedVersionInfo));\n-        BwcGitExtension gitExtension = project.getPlugins().apply(InternalBwcGitPlugin.class).getGitExtension();\n-        Provider<BwcVersions.UnreleasedVersionInfo> unreleasedVersionInfoProvider = bwcSetupExtension.getUnreleasedVersionInfo();\n-        Provider<Version> bwcVersion = unreleasedVersionInfoProvider.map(info -> info.version);\n-        gitExtension.setBwcVersion(unreleasedVersionInfoProvider.map(info -> info.version));\n-        gitExtension.setBwcBranch(unreleasedVersionInfoProvider.map(info -> info.branch));\n-        Provider<File> checkoutDir = bwcSetupExtension.getCheckoutDir();\n-        gitExtension.setCheckoutDir(bwcSetupExtension.getCheckoutDir());\n-\n-        project.getPlugins().apply(\"distribution\");\n-        // Not published so no need to assemble\n-        project.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n-\n-        TaskProvider<Task> buildBwcTaskProvider = project.getTasks().register(\"buildBwc\");\n-        List<ArchiveProject> archiveProjects = resolveArchiveProjects(checkoutDir.get(), bwcVersion.get());\n-\n-        for (ArchiveProject archiveProject : archiveProjects) {\n-            createBuildBwcTask(\n-                bwcSetupExtension,\n-                project,\n-                bwcVersion,\n-                archiveProject.name,\n-                archiveProject.getProjectPath(),\n-                archiveProject.getDistArchiveFile(),\n-                buildBwcTaskProvider\n-            );\n-\n-            registerBwcArtifacts(project, archiveProject);\n-        }\n-\n-        // Create build tasks for the JDBC driver used for compatibility testing\n-        String jdbcProjectDir = \"x-pack/plugin/sql/jdbc\";\n-\n-        File jdbcProjectArtifact = new File(\n-            checkoutDir.get(),\n-            jdbcProjectDir + \"/build/distributions/x-pack-sql-jdbc-\" + bwcVersion.get() + \"-SNAPSHOT.jar\"\n-        );\n-\n-        createBuildBwcTask(bwcSetupExtension, project, bwcVersion, \"jdbc\", jdbcProjectDir, jdbcProjectArtifact, buildBwcTaskProvider);\n-\n-        // make sure no dependencies were added to assemble; we want it to be a no-op\n-        project.getTasks().named(\"assemble\").configure(t -> t.setDependsOn(Collections.emptyList()));\n-    }\n-\n-    private void registerBwcArtifacts(Project bwcProject, ArchiveProject archiveProject) {\n-        String projectName = archiveProject.name;\n-        String buildBwcTask = buildBwcTaskName(projectName);\n-\n-        registerDistributionArchiveArtifact(bwcProject, archiveProject, buildBwcTask);\n-        if (archiveProject.getExpandedDistDirectory() != null) {\n-            String expandedDistConfiguration = \"expanded-\" + projectName;\n-            bwcProject.getConfigurations().create(expandedDistConfiguration);\n-            bwcProject.getArtifacts().add(expandedDistConfiguration, archiveProject.getExpandedDistDirectory(), artifact -> {\n-                artifact.setName(\"elasticsearch\");\n-                artifact.builtBy(buildBwcTask);\n-                artifact.setType(\"directory\");\n-            });\n-        }\n-    }\n-\n-    private void registerDistributionArchiveArtifact(Project bwcProject, ArchiveProject archiveProject, String buildBwcTask) {\n-        String artifactFileName = archiveProject.getDistArchiveFile().getName();\n-        String artifactName = artifactFileName.contains(\"oss\") ? \"elasticsearch-oss\" : \"elasticsearch\";\n-\n-        String suffix = artifactFileName.endsWith(\"tar.gz\") ? \"tar.gz\" : artifactFileName.substring(artifactFileName.length() - 3);\n-        int archIndex = artifactFileName.indexOf(\"x86_64\");\n-\n-        bwcProject.getConfigurations().create(archiveProject.name);\n-        bwcProject.getArtifacts().add(archiveProject.name, archiveProject.getDistArchiveFile(), artifact -> {\n-            artifact.setName(artifactName);\n-            artifact.builtBy(buildBwcTask);\n-            artifact.setType(suffix);\n-\n-            String classifier = \"\";\n-            if (archIndex != -1) {\n-                int osIndex = artifactFileName.lastIndexOf('-', archIndex - 2);\n-                classifier = \"-\" + artifactFileName.substring(osIndex + 1, archIndex - 1) + \"-x86_64\";\n-            }\n-            artifact.setClassifier(classifier);\n-        });\n-    }\n-\n-    private static List<ArchiveProject> resolveArchiveProjects(File checkoutDir, Version bwcVersion) {\n-        List<String> projects = new ArrayList<>();\n-        projects.addAll(asList(\"deb\", \"rpm\"));\n-        if (bwcVersion.onOrAfter(\"7.0.0\")) {\n-            projects.addAll(asList(\"oss-windows-zip\", \"windows-zip\", \"oss-darwin-tar\", \"darwin-tar\", \"oss-linux-tar\", \"linux-tar\"));\n-        } else if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-            projects.addAll(asList(\"oss-zip\", \"zip\", \"oss-deb\", \"oss-rpm\"));\n-        } else {\n-            projects.addAll(asList(\"zip\"));\n-        }\n-\n-        return projects.stream().map(name -> {\n-            String baseDir = \"distribution\";\n-            if (bwcVersion.onOrAfter(\"6.3.0\")) {\n-                baseDir = baseDir + (name.endsWith(\"zip\") || name.endsWith(\"tar\") ? \"/archives\" : \"/packages\");\n-            }\n-            String classifier = \"\";\n-            String extension = name;\n-            if (bwcVersion.onOrAfter(\"7.0.0\") && (name.contains(\"zip\") || name.contains(\"tar\"))) {\n-                int index = name.lastIndexOf('-');\n-                String baseName = name.startsWith(\"oss-\") ? name.substring(4, index) : name.substring(0, index);\n-                classifier = \"-\" + baseName + \"-x86_64\";\n-                extension = name.substring(index + 1);\n-                if (extension.equals(\"tar\")) {\n-                    extension += \".gz\";\n-                }\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"deb\")) {\n-                classifier = \"-amd64\";\n-            } else if (bwcVersion.onOrAfter(\"7.0.0\") && name.contains(\"rpm\")) {\n-                classifier = \"-x86_64\";\n-            }\n-            return new ArchiveProject(name, baseDir, bwcVersion, classifier, extension, checkoutDir);\n-        }).collect(Collectors.toList());\n-    }\n-\n-    private static String buildBwcTaskName(String projectName) {\n-        return \"buildBwc\"\n-            + stream(projectName.split(\"-\")).map(i -> i.substring(0, 1).toUpperCase(Locale.ROOT) + i.substring(1))\n-                .collect(Collectors.joining());\n-    }\n-\n-    static void createBuildBwcTask(\n-        BwcSetupExtension bwcSetupExtension,\n-        Project project,\n-        Provider<Version> bwcVersion,\n-        String projectName,\n-        String projectPath,\n-        File projectArtifact,\n-        TaskProvider<Task> bwcTaskProvider\n-    ) {\n-        String bwcTaskName = buildBwcTaskName(projectName);\n-        bwcSetupExtension.bwcTask(bwcTaskName, c -> {\n-            c.getInputs().file(new File(project.getBuildDir(), \"refspec\"));\n-            c.getOutputs().files(projectArtifact);\n-            c.getOutputs().cacheIf(\"BWC distribution caching is disabled on 'master' branch\", task -> {\n-                String gitBranch = System.getenv(\"GIT_BRANCH\");\n-                return BuildParams.isCi() && (gitBranch == null || gitBranch.endsWith(\"master\") == false);\n-            });\n-            c.args(projectPath.replace('/', ':') + \":assemble\");\n-            if (project.getGradle().getStartParameter().isBuildCacheEnabled()) {\n-                c.args(\"--build-cache\");\n-            }\n-            c.doLast(task -> {\n-                if (projectArtifact.exists() == false) {\n-                    throw new InvalidUserDataException(\n-                        \"Building \" + bwcVersion.get() + \" didn't generate expected file \" + projectArtifact\n-                    );\n+        BuildParams.getBwcVersions()\n+            .forPreviousUnreleased(\n+                (BwcVersions.UnreleasedVersionInfo unreleasedVersion) -> {\n+                    configureProject(project.project(unreleasedVersion.gradleProjectPath), unreleasedVersion);\n                 }\n-            });\n-        });\n-        bwcTaskProvider.configure(t -> t.dependsOn(bwcTaskName));\n-    }\n-\n-    /**\n-     * Represents an archive project (distribution/archives/*)\n-     * we build from a bwc Version in a cloned repository\n-     */\n-    private static class ArchiveProject {\n-        private final String name;\n-        private String projectPath;\n-        private File distArchiveFile;\n-        private File expandedDistDir;\n-\n-        ArchiveProject(String name, String baseDir, Version version, String classifier, String extension, File checkoutDir) {\n-            this.name = name;\n-            this.projectPath = baseDir + \"/\" + name;\n-            this.distArchiveFile = new File(\n-                checkoutDir,\n-                baseDir\n-                    + \"/\"\n-                    + name\n-                    + \"/build/distributions/elasticsearch-\"\n-                    + (name.startsWith(\"oss\") ? \"oss-\" : \"\")\n-                    + version\n-                    + \"-SNAPSHOT\"\n-                    + classifier\n-                    + \".\"\n-                    + extension\n             );\n-            // we only ported this down to the 7.x branch.\n-            if (version.onOrAfter(\"7.10.0\") && (name.endsWith(\"zip\") || name.endsWith(\"tar\"))) {\n-                this.expandedDistDir = new File(checkoutDir, baseDir + \"/\" + name + \"/build/install\");\n-            }\n-        }\n-\n-        public String getProjectPath() {\n-            return projectPath;\n-        }\n+    }\n \n-        public File getDistArchiveFile() {\n-            return distArchiveFile;\n-        }\n+    private void configureProject(Project bwcProject, BwcVersions.UnreleasedVersionInfo unreleasedVersion) {\n+        String bwcBranch = unreleasedVersion.branch;\n+        ExtraPropertiesExtension extraProps = bwcProject.getExtensions().getExtraProperties();\n+        extraProps.set(\"bwcVersion\", unreleasedVersion.version);\n+        extraProps.set(\"bwcBranch\", bwcBranch);\n+        extraProps.set(\"checkoutDir\", new File(bwcProject.getBuildDir(), \"bwc/checkout-\" + unreleasedVersion.branch));\n \n-        public File getExpandedDistDirectory() {\n-            return expandedDistDir;\n-        }\n+        bwcProject.getPlugins().apply(\"distribution\");\n+        // Not published so no need to assemble\n+        bwcProject.getTasks().named(\"assemble\").configure(t -> t.setEnabled(false));\n     }\n }\n"}}, {"oid": "aa2ac780e895911fd352a98a290ecb286e767626", "url": "https://github.com/elastic/elasticsearch/commit/aa2ac780e895911fd352a98a290ecb286e767626", "message": "Start porting bwc distribution setup into plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "url": "https://github.com/elastic/elasticsearch/commit/0661fe2183fcb7af8f376961ea7dfaad1efec7ad", "message": "Move git checkout logic into its own plugin", "committedDate": "2020-09-30T08:33:37Z", "type": "commit"}, {"oid": "27decd8d692f49640205923064472798c2ae444f", "url": "https://github.com/elastic/elasticsearch/commit/27decd8d692f49640205923064472798c2ae444f", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "876be3303e61ad8ce1366d23a10132e24812ca1e", "url": "https://github.com/elastic/elasticsearch/commit/876be3303e61ad8ce1366d23a10132e24812ca1e", "message": "Port more bwc setup into binary plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c490dbe281e85c53a9d97a01919154dd5517999c", "url": "https://github.com/elastic/elasticsearch/commit/c490dbe281e85c53a9d97a01919154dd5517999c", "message": "Cleanup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "0473bd731f336227259dc60a908d912d70dd53c9", "url": "https://github.com/elastic/elasticsearch/commit/0473bd731f336227259dc60a908d912d70dd53c9", "message": "Fix minor issues in bwc setup", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "2a16102ced91dd3745d780841bbed4fc73aa87fd", "url": "https://github.com/elastic/elasticsearch/commit/2a16102ced91dd3745d780841bbed4fc73aa87fd", "message": "Formatting", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "c19484aea04a9d7e5211013f0db8931d96f7fadf", "url": "https://github.com/elastic/elasticsearch/commit/c19484aea04a9d7e5211013f0db8931d96f7fadf", "message": "Extract specific logic from plugin", "committedDate": "2020-09-30T08:33:38Z", "type": "commit"}, {"oid": "584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "url": "https://github.com/elastic/elasticsearch/commit/584e2dc7c7787b8aa2a6d0f573f40abc61c06b62", "message": "Fix expected artifact paths", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "url": "https://github.com/elastic/elasticsearch/commit/3411ae2e0778c7e7b7d346fdaa3d28b4e905d944", "message": "fix bwc jdbc build", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "url": "https://github.com/elastic/elasticsearch/commit/e2f324d0b57c79e1791cfc43816e3f82f75ce73a", "message": "Add initial test coverage for general bwc setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "url": "https://github.com/elastic/elasticsearch/commit/20e5e8316b32ee089d3f51a31621d9bfcfdd0d32", "message": "Tweak func tests for bwc build setup", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "4b274baebaf6f2eb908cc1998760ab731216dfee", "url": "https://github.com/elastic/elasticsearch/commit/4b274baebaf6f2eb908cc1998760ab731216dfee", "message": "Add todo", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "fb6caff2525584d10577d8e164a008697673454b", "url": "https://github.com/elastic/elasticsearch/commit/fb6caff2525584d10577d8e164a008697673454b", "message": "Minor refactoring of the plugin and fixing path calculations", "committedDate": "2020-09-30T08:33:39Z", "type": "commit"}, {"oid": "5a5fb669575dea27c04bba1646bb9a5464b53814", "url": "https://github.com/elastic/elasticsearch/commit/5a5fb669575dea27c04bba1646bb9a5464b53814", "message": "Expose exploded dists as artifacts", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "0f40234e245834e81d9da285999b3544c92f5f75", "url": "https://github.com/elastic/elasticsearch/commit/0f40234e245834e81d9da285999b3544c92f5f75", "message": "Fix spotless", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9d523e134481093d3ebc0e0db3f85a8c38f288e7", "url": "https://github.com/elastic/elasticsearch/commit/9d523e134481093d3ebc0e0db3f85a8c38f288e7", "message": "fix bwc setup plugin func test", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "fe55986f5fe630ad737f9f7cef806562abc68f59", "url": "https://github.com/elastic/elasticsearch/commit/fe55986f5fe630ad737f9f7cef806562abc68f59", "message": "Resolve exploded dist for bwc versions > 7.10", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "32684c93f5c564fee3df1fbbd294b73d373e10d9", "url": "https://github.com/elastic/elasticsearch/commit/32684c93f5c564fee3df1fbbd294b73d373e10d9", "message": "Fix bwc tests against current", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "1be13123c054d2bb3d9d8499543b21343e94ae57", "url": "https://github.com/elastic/elasticsearch/commit/1be13123c054d2bb3d9d8499543b21343e94ae57", "message": "Fix formatting", "committedDate": "2020-09-30T08:33:40Z", "type": "commit"}, {"oid": "9a1b2278739ccd360262227cc3463987972dd970", "url": "https://github.com/elastic/elasticsearch/commit/9a1b2278739ccd360262227cc3463987972dd970", "message": "Polishing\n\n- unify namings\n- use provider api", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "url": "https://github.com/elastic/elasticsearch/commit/4e2bdc7d57ecdf8fa1c7c82a11918c38da724afd", "message": "Fix jdbc driver bwc build", "committedDate": "2020-09-30T08:33:41Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "commit"}, {"oid": "a1ff0830d57b34a52aaeedf705def222c01f0d2c", "url": "https://github.com/elastic/elasticsearch/commit/a1ff0830d57b34a52aaeedf705def222c01f0d2c", "message": "Apply review feedback", "committedDate": "2020-09-30T15:20:25Z", "type": "forcePushed"}]}