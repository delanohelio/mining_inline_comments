{"pr_number": 57948, "pr_title": "Save memory when rare_terms is not on top", "pr_createdAt": "2020-06-10T20:28:41Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57948", "timeline": [{"oid": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "url": "https://github.com/elastic/elasticsearch/commit/f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "message": "Same memory when rare_terms is not on top\n\nThis uses the optimization that we started making in #55873 for\n`rare_terms` to save a bit of memory when that aggregation is not on the\ntop level.", "committedDate": "2020-06-10T20:28:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NDUyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r438854525", "bodyText": "I hate javadocs so much :(  optimizing rendered readability while sacrificing IDE readability :(\nThanks for fixing this :)", "author": "polyfractal", "createdAt": "2020-06-11T15:05:41Z", "path": "server/src/main/java/org/elasticsearch/common/util/SetBackedScalingCuckooFilter.java", "diffHunk": "@@ -39,13 +39,13 @@\n  * An approximate set membership datastructure that scales as more unique values are inserted.\n  * Can definitively say if a member does not exist (no false negatives), but may say an item exists\n  * when it does not (has false positives).  Similar in usage to a Bloom Filter.\n- *\n+ * <p>", "originalCommit": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4MzQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r438883479", "bodyText": "Hmm, this is a bit confusingly named I think?  Maybe currentOffset or something?  Not sure, but size feels a bit confusing.", "author": "polyfractal", "createdAt": "2020-06-11T15:41:25Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java", "diffHunk": "@@ -42,111 +43,144 @@\n /**\n  * An aggregator that finds \"rare\" string values (e.g. terms agg that orders ascending)\n  */\n-public class LongRareTermsAggregator extends AbstractRareTermsAggregator<ValuesSource.Numeric, IncludeExclude.LongFilter, Long> {\n-\n-    protected LongHash bucketOrds;\n-\n-    LongRareTermsAggregator(String name, AggregatorFactories factories, ValuesSource.Numeric valuesSource, DocValueFormat format,\n-                                   SearchContext aggregationContext, Aggregator parent, IncludeExclude.LongFilter longFilter,\n-                                   int maxDocCount, double precision, Map<String, Object> metadata) throws IOException {\n-        super(name, factories, aggregationContext, parent, metadata, maxDocCount, precision, format, valuesSource, longFilter);\n-        this.bucketOrds = new LongHash(1, aggregationContext.bigArrays());\n+public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n+    private final ValuesSource.Numeric valuesSource;\n+    private final IncludeExclude.LongFilter filter;\n+    private final LongKeyedBucketOrds bucketOrds;\n+\n+    LongRareTermsAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        ValuesSource.Numeric valuesSource,\n+        DocValueFormat format,\n+        SearchContext aggregationContext,\n+        Aggregator parent,\n+        IncludeExclude.LongFilter filter,\n+        int maxDocCount,\n+        double precision,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata\n+    ) throws IOException {\n+        super(\n+            name,\n+            factories,\n+            aggregationContext,\n+            parent,\n+            metadata,\n+            maxDocCount,\n+            precision,\n+            format,\n+            collectsFromSingleBucket\n+        );\n+        this.valuesSource = valuesSource;\n+        this.filter = filter;\n+        this.bucketOrds = LongKeyedBucketOrds.build(context.bigArrays(), collectsFromSingleBucket);\n     }\n \n     protected SortedNumericDocValues getValues(ValuesSource.Numeric valuesSource, LeafReaderContext ctx) throws IOException {\n         return valuesSource.longValues(ctx);\n     }\n \n     @Override\n-    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n-                                                final LeafBucketCollector sub) throws IOException {\n-        final SortedNumericDocValues values = getValues(valuesSource, ctx);\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {\n+        SortedNumericDocValues values = getValues(valuesSource, ctx);\n         return new LeafBucketCollectorBase(sub, values) {\n-\n             @Override\n-            public void collect(int docId, long owningBucketOrdinal) throws IOException {\n-                if (values.advanceExact(docId)) {\n-                    final int valuesCount = values.docValueCount();\n-                    long previous = Long.MAX_VALUE;\n-                    for (int i = 0; i < valuesCount; ++i) {\n-                        final long val = values.nextValue();\n-                        if (previous != val || i == 0) {\n-                            if ((includeExclude == null) || (includeExclude.accept(val))) {\n-                                doCollect(sub, val, docId);\n-                            }\n-                            previous = val;\n-                        }\n+            public void collect(int docId, long owningBucketOrd) throws IOException {\n+                if (false == values.advanceExact(docId)) {\n+                    return;\n+                }\n+                int valuesCount = values.docValueCount();\n+                long previous = Long.MAX_VALUE;\n+                for (int i = 0; i < valuesCount; ++i) {\n+                    long val = values.nextValue();\n+                    if (i == 0 && previous == val) {\n+                        continue;\n+                    }\n+                    previous = val;\n+                    if (filter != null && false == filter.accept(val)) {\n+                        continue;\n+                    }\n+                    long bucketOrdinal = bucketOrds.add(owningBucketOrd, val);\n+                    if (bucketOrdinal < 0) { // already seen\n+                        bucketOrdinal = -1 - bucketOrdinal;\n+                        collectExistingBucket(sub, docId, bucketOrdinal);\n+                    } else {\n+                        collectBucket(sub, docId, bucketOrdinal);\n                     }\n                 }\n             }\n         };\n     }\n \n     @Override\n-    long addValueToOrds(Long value) {\n-        return bucketOrds.add(value);\n-    }\n-\n-    /**\n-     * Merges the ordinals to a minimal set, populates the CuckooFilter and\n-     * generates a final set of buckets.\n-     *\n-     * If a term is below the maxDocCount, it is turned into a Bucket.  Otherwise,\n-     * the term is added to the filter, and pruned from the ordinal map.  If\n-     * necessary the ordinal map is merged down to a minimal set to remove deletions\n-     */\n-    private List<LongRareTerms.Bucket> buildSketch() {\n-        long deletionCount = 0;\n-        LongHash newBucketOrds = new LongHash(1, context.bigArrays());\n-        List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-        try (LongHash oldBucketOrds = bucketOrds) {\n-\n-            long[] mergeMap = new long[(int) oldBucketOrds.size()];\n-            for (int i = 0; i < oldBucketOrds.size(); i++) {\n-                long oldKey = oldBucketOrds.get(i);\n-                long newBucketOrd = -1;\n-\n-                long docCount = bucketDocCount(i);\n-                // if the key is below threshold, reinsert into the new ords\n-                if (docCount <= maxDocCount) {\n-                    newBucketOrd = newBucketOrds.add(oldKey);\n-                    LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(oldKey, docCount, null, format);\n-                    bucket.bucketOrd = newBucketOrd;\n-                    buckets.add(bucket);\n-                } else {\n-                    // Make a note when one of the ords has been deleted\n-                    deletionCount += 1;\n-                    filter.add(oldKey);\n+    public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {\n+        /*\n+         * Collect the list of buckets, populate the filter with terms\n+         * that are too frequent, and figure out how to merge sub-buckets.\n+         */\n+        LongRareTerms.Bucket[][] rarestPerOrd = new LongRareTerms.Bucket[owningBucketOrds.length][];\n+        SetBackedScalingCuckooFilter[] filters = new SetBackedScalingCuckooFilter[owningBucketOrds.length];\n+        long keepCount = 0;\n+        long[] mergeMap = new long[(int) bucketOrds.size()];\n+        Arrays.fill(mergeMap, -1);\n+        long size = 0;", "originalCommit": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "280f7273e786355713c79460e0011a10c308f000", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\nindex 2f416233e49..261f7bdd82b 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n\n@@ -124,26 +124,27 @@ public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n         long keepCount = 0;\n         long[] mergeMap = new long[(int) bucketOrds.size()];\n         Arrays.fill(mergeMap, -1);\n-        long size = 0;\n-        for (int ordIdx = 0; ordIdx < owningBucketOrds.length; ordIdx++) {\n-            try (LongHash ordsToCollect = new LongHash(1, context.bigArrays())) {\n-                filters[ordIdx] = newFilter();\n-                List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-                LongKeyedBucketOrds.BucketOrdsEnum ordsEnum = bucketOrds.ordsEnum(owningBucketOrds[ordIdx]);\n-                while (ordsEnum.next()) {\n-                    long docCount = bucketDocCount(ordsEnum.ord());\n+        long offset = 0;\n+        for (int owningOrdIdx = 0; owningOrdIdx < owningBucketOrds.length; owningOrdIdx++) {\n+            try (LongHash bucketsInThisOwningBucketToCollect = new LongHash(1, context.bigArrays())) {\n+                filters[owningOrdIdx] = newFilter();\n+                List<LongRareTerms.Bucket> builtBuckets = new ArrayList<>();\n+                LongKeyedBucketOrds.BucketOrdsEnum collectedBuckets = bucketOrds.ordsEnum(owningBucketOrds[owningOrdIdx]);\n+                while (collectedBuckets.next()) {\n+                    long docCount = bucketDocCount(collectedBuckets.ord());\n                     // if the key is below threshold, reinsert into the new ords\n                     if (docCount <= maxDocCount) {\n-                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(ordsEnum.value(), docCount, null, format);\n-                        bucket.bucketOrd = mergeMap[(int) ordsEnum.ord()] = size + ordsToCollect.add(ordsEnum.value());\n-                        buckets.add(bucket);\n+                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(collectedBuckets.value(), docCount, null, format);\n+                        bucket.bucketOrd = offset + bucketsInThisOwningBucketToCollect.add(collectedBuckets.value());\n+                        mergeMap[(int) collectedBuckets.ord()] = bucket.bucketOrd;\n+                        builtBuckets.add(bucket);\n                         keepCount++;\n                     } else {\n-                        filters[ordIdx].add(ordsEnum.value());\n+                        filters[owningOrdIdx].add(collectedBuckets.value());\n                     }\n                 }\n-                rarestPerOrd[ordIdx] = buckets.toArray(LongRareTerms.Bucket[]::new);\n-                size += ordsToCollect.size();\n+                rarestPerOrd[owningOrdIdx] = builtBuckets.toArray(LongRareTerms.Bucket[]::new);\n+                offset += bucketsInThisOwningBucketToCollect.size();\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4NTE4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r438885183", "bodyText": "Should we just change this to a boolean flag?  hasDeletions or whatever?", "author": "polyfractal", "createdAt": "2020-06-11T15:43:54Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java", "diffHunk": "@@ -42,111 +43,144 @@\n /**\n  * An aggregator that finds \"rare\" string values (e.g. terms agg that orders ascending)\n  */\n-public class LongRareTermsAggregator extends AbstractRareTermsAggregator<ValuesSource.Numeric, IncludeExclude.LongFilter, Long> {\n-\n-    protected LongHash bucketOrds;\n-\n-    LongRareTermsAggregator(String name, AggregatorFactories factories, ValuesSource.Numeric valuesSource, DocValueFormat format,\n-                                   SearchContext aggregationContext, Aggregator parent, IncludeExclude.LongFilter longFilter,\n-                                   int maxDocCount, double precision, Map<String, Object> metadata) throws IOException {\n-        super(name, factories, aggregationContext, parent, metadata, maxDocCount, precision, format, valuesSource, longFilter);\n-        this.bucketOrds = new LongHash(1, aggregationContext.bigArrays());\n+public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n+    private final ValuesSource.Numeric valuesSource;\n+    private final IncludeExclude.LongFilter filter;\n+    private final LongKeyedBucketOrds bucketOrds;\n+\n+    LongRareTermsAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        ValuesSource.Numeric valuesSource,\n+        DocValueFormat format,\n+        SearchContext aggregationContext,\n+        Aggregator parent,\n+        IncludeExclude.LongFilter filter,\n+        int maxDocCount,\n+        double precision,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata\n+    ) throws IOException {\n+        super(\n+            name,\n+            factories,\n+            aggregationContext,\n+            parent,\n+            metadata,\n+            maxDocCount,\n+            precision,\n+            format,\n+            collectsFromSingleBucket\n+        );\n+        this.valuesSource = valuesSource;\n+        this.filter = filter;\n+        this.bucketOrds = LongKeyedBucketOrds.build(context.bigArrays(), collectsFromSingleBucket);\n     }\n \n     protected SortedNumericDocValues getValues(ValuesSource.Numeric valuesSource, LeafReaderContext ctx) throws IOException {\n         return valuesSource.longValues(ctx);\n     }\n \n     @Override\n-    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n-                                                final LeafBucketCollector sub) throws IOException {\n-        final SortedNumericDocValues values = getValues(valuesSource, ctx);\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {\n+        SortedNumericDocValues values = getValues(valuesSource, ctx);\n         return new LeafBucketCollectorBase(sub, values) {\n-\n             @Override\n-            public void collect(int docId, long owningBucketOrdinal) throws IOException {\n-                if (values.advanceExact(docId)) {\n-                    final int valuesCount = values.docValueCount();\n-                    long previous = Long.MAX_VALUE;\n-                    for (int i = 0; i < valuesCount; ++i) {\n-                        final long val = values.nextValue();\n-                        if (previous != val || i == 0) {\n-                            if ((includeExclude == null) || (includeExclude.accept(val))) {\n-                                doCollect(sub, val, docId);\n-                            }\n-                            previous = val;\n-                        }\n+            public void collect(int docId, long owningBucketOrd) throws IOException {\n+                if (false == values.advanceExact(docId)) {\n+                    return;\n+                }\n+                int valuesCount = values.docValueCount();\n+                long previous = Long.MAX_VALUE;\n+                for (int i = 0; i < valuesCount; ++i) {\n+                    long val = values.nextValue();\n+                    if (i == 0 && previous == val) {\n+                        continue;\n+                    }\n+                    previous = val;\n+                    if (filter != null && false == filter.accept(val)) {\n+                        continue;\n+                    }\n+                    long bucketOrdinal = bucketOrds.add(owningBucketOrd, val);\n+                    if (bucketOrdinal < 0) { // already seen\n+                        bucketOrdinal = -1 - bucketOrdinal;\n+                        collectExistingBucket(sub, docId, bucketOrdinal);\n+                    } else {\n+                        collectBucket(sub, docId, bucketOrdinal);\n                     }\n                 }\n             }\n         };\n     }\n \n     @Override\n-    long addValueToOrds(Long value) {\n-        return bucketOrds.add(value);\n-    }\n-\n-    /**\n-     * Merges the ordinals to a minimal set, populates the CuckooFilter and\n-     * generates a final set of buckets.\n-     *\n-     * If a term is below the maxDocCount, it is turned into a Bucket.  Otherwise,\n-     * the term is added to the filter, and pruned from the ordinal map.  If\n-     * necessary the ordinal map is merged down to a minimal set to remove deletions\n-     */\n-    private List<LongRareTerms.Bucket> buildSketch() {\n-        long deletionCount = 0;\n-        LongHash newBucketOrds = new LongHash(1, context.bigArrays());\n-        List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-        try (LongHash oldBucketOrds = bucketOrds) {\n-\n-            long[] mergeMap = new long[(int) oldBucketOrds.size()];\n-            for (int i = 0; i < oldBucketOrds.size(); i++) {\n-                long oldKey = oldBucketOrds.get(i);\n-                long newBucketOrd = -1;\n-\n-                long docCount = bucketDocCount(i);\n-                // if the key is below threshold, reinsert into the new ords\n-                if (docCount <= maxDocCount) {\n-                    newBucketOrd = newBucketOrds.add(oldKey);\n-                    LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(oldKey, docCount, null, format);\n-                    bucket.bucketOrd = newBucketOrd;\n-                    buckets.add(bucket);\n-                } else {\n-                    // Make a note when one of the ords has been deleted\n-                    deletionCount += 1;\n-                    filter.add(oldKey);\n+    public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {\n+        /*\n+         * Collect the list of buckets, populate the filter with terms\n+         * that are too frequent, and figure out how to merge sub-buckets.\n+         */\n+        LongRareTerms.Bucket[][] rarestPerOrd = new LongRareTerms.Bucket[owningBucketOrds.length][];\n+        SetBackedScalingCuckooFilter[] filters = new SetBackedScalingCuckooFilter[owningBucketOrds.length];\n+        long keepCount = 0;\n+        long[] mergeMap = new long[(int) bucketOrds.size()];\n+        Arrays.fill(mergeMap, -1);\n+        long size = 0;\n+        for (int ordIdx = 0; ordIdx < owningBucketOrds.length; ordIdx++) {\n+            try (LongHash ordsToCollect = new LongHash(1, context.bigArrays())) {\n+                filters[ordIdx] = newFilter();\n+                List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n+                LongKeyedBucketOrds.BucketOrdsEnum ordsEnum = bucketOrds.ordsEnum(owningBucketOrds[ordIdx]);\n+                while (ordsEnum.next()) {\n+                    long docCount = bucketDocCount(ordsEnum.ord());\n+                    // if the key is below threshold, reinsert into the new ords\n+                    if (docCount <= maxDocCount) {\n+                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(ordsEnum.value(), docCount, null, format);\n+                        bucket.bucketOrd = mergeMap[(int) ordsEnum.ord()] = size + ordsToCollect.add(ordsEnum.value());\n+                        buckets.add(bucket);\n+                        keepCount++;", "originalCommit": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyODgxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r439428811", "bodyText": "I think we need to perform the merge if we don't keep all the buckets. We can remove buckets for two reasons now!\n\nThe key is above the threshold.\nThe owningBucketOrd isn't selected.\n\nThis counter will catch both ways. I couldn't come up with a cleaner way to do it.", "author": "nik9000", "createdAt": "2020-06-12T13:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4NTE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "280f7273e786355713c79460e0011a10c308f000", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\nindex 2f416233e49..261f7bdd82b 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n\n@@ -124,26 +124,27 @@ public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n         long keepCount = 0;\n         long[] mergeMap = new long[(int) bucketOrds.size()];\n         Arrays.fill(mergeMap, -1);\n-        long size = 0;\n-        for (int ordIdx = 0; ordIdx < owningBucketOrds.length; ordIdx++) {\n-            try (LongHash ordsToCollect = new LongHash(1, context.bigArrays())) {\n-                filters[ordIdx] = newFilter();\n-                List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-                LongKeyedBucketOrds.BucketOrdsEnum ordsEnum = bucketOrds.ordsEnum(owningBucketOrds[ordIdx]);\n-                while (ordsEnum.next()) {\n-                    long docCount = bucketDocCount(ordsEnum.ord());\n+        long offset = 0;\n+        for (int owningOrdIdx = 0; owningOrdIdx < owningBucketOrds.length; owningOrdIdx++) {\n+            try (LongHash bucketsInThisOwningBucketToCollect = new LongHash(1, context.bigArrays())) {\n+                filters[owningOrdIdx] = newFilter();\n+                List<LongRareTerms.Bucket> builtBuckets = new ArrayList<>();\n+                LongKeyedBucketOrds.BucketOrdsEnum collectedBuckets = bucketOrds.ordsEnum(owningBucketOrds[owningOrdIdx]);\n+                while (collectedBuckets.next()) {\n+                    long docCount = bucketDocCount(collectedBuckets.ord());\n                     // if the key is below threshold, reinsert into the new ords\n                     if (docCount <= maxDocCount) {\n-                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(ordsEnum.value(), docCount, null, format);\n-                        bucket.bucketOrd = mergeMap[(int) ordsEnum.ord()] = size + ordsToCollect.add(ordsEnum.value());\n-                        buckets.add(bucket);\n+                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(collectedBuckets.value(), docCount, null, format);\n+                        bucket.bucketOrd = offset + bucketsInThisOwningBucketToCollect.add(collectedBuckets.value());\n+                        mergeMap[(int) collectedBuckets.ord()] = bucket.bucketOrd;\n+                        builtBuckets.add(bucket);\n                         keepCount++;\n                     } else {\n-                        filters[ordIdx].add(ordsEnum.value());\n+                        filters[owningOrdIdx].add(collectedBuckets.value());\n                     }\n                 }\n-                rarestPerOrd[ordIdx] = buckets.toArray(LongRareTerms.Bucket[]::new);\n-                size += ordsToCollect.size();\n+                rarestPerOrd[owningOrdIdx] = builtBuckets.toArray(LongRareTerms.Bucket[]::new);\n+                offset += bucketsInThisOwningBucketToCollect.size();\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4Njg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r438886869", "bodyText": "Nit: !filter.accept() :)\n(Also I realize the irony since the original code had that and it was my fault :) )", "author": "polyfractal", "createdAt": "2020-06-11T15:45:58Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringRareTermsAggregator.java", "diffHunk": "@@ -63,96 +87,106 @@ public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n             final BytesRefBuilder previous = new BytesRefBuilder();\n \n             @Override\n-            public void collect(int docId, long bucket) throws IOException {\n-                assert bucket == 0;\n-                if (values.advanceExact(docId)) {\n-                    final int valuesCount = values.docValueCount();\n-                    previous.clear();\n-\n-                    // SortedBinaryDocValues don't guarantee uniqueness so we\n-                    // need to take care of dups\n-                    for (int i = 0; i < valuesCount; ++i) {\n-                        final BytesRef bytes = values.nextValue();\n-                        if (includeExclude != null && !includeExclude.accept(bytes)) {\n-                            continue;\n-                        }\n-                        if (i > 0 && previous.get().equals(bytes)) {\n-                            continue;\n-                        }\n-\n-                        doCollect(sub, bytes, docId);\n-                        previous.copyBytes(bytes);\n+            public void collect(int docId, long owningBucketOrd) throws IOException {\n+                if (false == values.advanceExact(docId)) {\n+                    return;\n+                }\n+                int valuesCount = values.docValueCount();\n+                previous.clear();\n+\n+                // SortedBinaryDocValues don't guarantee uniqueness so we\n+                // need to take care of dups\n+                for (int i = 0; i < valuesCount; ++i) {\n+                    BytesRef bytes = values.nextValue();\n+                    if (filter != null && !filter.accept(bytes)) {", "originalCommit": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyODk5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r439428992", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-06-12T13:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4Njg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "280f7273e786355713c79460e0011a10c308f000", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringRareTermsAggregator.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringRareTermsAggregator.java\nindex eaa31236c43..00726b0ce25 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringRareTermsAggregator.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/StringRareTermsAggregator.java\n\n@@ -98,7 +98,7 @@ public class StringRareTermsAggregator extends AbstractRareTermsAggregator {\n                 // need to take care of dups\n                 for (int i = 0; i < valuesCount; ++i) {\n                     BytesRef bytes = values.nextValue();\n-                    if (filter != null && !filter.accept(bytes)) {\n+                    if (filter != null && false == filter.accept(bytes)) {\n                         continue;\n                     }\n                     if (i > 0 && previous.get().equals(bytes)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5NDQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/57948#discussion_r438894412", "bodyText": "General comment about this method:  we have a lot of \"ords\" being referenced and it's hard to keep track of which ord is which.  E.g. we have the bucket ordinals that our parent is requesting we build, and then we have the bucket ordinals from each of those instances that we are collecting into buckets\nNot sure how, but if we could find a way to rename the variables to help identify or disambiguate I think it would help a bunch.", "author": "polyfractal", "createdAt": "2020-06-11T15:54:03Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java", "diffHunk": "@@ -42,111 +43,144 @@\n /**\n  * An aggregator that finds \"rare\" string values (e.g. terms agg that orders ascending)\n  */\n-public class LongRareTermsAggregator extends AbstractRareTermsAggregator<ValuesSource.Numeric, IncludeExclude.LongFilter, Long> {\n-\n-    protected LongHash bucketOrds;\n-\n-    LongRareTermsAggregator(String name, AggregatorFactories factories, ValuesSource.Numeric valuesSource, DocValueFormat format,\n-                                   SearchContext aggregationContext, Aggregator parent, IncludeExclude.LongFilter longFilter,\n-                                   int maxDocCount, double precision, Map<String, Object> metadata) throws IOException {\n-        super(name, factories, aggregationContext, parent, metadata, maxDocCount, precision, format, valuesSource, longFilter);\n-        this.bucketOrds = new LongHash(1, aggregationContext.bigArrays());\n+public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n+    private final ValuesSource.Numeric valuesSource;\n+    private final IncludeExclude.LongFilter filter;\n+    private final LongKeyedBucketOrds bucketOrds;\n+\n+    LongRareTermsAggregator(\n+        String name,\n+        AggregatorFactories factories,\n+        ValuesSource.Numeric valuesSource,\n+        DocValueFormat format,\n+        SearchContext aggregationContext,\n+        Aggregator parent,\n+        IncludeExclude.LongFilter filter,\n+        int maxDocCount,\n+        double precision,\n+        boolean collectsFromSingleBucket,\n+        Map<String, Object> metadata\n+    ) throws IOException {\n+        super(\n+            name,\n+            factories,\n+            aggregationContext,\n+            parent,\n+            metadata,\n+            maxDocCount,\n+            precision,\n+            format,\n+            collectsFromSingleBucket\n+        );\n+        this.valuesSource = valuesSource;\n+        this.filter = filter;\n+        this.bucketOrds = LongKeyedBucketOrds.build(context.bigArrays(), collectsFromSingleBucket);\n     }\n \n     protected SortedNumericDocValues getValues(ValuesSource.Numeric valuesSource, LeafReaderContext ctx) throws IOException {\n         return valuesSource.longValues(ctx);\n     }\n \n     @Override\n-    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n-                                                final LeafBucketCollector sub) throws IOException {\n-        final SortedNumericDocValues values = getValues(valuesSource, ctx);\n+    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {\n+        SortedNumericDocValues values = getValues(valuesSource, ctx);\n         return new LeafBucketCollectorBase(sub, values) {\n-\n             @Override\n-            public void collect(int docId, long owningBucketOrdinal) throws IOException {\n-                if (values.advanceExact(docId)) {\n-                    final int valuesCount = values.docValueCount();\n-                    long previous = Long.MAX_VALUE;\n-                    for (int i = 0; i < valuesCount; ++i) {\n-                        final long val = values.nextValue();\n-                        if (previous != val || i == 0) {\n-                            if ((includeExclude == null) || (includeExclude.accept(val))) {\n-                                doCollect(sub, val, docId);\n-                            }\n-                            previous = val;\n-                        }\n+            public void collect(int docId, long owningBucketOrd) throws IOException {\n+                if (false == values.advanceExact(docId)) {\n+                    return;\n+                }\n+                int valuesCount = values.docValueCount();\n+                long previous = Long.MAX_VALUE;\n+                for (int i = 0; i < valuesCount; ++i) {\n+                    long val = values.nextValue();\n+                    if (i == 0 && previous == val) {\n+                        continue;\n+                    }\n+                    previous = val;\n+                    if (filter != null && false == filter.accept(val)) {\n+                        continue;\n+                    }\n+                    long bucketOrdinal = bucketOrds.add(owningBucketOrd, val);\n+                    if (bucketOrdinal < 0) { // already seen\n+                        bucketOrdinal = -1 - bucketOrdinal;\n+                        collectExistingBucket(sub, docId, bucketOrdinal);\n+                    } else {\n+                        collectBucket(sub, docId, bucketOrdinal);\n                     }\n                 }\n             }\n         };\n     }\n \n     @Override\n-    long addValueToOrds(Long value) {\n-        return bucketOrds.add(value);\n-    }\n-\n-    /**\n-     * Merges the ordinals to a minimal set, populates the CuckooFilter and\n-     * generates a final set of buckets.\n-     *\n-     * If a term is below the maxDocCount, it is turned into a Bucket.  Otherwise,\n-     * the term is added to the filter, and pruned from the ordinal map.  If\n-     * necessary the ordinal map is merged down to a minimal set to remove deletions\n-     */\n-    private List<LongRareTerms.Bucket> buildSketch() {\n-        long deletionCount = 0;\n-        LongHash newBucketOrds = new LongHash(1, context.bigArrays());\n-        List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-        try (LongHash oldBucketOrds = bucketOrds) {\n-\n-            long[] mergeMap = new long[(int) oldBucketOrds.size()];\n-            for (int i = 0; i < oldBucketOrds.size(); i++) {\n-                long oldKey = oldBucketOrds.get(i);\n-                long newBucketOrd = -1;\n-\n-                long docCount = bucketDocCount(i);\n-                // if the key is below threshold, reinsert into the new ords\n-                if (docCount <= maxDocCount) {\n-                    newBucketOrd = newBucketOrds.add(oldKey);\n-                    LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(oldKey, docCount, null, format);\n-                    bucket.bucketOrd = newBucketOrd;\n-                    buckets.add(bucket);\n-                } else {\n-                    // Make a note when one of the ords has been deleted\n-                    deletionCount += 1;\n-                    filter.add(oldKey);\n+    public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {", "originalCommit": "f403c0cf68f9a94db4aaeb609f7855815fcdbb51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "280f7273e786355713c79460e0011a10c308f000", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\nindex 2f416233e49..261f7bdd82b 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongRareTermsAggregator.java\n\n@@ -124,26 +124,27 @@ public class LongRareTermsAggregator extends AbstractRareTermsAggregator {\n         long keepCount = 0;\n         long[] mergeMap = new long[(int) bucketOrds.size()];\n         Arrays.fill(mergeMap, -1);\n-        long size = 0;\n-        for (int ordIdx = 0; ordIdx < owningBucketOrds.length; ordIdx++) {\n-            try (LongHash ordsToCollect = new LongHash(1, context.bigArrays())) {\n-                filters[ordIdx] = newFilter();\n-                List<LongRareTerms.Bucket> buckets = new ArrayList<>();\n-                LongKeyedBucketOrds.BucketOrdsEnum ordsEnum = bucketOrds.ordsEnum(owningBucketOrds[ordIdx]);\n-                while (ordsEnum.next()) {\n-                    long docCount = bucketDocCount(ordsEnum.ord());\n+        long offset = 0;\n+        for (int owningOrdIdx = 0; owningOrdIdx < owningBucketOrds.length; owningOrdIdx++) {\n+            try (LongHash bucketsInThisOwningBucketToCollect = new LongHash(1, context.bigArrays())) {\n+                filters[owningOrdIdx] = newFilter();\n+                List<LongRareTerms.Bucket> builtBuckets = new ArrayList<>();\n+                LongKeyedBucketOrds.BucketOrdsEnum collectedBuckets = bucketOrds.ordsEnum(owningBucketOrds[owningOrdIdx]);\n+                while (collectedBuckets.next()) {\n+                    long docCount = bucketDocCount(collectedBuckets.ord());\n                     // if the key is below threshold, reinsert into the new ords\n                     if (docCount <= maxDocCount) {\n-                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(ordsEnum.value(), docCount, null, format);\n-                        bucket.bucketOrd = mergeMap[(int) ordsEnum.ord()] = size + ordsToCollect.add(ordsEnum.value());\n-                        buckets.add(bucket);\n+                        LongRareTerms.Bucket bucket = new LongRareTerms.Bucket(collectedBuckets.value(), docCount, null, format);\n+                        bucket.bucketOrd = offset + bucketsInThisOwningBucketToCollect.add(collectedBuckets.value());\n+                        mergeMap[(int) collectedBuckets.ord()] = bucket.bucketOrd;\n+                        builtBuckets.add(bucket);\n                         keepCount++;\n                     } else {\n-                        filters[ordIdx].add(ordsEnum.value());\n+                        filters[owningOrdIdx].add(collectedBuckets.value());\n                     }\n                 }\n-                rarestPerOrd[ordIdx] = buckets.toArray(LongRareTerms.Bucket[]::new);\n-                size += ordsToCollect.size();\n+                rarestPerOrd[owningOrdIdx] = builtBuckets.toArray(LongRareTerms.Bucket[]::new);\n+                offset += bucketsInThisOwningBucketToCollect.size();\n             }\n         }\n \n"}}, {"oid": "7c69d58be45e140df9d58944b1cd11b3ac873210", "url": "https://github.com/elastic/elasticsearch/commit/7c69d58be45e140df9d58944b1cd11b3ac873210", "message": "Merge branch 'master' into rare_terms_mem", "committedDate": "2020-06-12T12:50:35Z", "type": "commit"}, {"oid": "fbf96ea66edfef41d0c7dee450f90db978d7cf7b", "url": "https://github.com/elastic/elasticsearch/commit/fbf96ea66edfef41d0c7dee450f90db978d7cf7b", "message": "Merge branch 'master' into rare_terms_mem", "committedDate": "2020-06-12T13:43:57Z", "type": "commit"}, {"oid": "280f7273e786355713c79460e0011a10c308f000", "url": "https://github.com/elastic/elasticsearch/commit/280f7273e786355713c79460e0011a10c308f000", "message": "Rename", "committedDate": "2020-06-12T17:57:05Z", "type": "commit"}, {"oid": "34f3e114013844ffa0930fb9769f1af240060e65", "url": "https://github.com/elastic/elasticsearch/commit/34f3e114013844ffa0930fb9769f1af240060e65", "message": "Merge branch 'master' into rare_terms_mem", "committedDate": "2020-06-12T19:18:53Z", "type": "commit"}]}