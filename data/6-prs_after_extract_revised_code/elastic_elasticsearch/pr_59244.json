{"pr_number": 59244, "pr_title": "Composable templates: add a default mapping for @timestamp", "pr_createdAt": "2020-07-08T17:55:57Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/59244", "timeline": [{"oid": "c5e73b776884be4ebd5ba87c783bcf5e0a162644", "url": "https://github.com/elastic/elasticsearch/commit/c5e73b776884be4ebd5ba87c783bcf5e0a162644", "message": "Composable templates: add a default mapping for @timestamp\n\nThis adds a low precendece mapping for the `@timestamp` field with\ntype `date`.\nThis will aid with the bootstrapping of data streams as a timestamp\nmapping can be omitted when nanos precision is not needed.", "committedDate": "2020-07-08T17:54:09Z", "type": "commit"}, {"oid": "b414ed4dee5d59091af3cc91b02a0e8ecb157f1a", "url": "https://github.com/elastic/elasticsearch/commit/b414ed4dee5d59091af3cc91b02a0e8ecb157f1a", "message": "Add precedence test", "committedDate": "2020-07-08T18:02:45Z", "type": "commit"}, {"oid": "13ab97b08d0723fdb0a0f2817aa7e441c67c2caa", "url": "https://github.com/elastic/elasticsearch/commit/13ab97b08d0723fdb0a0f2817aa7e441c67c2caa", "message": "Fix line length", "committedDate": "2020-07-08T18:04:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTczMDk4MA==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r451730980", "bodyText": "Shouldn't this be inside an if to only add this if the template has a data stream component defined?", "author": "dakrone", "createdAt": "2020-07-08T18:03:26Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -954,11 +964,14 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n             .map(ComponentTemplate::template)\n             .map(Template::mappings)\n             .filter(Objects::nonNull)\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toCollection(LinkedList::new));\n         // Add the actual index template's mappings, since it takes the highest precedence\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n+        // add a default mapping for the `@timestamp` field, at the lowest precedence, to make bootstrapping data streams more\n+        // straightforward\n+        mappings.add(0, new CompressedXContent(wrapMappingsIfNecessary(DEFAULT_TIMESTAMP_MAPPING, xContentRegistry)));", "originalCommit": "c5e73b776884be4ebd5ba87c783bcf5e0a162644", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc0MDQ1OA==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r451740458", "bodyText": "I was under the impression we always wanted to add it, however I think you're right. Thanks, Lee", "author": "andreidan", "createdAt": "2020-07-08T18:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTczMDk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ed622209bd7123653a420125461b1690805e98f4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\nindex a6bc692677e..6b4584d8a16 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n\n@@ -969,9 +969,11 @@ public class MetadataIndexTemplateService {\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n-        // add a default mapping for the `@timestamp` field, at the lowest precedence, to make bootstrapping data streams more\n-        // straightforward\n-        mappings.add(0, new CompressedXContent(wrapMappingsIfNecessary(DEFAULT_TIMESTAMP_MAPPING, xContentRegistry)));\n+        if (template.getDataStreamTemplate() != null) {\n+            // add a default mapping for the `@timestamp` field, at the lowest precedence, to make bootstrapping data streams more\n+            // straightforward\n+            mappings.add(0, new CompressedXContent(wrapMappingsIfNecessary(DEFAULT_TIMESTAMP_MAPPING, xContentRegistry)));\n+        }\n \n         // Only include _timestamp mapping snippet if creating backing index.\n         if (indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {\n"}}, {"oid": "6fc65c772f4f01e0ae9b25cd9f107488c27c25fb", "url": "https://github.com/elastic/elasticsearch/commit/6fc65c772f4f01e0ae9b25cd9f107488c27c25fb", "message": "Merge branch 'master' into composable-templates-default-timestamp-mapping", "committedDate": "2020-07-08T18:14:45Z", "type": "commit"}, {"oid": "ed622209bd7123653a420125461b1690805e98f4", "url": "https://github.com/elastic/elasticsearch/commit/ed622209bd7123653a420125461b1690805e98f4", "message": "Add default timestamp only when datastream is defined in template", "committedDate": "2020-07-08T18:27:22Z", "type": "commit"}, {"oid": "c4ea34cab36342ac3019aa7cba88732afe4a6253", "url": "https://github.com/elastic/elasticsearch/commit/c4ea34cab36342ac3019aa7cba88732afe4a6253", "message": "Merge branch 'master' into composable-templates-default-timestamp-mapping", "committedDate": "2020-07-09T07:17:49Z", "type": "commit"}, {"oid": "f6de98d4b3c48a140d62b020e9c72d19d01b9dd4", "url": "https://github.com/elastic/elasticsearch/commit/f6de98d4b3c48a140d62b020e9c72d19d01b9dd4", "message": "Disable tests in 7.9 until after we backport", "committedDate": "2020-07-09T08:33:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA2NTc2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r452065762", "bodyText": "why linked list?", "author": "martijnvg", "createdAt": "2020-07-09T08:53:06Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -954,11 +964,16 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n             .map(ComponentTemplate::template)\n             .map(Template::mappings)\n             .filter(Objects::nonNull)\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toCollection(LinkedList::new));", "originalCommit": "f6de98d4b3c48a140d62b020e9c72d19d01b9dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjExMjM3MA==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r452112370", "bodyText": "because we insert a mapping on the first position below (adding the default @timestamp). That takes linear time with ArrayList as opposed to constant time with the LinkedList. We also don't random access the mappings list but always iterate it on, so it seems like the LinkedList is a better fit for the current use cases.", "author": "andreidan", "createdAt": "2020-07-09T10:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA2NTc2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ae6dab8005984f27bda2448a3c4efcbfe5df0d67", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\nindex 6b4584d8a16..4eb40e72658 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n\n@@ -969,9 +969,9 @@ public class MetadataIndexTemplateService {\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n-        if (template.getDataStreamTemplate() != null) {\n+        if (template.getDataStreamTemplate() != null && indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {\n             // add a default mapping for the `@timestamp` field, at the lowest precedence, to make bootstrapping data streams more\n-            // straightforward\n+            // straightforward as all backing indices are required to have a timestamp field\n             mappings.add(0, new CompressedXContent(wrapMappingsIfNecessary(DEFAULT_TIMESTAMP_MAPPING, xContentRegistry)));\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA2Nzg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r452067877", "bodyText": "I think we need to move this side the body of if (indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {,\nbecause this should only be applied when a backing index is created (and otherwise a regular create index call and if a template matches with a 'data_stream' definition would get this mapping applied as well).", "author": "martijnvg", "createdAt": "2020-07-09T08:56:26Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java", "diffHunk": "@@ -954,11 +964,16 @@ public static String findV2Template(Metadata metadata, String indexName, boolean\n             .map(ComponentTemplate::template)\n             .map(Template::mappings)\n             .filter(Objects::nonNull)\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toCollection(LinkedList::new));\n         // Add the actual index template's mappings, since it takes the highest precedence\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n+        if (template.getDataStreamTemplate() != null) {", "originalCommit": "f6de98d4b3c48a140d62b020e9c72d19d01b9dd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae6dab8005984f27bda2448a3c4efcbfe5df0d67", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\nindex 6b4584d8a16..4eb40e72658 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateService.java\n\n@@ -969,9 +969,9 @@ public class MetadataIndexTemplateService {\n         Optional.ofNullable(template.template())\n             .map(Template::mappings)\n             .ifPresent(mappings::add);\n-        if (template.getDataStreamTemplate() != null) {\n+        if (template.getDataStreamTemplate() != null && indexName.startsWith(DataStream.BACKING_INDEX_PREFIX)) {\n             // add a default mapping for the `@timestamp` field, at the lowest precedence, to make bootstrapping data streams more\n-            // straightforward\n+            // straightforward as all backing indices are required to have a timestamp field\n             mappings.add(0, new CompressedXContent(wrapMappingsIfNecessary(DEFAULT_TIMESTAMP_MAPPING, xContentRegistry)));\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA3NTU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/59244#discussion_r452075545", "bodyText": "These are good tests. Maybe also add another test that tests that a user adds a mapping for @timestamp in a composable index template?", "author": "martijnvg", "createdAt": "2020-07-09T09:09:32Z", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java", "diffHunk": "@@ -795,6 +797,97 @@ public void testResolveMappings() throws Exception {\n             equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field3\", Map.of(\"type\", \"integer\"))))));\n     }\n \n+    public void testDefinedTimestampMappingIsAddedForDataStreamTemplates() throws Exception {\n+        final MetadataIndexTemplateService service = getMetadataIndexTemplateService();\n+        ClusterState state = ClusterState.EMPTY_STATE;\n+\n+        ComponentTemplate ct1 = new ComponentTemplate(new Template(null,\n+            new CompressedXContent(\"{\\n\" +\n+                \"      \\\"properties\\\": {\\n\" +\n+                \"        \\\"field1\\\": {\\n\" +\n+                \"          \\\"type\\\": \\\"keyword\\\"\\n\" +\n+                \"        }\\n\" +\n+                \"      }\\n\" +\n+                \"    }\"), null), null, null);\n+\n+        state = service.addComponentTemplate(state, true, \"ct1\", ct1);\n+        ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"i*\"),\n+            new Template(null,\n+                new CompressedXContent(\"{\\n\" +\n+                    \"    \\\"properties\\\": {\\n\" +\n+                    \"      \\\"field2\\\": {\\n\" +\n+                    \"        \\\"type\\\": \\\"integer\\\"\\n\" +\n+                    \"      }\\n\" +\n+                    \"    }\\n\" +\n+                    \"  }\"), null),\n+            List.of(\"ct1\"), 0L, 1L, null, new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n+        state = service.addIndexTemplateV2(state, true, \"my-template\", it);\n+\n+        List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"my-template\", \"my-index\",\n+            xContentRegistry());\n+\n+        assertNotNull(mappings);\n+        assertThat(mappings.size(), equalTo(3));\n+        List<Map<String, Object>> parsedMappings = mappings.stream()\n+            .map(m -> {\n+                try {\n+                    return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                } catch (Exception e) {\n+                    logger.error(e);\n+                    fail(\"failed to parse mappings: \" + m.string());\n+                    return null;\n+                }\n+            })\n+            .collect(Collectors.toList());\n+\n+        assertThat(parsedMappings.get(0),\n+            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n+        assertThat(parsedMappings.get(1),\n+            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field1\", Map.of(\"type\", \"keyword\"))))));\n+        assertThat(parsedMappings.get(2),\n+            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field2\", Map.of(\"type\", \"integer\"))))));\n+    }\n+\n+    public void testUserDefinedMappingTakesPrecedenceOverDefault() throws Exception {", "originalCommit": "f6de98d4b3c48a140d62b020e9c72d19d01b9dd4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ae6dab8005984f27bda2448a3c4efcbfe5df0d67", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java\nindex 76e9438bb91..d4f2eb4a8d7 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/MetadataIndexTemplateServiceTests.java\n\n@@ -811,81 +812,189 @@ public class MetadataIndexTemplateServiceTests extends ESSingleNodeTestCase {\n                 \"    }\"), null), null, null);\n \n         state = service.addComponentTemplate(state, true, \"ct1\", ct1);\n-        ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"i*\"),\n-            new Template(null,\n-                new CompressedXContent(\"{\\n\" +\n-                    \"    \\\"properties\\\": {\\n\" +\n-                    \"      \\\"field2\\\": {\\n\" +\n-                    \"        \\\"type\\\": \\\"integer\\\"\\n\" +\n-                    \"      }\\n\" +\n-                    \"    }\\n\" +\n-                    \"  }\"), null),\n-            List.of(\"ct1\"), 0L, 1L, null, new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n-        state = service.addIndexTemplateV2(state, true, \"my-template\", it);\n \n-        List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"my-template\", \"my-index\",\n-            xContentRegistry());\n+        {\n+            ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"logs*\"),\n+                new Template(null,\n+                    new CompressedXContent(\"{\\n\" +\n+                        \"    \\\"properties\\\": {\\n\" +\n+                        \"      \\\"field2\\\": {\\n\" +\n+                        \"        \\\"type\\\": \\\"integer\\\"\\n\" +\n+                        \"      }\\n\" +\n+                        \"    }\\n\" +\n+                        \"  }\"), null),\n+                List.of(\"ct1\"), 0L, 1L, null, new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n+            state = service.addIndexTemplateV2(state, true, \"logs-data-stream-template\", it);\n+\n+            List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"logs-data-stream-template\",\n+                DataStream.getDefaultBackingIndexName(\"logs\", 1L), xContentRegistry());\n+\n+            assertNotNull(mappings);\n+            assertThat(mappings.size(), equalTo(4));\n+            List<Map<String, Object>> parsedMappings = mappings.stream()\n+                .map(m -> {\n+                    try {\n+                        return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                    } catch (Exception e) {\n+                        logger.error(e);\n+                        fail(\"failed to parse mappings: \" + m.string());\n+                        return null;\n+                    }\n+                })\n+                .collect(Collectors.toList());\n+\n+            assertThat(parsedMappings.get(0),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n+            assertThat(parsedMappings.get(1),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field1\", Map.of(\"type\", \"keyword\"))))));\n+            assertThat(parsedMappings.get(2),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field2\", Map.of(\"type\", \"integer\"))))));\n+            assertThat(parsedMappings.get(3),\n+                equalTo(Map.of(\"_doc\", Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", DEFAULT_TIMESTAMP_FIELD)))));\n+        }\n \n-        assertNotNull(mappings);\n-        assertThat(mappings.size(), equalTo(3));\n-        List<Map<String, Object>> parsedMappings = mappings.stream()\n-            .map(m -> {\n-                try {\n-                    return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n-                } catch (Exception e) {\n-                    logger.error(e);\n-                    fail(\"failed to parse mappings: \" + m.string());\n-                    return null;\n-                }\n-            })\n-            .collect(Collectors.toList());\n+        {\n+            // indices matched by templates without the data stream field defined don't get the default @timestamp mapping\n+            ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"timeseries*\"),\n+                new Template(null,\n+                    new CompressedXContent(\"{\\n\" +\n+                        \"    \\\"properties\\\": {\\n\" +\n+                        \"      \\\"field2\\\": {\\n\" +\n+                        \"        \\\"type\\\": \\\"integer\\\"\\n\" +\n+                        \"      }\\n\" +\n+                        \"    }\\n\" +\n+                        \"  }\"), null),\n+                List.of(\"ct1\"), 0L, 1L, null, null);\n+            state = service.addIndexTemplateV2(state, true, \"timeseries-template\", it);\n+\n+            List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"timeseries-template\", \"timeseries\",\n+                xContentRegistry());\n+\n+            assertNotNull(mappings);\n+            assertThat(mappings.size(), equalTo(2));\n+            List<Map<String, Object>> parsedMappings = mappings.stream()\n+                .map(m -> {\n+                    try {\n+                        return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                    } catch (Exception e) {\n+                        logger.error(e);\n+                        fail(\"failed to parse mappings: \" + m.string());\n+                        return null;\n+                    }\n+                })\n+                .collect(Collectors.toList());\n+\n+            assertThat(parsedMappings.get(0),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field1\", Map.of(\"type\", \"keyword\"))))));\n+            assertThat(parsedMappings.get(1),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field2\", Map.of(\"type\", \"integer\"))))));\n+\n+            // a default @timestamp mapping will not be added if the matching template doesn't have the data stream field configured, even\n+            // if the index name matches that of a data stream backing index\n+            mappings = MetadataIndexTemplateService.collectMappings(state, \"timeseries-template\",\n+                DataStream.getDefaultBackingIndexName(\"timeseries\", 1L), xContentRegistry());\n+\n+            assertNotNull(mappings);\n+            assertThat(mappings.size(), equalTo(2));\n+            parsedMappings = mappings.stream()\n+                .map(m -> {\n+                    try {\n+                        return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                    } catch (Exception e) {\n+                        logger.error(e);\n+                        fail(\"failed to parse mappings: \" + m.string());\n+                        return null;\n+                    }\n+                })\n+                .collect(Collectors.toList());\n \n-        assertThat(parsedMappings.get(0),\n-            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n-        assertThat(parsedMappings.get(1),\n-            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field1\", Map.of(\"type\", \"keyword\"))))));\n-        assertThat(parsedMappings.get(2),\n-            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field2\", Map.of(\"type\", \"integer\"))))));\n+            assertThat(parsedMappings.get(0),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field1\", Map.of(\"type\", \"keyword\"))))));\n+            assertThat(parsedMappings.get(1),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(\"field2\", Map.of(\"type\", \"integer\"))))));\n+        }\n     }\n \n     public void testUserDefinedMappingTakesPrecedenceOverDefault() throws Exception {\n         final MetadataIndexTemplateService service = getMetadataIndexTemplateService();\n         ClusterState state = ClusterState.EMPTY_STATE;\n \n-        ComponentTemplate ct1 = new ComponentTemplate(new Template(null,\n-            new CompressedXContent(\"{\\n\" +\n+        {\n+            // user defines a @timestamp mapping as part of a component template\n+            ComponentTemplate ct1 = new ComponentTemplate(new Template(null,\n+                new CompressedXContent(\"{\\n\" +\n+                    \"      \\\"properties\\\": {\\n\" +\n+                    \"        \\\"@timestamp\\\": {\\n\" +\n+                    \"          \\\"type\\\": \\\"date_nanos\\\"\\n\" +\n+                    \"        }\\n\" +\n+                    \"      }\\n\" +\n+                    \"    }\"), null), null, null);\n+\n+            state = service.addComponentTemplate(state, true, \"ct1\", ct1);\n+            ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"logs*\"), null, List.of(\"ct1\"), 0L, 1L, null,\n+                new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n+            state = service.addIndexTemplateV2(state, true, \"logs-template\", it);\n+\n+            List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"logs-template\",\n+                DataStream.getDefaultBackingIndexName(\"logs\", 1L), xContentRegistry());\n+\n+            assertNotNull(mappings);\n+            assertThat(mappings.size(), equalTo(3));\n+            List<Map<String, Object>> parsedMappings = mappings.stream()\n+                .map(m -> {\n+                    try {\n+                        return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                    } catch (Exception e) {\n+                        logger.error(e);\n+                        fail(\"failed to parse mappings: \" + m.string());\n+                        return null;\n+                    }\n+                })\n+                .collect(Collectors.toList());\n+            assertThat(parsedMappings.get(0),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n+            assertThat(parsedMappings.get(1),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date_nanos\"))))));\n+            assertThat(parsedMappings.get(2),\n+                equalTo(Map.of(\"_doc\", Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", DEFAULT_TIMESTAMP_FIELD)))));\n+        }\n+\n+        {\n+            // user defines a @timestamp mapping as part of a composable index template\n+            Template template = new Template(null, new CompressedXContent(\"{\\n\" +\n                 \"      \\\"properties\\\": {\\n\" +\n                 \"        \\\"@timestamp\\\": {\\n\" +\n                 \"          \\\"type\\\": \\\"date_nanos\\\"\\n\" +\n                 \"        }\\n\" +\n                 \"      }\\n\" +\n-                \"    }\"), null), null, null);\n-\n-        state = service.addComponentTemplate(state, true, \"ct1\", ct1);\n-        ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"i*\"), null, List.of(\"ct1\"), 0L, 1L, null,\n-            new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n-        state = service.addIndexTemplateV2(state, true, \"my-template\", it);\n-\n-        List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"my-template\", \"my-index\",\n-            xContentRegistry());\n-\n-        assertNotNull(mappings);\n-        assertThat(mappings.size(), equalTo(2));\n-        List<Map<String, Object>> parsedMappings = mappings.stream()\n-            .map(m -> {\n-                try {\n-                    return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n-                } catch (Exception e) {\n-                    logger.error(e);\n-                    fail(\"failed to parse mappings: \" + m.string());\n-                    return null;\n-                }\n-            })\n-            .collect(Collectors.toList());\n-        assertThat(parsedMappings.get(0),\n-            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n-        assertThat(parsedMappings.get(1),\n-            equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date_nanos\"))))));\n+                \"    }\"), null);\n+            ComposableIndexTemplate it = new ComposableIndexTemplate(List.of(\"timeseries*\"), template, null, 0L, 1L, null,\n+                new ComposableIndexTemplate.DataStreamTemplate(DEFAULT_TIMESTAMP_FIELD));\n+            state = service.addIndexTemplateV2(state, true, \"timeseries-template\", it);\n+\n+            List<CompressedXContent> mappings = MetadataIndexTemplateService.collectMappings(state, \"timeseries-template\",\n+                DataStream.getDefaultBackingIndexName(\"timeseries-template\", 1L), xContentRegistry());\n+\n+            assertNotNull(mappings);\n+            assertThat(mappings.size(), equalTo(3));\n+            List<Map<String, Object>> parsedMappings = mappings.stream()\n+                .map(m -> {\n+                    try {\n+                        return MapperService.parseMapping(new NamedXContentRegistry(List.of()), m.string());\n+                    } catch (Exception e) {\n+                        logger.error(e);\n+                        fail(\"failed to parse mappings: \" + m.string());\n+                        return null;\n+                    }\n+                })\n+                .collect(Collectors.toList());\n+            assertThat(parsedMappings.get(0),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date\"))))));\n+            assertThat(parsedMappings.get(1),\n+                equalTo(Map.of(\"_doc\", Map.of(\"properties\", Map.of(DEFAULT_TIMESTAMP_FIELD, Map.of(\"type\", \"date_nanos\"))))));\n+            assertThat(parsedMappings.get(2),\n+                equalTo(Map.of(\"_doc\", Map.of(TimestampFieldMapper.NAME, Map.of(\"path\", DEFAULT_TIMESTAMP_FIELD)))));\n+        }\n     }\n \n     public void testResolveSettings() throws Exception {\n"}}, {"oid": "ae6dab8005984f27bda2448a3c4efcbfe5df0d67", "url": "https://github.com/elastic/elasticsearch/commit/ae6dab8005984f27bda2448a3c4efcbfe5df0d67", "message": "Add @timestamp mapping only for backing indices", "committedDate": "2020-07-09T10:58:49Z", "type": "commit"}, {"oid": "57403c350f2c356ac1bb022f4bb470bfd69d1899", "url": "https://github.com/elastic/elasticsearch/commit/57403c350f2c356ac1bb022f4bb470bfd69d1899", "message": "DOCS: mention the default date field used has the default options", "committedDate": "2020-07-09T11:00:49Z", "type": "commit"}, {"oid": "d24c886f34a075530600ea3139a4c5f6d16d2d6a", "url": "https://github.com/elastic/elasticsearch/commit/d24c886f34a075530600ea3139a4c5f6d16d2d6a", "message": "YAML test: assert timestamp field mapping type", "committedDate": "2020-07-09T11:53:09Z", "type": "commit"}, {"oid": "009dc356d4613a23ab800df7986708cb5bf0800c", "url": "https://github.com/elastic/elasticsearch/commit/009dc356d4613a23ab800df7986708cb5bf0800c", "message": "Merge branch 'master' into composable-templates-default-timestamp-mapping", "committedDate": "2020-07-13T16:36:24Z", "type": "commit"}, {"oid": "5b3c0663e4de1f2ef0b930a7f9905144f342270c", "url": "https://github.com/elastic/elasticsearch/commit/5b3c0663e4de1f2ef0b930a7f9905144f342270c", "message": "Fix merge", "committedDate": "2020-07-13T17:20:53Z", "type": "commit"}, {"oid": "20343bed1b2ce84752e63d3f81596038afabc51a", "url": "https://github.com/elastic/elasticsearch/commit/20343bed1b2ce84752e63d3f81596038afabc51a", "message": "Fix test after merge", "committedDate": "2020-07-13T17:29:50Z", "type": "commit"}, {"oid": "d254ea6e7b467dbd8918cd72f6cbbd0d46114084", "url": "https://github.com/elastic/elasticsearch/commit/d254ea6e7b467dbd8918cd72f6cbbd0d46114084", "message": "Spotless", "committedDate": "2020-07-13T17:42:47Z", "type": "commit"}, {"oid": "97a2a59870aeb4b34e3ac222d72d958fc8139f91", "url": "https://github.com/elastic/elasticsearch/commit/97a2a59870aeb4b34e3ac222d72d958fc8139f91", "message": "Merge branch 'master' into composable-templates-default-timestamp-mapping", "committedDate": "2020-07-13T18:56:06Z", "type": "commit"}, {"oid": "9bf89f81428fb2f5ce29b05fd432dc47fea9408a", "url": "https://github.com/elastic/elasticsearch/commit/9bf89f81428fb2f5ce29b05fd432dc47fea9408a", "message": "Disable bwc tests", "committedDate": "2020-07-13T18:59:17Z", "type": "commit"}]}