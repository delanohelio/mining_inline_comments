{"pr_number": 61427, "pr_title": "Allow parsing Content-Type and Accept headers with version", "pr_createdAt": "2020-08-21T15:41:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61427", "timeline": [{"oid": "7514d87cbc1269be095ebcf77e586fc20e67849e", "url": "https://github.com/elastic/elasticsearch/commit/7514d87cbc1269be095ebcf77e586fc20e67849e", "message": "Allow parsing Content-Type and Accept headers with version\n\nContent-Type and Accept headers expect a verioned form of media types\nlike application/vnd.elasticsearch+json;compatible-with=7\nwhen previously it was simple application/json or similar - it is still\nsupported", "committedDate": "2020-08-21T15:31:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r475790152", "bodyText": "can you add a test for yaml too ?", "author": "jakelandis", "createdAt": "2020-08-24T17:48:51Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -84,4 +84,57 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaTypeOrFormat(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaTypeOrFormat(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testMediaType() {", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjQ4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476422487", "bodyText": "will do", "author": "pgomulka", "createdAt": "2020-08-25T12:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5MDE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\nindex 7dd063e7e58d..bde87d2c43b0 100644\n--- a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n\n@@ -86,13 +85,15 @@ public class XContentTypeTests extends ESTestCase {\n     }\n \n     public void testMediaType() {\n-        byte version = randomByte();\n+        String version = String.valueOf(Math.abs(randomByte()));\n         assertThat(XContentType.parseMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n             equalTo(\"application/json\"));\n         assertThat(XContentType.parseMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n             equalTo(\"application/cbor\"));\n         assertThat(XContentType.parseMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n             equalTo(\"application/smile\"));\n+        assertThat(XContentType.parseMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(\"application/yaml\"));\n         assertThat(XContentType.parseMediaType(\"application/json\"),\n             equalTo(\"application/json\"));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476608285", "bodyText": "Regex needs a few more escapes:\n\nEscape the . within vnd.elasticsearch+\nEscape the / between the type and subtype\n\n(application|text)\\\\/(vnd\\\\.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?", "author": "sethmlarson", "createdAt": "2020-08-25T17:14:55Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,19 @@ public XContent xContent() {\n         }\n     };\n \n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NTY2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r476785662", "bodyText": "Something I am curious about is the (\\\\d+))? at the end. If possible, it would be nice to define this as part of our \"spec\". This would be something we could be strict (eschew leniency!) about, such as enforcing it to be in a specific format (and throwing an exception when someone specifies a pattern that is not correct. We can also put the format into the documentation.\nIf you agree with the sentiment, I would be curious what we expect the final number to be, for example, which of these do we intend to support (now and in the future):\n\ncompatible-with=7\ncompatible-with=7.11\ncompatible-with=7.x\ncompatible-with=7x\ncompatible-with=7.11.2\n\nThen I think we should make this strict so users find out early if they've send an illegal value", "author": "dakrone", "createdAt": "2020-08-25T22:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyMzQxOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477423418", "bodyText": "@sethmlarson Why does the forward slash needs escaping? It's not special in Java?\nI wondering if we should anchor the pattern with ^ at the start and $ at the end, to be on the safe side?\nIn ([^;]+)(\\\\s*;, the [^;]+ will also consume whitespace, so I believe you can remove the \\\\s*.\nCan we switch any of these capture groups to non-capturing if we don't actually need the contents, just the grouping? i.e (?:<pattern>)", "author": "pugnascotia", "createdAt": "2020-08-26T16:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzMDMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477430326", "bodyText": "@pugnascotia You're right the / doesn't need an escape in Java", "author": "sethmlarson", "createdAt": "2020-08-26T16:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4OTk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r480189969", "bodyText": "@sethmlarson fixed the \\\\.\n@dakrone Only major versions are supported, hence only digits are allowed - representing the major part of the version #51816 (no dots or any other character, preventing parsing minor version)\nGood point on validation - how much should be done, how precise the exception should be.. @jakelandis or @jaymode  any views on this?\n@pugnascotia good point on consuming a space. The subtype (json, yaml, etc) are not allowing spaces. Added the anchoring and skipped capturing when possible. I think all of the groups require capturing though (except maybe for the optional ; charset=UTF-8)", "author": "pgomulka", "createdAt": "2020-08-31T15:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwODI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex 42129e4f5e4b..54686486db16 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -116,10 +118,26 @@ public enum XContentType {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n     private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n-        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",\n+        //type\n+        \"^(application|text)/\" +\n+            // type with custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n         Pattern.CASE_INSENSITIVE);\n \n+\n+    /*Pattern.compile(\n+        \"^(application|text)/(vnd\\\\.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?$\",\n+        Pattern.CASE_INSENSITIVE);\n+*/\n     /**\n      * Accepts either a format string, which is equivalent to {@link XContentType#shortName()} or a media type that optionally has\n      * parameters and attempts to match the value to an {@link XContentType}. The comparisons are done in lower case format and this method\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwODQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r477608478", "bodyText": "(vnd.elasticsearch\\+)?\n\nAm I reading this correctly that the vnd.elasticsearch part is completely optional? I thought the intent was to only add compatible-with when vnd.elasticsearch is present?", "author": "rjernst", "createdAt": "2020-08-26T21:47:52Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,19 @@ public XContent xContent() {\n         }\n     };\n \n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",", "originalCommit": "7514d87cbc1269be095ebcf77e586fc20e67849e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4OTI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r480089275", "bodyText": "you are right. This is possibly a bit oversimplified.\nDo you think we should aim to be more strict on the regex side or should we validate the values after the parsing with more relaxed regex?\nThe more strict could look like\nPattern.compile(\n        \"(application|text)/((vnd\\\\.elasticsearch\\\\+(json|smile|yaml|cbor)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n            \"|(json|smile|yaml|cbor))\");\n\nthere is a simplistic validation in parseVerion method, but it still allows to add compatible-with even when subtype vnd.elasticsearch is not present. The version won't be parsed though", "author": "pgomulka", "createdAt": "2020-08-31T12:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwODQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex 42129e4f5e4b..54686486db16 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -116,10 +118,26 @@ public enum XContentType {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n     private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n-        \"(application|text)/(vnd.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?\",\n+        //type\n+        \"^(application|text)/\" +\n+            // type with custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n         Pattern.CASE_INSENSITIVE);\n \n+\n+    /*Pattern.compile(\n+        \"^(application|text)/(vnd\\\\.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?$\",\n+        Pattern.CASE_INSENSITIVE);\n+*/\n     /**\n      * Accepts either a format string, which is equivalent to {@link XContentType#shortName()} or a media type that optionally has\n      * parameters and attempts to match the value to an {@link XContentType}. The comparisons are done in lower case format and this method\n"}}, {"oid": "921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "url": "https://github.com/elastic/elasticsearch/commit/921bc6f6047c2c8412a8cd44c2fa3b40c398cc23", "message": "code review follow up", "committedDate": "2020-09-01T07:43:11Z", "type": "commit"}, {"oid": "ee280bab965e94a29a388710804b1379ee7b9801", "url": "https://github.com/elastic/elasticsearch/commit/ee280bab965e94a29a388710804b1379ee7b9801", "message": "unused imports", "committedDate": "2020-09-01T08:58:47Z", "type": "commit"}, {"oid": "433de741d264768174cd95a9475d77cc0d41f247", "url": "https://github.com/elastic/elasticsearch/commit/433de741d264768174cd95a9475d77cc0d41f247", "message": "revert unrelated test", "committedDate": "2020-09-02T09:31:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMjMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482122324", "bodyText": "why do we allow */* to be JSON?", "author": "jaymode", "createdAt": "2020-09-02T14:39:56Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -130,7 +154,7 @@ public static XContentType fromMediaTypeOrFormat(String mediaType) {\n             }\n         }\n         final String lowercaseMediaType = mediaType.toLowerCase(Locale.ROOT);\n-        if (lowercaseMediaType.startsWith(\"application/*\")) {\n+        if (lowercaseMediaType.startsWith(\"application/*\") || lowercaseMediaType.equals(\"*/*\")) {", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1NTAzMw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482155033", "bodyText": "I incorrectly read the SQL test, will remove", "author": "pgomulka", "createdAt": "2020-09-02T15:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMjMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "de13d4be25dd9506dc555eb1e38ada04c0d0e960", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex dd1d10175720..a72889d56c37 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -115,103 +116,50 @@ public enum XContentType {\n             return CborXContent.cborXContent;\n         }\n     };\n-\n-    /**\n+/*\n+/**\n      * A regexp to allow parsing media types. It covers two use cases.\n-     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n      * i.e. application/vnd.elasticsearch+json;compatible-with\n      * 2. Media type without a version - for users not using compatible API i.e. application/json\n      */\n-    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n-            //type\n-        \"^(application|text)/\" +\n-            // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n-            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n-            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n-            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n-        Pattern.CASE_INSENSITIVE);\n-\n-\n-    /*Pattern.compile(\n-        \"^(application|text)/(vnd\\\\.elasticsearch\\\\+)?([^;]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+))?$\",\n-        Pattern.CASE_INSENSITIVE);\n-*/\n-    /**\n-     * Accepts either a format string, which is equivalent to {@link XContentType#shortName()} or a media type that optionally has\n-     * parameters and attempts to match the value to an {@link XContentType}. The comparisons are done in lower case format and this method\n-     * also supports a wildcard accept for {@code application/*}. This method can be used to parse the {@code Accept} HTTP header or a\n-     * format query string parameter. This method will return {@code null} if no match is found\n-     */\n-    public static XContentType fromMediaTypeOrFormat(String mediaTypeHeaderValue) {\n-        String mediaType = parseMediaType(mediaTypeHeaderValue);\n+//private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+//    //type\n+//    \"^(application|text)/\" +\n+//        // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+//        \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+//        \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+//        \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n+//    Pattern.CASE_INSENSITIVE);\n+// */\n+    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser<>(XContentType.values(),\n+        Map.of(\"application/*\", JSON, \"application/x-ndjson\", JSON,\n+            \"application/vnd.elasticsearch+json\", JSON,\n+            \"application/vnd.elasticsearch+smile\", SMILE,\n+            \"application/vnd.elasticsearch+yaml\", YAML,\n+            \"application/vnd.elasticsearch+cbor\", CBOR));\n \n-        if (mediaType == null) {\n-            return null;\n-        }\n-        for (XContentType type : values()) {\n-            if (isSameMediaTypeOrFormatAs(mediaType, type)) {\n-                return type;\n-            }\n-        }\n-        final String lowercaseMediaType = mediaType.toLowerCase(Locale.ROOT);\n-        if (lowercaseMediaType.startsWith(\"application/*\") || lowercaseMediaType.equals(\"*/*\")) {\n-            return JSON;\n-        }\n \n-        return null;\n+    /**\n+     * Accepts a format string, which is most of the time is equivalent to {@link XContentType#subtype()}\n+     * and attempts to match the value to an {@link XContentType}.\n+     * The comparisons are done in lower case format.\n+     * This method will return {@code null} if no match is found\n+     */\n+    public static XContentType fromFormat(String mediaType) {\n+        return mediaTypeParser.fromFormat(mediaType);\n     }\n \n     /**\n      * Attempts to match the given media type with the known {@link XContentType} values. This match is done in a case-insensitive manner.\n-     * The provided media type should not include any parameters. This method is suitable for parsing part of the {@code Content-Type}\n-     * HTTP header. This method will return {@code null} if no match is found\n+     * The provided media type can optionally has parameters.\n+     * This method is suitable for parsing of the {@code Content-Type} and {@code Accept} HTTP headers.\n+     * This method will return {@code null} if no match is found\n      */\n     public static XContentType fromMediaType(String mediaTypeHeaderValue) {\n-        String mediaType = parseMediaType(mediaTypeHeaderValue);\n-\n-        final String lowercaseMediaType = Objects.requireNonNull(mediaType, \"mediaType cannot be null\").toLowerCase(Locale.ROOT);\n-        for (XContentType type : values()) {\n-            if (type.mediaTypeWithoutParameters().equals(lowercaseMediaType)) {\n-                return type;\n-            }\n-        }\n-        // we also support newline delimited JSON: http://specs.okfnlabs.org/ndjson/\n-        if (lowercaseMediaType.toLowerCase(Locale.ROOT).equals(\"application/x-ndjson\")) {\n-            return XContentType.JSON;\n-        }\n-\n-        return null;\n+        return mediaTypeParser.fromMediaType(mediaTypeHeaderValue);\n     }\n \n-    //public scope needed for text formats hack\n-    public static String parseMediaType(String mediaType) {\n-        if (mediaType != null) {\n-            Matcher matcher = COMPATIBLE_API_HEADER_PATTERN.matcher(mediaType);\n-            if (matcher.find()) {\n-                if(matcher.group(2).toLowerCase(Locale.ROOT).startsWith(\"vnd.elasticsearch\")){\n-                    return (matcher.group(1) + \"/\" + matcher.group(4)).toLowerCase(Locale.ROOT);\n-                }\n-                return (matcher.group(1) + \"/\" + matcher.group(7)).toLowerCase(Locale.ROOT);\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    public static String parseVersion(String mediaType){\n-        if(mediaType != null){\n-            Matcher matcher = COMPATIBLE_API_HEADER_PATTERN.matcher(mediaType);\n-            if (matcher.find() && matcher.group(2).toLowerCase(Locale.ROOT).startsWith(\"vnd.elasticsearch\")) {\n-                return matcher.group(6);\n-            }\n-        }\n-        return null;\n-    }\n-    private static boolean isSameMediaTypeOrFormatAs(String stringType, XContentType type) {\n-        return type.mediaTypeWithoutParameters().equalsIgnoreCase(stringType) ||\n-                stringType.toLowerCase(Locale.ROOT).startsWith(type.mediaTypeWithoutParameters().toLowerCase(Locale.ROOT) + \";\") ||\n-                type.shortName().equalsIgnoreCase(stringType);\n-    }\n \n     private int index;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNzIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482127202", "bodyText": "I think the charset aspect should be handled separately since we haven't deprecated accepting other charsets yet, see #22769", "author": "jaymode", "createdAt": "2020-09-02T14:46:14Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+            //type\n+        \"^(application|text)/\" +\n+            // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1NzAyMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482157020", "bodyText": "good point. What is more there could other parameters which we do not expect from server perspective.\nSQL for instance has header=absent parameter\nSo this should either be any text or a sequence of ; key=value", "author": "pgomulka", "createdAt": "2020-09-02T15:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNzIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex dd1d10175720..5836cd11f3de 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -118,7 +118,7 @@ public enum XContentType {\n \n     /**\n      * A regexp to allow parsing media types. It covers two use cases.\n-     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n      * i.e. application/vnd.elasticsearch+json;compatible-with\n      * 2. Media type without a version - for users not using compatible API i.e. application/json\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482131812", "bodyText": "since this hack is not in this PR can we make this pkg private for now?", "author": "jaymode", "createdAt": "2020-09-02T14:51:58Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -157,6 +183,30 @@ public static XContentType fromMediaType(String mediaType) {\n         return null;\n     }\n \n+    //public scope needed for text formats hack", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE1Nzg3MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482157870", "bodyText": "this possibly was a stale comment - removed and changed to package private", "author": "pgomulka", "createdAt": "2020-09-02T15:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex dd1d10175720..37c72ac4fc5f 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -183,8 +183,8 @@ public enum XContentType {\n         return null;\n     }\n \n-    //public scope needed for text formats hack\n-    public static String parseMediaType(String mediaType) {\n+    // package private for testing\n+    static String parseMediaType(String mediaType) {\n         if (mediaType != null) {\n             Matcher matcher = COMPATIBLE_API_HEADER_PATTERN.matcher(mediaType);\n             if (matcher.find()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMjM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482132354", "bodyText": "let's remove this since it is now commented out", "author": "jaymode", "createdAt": "2020-09-02T14:52:41Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+    private static final Pattern COMPATIBLE_API_HEADER_PATTERN = Pattern.compile(\n+            //type\n+        \"^(application|text)/\" +\n+            // custom subtype and a version: vnd.elasticsearch+json;compatible-with=7\n+            \"((vnd\\\\.elasticsearch\\\\+([^;\\\\s]+)(\\\\s*;\\\\s*compatible-with=(\\\\d+)))\" +\n+            \"|([^;\\\\s]+))\" + //subtype: json,yaml,etc some of these are defined in x-pack so can't be enumerated\n+            \"(?:\\\\s*;\\\\s*(charset=UTF-8)?)?$\",\n+        Pattern.CASE_INSENSITIVE);\n+\n+\n+    /*Pattern.compile(", "originalCommit": "433de741d264768174cd95a9475d77cc0d41f247", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex dd1d10175720..5836cd11f3de 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -118,7 +118,7 @@ public enum XContentType {\n \n     /**\n      * A regexp to allow parsing media types. It covers two use cases.\n-     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n      * i.e. application/vnd.elasticsearch+json;compatible-with\n      * 2. Media type without a version - for users not using compatible API i.e. application/json\n      */\n"}}, {"oid": "51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "url": "https://github.com/elastic/elasticsearch/commit/51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "message": "remove */* and method visibility", "committedDate": "2020-09-02T15:26:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3MjczMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482972732", "bodyText": "elasticserach broke my eyes", "author": "tlrx", "createdAt": "2020-09-03T13:21:57Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -114,13 +116,35 @@ public XContent xContent() {\n         }\n     };\n \n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter", "originalCommit": "51467e0ea1d8af04da4c4f5eac3449a3a40da9e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5NDIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r482994233", "bodyText": "sorry for this :D fixed", "author": "pgomulka", "createdAt": "2020-09-03T13:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3MjczMg=="}], "type": "inlineReview", "revised_code": {"commit": "ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex 37c72ac4fc5f..5836cd11f3de 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -118,7 +118,7 @@ public enum XContentType {\n \n     /**\n      * A regexp to allow parsing media types. It covers two use cases.\n-     * 1. Media type with a version - requires a custom vnd.elasticserach subtype and a compatible-with parameter\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n      * i.e. application/vnd.elasticsearch+json;compatible-with\n      * 2. Media type without a version - for users not using compatible API i.e. application/json\n      */\n"}}, {"oid": "ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "url": "https://github.com/elastic/elasticsearch/commit/ccaadbd7867f9a5cf9211f6a6f3a22456b8e9abd", "message": "typos", "committedDate": "2020-09-03T13:52:05Z", "type": "commit"}, {"oid": "de13d4be25dd9506dc555eb1e38ada04c0d0e960", "url": "https://github.com/elastic/elasticsearch/commit/de13d4be25dd9506dc555eb1e38ada04c0d0e960", "message": "Merge branch 'master' into compat/content-type-header-with-version", "committedDate": "2020-09-17T15:04:09Z", "type": "commit"}, {"oid": "d9ee420f73ebe68a40842963a2df89c3eb03f98d", "url": "https://github.com/elastic/elasticsearch/commit/d9ee420f73ebe68a40842963a2df89c3eb03f98d", "message": "exted parsing with parameters", "committedDate": "2020-09-17T17:04:37Z", "type": "commit"}, {"oid": "41150a6a7efce3a34ebcfa603274a7130c863788", "url": "https://github.com/elastic/elasticsearch/commit/41150a6a7efce3a34ebcfa603274a7130c863788", "message": "import", "committedDate": "2020-09-17T17:06:21Z", "type": "commit"}, {"oid": "2fc8f86027e3576cd677f644902b75265dc6ad26", "url": "https://github.com/elastic/elasticsearch/commit/2fc8f86027e3576cd677f644902b75265dc6ad26", "message": "fix test", "committedDate": "2020-09-17T17:22:35Z", "type": "commit"}, {"oid": "734031a55d9f784f66c5e4a4fcfb9fb90e6e13cf", "url": "https://github.com/elastic/elasticsearch/commit/734031a55d9f784f66c5e4a4fcfb9fb90e6e13cf", "message": "scope parser", "committedDate": "2020-09-18T10:21:48Z", "type": "commit"}, {"oid": "c04af650551c1522c8300830be2c3c754dad1759", "url": "https://github.com/elastic/elasticsearch/commit/c04af650551c1522c8300830be2c3c754dad1759", "message": "x-ndjson to be versioned", "committedDate": "2020-09-18T10:30:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490876410", "bodyText": "for the discussion:\ndefining versioned media types up front, means that we won't throw an exception if someone specifies it with oss licence\nif he uses oss on v8 server for api that was removed and provides application/vnd.elasticsearch+json;compatible-with=7 he will get a 404\nis there an easy way to make XContentType plugin aware? or licence aware?\nor are we ok with allowing to use versioned media types with oss?", "author": "pgomulka", "createdAt": "2020-09-18T11:14:50Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -112,10 +113,25 @@ public XContent xContent() {\n             return CborXContent.cborXContent;\n         }\n     };\n-\n-    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser<>(XContentType.values(),\n-        Map.of(\"application/*\", JSON, \"application/x-ndjson\", JSON));\n-\n+    /**\n+     * A regexp to allow parsing media types. It covers two use cases.\n+     * 1. Media type with a version - requires a custom vnd.elasticsearch subtype and a compatible-with parameter\n+     * i.e. application/vnd.elasticsearch+json;compatible-with\n+     * 2. Media type without a version - for users not using compatible API i.e. application/json\n+     */\n+     private static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/*\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/x-ndjson\", JSON, Map.of(\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+smile\", SMILE, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+yaml\", YAML, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+cbor\", CBOR, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+x-ndjson\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .build();", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3NTM4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490975383", "bodyText": "I think a 404 (or maybe 400) is the right thing to do here since the infrastructure for version support is in OSS and we do not have a compatible handler for V7.", "author": "jaymode", "createdAt": "2020-09-18T14:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwMzc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491903775", "bodyText": "but this also would affect plugins like SQL. In oss we don't know about MediaTypes which are defined over there\nif we throw an exception for a unknown type I am worried we might end up with a logic based on exceptions\ntry XContentType.parseMediaType\ntry XContentType.parseFormat\ntry TextFormat.parseMediaType\ntry TextFormat.parseFormat\n\n@bpintea any thoughts on this? I guess SQL had to face this in the past", "author": "pgomulka", "createdAt": "2020-09-21T09:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMTg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492121856", "bodyText": "Is there any way to register a custom parser ? or just add the SQL values to the core parser and specificy which rule set to use when parsing ?", "author": "jakelandis", "createdAt": "2020-09-21T15:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMzQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492213411", "bodyText": "that is an interesting idea.. We could have something like a SqlMediaTypeParser and it would either return TextFormat or XContentType. The parsing logic would remain the same in the MediaTypeParser. The idea of SqlMediaTypeParser woudl be just to abstract on the setup of the parser.\nThe same could be done for CompatibleApiMediaTypeParser and we could keep it in xpack plugin.\nthis does not solve the problem of trying to parse a format, then if failed to parse a media type. I think we should try to just check for presence of the format parameter and if present to used. Otherwise trying to use Accept Header.\nI think also that Content-Type should not be used for response formatting in SQL plugin. It looks like it is allowed in code, but I don't think it would work (it would fail when parsing that header in server)", "author": "pgomulka", "createdAt": "2020-09-21T17:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg3NjQxMA=="}], "type": "inlineReview", "revised_code": {"commit": "b6ebd6399abcec1faad8a994ae202c82151139f7", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex d73c970f24a7..431d30c89122 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -122,15 +123,20 @@ public enum XContentType implements MediaType {\n      private static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n         .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n         .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n-        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/*\", JSON, Map.of(\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/x-ndjson\", JSON, Map.of(\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/vnd.elasticsearch+smile\", SMILE, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/vnd.elasticsearch+yaml\", YAML, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/vnd.elasticsearch+cbor\", CBOR, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n-        .withMediaTypeAndParams(\"application/vnd.elasticsearch+x-ndjson\", JSON, Map.of(\"compatible-with\", \"\\\\d+\",\"charset\", \"UTF-8\"))\n+        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/*\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/x-ndjson\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\", JSON,\n+            Map.of(\"compatible-with\", Pattern.compile(\"\\\\d+\"),\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+smile\", SMILE,\n+            Map.of(\"compatible-with\", Pattern.compile(\"\\\\d+\"),\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+yaml\", YAML,\n+            Map.of(\"compatible-with\", Pattern.compile(\"\\\\d+\"),\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+cbor\", CBOR,\n+            Map.of(\"compatible-with\", Pattern.compile(\"\\\\d+\"),\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+x-ndjson\", JSON,\n+            Map.of(\"compatible-with\", Pattern.compile(\"\\\\d+\"),\"charset\", Pattern.compile(\"UTF-8\")))\n         .build();\n \n     /**\n"}}, {"oid": "474eb298470fdb651f9900f050949c738b2cca2c", "url": "https://github.com/elastic/elasticsearch/commit/474eb298470fdb651f9900f050949c738b2cca2c", "message": "Merge branch 'master' into compat/content-type-header-with-version", "committedDate": "2020-09-18T14:20:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490971521", "bodyText": "I suggest that we benchmark this with a JMH microbenchmark (separately) with a variety of different content types and parameters", "author": "jaymode", "createdAt": "2020-09-18T14:03:02Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -65,8 +51,10 @@ public T fromFormat(String format) {\n \n     /**\n      * parsing media type that follows https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+     *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n+     * //todo pg should this all be maybe based on a regex?", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MDc0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496660746", "bodyText": "I wrote a benchmark and regex approach is slower. I does cover more (the exact characters allowed by rfc) but not sure we need this. See the implementation:\nhttps://github.com/pgomulka/elasticsearch/blob/compat/benchmark_regex_vs_splits/benchmarks/src/main/java/org/elasticsearch/benchmark/MediaTypeParsingBenchmark.java\nhttps://github.com/pgomulka/elasticsearch/blob/compat/benchmark_regex_vs_splits/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParserRegex.java\nBenchmark                                     Mode  Cnt  Score   Error  Units\nMediaTypeParsingBenchmark.parseIter           avgt   30  0.801 \u00b1 0.010  us/op\nMediaTypeParsingBenchmark.parseIterNoParams   avgt   30  0.200 \u00b1 0.002  us/op\nMediaTypeParsingBenchmark.parseRegex          avgt   30  1.639 \u00b1 0.012  us/op\nMediaTypeParsingBenchmark.parseRegexNoParams  avgt   30  0.504 \u00b1 0.011  us/op", "author": "pgomulka", "createdAt": "2020-09-29T12:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "eab471c5ebd45f8ab008bdf1f3272cd091bae2b7", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..387a971f3dc4 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -54,7 +53,7 @@ public class MediaTypeParser<T extends MediaType> {\n      *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n-     * //todo pg should this all be maybe based on a regex?\n+     * //todo pg write a benchmark and consider using a regex\n      */\n     public ParsedMediaType parseMediaType(String headerValue) {\n         if (headerValue != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MTk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490971997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(parametersMap.containsKey(typeWithSubtype)){\n          \n          \n            \n                    if (parametersMap.containsKey(typeWithSubtype)) {", "author": "jaymode", "createdAt": "2020-09-18T14:03:44Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..ba87858b1e81 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -92,9 +92,9 @@ public class MediaTypeParser<T extends MediaType> {\n     }\n \n     private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n-        if(parametersMap.containsKey(typeWithSubtype)){\n+        if (parametersMap.containsKey(typeWithSubtype)) {\n             Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n-            if(parameters.containsKey(parameterName)){\n+            if (parameters.containsKey(parameterName)) {\n                 String regex = parameters.get(parameterName);\n                 return parameterValue.matches(regex);//todo pg should we precompile regex?\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjExNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490972116", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(parameters.containsKey(parameterName)){\n          \n          \n            \n                        if (parameters.containsKey(parameterName)) {", "author": "jaymode", "createdAt": "2020-09-18T14:03:56Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){\n+            Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n+            if(parameters.containsKey(parameterName)){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..ba87858b1e81 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -92,9 +92,9 @@ public class MediaTypeParser<T extends MediaType> {\n     }\n \n     private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n-        if(parametersMap.containsKey(typeWithSubtype)){\n+        if (parametersMap.containsKey(typeWithSubtype)) {\n             Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n-            if(parameters.containsKey(parameterName)){\n+            if (parameters.containsKey(parameterName)) {\n                 String regex = parameters.get(parameterName);\n                 return parameterValue.matches(regex);//todo pg should we precompile regex?\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MzU4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490973583", "bodyText": "We should compile the regex into a pattern to avoid doing it everytime", "author": "jaymode", "createdAt": "2020-09-18T14:06:11Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -96,6 +91,17 @@ public ParsedMediaType parseMediaType(String headerValue) {\n         return null;\n     }\n \n+    private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n+        if(parametersMap.containsKey(typeWithSubtype)){\n+            Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n+            if(parameters.containsKey(parameterName)){\n+                String regex = parameters.get(parameterName);\n+                return parameterValue.matches(regex);//todo pg should we precompile regex?", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTY2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491015667", "bodyText": "will do", "author": "pgomulka", "createdAt": "2020-09-18T15:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MzU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..ba87858b1e81 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -92,9 +92,9 @@ public class MediaTypeParser<T extends MediaType> {\n     }\n \n     private boolean isValidParameter(String typeWithSubtype, String parameterName, String parameterValue) {\n-        if(parametersMap.containsKey(typeWithSubtype)){\n+        if (parametersMap.containsKey(typeWithSubtype)) {\n             Map<String, String> parameters = parametersMap.get(typeWithSubtype);\n-            if(parameters.containsKey(parameterName)){\n+            if (parameters.containsKey(parameterName)) {\n                 String regex = parameters.get(parameterName);\n                 return parameterValue.matches(regex);//todo pg should we precompile regex?\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3NTU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490975562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(parsedMediaType != null) {\n          \n          \n            \n                    if (parsedMediaType != null) {", "author": "jaymode", "createdAt": "2020-09-18T14:09:19Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -137,13 +153,23 @@ public static XContentType fromMediaType(String mediaTypeHeaderValue) {\n         return mediaTypeParser.fromMediaType(mediaTypeHeaderValue);\n     }\n \n-\n     private int index;\n \n     XContentType(int index) {\n         this.index = index;\n     }\n \n+    public static Byte parseVersion(String mediaType) {\n+        MediaTypeParser<XContentType>.ParsedMediaType parsedMediaType = mediaTypeParser.parseMediaType(mediaType);\n+        if(parsedMediaType != null) {", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex d73c970f24a7..31280cfe5153 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -161,7 +161,7 @@ public enum XContentType implements MediaType {\n \n     public static Byte parseVersion(String mediaType) {\n         MediaTypeParser<XContentType>.ParsedMediaType parsedMediaType = mediaTypeParser.parseMediaType(mediaType);\n-        if(parsedMediaType != null) {\n+        if (parsedMediaType != null) {\n             String version = parsedMediaType\n                 .getParameters()\n                 .get(\"compatible-with\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3OTgyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490979821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        XContentType.JSON,Map.of(\"compatible-with\",\"\\\\d+\",\n          \n          \n            \n                        \"charset\",\"UTF-8\"))\n          \n          \n            \n                        XContentType.JSON, Map.of(\"compatible-with\", \"\\\\d+\",\n          \n          \n            \n                        \"charset\", \"UTF-8\"))", "author": "jaymode", "createdAt": "2020-09-18T14:15:44Z", "path": "libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java", "diffHunk": "@@ -29,37 +29,42 @@\n import static org.hamcrest.Matchers.nullValue;\n \n public class MediaTypeParserTests extends ESTestCase {\n-    MediaTypeParser<XContentType> mediaTypeParser = XContentType.mediaTypeParser;\n+\n+    MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\",\n+            XContentType.JSON,Map.of(\"compatible-with\",\"\\\\d+\",\n+            \"charset\",\"UTF-8\"))", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java\nindex 26105082530b..76cbb03a4ca5 100644\n--- a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java\n+++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/MediaTypeParserTests.java\n\n@@ -32,8 +32,8 @@ public class MediaTypeParserTests extends ESTestCase {\n \n     MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n         .withMediaTypeAndParams(\"application/vnd.elasticsearch+json\",\n-            XContentType.JSON,Map.of(\"compatible-with\",\"\\\\d+\",\n-            \"charset\",\"UTF-8\"))\n+            XContentType.JSON, Map.of(\"compatible-with\", \"\\\\d+\",\n+            \"charset\", \"UTF-8\"))\n         .build();\n \n     public void testJsonWithParameters() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MDM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490980348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n          \n          \n            \n                    assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version + \".0\"),", "author": "jaymode", "createdAt": "2020-09-18T14:16:27Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\nindex db7ec87922eb..686bc9fa6540 100644\n--- a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n\n@@ -118,7 +118,7 @@ public class XContentTypeTests extends ESTestCase {\n     }\n \n     public void testVersionParsing() {\n-        byte version = (byte)Math.abs(randomByte());\n+        byte version = (byte) Math.abs(randomByte());\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n             equalTo(version));\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTI3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490981271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\".0\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version + \".0\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version + \"_sth\"), nullValue());\n          \n          \n            \n                    assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version + \"_sth\"), nullValue());", "author": "jaymode", "createdAt": "2020-09-18T14:17:42Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testUnrecognizedParameter() {\n+        assertThat(XContentType.parseVersion(\"application/json; sth=123\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testMediaTypeWithoutESSubtype() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version), nullValue());\n+    }\n+\n+    public void testAnchoring(){\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\".0\"), nullValue());\n+        assertThat(XContentType.fromMediaType(\"sth_application/json;compatible-with=\" + version+\"_sth\"), nullValue());\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version+\"_sth\"), nullValue());", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\nindex db7ec87922eb..686bc9fa6540 100644\n--- a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n\n@@ -118,7 +118,7 @@ public class XContentTypeTests extends ESTestCase {\n     }\n \n     public void testVersionParsing() {\n-        byte version = (byte)Math.abs(randomByte());\n+        byte version = (byte) Math.abs(randomByte());\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n             equalTo(version));\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTQwNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490981407", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testAnchoring(){\n          \n          \n            \n                public void testAnchoring() {", "author": "jaymode", "createdAt": "2020-09-18T14:17:52Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"application/json\"),\n+            nullValue());\n+\n+\n+        assertThat(XContentType.parseVersion(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(version));\n+        assertThat(XContentType.parseVersion(\"APPLICATION/JSON\"),\n+            nullValue());\n+\n+        assertThat(XContentType.parseVersion(\"application/json;compatible-with=\" + version+\".0\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testUnrecognizedParameter() {\n+        assertThat(XContentType.parseVersion(\"application/json; sth=123\"),\n+            is(nullValue()));\n+    }\n+\n+    public void testMediaTypeWithoutESSubtype() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/json;compatible-with=\" + version), nullValue());\n+    }\n+\n+    public void testAnchoring(){", "originalCommit": "c04af650551c1522c8300830be2c3c754dad1759", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\nindex db7ec87922eb..686bc9fa6540 100644\n--- a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n\n@@ -118,7 +118,7 @@ public class XContentTypeTests extends ESTestCase {\n     }\n \n     public void testVersionParsing() {\n-        byte version = (byte)Math.abs(randomByte());\n+        byte version = (byte) Math.abs(randomByte());\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n             equalTo(version));\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NTM2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490985364", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte version = (byte)Math.abs(randomByte());\n          \n          \n            \n                    byte version = (byte) Math.abs(randomByte());", "author": "jaymode", "createdAt": "2020-09-18T14:23:11Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,66 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n+            equalTo(XContentType.CBOR));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+smile;compatible-with=\" + version),\n+            equalTo(XContentType.SMILE));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+yaml;compatible-with=\" + version),\n+            equalTo(XContentType.YAML));\n+        assertThat(XContentType.fromMediaType(\"application/json\"),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+x-ndjson;compatible-with=\" + version),\n+            equalTo(XContentType.JSON));\n+\n+\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/VND.ELASTICSEARCH+JSON;COMPATIBLE-WITH=\" + version),\n+            equalTo(XContentType.JSON));\n+        assertThat(XContentType.fromMediaType(\"APPLICATION/JSON\"),\n+            equalTo(XContentType.JSON));\n+    }\n+\n+    public void testVersionParsing() {\n+        byte version = (byte)Math.abs(randomByte());", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\nindex db7ec87922eb..686bc9fa6540 100644\n--- a/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java\n\n@@ -118,7 +118,7 @@ public class XContentTypeTests extends ESTestCase {\n     }\n \n     public void testVersionParsing() {\n-        byte version = (byte)Math.abs(randomByte());\n+        byte version = (byte) Math.abs(randomByte());\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+json;compatible-with=\" + version),\n             equalTo(version));\n         assertThat(XContentType.parseVersion(\"application/vnd.elasticsearch+cbor;compatible-with=\" + version),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NzYxNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490987616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n          \n          \n            \n                                    if (isValidParameter(typeWithSubtype, parameterName, parameterValue) == false) {", "author": "jaymode", "createdAt": "2020-09-18T14:26:27Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -86,7 +76,12 @@ public ParsedMediaType parseMediaType(String headerValue) {\n                         if (keyValueParam.length != 2 || hasSpaces(keyValueParam[0]) || hasSpaces(keyValueParam[1])) {\n                             return null;\n                         }\n-                        parameters.put(keyValueParam[0].toLowerCase(Locale.ROOT), keyValueParam[1].toLowerCase(Locale.ROOT));\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n+                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..ba87858b1e81 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -78,7 +78,7 @@ public class MediaTypeParser<T extends MediaType> {\n                         }\n                         String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n                         String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n-                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n+                        if (isValidParameter(typeWithSubtype, parameterName, parameterValue) == false) {\n                             return null;\n                         }\n                         parameters.put(parameterName, parameterValue);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490988828", "bodyText": "should we throw an exception here? Maybe one that returns a 400 since the parameter is invalid", "author": "jaymode", "createdAt": "2020-09-18T14:28:24Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -86,7 +76,12 @@ public ParsedMediaType parseMediaType(String headerValue) {\n                         if (keyValueParam.length != 2 || hasSpaces(keyValueParam[0]) || hasSpaces(keyValueParam[1])) {\n                             return null;\n                         }\n-                        parameters.put(keyValueParam[0].toLowerCase(Locale.ROOT), keyValueParam[1].toLowerCase(Locale.ROOT));\n+                        String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n+                        String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n+                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n+                            return null;", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzNDgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491934835", "bodyText": "but should it only be here? or should we throw exceptions in other places where we return null.\nI think we should throw an exception when a media type does not conform to rfc\nbut if we don't know about the requested media type I think it might cause problems in code at the moment (we rely on checking if parsing returned null and then try a different method. See https://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java#L100", "author": "pgomulka", "createdAt": "2020-09-21T10:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwODUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492108508", "bodyText": "I think we should throw an exception here that results in a 400 (either due to non-conformance with RFC or our own definition of what is supported).  Since we are very explicit about what is supported (as of this PR), we should throw the exception as soon we discover something that is not supported. I don't think we should \"fallback\" to use format ... those cases should be handled explicitly.", "author": "jakelandis", "createdAt": "2020-09-21T14:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MDMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496080335", "bodyText": "as mentioned here this PR will not introduce throwing exceptions yet. I will follow up in another PR", "author": "pgomulka", "createdAt": "2020-09-28T16:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzOTIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497539202", "bodyText": "Can you log an issue for this ?", "author": "jakelandis", "createdAt": "2020-09-30T14:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NzA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497587074", "bodyText": "done - #63080 will try to gather more details before starting work on it and possibly discussing with the team", "author": "pgomulka", "createdAt": "2020-09-30T15:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4ODgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 1d6c264f31c9..ba87858b1e81 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -78,7 +78,7 @@ public class MediaTypeParser<T extends MediaType> {\n                         }\n                         String parameterName = keyValueParam[0].toLowerCase(Locale.ROOT);\n                         String parameterValue = keyValueParam[1].toLowerCase(Locale.ROOT);\n-                        if(isValidParameter(typeWithSubtype,parameterName,parameterValue) == false) {\n+                        if (isValidParameter(typeWithSubtype, parameterName, parameterValue) == false) {\n                             return null;\n                         }\n                         parameters.put(parameterName, parameterValue);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r490992855", "bodyText": "I am concerned that having charset with a regex of utf-8 could break someone using sql. This should be checked with the sql team", "author": "jaymode", "createdAt": "2020-09-18T14:34:49Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java", "diffHunk": "@@ -294,7 +295,11 @@ public String subtype() {\n     private static final String PARAM_HEADER_ABSENT = \"absent\";\n     private static final String PARAM_HEADER_PRESENT = \"present\";\n \n-    private static final MediaTypeParser<TextFormat> parser = new MediaTypeParser<>(TextFormat.values());\n+    private static final MediaTypeParser<TextFormat> parser = new MediaTypeParser.Builder<TextFormat>()\n+        .withMediaTypeAndParams(PLAIN_TEXT.typeWithSubtype(), PLAIN_TEXT, Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))", "originalCommit": "474eb298470fdb651f9900f050949c738b2cca2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzNTg5OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r491935898", "bodyText": "this only means that a parameter is possible. if it won't be provided it won't fail any validation.\nI asked SQL team about this offline.\n@bpintea  can you confirm that we can expect any of these in SQL? Do you expect any other charsets?", "author": "pgomulka", "createdAt": "2020-09-21T10:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc5MzU4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492793589", "bodyText": "Not speaking for SQL, but in general with a lot of clients on Windows, I have seen them send charset=ISO-8859-1 with the Content-Type header and would operate under the assumption that they may also send the charset with the Accept header; nothing in RFC 7231 would prevent that. Additionally, multiple accept headers are allowed so you can wind up with something like:\nAccept: text/plain;charset=\"utf-8\", text/plain;charset=\"ISO-8859-1\"\n\nThere is also the Accept-Charset header which technically should have precedence over the media type parameter in the Accept header. (It is kind of a mess)", "author": "jaymode", "createdAt": "2020-09-22T14:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY0OTUxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r493649511", "bodyText": "I think having multiple headers would be beyond the scope of this change. We would also have to support the q factor to understand the preference of clients Accept type.", "author": "pgomulka", "createdAt": "2020-09-23T14:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498916152", "bodyText": "if it won't be provided it won't fail any validation.\n\nRight, I believe currently the TextFormater simply ignores an Accept-requested charset (that happens to be different than UTF-8). Hasn't been an issue so far, but it might make sense to do something about it at some point.", "author": "bpintea", "createdAt": "2020-10-02T16:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5Mjg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6ebd6399abcec1faad8a994ae202c82151139f7", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java\nindex 09da5b695238..15ef8fa83eca 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/TextFormat.java\n\n@@ -296,9 +297,12 @@ enum TextFormat implements MediaType {\n     private static final String PARAM_HEADER_PRESENT = \"present\";\n \n     private static final MediaTypeParser<TextFormat> parser = new MediaTypeParser.Builder<TextFormat>()\n-        .withMediaTypeAndParams(PLAIN_TEXT.typeWithSubtype(), PLAIN_TEXT, Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n-        .withMediaTypeAndParams(CSV.typeWithSubtype(), CSV, Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n-        .withMediaTypeAndParams(TSV.typeWithSubtype(), TSV, Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(PLAIN_TEXT.typeWithSubtype(), PLAIN_TEXT,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(CSV.typeWithSubtype(), CSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(TSV.typeWithSubtype(), TSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n         .build();\n \n     String format(RestRequest request, SqlQueryResponse response) {\n"}}, {"oid": "5c308136a2c10c74bca289b54b7f899afda6c9fb", "url": "https://github.com/elastic/elasticsearch/commit/5c308136a2c10c74bca289b54b7f899afda6c9fb", "message": "Apply suggestions from code review\n\nCo-authored-by: Jay Modi <jaymode@users.noreply.github.com>", "committedDate": "2020-09-18T14:51:05Z", "type": "commit"}, {"oid": "7b760ba92ea2c032febabc5ced960802dd9385b1", "url": "https://github.com/elastic/elasticsearch/commit/7b760ba92ea2c032febabc5ced960802dd9385b1", "message": "precompile pattern", "committedDate": "2020-09-18T15:10:06Z", "type": "commit"}, {"oid": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "url": "https://github.com/elastic/elasticsearch/commit/5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "message": "import", "committedDate": "2020-09-21T08:45:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzA2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492097063", "bodyText": "nit: I would suggest to pass a Map<String, Pattern> so that the contract is a bit clearer (not obvious that the value can a regex expression)", "author": "jakelandis", "createdAt": "2020-09-21T14:34:12Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,36 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatMap = new HashMap<>();\n+        private final Map<String, T> typeMap = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {\n+            typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n+            formatMap.put(mediaType.format(), mediaType);\n+            return this;\n+        }\n+\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, String> paramNameAndValueRegex) {", "originalCommit": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwNzE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492207196", "bodyText": "I will have to copy the pattern and create a new one to make sure  case insensitivity is used. I will give a go and see how it works", "author": "pgomulka", "createdAt": "2020-09-21T16:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b6ebd6399abcec1faad8a994ae202c82151139f7", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex ef498349d132..1b737c854969 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -131,21 +131,15 @@ public class MediaTypeParser<T extends MediaType> {\n         private final Map<String, T> typeMap = new HashMap<>();\n         private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n \n-        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {\n-            typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n-            formatMap.put(mediaType.format(), mediaType);\n-            return this;\n-        }\n-\n-        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, String> paramNameAndValueRegex) {\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, Pattern> paramNameAndValueRegex) {\n             typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n             formatMap.put(mediaType.format(), mediaType);\n \n             Map<String, Pattern> parametersForMediaType = new HashMap<>(paramNameAndValueRegex.size());\n-            for (Map.Entry<String, String> params : paramNameAndValueRegex.entrySet()) {\n+            for (Map.Entry<String, Pattern> params : paramNameAndValueRegex.entrySet()) {\n                 String parameterName = params.getKey().toLowerCase(Locale.ROOT);\n-                String parameterRegex = params.getValue().toLowerCase(Locale.ROOT);\n-                Pattern pattern = Pattern.compile(parameterRegex, Pattern.CASE_INSENSITIVE);\n+                Pattern parameterRegex = params.getValue();\n+                Pattern pattern = Pattern.compile(parameterRegex.pattern(), Pattern.CASE_INSENSITIVE);\n                 parametersForMediaType.put(parameterName, pattern);\n             }\n             parametersMap.put(alternativeMediaType, parametersForMediaType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5ODMxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r492098319", "bodyText": "I think you can remove this method in favor of just consumers just passing Colections.emptyMap() (which is how it is currently used).", "author": "jakelandis", "createdAt": "2020-09-21T14:35:50Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,36 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatMap = new HashMap<>();\n+        private final Map<String, T> typeMap = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {", "originalCommit": "5853561bb30b1d61aaf3db6b74bd1aa7f43e6ea8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b6ebd6399abcec1faad8a994ae202c82151139f7", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex ef498349d132..1b737c854969 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -131,21 +131,15 @@ public class MediaTypeParser<T extends MediaType> {\n         private final Map<String, T> typeMap = new HashMap<>();\n         private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n \n-        public Builder<T> withMediaTypeNoParams(String alternativeMediaType, T mediaType) {\n-            typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n-            formatMap.put(mediaType.format(), mediaType);\n-            return this;\n-        }\n-\n-        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, String> paramNameAndValueRegex) {\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, Pattern> paramNameAndValueRegex) {\n             typeMap.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n             formatMap.put(mediaType.format(), mediaType);\n \n             Map<String, Pattern> parametersForMediaType = new HashMap<>(paramNameAndValueRegex.size());\n-            for (Map.Entry<String, String> params : paramNameAndValueRegex.entrySet()) {\n+            for (Map.Entry<String, Pattern> params : paramNameAndValueRegex.entrySet()) {\n                 String parameterName = params.getKey().toLowerCase(Locale.ROOT);\n-                String parameterRegex = params.getValue().toLowerCase(Locale.ROOT);\n-                Pattern pattern = Pattern.compile(parameterRegex, Pattern.CASE_INSENSITIVE);\n+                Pattern parameterRegex = params.getValue();\n+                Pattern pattern = Pattern.compile(parameterRegex.pattern(), Pattern.CASE_INSENSITIVE);\n                 parametersForMediaType.put(parameterName, pattern);\n             }\n             parametersMap.put(alternativeMediaType, parametersForMediaType);\n"}}, {"oid": "b6ebd6399abcec1faad8a994ae202c82151139f7", "url": "https://github.com/elastic/elasticsearch/commit/b6ebd6399abcec1faad8a994ae202c82151139f7", "message": "removal of unused method and pattern in method", "committedDate": "2020-09-21T17:07:24Z", "type": "commit"}, {"oid": "ff6c94f3e6d483b53415b7a2162c4a9f651fad7c", "url": "https://github.com/elastic/elasticsearch/commit/ff6c94f3e6d483b53415b7a2162c4a9f651fad7c", "message": "throwing exception when failing to parse", "committedDate": "2020-09-22T13:49:35Z", "type": "commit"}, {"oid": "b969f2bd860b74caff6bbf11b9eb19e3f4651ae9", "url": "https://github.com/elastic/elasticsearch/commit/b969f2bd860b74caff6bbf11b9eb19e3f4651ae9", "message": "checkstyle", "committedDate": "2020-09-22T15:03:06Z", "type": "commit"}, {"oid": "0684e584eb812fe76e2eb8427ac0b323b43ff83d", "url": "https://github.com/elastic/elasticsearch/commit/0684e584eb812fe76e2eb8427ac0b323b43ff83d", "message": "test fixes", "committedDate": "2020-09-23T09:34:18Z", "type": "commit"}, {"oid": "b91d4721754e7d0111ba1a3731bb0170b52fe8cb", "url": "https://github.com/elastic/elasticsearch/commit/b91d4721754e7d0111ba1a3731bb0170b52fe8cb", "message": "*/* header", "committedDate": "2020-09-23T12:16:03Z", "type": "commit"}, {"oid": "9edc49f64ad91799628068bd80abc8706ebc86c4", "url": "https://github.com/elastic/elasticsearch/commit/9edc49f64ad91799628068bd80abc8706ebc86c4", "message": "catch", "committedDate": "2020-09-23T12:43:58Z", "type": "commit"}, {"oid": "c5d816693e18003a9b78246cb3ed2e3efc0be3be", "url": "https://github.com/elastic/elasticsearch/commit/c5d816693e18003a9b78246cb3ed2e3efc0be3be", "message": "hacks around text/plain", "committedDate": "2020-09-23T17:48:43Z", "type": "commit"}, {"oid": "ad673b64ddd1a2bbe01823084515af5706d46c4e", "url": "https://github.com/elastic/elasticsearch/commit/ad673b64ddd1a2bbe01823084515af5706d46c4e", "message": "sout remove", "committedDate": "2020-09-23T17:53:13Z", "type": "commit"}, {"oid": "1ae6a609a9b6ed0826ac5bb1847f431e5e56190e", "url": "https://github.com/elastic/elasticsearch/commit/1ae6a609a9b6ed0826ac5bb1847f431e5e56190e", "message": "precommit", "committedDate": "2020-09-23T18:12:03Z", "type": "commit"}, {"oid": "1ae63c69122b0deec888afa0f236cfb579472eeb", "url": "https://github.com/elastic/elasticsearch/commit/1ae63c69122b0deec888afa0f236cfb579472eeb", "message": "fix nullpointer", "committedDate": "2020-09-24T06:28:56Z", "type": "commit"}, {"oid": "ee1e5a0459d7228c53369928516d0e9acb1e2e2f", "url": "https://github.com/elastic/elasticsearch/commit/ee1e5a0459d7228c53369928516d0e9acb1e2e2f", "message": "fix yml test", "committedDate": "2020-09-24T07:23:53Z", "type": "commit"}, {"oid": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "url": "https://github.com/elastic/elasticsearch/commit/9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "message": "fix yml test", "committedDate": "2020-09-24T07:51:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494151857", "bodyText": "an exception is thrown when parsing so we would not need thisif", "author": "pgomulka", "createdAt": "2020-09-24T08:57:27Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java", "diffHunk": "@@ -1900,9 +1900,9 @@ protected final ElasticsearchStatusException parseResponseException(ResponseExce\n             throw new IllegalStateException(\"Elasticsearch didn't return the [Content-Type] header, unable to parse response body\");\n         }\n         XContentType xContentType = XContentType.fromMediaType(entity.getContentType().getValue());\n-        if (xContentType == null) {\n-            throw new IllegalStateException(\"Unsupported Content-Type: \" + entity.getContentType().getValue());\n-        }\n+//        if (xContentType == null) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzOTI0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495939241", "bodyText": "not throwin exception in this PR", "author": "pgomulka", "createdAt": "2020-09-28T13:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTg1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java\nindex 3cf285bf23a9..8d1a8e22a4b1 100644\n--- a/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java\n+++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/RestHighLevelClient.java\n\n@@ -1900,9 +1900,9 @@ public class RestHighLevelClient implements Closeable {\n             throw new IllegalStateException(\"Elasticsearch didn't return the [Content-Type] header, unable to parse response body\");\n         }\n         XContentType xContentType = XContentType.fromMediaType(entity.getContentType().getValue());\n-//        if (xContentType == null) {\n-//            throw new IllegalStateException(\"Unsupported Content-Type: \" + entity.getContentType().getValue());\n-//        }\n+        if (xContentType == null) {\n+            throw new IllegalStateException(\"Unsupported Content-Type: \" + entity.getContentType().getValue());\n+        }\n         try (XContentParser parser = xContentType.xContent().createParser(registry, DEPRECATION_HANDLER, entity.getContent())) {\n             return entityParser.apply(parser);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MDU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494160556", "bodyText": "when parsing returns a supertype to TextFormat and XContentType - MediaType -  it makes it harder to implement these two branches.\ni think we should probably move the formatting behaviour out of TextFormat. It should only implement methods defined on MediaType (the original XContentType methods)", "author": "pgomulka", "createdAt": "2020-09-24T09:11:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzODI2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495938264", "bodyText": "leaving this up for discussion. With this approach we can have a single parser that returns both XContentType and TextFormat under MediaType interface\nXContentType does not implement format method. But maybe these two should have a common createRestResponse method?", "author": "pgomulka", "createdAt": "2020-09-28T13:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MDU1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\nindex 133d03d1b5bb..4ade958b60e8 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n\n@@ -61,16 +107,16 @@ public class RestSqlQueryAction extends BaseRestHandler {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (responseMediaType != null && responseMediaType instanceof XContentType) {\n-                    XContentType type = (XContentType)responseMediaType;\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), type, true);\n+                if (xContentType != null) {\n+                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n                     response.toXContent(builder, request);\n                     restResponse = new BytesRestResponse(RestStatus.OK, builder);\n-                } else {// TextFormat\n-                    TextFormat type = (TextFormat)responseMediaType;\n-                    final String data = type.format(request, response);\n+                }\n+                // TextFormat\n+                else {\n+                    final String data = textFormat.format(request, response);\n \n-                    restResponse = new BytesRestResponse(RestStatus.OK, type.contentType(request),\n+                    restResponse = new BytesRestResponse(RestStatus.OK, textFormat.contentType(request),\n                         data.getBytes(StandardCharsets.UTF_8));\n \n                     if (response.hasCursor()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494163209", "bodyText": "I made a comment to suggest we get rid of using Content-Type to set responseType. However I think most sql queries contain a body, so using a Content-Type to default responseType might be ok.\nIf however a request did not contain a body, then it would not make sense. I don't know we have any SQL api though.\nHowever, this obviously means that only json/cbor/smile/yml are allowed .", "author": "pgomulka", "createdAt": "2020-09-24T09:15:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        }\n+        if (request.getHeaders().containsKey(\"Accept\")) {\n+            String accept = request.header(\"Accept\");\n+            // */* means \"I don't care\" which we should treat like not specifying the header\n+            if (\"*/*\".equals(accept) == false) {\n+                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n+            }\n+        }\n+\n+        //todo pg we should probably remove this possibility. it should only be accept or format.\n+        // also if you specify sql's textformat in content type it will fail with exception now\n+        String contentType = request.header(\"Content-Type\");", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMjQwMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495922400", "bodyText": "also not fixing this in current PR. might be worth discussing with @elastic/es-ql", "author": "pgomulka", "createdAt": "2020-09-28T13:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5Mzc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498893782", "bodyText": "I think most sql queries contain a body\n\nIndeed, all requests concerning this code always contain a body.\n(In the SQL API only one API lacks it, the one for stats inquiring, which won't hit this code tho.)", "author": "bpintea", "createdAt": "2020-10-02T15:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2MzIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\ndeleted file mode 100644\nindex e784d0cff49b..000000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n+++ /dev/null\n\n@@ -1,77 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.plugin;\n-\n-import org.elasticsearch.common.xcontent.MediaType;\n-import org.elasticsearch.common.xcontent.MediaTypeParser;\n-import org.elasticsearch.common.xcontent.XContentType;\n-import org.elasticsearch.rest.RestRequest;\n-import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n-import org.elasticsearch.xpack.sql.proto.Mode;\n-\n-import java.util.Map;\n-import java.util.regex.Pattern;\n-\n-import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n-\n-public class SqlMediaTypeParser {\n-    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n-        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n-        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n-            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n-        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n-            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n-        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n-            Map.of(\"header\", Pattern.compile(\"present|absent\"), \"charset\", Pattern.compile(\"utf-8\")))\n-        .build();\n-\n-    /*\n-     * Since we support {@link TextFormat} <strong>and</strong>\n-     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n-     * like everything else. We want to stick as closely as possible to\n-     * Elasticsearch's defaults though, while still layering in ways to\n-     * control the output more easily.\n-     *\n-     * First we find the string that the user used to specify the response\n-     * format. If there is a {@code format} parameter we use that. If there\n-     * isn't but there is a {@code Accept} header then we use that. If there\n-     * isn't then we use the {@code Content-Type} header which is required.\n-     */\n-    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n-\n-        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n-            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n-            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n-            return XContentType.CBOR;\n-        } else if (request.hasParam(URL_PARAM_FORMAT)){\n-            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n-        }\n-        if (request.getHeaders().containsKey(\"Accept\")) {\n-            String accept = request.header(\"Accept\");\n-            // */* means \"I don't care\" which we should treat like not specifying the header\n-            if (\"*/*\".equals(accept) == false) {\n-                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n-            }\n-        }\n-\n-        //todo pg we should probably remove this possibility. it should only be accept or format.\n-        // also if you specify sql's textformat in content type it will fail with exception now\n-        String contentType = request.header(\"Content-Type\");\n-        assert contentType != null : \"The Content-Type header is required\";\n-        return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(contentType));\n-    }\n-\n-    private MediaType validateColumnarRequest(boolean requestIsColumnar, MediaType fromMediaType) {\n-        if(requestIsColumnar && fromMediaType instanceof TextFormat){\n-            throw new IllegalArgumentException(\"Invalid use of [columnar] argument: cannot be used in combination with \"\n-                + \"txt, csv or tsv formats\");\n-        }\n-        return fromMediaType;\n-\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2Mzg2NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494163864", "bodyText": "this client does not have access to SQL code, but has to support these formats too.", "author": "pgomulka", "createdAt": "2020-09-24T09:16:45Z", "path": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java", "diffHunk": "@@ -45,15 +45,21 @@\n \n     private final Response response;\n     private final byte[] body;\n-    private final XContentType bodyContentType;\n+    private XContentType bodyContentType;\n     private ObjectPath parsedResponse;\n     private String bodyAsString;\n \n     public ClientYamlTestResponse(Response response) throws IOException {\n         this.response = response;\n         if (response.getEntity() != null) {\n             String contentType = response.getHeader(\"Content-Type\");\n-            this.bodyContentType = XContentType.fromMediaType(contentType);\n+            // todo pg it feels like there is a lot of 'ifs' around text, csv etc being returned. shouldn't we treat text as the same json and others?\n+            // we are testing sql formats with this client, but don't have access to sql parsing code\n+            try{", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMjAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495922015", "bodyText": "we are not throwing an exception when parsing in this PR", "author": "pgomulka", "createdAt": "2020-09-28T13:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2Mzg2NA=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java b/test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java\nindex 0b8bf9367b8f..9f5d0dfe9dcd 100644\n--- a/test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java\n+++ b/test/framework/src/main/java/org/elasticsearch/test/rest/yaml/ClientYamlTestResponse.java\n\n@@ -45,7 +45,7 @@ public class ClientYamlTestResponse {\n \n     private final Response response;\n     private final byte[] body;\n-    private XContentType bodyContentType;\n+    private final XContentType bodyContentType;\n     private ObjectPath parsedResponse;\n     private String bodyAsString;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2NDc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494164761", "bodyText": "since parsing is strict and throws an exception when unkown type is used then it requires a lot of \"if guards\" to make sure it will not fail.\nOr it leads to flow being controlled by exceptions -which is bad I think.\nAlso looks to me that text/plain is commonly used as returnType for _cat api. We should probably add it to xcontentType?", "author": "pgomulka", "createdAt": "2020-09-24T09:18:20Z", "path": "server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java", "diffHunk": "@@ -98,10 +101,17 @@ public XContentBuilder newBuilder(@Nullable XContentType requestContentType, boo\n     public XContentBuilder newBuilder(@Nullable XContentType requestContentType, @Nullable XContentType responseContentType,\n             boolean useFiltering) throws IOException {\n         if (responseContentType == null) {\n-            //TODO PG shoudld format vs acceptHeader be always the same, do we allow overriding?\n-            responseContentType = XContentType.fromFormat(format);\n-            if (responseContentType == null) {\n-                responseContentType = XContentType.fromMediaType(acceptHeader);\n+            if (Strings.hasText(format)) {\n+                responseContentType = XContentType.fromFormat(format);\n+            } else if (Strings.hasText(acceptHeader) && acceptHeader.equals(\"*/*\") == false", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkyMTY4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495921681", "bodyText": "not fixing this in current PR. will follow up", "author": "pgomulka", "createdAt": "2020-09-28T13:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE2NDc2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java b/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java\nindex eaf0fd301d8d..c5bf1efa2cdb 100644\n--- a/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java\n+++ b/server/src/main/java/org/elasticsearch/rest/AbstractRestChannel.java\n\n@@ -101,17 +98,10 @@ public abstract class AbstractRestChannel implements RestChannel {\n     public XContentBuilder newBuilder(@Nullable XContentType requestContentType, @Nullable XContentType responseContentType,\n             boolean useFiltering) throws IOException {\n         if (responseContentType == null) {\n-            if (Strings.hasText(format)) {\n-                responseContentType = XContentType.fromFormat(format);\n-            } else if (Strings.hasText(acceptHeader) && acceptHeader.equals(\"*/*\") == false\n-                && acceptHeader.startsWith(\"text/plain\")==false) { //TODO PG there are a lot of usages of text/plain as a response type.\n-                // I feel it would fit into xcontenttype..\n-                try {\n-                    responseContentType = XContentType.fromMediaType(acceptHeader);\n-                }catch (IllegalArgumentException e){\n-                    //todo pg this is in a way controlling the flow by exceptions. to be discussed\n-                    logger.debug(\"Unrecognized accept header\",e);\n-                }\n+            //TODO PG shoudld format vs acceptHeader be always the same, do we allow overriding?\n+            responseContentType = XContentType.fromFormat(format);\n+            if (responseContentType == null) {\n+                responseContentType = XContentType.fromMediaType(acceptHeader);\n             }\n         }\n         // try to determine the response content type from the media type or the format query string parameter, with the format parameter\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NTQ0NA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494175444", "bodyText": "should this be renamed to acceptType?", "author": "pgomulka", "createdAt": "2020-09-24T09:35:39Z", "path": "server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java", "diffHunk": "@@ -83,6 +83,7 @@ public BytesRestResponse(RestStatus status, String contentType, byte[] content)\n     /**\n      * Creates a binary response.\n      */\n+    //todo pg this should probably be acceptType? (2nd param)\n     public BytesRestResponse(RestStatus status, String contentType, BytesReference content) {", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkxMjE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r495912159", "bodyText": "renamed.", "author": "pgomulka", "createdAt": "2020-09-28T12:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java b/server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java\nindex 91f3c1e5d3b6..3babe4347426 100644\n--- a/server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java\n+++ b/server/src/main/java/org/elasticsearch/rest/BytesRestResponse.java\n\n@@ -83,7 +83,6 @@ public class BytesRestResponse extends RestResponse {\n     /**\n      * Creates a binary response.\n      */\n-    //todo pg this should probably be acceptType? (2nd param)\n     public BytesRestResponse(RestStatus status, String contentType, BytesReference content) {\n         this.status = status;\n         this.content = content;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NjUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r494176508", "bodyText": "this prevents defaulting Accept header to text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 by sun.net.www.protocol.http.HttpURLConnection", "author": "pgomulka", "createdAt": "2020-09-24T09:37:24Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java", "diffHunk": "@@ -145,6 +145,7 @@ HttpURLConnection buildConnection(SSLContext ssl) throws IOException {\n         configureSslContext(connection, ssl);\n         configureBasicAuth(connection);\n         connection.setRequestMethod(\"GET\");\n+        connection.setRequestProperty(\"Accept\", \"text/plain; charset=UTF-8\");", "originalCommit": "9f4b6c38a5869c22b8354e59bf0f7a7aeb1e69f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "chunk": "diff --git a/buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java b/buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java\nindex 9aef2f6c98c4..db805b26cdca 100644\n--- a/buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java\n+++ b/buildSrc/src/main/java/org/elasticsearch/gradle/http/WaitForHttpResource.java\n\n@@ -145,7 +145,6 @@ public class WaitForHttpResource {\n         configureSslContext(connection, ssl);\n         configureBasicAuth(connection);\n         connection.setRequestMethod(\"GET\");\n-        connection.setRequestProperty(\"Accept\", \"text/plain; charset=UTF-8\");\n         return connection;\n     }\n \n"}}, {"oid": "bd4dee1126974d0cf66d63eaf62564b8c3d9f032", "url": "https://github.com/elastic/elasticsearch/commit/bd4dee1126974d0cf66d63eaf62564b8c3d9f032", "message": "throwing exception when failing to parse\n\ncheckstyle\n\ntest fixes\n\n*/* header\n\ncatch\n\nhacks around text/plain\n\nsout remove\n\nprecommit\n\nfix nullpointer\n\nfix yml test\n\nfix yml test", "committedDate": "2020-09-24T10:25:09Z", "type": "commit"}, {"oid": "ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "url": "https://github.com/elastic/elasticsearch/commit/ce42f1bd933ef7823b11258d1b3c5f5efa88fcbc", "message": "Revert \"throwing exception when failing to parse\"\n\nThis reverts commit bd4dee1126974d0cf66d63eaf62564b8c3d9f032.", "committedDate": "2020-09-24T16:41:34Z", "type": "commit"}, {"oid": "0f8ae7b50485a8ca201f235d15ba3a0fe77c15bf", "url": "https://github.com/elastic/elasticsearch/commit/0f8ae7b50485a8ca201f235d15ba3a0fe77c15bf", "message": "Merge branch 'revert_strict_header_parsing' into compat/content-type-header-with-version", "committedDate": "2020-09-24T16:48:40Z", "type": "commit"}, {"oid": "c4f02ade240cd69c6966d0082800c8cc5ba69854", "url": "https://github.com/elastic/elasticsearch/commit/c4f02ade240cd69c6966d0082800c8cc5ba69854", "message": "import", "committedDate": "2020-09-28T07:27:51Z", "type": "commit"}, {"oid": "176302efd7687f267a211337d6c5632bc44d3085", "url": "https://github.com/elastic/elasticsearch/commit/176302efd7687f267a211337d6c5632bc44d3085", "message": "fix storing response time in sql", "committedDate": "2020-09-28T07:57:09Z", "type": "commit"}, {"oid": "eab471c5ebd45f8ab008bdf1f3272cd091bae2b7", "url": "https://github.com/elastic/elasticsearch/commit/eab471c5ebd45f8ab008bdf1f3272cd091bae2b7", "message": "return null on errors", "committedDate": "2020-09-28T09:34:40Z", "type": "commit"}, {"oid": "e128fd78e363cb027ccf7a41018cb9e965fcc801", "url": "https://github.com/elastic/elasticsearch/commit/e128fd78e363cb027ccf7a41018cb9e965fcc801", "message": "sqlmedia type parsing test - do not throw exceptions", "committedDate": "2020-09-28T10:16:37Z", "type": "commit"}, {"oid": "66435dd9c9bf07f1457344b9e6772d65ac4a4afc", "url": "https://github.com/elastic/elasticsearch/commit/66435dd9c9bf07f1457344b9e6772d65ac4a4afc", "message": "remove todoes", "committedDate": "2020-09-28T12:45:26Z", "type": "commit"}, {"oid": "08f1395ce1f1014d06cefaff9f2722945f761e75", "url": "https://github.com/elastic/elasticsearch/commit/08f1395ce1f1014d06cefaff9f2722945f761e75", "message": "rename argument", "committedDate": "2020-09-28T16:30:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MTgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496781829", "bodyText": "remove todo", "author": "jakelandis", "createdAt": "2020-09-29T14:49:59Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -65,8 +50,10 @@ public T fromFormat(String format) {\n \n     /**\n      * parsing media type that follows https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n+     *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n+     * //todo pg write a benchmark and consider using a regex", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 387a971f3dc4..e5825cae50ca 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -53,7 +53,6 @@ public class MediaTypeParser<T extends MediaType> {\n      *\n      * @param headerValue a header value from Accept or Content-Type\n      * @return a parsed media-type\n-     * //todo pg write a benchmark and consider using a regex\n      */\n     public ParsedMediaType parseMediaType(String headerValue) {\n         if (headerValue != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496792237", "bodyText": "I think this is technically non-passive (only supporting UTF-8 encoding) and should probably be mentioned in the breaking changes ... thus only targeting 8.0 and (outside of this PR) ensure that a 7.x server maps the compatible header to standard header ... i.e. (application/vnd.elasticsearch+yaml; compatible-with=7 == application/yaml)", "author": "jakelandis", "createdAt": "2020-09-29T15:02:48Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java", "diffHunk": "@@ -113,9 +115,26 @@ public XContent xContent() {\n         }\n     };\n \n-    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser<>(XContentType.values(),\n-        Map.of(\"application/*\", JSON, \"application/x-ndjson\", JSON));\n-\n+    private static final Pattern VERSION_PATTERN = Pattern.compile(\"\\\\d+\");\n+    private static final String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n+     public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+        .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n+        .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n+        .withMediaTypeAndParams(\"application/yaml\", YAML, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNzczNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496917737", "bodyText": "that's a good point. I think clients will have to upgrade to latest 7.x client to get compatible-with  sent on their request.\nWe should also support that in 7.x server. Will raise an issue/pr", "author": "pgomulka", "createdAt": "2020-09-29T17:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497489847", "bodyText": "handling of versioned media types in a form application/vnd.elasticsearch+json;compatible-with=7 will be handled in this pr #63071", "author": "pgomulka", "createdAt": "2020-09-30T13:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MjIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\nindex f7c1625a2683..c15cca4d1ab3 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/XContentType.java\n\n@@ -117,7 +117,7 @@ public enum XContentType implements MediaType {\n \n     private static final Pattern VERSION_PATTERN = Pattern.compile(\"\\\\d+\");\n     private static final String COMPATIBLE_WITH_PARAMETER_NAME = \"compatible-with\";\n-     public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n+    public static final MediaTypeParser<XContentType> mediaTypeParser = new MediaTypeParser.Builder<XContentType>()\n         .withMediaTypeAndParams(\"application/smile\", SMILE, Collections.emptyMap())\n         .withMediaTypeAndParams(\"application/cbor\", CBOR, Collections.emptyMap())\n         .withMediaTypeAndParams(\"application/json\", JSON, Map.of(\"charset\", Pattern.compile(\"UTF-8\")))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwODQwNA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496808404", "bodyText": "Can you also add a small test for (lowercase charset=utf-8)", "author": "jakelandis", "createdAt": "2020-09-29T15:22:44Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -23,6 +23,7 @@\n import java.util.Locale;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n \n public class XContentTypeTests extends ESTestCase {", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496815809", "bodyText": "can you remove the insensitive recompile here and and just use the pattern as-is (and move the insenstivie up to the declration)", "author": "jakelandis", "createdAt": "2020-09-29T15:29:42Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java", "diffHunk": "@@ -120,4 +125,37 @@ public T getMediaType() {\n             return parameters;\n         }\n     }\n+\n+    public static class Builder<T extends MediaType> {\n+        private final Map<String, T> formatToMediaType = new HashMap<>();\n+        private final Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n+        private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n+\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, Pattern> paramNameAndValueRegex) {\n+            typeWithSubtypeToMediaType.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n+            formatToMediaType.put(mediaType.format(), mediaType);\n+\n+            Map<String, Pattern> parametersForMediaType = new HashMap<>(paramNameAndValueRegex.size());\n+            for (Map.Entry<String, Pattern> params : paramNameAndValueRegex.entrySet()) {\n+                String parameterName = params.getKey().toLowerCase(Locale.ROOT);\n+                Pattern parameterRegex = params.getValue();\n+                Pattern pattern = Pattern.compile(parameterRegex.pattern(), Pattern.CASE_INSENSITIVE);", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMzA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496913042", "bodyText": "It would result in a fairly big number of duplication. there are other textual parameters like header (present/absent), delimeter which would also had to declare case insensitivity.\nI wonder if we ever want to support case sensitivity for params values", "author": "pgomulka", "createdAt": "2020-09-29T17:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5MzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497093537", "bodyText": "OK ... in that case, maybe go back to a Map<String, String> as the collection passed ?  It is a bit confusing to compile it, then re-compile it.  Sorry, when i first suggested to pass Map<String, Pattern> I had envisioned only compiling once.", "author": "jakelandis", "createdAt": "2020-09-29T22:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI3NzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497277808", "bodyText": "agree, will refactor this back. Using the Pattern as a type was making it obvious what that parameter was, but then compiling multiple times is probably not clean.", "author": "pgomulka", "createdAt": "2020-09-30T06:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTgwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "427c3913e197afecb821f36f29adbf8a298e2055", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\nindex 387a971f3dc4..62a3f3fd915d 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/MediaTypeParser.java\n\n@@ -131,15 +130,15 @@ public class MediaTypeParser<T extends MediaType> {\n         private final Map<String, T> typeWithSubtypeToMediaType = new HashMap<>();\n         private final Map<String, Map<String, Pattern>> parametersMap = new HashMap<>();\n \n-        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, Pattern> paramNameAndValueRegex) {\n+        public Builder<T> withMediaTypeAndParams(String alternativeMediaType, T mediaType, Map<String, String> paramNameAndValueRegex) {\n             typeWithSubtypeToMediaType.put(alternativeMediaType.toLowerCase(Locale.ROOT), mediaType);\n             formatToMediaType.put(mediaType.format(), mediaType);\n \n             Map<String, Pattern> parametersForMediaType = new HashMap<>(paramNameAndValueRegex.size());\n-            for (Map.Entry<String, Pattern> params : paramNameAndValueRegex.entrySet()) {\n+            for (Map.Entry<String, String> params : paramNameAndValueRegex.entrySet()) {\n                 String parameterName = params.getKey().toLowerCase(Locale.ROOT);\n-                Pattern parameterRegex = params.getValue();\n-                Pattern pattern = Pattern.compile(parameterRegex.pattern(), Pattern.CASE_INSENSITIVE);\n+                String parameterRegex = params.getValue();\n+                Pattern pattern = Pattern.compile(parameterRegex, Pattern.CASE_INSENSITIVE);\n                 parametersForMediaType.put(parameterName, pattern);\n             }\n             parametersMap.put(alternativeMediaType, parametersForMediaType);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496832480", "bodyText": "can you also add a test that has both compatible-with and charset ?", "author": "jakelandis", "createdAt": "2020-09-29T15:45:08Z", "path": "server/src/test/java/org/elasticsearch/common/xcontent/XContentTypeTests.java", "diffHunk": "@@ -93,4 +94,65 @@ public void testFromRubbish() throws Exception {\n         assertThat(XContentType.fromMediaType(\"text/plain\"), nullValue());\n         assertThat(XContentType.fromMediaType(\"gobbly;goop\"), nullValue());\n     }\n+\n+    public void testVersionedMediaType() {\n+        String version = String.valueOf(Math.abs(randomByte()));\n+        assertThat(XContentType.fromMediaType(\"application/vnd.elasticsearch+json;compatible-with=\" + version),", "originalCommit": "08f1395ce1f1014d06cefaff9f2722945f761e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r496916910", "bodyText": "this specific test is only meant to test versioning. I covered multiple parameters support in MediaTypeParserTests.testJsonWithParameters", "author": "pgomulka", "createdAt": "2020-09-29T17:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5NDI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r497094253", "bodyText": "thanks... i missed that!", "author": "jakelandis", "createdAt": "2020-09-29T22:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMjQ4MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "url": "https://github.com/elastic/elasticsearch/commit/3f3f0d55628bc05dd679ac6dd0f333446cd6093c", "message": "review follow up", "committedDate": "2020-09-29T18:04:50Z", "type": "commit"}, {"oid": "427c3913e197afecb821f36f29adbf8a298e2055", "url": "https://github.com/elastic/elasticsearch/commit/427c3913e197afecb821f36f29adbf8a298e2055", "message": "remove pattern from signature", "committedDate": "2020-09-30T07:07:59Z", "type": "commit"}, {"oid": "e0316054c4a9559ddc5b115b9b5b72999c701649", "url": "https://github.com/elastic/elasticsearch/commit/e0316054c4a9559ddc5b115b9b5b72999c701649", "message": "fix regex", "committedDate": "2020-09-30T08:01:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2Nzg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498367868", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                XContentType type = (XContentType)responseMediaType;\n          \n          \n            \n                                XContentType type = (XContentType) responseMediaType;", "author": "jaymode", "createdAt": "2020-10-01T16:20:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {\n+                    XContentType type = (XContentType)responseMediaType;", "originalCommit": "e0316054c4a9559ddc5b115b9b5b72999c701649", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\nindex 7ad9ac8c8d53..763e460170cf 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n\n@@ -62,11 +62,11 @@ public class RestSqlQueryAction extends BaseRestHandler {\n \n                 // XContent branch\n                 if (responseMediaType != null && responseMediaType instanceof XContentType) {\n-                    XContentType type = (XContentType)responseMediaType;\n+                    XContentType type = (XContentType) responseMediaType;\n                     XContentBuilder builder = channel.newBuilder(request.getXContentType(), type, true);\n                     response.toXContent(builder, request);\n                     restResponse = new BytesRestResponse(RestStatus.OK, builder);\n-                } else {// TextFormat\n+                } else { // TextFormat\n                     TextFormat type = (TextFormat)responseMediaType;\n                     final String data = type.format(request, response);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM2ODI1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498368253", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else {// TextFormat\n          \n          \n            \n                            } else { // TextFormat", "author": "jaymode", "createdAt": "2020-10-01T16:20:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java", "diffHunk": "@@ -107,16 +61,16 @@ public RestResponse buildResponse(SqlQueryResponse response) throws Exception {\n                 RestResponse restResponse;\n \n                 // XContent branch\n-                if (xContentType != null) {\n-                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), xContentType, true);\n+                if (responseMediaType != null && responseMediaType instanceof XContentType) {\n+                    XContentType type = (XContentType)responseMediaType;\n+                    XContentBuilder builder = channel.newBuilder(request.getXContentType(), type, true);\n                     response.toXContent(builder, request);\n                     restResponse = new BytesRestResponse(RestStatus.OK, builder);\n-                }\n-                // TextFormat\n-                else {\n-                    final String data = textFormat.format(request, response);\n+                } else {// TextFormat", "originalCommit": "e0316054c4a9559ddc5b115b9b5b72999c701649", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\nindex 7ad9ac8c8d53..763e460170cf 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/RestSqlQueryAction.java\n\n@@ -62,11 +62,11 @@ public class RestSqlQueryAction extends BaseRestHandler {\n \n                 // XContent branch\n                 if (responseMediaType != null && responseMediaType instanceof XContentType) {\n-                    XContentType type = (XContentType)responseMediaType;\n+                    XContentType type = (XContentType) responseMediaType;\n                     XContentBuilder builder = channel.newBuilder(request.getXContentType(), type, true);\n                     response.toXContent(builder, request);\n                     restResponse = new BytesRestResponse(RestStatus.OK, builder);\n-                } else {// TextFormat\n+                } else { // TextFormat\n                     TextFormat type = (TextFormat)responseMediaType;\n                     final String data = type.format(request, response);\n \n"}}, {"oid": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "url": "https://github.com/elastic/elasticsearch/commit/4134d92ef9ea93c205746bc2f5031ee40c1d579e", "message": "Apply suggestions from code review\n\nCo-authored-by: Jay Modi <jaymode@users.noreply.github.com>", "committedDate": "2020-10-02T06:24:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498879006", "bodyText": "Is the delimiter regex derived from TextFormat.CSV#delimiter()? Because it specifies what characters are allowed, inline with what that method checks, on one hand, but allows a count of multiple character, out of line with a check there, on the other.\nThe exception messages in the method are explanatory and I'd ever so slightly prefer to return those (and maybe don't enforce a specific set here), but if you'd still like to enforce the param format in the parser definition, I'd suggest to maybe also limit the char count to one.", "author": "bpintea", "createdAt": "2020-10-02T15:04:40Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MTQ3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r499451472", "bodyText": "good point, I misread that method. It should only be one character.\nThe exception messages are indeed explanatory in this method. With the parameter validation when parsing, we will loose them - that code will not be reachable as it will fail earlier when parsing", "author": "pgomulka", "createdAt": "2020-10-05T09:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2MDI3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r499560277", "bodyText": "I changed this to expect the presence of a delimiter parameter, but the pattern will be .+ which will always pass, and the validation will be done in TextFormat.CSV#delimiter()", "author": "pgomulka", "createdAt": "2020-10-05T12:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3OTAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "a976f5b53d024edf45b5e583130f53f65184ffd9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\nindex f3b1bd228e9c..75c896a68318 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n\n@@ -47,8 +47,8 @@ public class SqlMediaTypeParser {\n             && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n             // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n             return XContentType.CBOR;\n-        } else if (request.hasParam(URL_PARAM_FORMAT)){\n-            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        } else if (request.hasParam(URL_PARAM_FORMAT)) {\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));\n         }\n         if (request.getHeaders().containsKey(\"Accept\")) {\n             String accept = request.header(\"Accept\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4MjMzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498882336", "bodyText": "nit, spacing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (request.hasParam(URL_PARAM_FORMAT)){\n          \n          \n            \n                        return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n          \n          \n            \n                    } else if (request.hasParam(URL_PARAM_FORMAT)) {\n          \n          \n            \n                        return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));", "author": "bpintea", "createdAt": "2020-10-02T15:10:09Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a976f5b53d024edf45b5e583130f53f65184ffd9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\nindex f3b1bd228e9c..75c896a68318 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n\n@@ -47,8 +47,8 @@ public class SqlMediaTypeParser {\n             && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n             // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n             return XContentType.CBOR;\n-        } else if (request.hasParam(URL_PARAM_FORMAT)){\n-            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        } else if (request.hasParam(URL_PARAM_FORMAT)) {\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));\n         }\n         if (request.getHeaders().containsKey(\"Accept\")) {\n             String accept = request.header(\"Accept\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4ODM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498888350", "bodyText": "optional, could be made static.", "author": "bpintea", "createdAt": "2020-10-02T15:20:22Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.MediaTypeParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.proto.Protocol.URL_PARAM_FORMAT;\n+\n+public class SqlMediaTypeParser {\n+    private static final MediaTypeParser<? extends MediaType> parser = new MediaTypeParser.Builder<>()\n+        .copyFromMediaTypeParser(XContentType.mediaTypeParser)\n+        .withMediaTypeAndParams(TextFormat.PLAIN_TEXT.typeWithSubtype(), TextFormat.PLAIN_TEXT,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .withMediaTypeAndParams(TextFormat.CSV.typeWithSubtype(), TextFormat.CSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\",\n+                \"delimiter\", \"[^\\\"\\n\\r\\t]+\"))\n+        .withMediaTypeAndParams(TextFormat.TSV.typeWithSubtype(), TextFormat.TSV,\n+            Map.of(\"header\", \"present|absent\", \"charset\", \"utf-8\"))\n+        .build();\n+\n+    /*\n+     * Since we support {@link TextFormat} <strong>and</strong>\n+     * {@link XContent} outputs we can't use {@link RestToXContentListener}\n+     * like everything else. We want to stick as closely as possible to\n+     * Elasticsearch's defaults though, while still layering in ways to\n+     * control the output more easily.\n+     *\n+     * First we find the string that the user used to specify the response\n+     * format. If there is a {@code format} parameter we use that. If there\n+     * isn't but there is a {@code Accept} header then we use that. If there\n+     * isn't then we use the {@code Content-Type} header which is required.\n+     */\n+    public MediaType getMediaType(RestRequest request, SqlQueryRequest sqlRequest) {\n+\n+        if (Mode.isDedicatedClient(sqlRequest.requestInfo().mode())\n+            && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n+            // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n+            return XContentType.CBOR;\n+        } else if (request.hasParam(URL_PARAM_FORMAT)){\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        }\n+        if (request.getHeaders().containsKey(\"Accept\")) {\n+            String accept = request.header(\"Accept\");\n+            // */* means \"I don't care\" which we should treat like not specifying the header\n+            if (\"*/*\".equals(accept) == false) {\n+                return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(accept));\n+            }\n+        }\n+\n+        String contentType = request.header(\"Content-Type\");\n+        assert contentType != null : \"The Content-Type header is required\";\n+        return validateColumnarRequest(sqlRequest.columnar(), parser.fromMediaType(contentType));\n+    }\n+\n+    private MediaType validateColumnarRequest(boolean requestIsColumnar, MediaType fromMediaType) {", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a976f5b53d024edf45b5e583130f53f65184ffd9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\nindex f3b1bd228e9c..75c896a68318 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParser.java\n\n@@ -47,8 +47,8 @@ public class SqlMediaTypeParser {\n             && (sqlRequest.binaryCommunication() == null || sqlRequest.binaryCommunication())) {\n             // enforce CBOR response for drivers and CLI (unless instructed differently through the config param)\n             return XContentType.CBOR;\n-        } else if (request.hasParam(URL_PARAM_FORMAT)){\n-            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat( request.param(URL_PARAM_FORMAT)));\n+        } else if (request.hasParam(URL_PARAM_FORMAT)) {\n+            return validateColumnarRequest(sqlRequest.columnar(), parser.fromFormat(request.param(URL_PARAM_FORMAT)));\n         }\n         if (request.getHeaders().containsKey(\"Accept\")) {\n             String accept = request.header(\"Accept\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61427#discussion_r498909556", "bodyText": "Since the methods only tests media type correct detection - i.e. the other parameters in the Accept aren't analysed by SqlMediaTypeParser, nor tested here, right? -, I would maybe propose to rename it (testMediaTypeDetection or similar?).\n(Slightly off-topic, the header parameter will need a rework or removal, as per #60271, but that's not the object of this PR).", "author": "bpintea", "createdAt": "2020-10-02T15:57:49Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.plugin;\n+\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.MediaType;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.rest.FakeRestRequest;\n+import org.elasticsearch.xpack.sql.action.SqlQueryRequest;\n+import org.elasticsearch.xpack.sql.proto.Mode;\n+import org.elasticsearch.xpack.sql.proto.RequestInfo;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.CSV;\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.PLAIN_TEXT;\n+import static org.elasticsearch.xpack.sql.plugin.TextFormat.TSV;\n+import static org.elasticsearch.xpack.sql.proto.RequestInfo.CLIENT_IDS;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+\n+public class SqlMediaTypeParserTests extends ESTestCase {\n+    SqlMediaTypeParser parser = new SqlMediaTypeParser();\n+\n+    public void testPlainTextDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/plain\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(PLAIN_TEXT));\n+    }\n+\n+    public void testCsvDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/csv\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(CSV));\n+    }\n+\n+    public void testTsvDetection() {\n+        MediaType text = parser.getMediaType(reqWithAccept(\"text/tab-separated-values\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(TSV));\n+    }\n+\n+    public void testParametersParsing() {", "originalCommit": "4134d92ef9ea93c205746bc2f5031ee40c1d579e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e0eec01383a9cbb7ec2f5e858149a93848ae8d6", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java\nindex d2671c1748ba..0459b777b15f 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/plugin/SqlMediaTypeParserTests.java\n\n@@ -37,6 +37,9 @@ public class SqlMediaTypeParserTests extends ESTestCase {\n     public void testCsvDetection() {\n         MediaType text = parser.getMediaType(reqWithAccept(\"text/csv\"), createTestInstance(false, Mode.PLAIN, false));\n         assertThat(text, is(CSV));\n+\n+        text = parser.getMediaType(reqWithAccept(\"text/csv; delimiter=x\"), createTestInstance(false, Mode.PLAIN, false));\n+        assertThat(text, is(CSV));\n     }\n \n     public void testTsvDetection() {\n"}}, {"oid": "a976f5b53d024edf45b5e583130f53f65184ffd9", "url": "https://github.com/elastic/elasticsearch/commit/a976f5b53d024edf45b5e583130f53f65184ffd9", "message": "Apply suggestions from code review\n\nCo-authored-by: Bogdan Pintea <bpintea@gmail.com>", "committedDate": "2020-10-05T09:11:33Z", "type": "commit"}, {"oid": "3e0eec01383a9cbb7ec2f5e858149a93848ae8d6", "url": "https://github.com/elastic/elasticsearch/commit/3e0eec01383a9cbb7ec2f5e858149a93848ae8d6", "message": "relax delimiter validation", "committedDate": "2020-10-05T12:09:59Z", "type": "commit"}]}