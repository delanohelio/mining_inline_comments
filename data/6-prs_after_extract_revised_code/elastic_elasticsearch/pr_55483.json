{"pr_number": 55483, "pr_title": "Add InstantiatingObjectParser", "pr_createdAt": "2020-04-20T19:09:06Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55483", "timeline": [{"oid": "15fbeb37410dcbccb2e5e083fcb2bfe4930e2a0a", "url": "https://github.com/elastic/elasticsearch/commit/15fbeb37410dcbccb2e5e083fcb2bfe4930e2a0a", "message": "Add InstantiatingObjectParser\n\nIntroduces InstantiatingObjectParser which is similar to the\nConstructingObjectParser, but instantiates the object using the constructor\ninstead of a builder function.\n\nCloses #52499", "committedDate": "2020-04-20T19:04:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2NjU4MA==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412166580", "bodyText": "I wonder if it'd make more sense to make a Builder for it rather than this. These are generally static state stuff like this is a bit scary. I see why it is just fine but it'd be a bit more \"obviously fine\" if it had a builder instead of \"finalized\".", "author": "nik9000", "createdAt": "2020-04-21T13:05:21Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/InstantiatingObjectParser.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import org.elasticsearch.common.ParseField;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Like {@link ConstructingObjectParser} but works with objects which have a constructor that matches declared fields.\n+ * <p>\n+ * Declaring a {@linkplain InstantiatingObjectParser} is intentionally quite similar to declaring an {@linkplain ConstructingObjectParser}\n+ * with two important differences.\n+ * <p>\n+ * The first differences being that constructor arguments are declared with the consumer returned by the static {@link #constructorArg()}\n+ * method and that {@linkplain InstantiatingObjectParser}'s constructor takes a class of the target object. The target object must have\n+ * exactly one constructor with the number and order of arguments matching the number of order of declared fields. If there are more\n+ * then 2 constructors with the same number of arguments, one of them needs to be marked with {@linkplain ParserConstructor} annotation.\n+ * </p>\n+ * The second differences being that at the end of field declarations the {@linkplain #finalizeFields()} method has to be called before\n+ * any parsing is possible.\n+ * <pre>{@code\n+ *   public static class Thing{\n+ *       public Thing(String animal, String vegetable, int mineral) {\n+ *           ....\n+ *       }\n+ *\n+ *       public void setFruit(int fruit) { ... }\n+ *\n+ *       public void setBug(int bug) { ... }\n+ *\n+ *   }\n+ *\n+ *   private static final InstantiatingObjectParser<Thing, SomeContext> PARSER = new InstantiatingObjectParser<>(\"thing\", Thing.class);\n+ *   static {\n+ *       PARSER.declareString(constructorArg(), new ParseField(\"animal\"));\n+ *       PARSER.declareString(constructorArg(), new ParseField(\"vegetable\"));\n+ *       PARSER.declareInt(optionalConstructorArg(), new ParseField(\"mineral\"));\n+ *       PARSER.declareInt(Thing::setFruit, new ParseField(\"fruit\"));\n+ *       PARSER.declareInt(Thing::setBug, new ParseField(\"bug\"));\n+ *       PARSER.finalizeFields()\n+ *   }\n+ * }</pre>\n+ */\n+public class InstantiatingObjectParser<Value, Context> extends AbstractConstructingObjectParser<Value, Context> {\n+    private final Class<Value> valueClass;\n+    private volatile Constructor<Value> constructor;", "originalCommit": "15fbeb37410dcbccb2e5e083fcb2bfe4930e2a0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/InstantiatingObjectParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/InstantiatingObjectParser.java\nindex 67f656a6685..3cb1804ef20 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/InstantiatingObjectParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/InstantiatingObjectParser.java\n\n@@ -25,6 +25,7 @@ import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.util.List;\n import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n import java.util.function.Consumer;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3MDMzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412170339", "bodyText": "It'd be kind of neat to have a test that uses the two-arg ctor or the one arg ctor. And maybe one that sets a member after calling the ctor just for paranoia's sake.", "author": "nik9000", "createdAt": "2020-04-21T13:10:31Z", "path": "libs/x-content/src/test/java/org/elasticsearch/common/xcontent/InstantiatingObjectParserTests.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.xcontent;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class InstantiatingObjectParserTests extends ESTestCase {\n+\n+    public static class NoAnnotations {\n+        final int a;\n+        final String b;\n+        final long c;\n+\n+        public NoAnnotations() {\n+            this(1, \"2\", 3);\n+        }\n+\n+        private NoAnnotations(int a) {\n+            this(a, \"2\", 3);\n+        }\n+\n+        public NoAnnotations(int a, String b) {\n+            this(a, b, 3);\n+        }\n+\n+        public NoAnnotations(int a, long c) {\n+            this(a, \"2\", c);\n+        }\n+\n+        public NoAnnotations(int a, String b, long c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            NoAnnotations that = (NoAnnotations) o;\n+            return a == that.a &&\n+                c == that.c &&\n+                Objects.equals(b, that.b);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(a, b, c);\n+        }\n+    }\n+\n+    public void testNoAnnotation() throws IOException {\n+        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n+        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n+        parser.declareString(constructorArg(), new ParseField(\"b\"));\n+        parser.declareLong(constructorArg(), new ParseField(\"c\"));\n+        parser.finalizeFields();", "originalCommit": "15fbeb37410dcbccb2e5e083fcb2bfe4930e2a0a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "chunk": "diff --git a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/InstantiatingObjectParserTests.java b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/InstantiatingObjectParserTests.java\nindex 898e8d09fc5..0ab46612095 100644\n--- a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/InstantiatingObjectParserTests.java\n+++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/InstantiatingObjectParserTests.java\n\n@@ -76,51 +76,94 @@ public class InstantiatingObjectParserTests extends ESTestCase {\n     }\n \n     public void testNoAnnotation() throws IOException {\n-        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n-        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n-        parser.declareString(constructorArg(), new ParseField(\"b\"));\n-        parser.declareLong(constructorArg(), new ParseField(\"c\"));\n-        parser.finalizeFields();\n+        InstantiatingObjectParser.Builder<NoAnnotations, Void> builder = InstantiatingObjectParser.builder(\"foo\", NoAnnotations.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        builder.declareString(constructorArg(), new ParseField(\"b\"));\n+        builder.declareLong(constructorArg(), new ParseField(\"c\"));\n+        InstantiatingObjectParser<NoAnnotations, Void> parser = builder.build();\n         try (XContentParser contentParser = createParser(JsonXContent.jsonXContent, \"{\\\"a\\\": 5, \\\"b\\\":\\\"6\\\", \\\"c\\\": 7 }\")) {\n             assertThat(parser.parse(contentParser, null), equalTo(new NoAnnotations(5, \"6\", 7)));\n         }\n     }\n \n     public void testNoAnnotationWrongArgumentNumber() {\n-        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n-        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n-        parser.declareString(constructorArg(), new ParseField(\"b\"));\n-        parser.declareLong(constructorArg(), new ParseField(\"c\"));\n-        parser.declareLong(constructorArg(), new ParseField(\"d\"));\n-        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, parser::finalizeFields);\n+        InstantiatingObjectParser.Builder<NoAnnotations, Void> builder = InstantiatingObjectParser.builder(\"foo\", NoAnnotations.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        builder.declareString(constructorArg(), new ParseField(\"b\"));\n+        builder.declareLong(constructorArg(), new ParseField(\"c\"));\n+        builder.declareLong(constructorArg(), new ParseField(\"d\"));\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, builder::build);\n         assertThat(e.getMessage(), containsString(\"No public constructors with 4 parameters exist in the class\"));\n     }\n \n     public void testAmbiguousConstructor() {\n-        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n-        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n-        parser.declareString(constructorArg(), new ParseField(\"b\"));\n-        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, parser::finalizeFields);\n+        InstantiatingObjectParser.Builder<NoAnnotations, Void> builder = InstantiatingObjectParser.builder(\"foo\", NoAnnotations.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        builder.declareString(constructorArg(), new ParseField(\"b\"));\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, builder::build);\n         assertThat(e.getMessage(), containsString(\n             \"More then one public constructor with 2 arguments found. The use of @ParserConstructor annotation is required\"\n         ));\n     }\n \n     public void testPrivateConstructor() {\n-        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n-        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n-        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, parser::finalizeFields);\n+        InstantiatingObjectParser.Builder<NoAnnotations, Void> builder = InstantiatingObjectParser.builder(\"foo\", NoAnnotations.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, builder::build);\n         assertThat(e.getMessage(), containsString(\"No public constructors with 1 parameters exist in the class \"));\n     }\n \n-    public void testNonFinalizedParsing() throws IOException {\n-        InstantiatingObjectParser<NoAnnotations, Void> parser = new InstantiatingObjectParser<>(\"foo\", NoAnnotations.class);\n-        parser.declareInt(constructorArg(), new ParseField(\"a\"));\n-        parser.declareString(constructorArg(), new ParseField(\"b\"));\n-        parser.declareLong(constructorArg(), new ParseField(\"c\"));\n-        try (XContentParser contentParser = createParser(JsonXContent.jsonXContent, \"{\\\"a\\\": 5, \\\"b\\\":\\\"6\\\", \\\"c\\\": 7}\")) {\n-            IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parser.parse(contentParser, null));\n-            assertThat(e.getMessage(), containsString(\"wasn't finalized\"));\n+    public static class LonelyArgument {\n+        public final int a;\n+\n+        private String b;\n+\n+        public LonelyArgument(int a) {\n+            this.a = a;\n+            this.b = \"Not set\";\n+        }\n+\n+        public void setB(String b) {\n+            this.b = b;\n+        }\n+\n+        public String getB() {\n+            return b;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            LonelyArgument that = (LonelyArgument) o;\n+            return a == that.a &&\n+                Objects.equals(b, that.b);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(a, b);\n+        }\n+    }\n+\n+    public void testOneArgConstructor() throws IOException {\n+        InstantiatingObjectParser.Builder<LonelyArgument, Void> builder = InstantiatingObjectParser.builder(\"foo\", LonelyArgument.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        InstantiatingObjectParser<LonelyArgument, Void> parser = builder.build();\n+        try (XContentParser contentParser = createParser(JsonXContent.jsonXContent, \"{\\\"a\\\": 5 }\")) {\n+            assertThat(parser.parse(contentParser, null), equalTo(new LonelyArgument(5)));\n+        }\n+    }\n+\n+    public void testSetNonConstructor() throws IOException {\n+        InstantiatingObjectParser.Builder<LonelyArgument, Void> builder = InstantiatingObjectParser.builder(\"foo\", LonelyArgument.class);\n+        builder.declareInt(constructorArg(), new ParseField(\"a\"));\n+        builder.declareString(LonelyArgument::setB, new ParseField(\"b\"));\n+        InstantiatingObjectParser<LonelyArgument, Void> parser = builder.build();\n+        try (XContentParser contentParser = createParser(JsonXContent.jsonXContent, \"{\\\"a\\\": 5, \\\"b\\\": \\\"set\\\" }\")) {\n+            LonelyArgument expected = parser.parse(contentParser, null);\n+            assertThat(expected.a, equalTo(5));\n+            assertThat(expected.b, equalTo(\"set\"));\n         }\n     }\n \n"}}, {"oid": "c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "url": "https://github.com/elastic/elasticsearch/commit/c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "message": "Address review comments", "committedDate": "2020-04-21T15:13:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMDcwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412420700", "bodyText": "Maybe call it parser? I don't feel too bad doing things like that because when it is built it become PARSER.", "author": "nik9000", "createdAt": "2020-04-21T19:10:55Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskResult.java", "diffHunk": "@@ -174,21 +174,17 @@ public XContentBuilder innerToXContent(XContentBuilder builder, Params params) t\n         return builder;\n     }\n \n-    public static final ConstructingObjectParser<TaskResult, Void> PARSER = new ConstructingObjectParser<>(\n-            \"stored_task_result\", a -> {\n-                int i = 0;\n-                boolean completed = (boolean) a[i++];\n-                TaskInfo task = (TaskInfo) a[i++];\n-                BytesReference error = (BytesReference) a[i++];\n-                BytesReference response = (BytesReference) a[i++];\n-                return new TaskResult(completed, task, error, response);\n-            });\n+    public static final InstantiatingObjectParser<TaskResult, Void> PARSER;\n+\n     static {\n-        PARSER.declareBoolean(constructorArg(), new ParseField(\"completed\"));\n-        PARSER.declareObject(constructorArg(), TaskInfo.PARSER, new ParseField(\"task\"));\n+        InstantiatingObjectParser.Builder<TaskResult, Void> builder = InstantiatingObjectParser.builder(", "originalCommit": "c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e9a16103ab0a00b285e075ddf9f11ec2855ad1c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskResult.java b/server/src/main/java/org/elasticsearch/tasks/TaskResult.java\nindex c39f98379f4..b2cf9c224b6 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskResult.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskResult.java\n\n@@ -177,14 +177,14 @@ public final class TaskResult implements Writeable, ToXContentObject {\n     public static final InstantiatingObjectParser<TaskResult, Void> PARSER;\n \n     static {\n-        InstantiatingObjectParser.Builder<TaskResult, Void> builder = InstantiatingObjectParser.builder(\n+        InstantiatingObjectParser.Builder<TaskResult, Void> parser = InstantiatingObjectParser.builder(\n             \"stored_task_result\", true, TaskResult.class);\n-        builder.declareBoolean(constructorArg(), new ParseField(\"completed\"));\n-        builder.declareObject(constructorArg(), TaskInfo.PARSER, new ParseField(\"task\"));\n+        parser.declareBoolean(constructorArg(), new ParseField(\"completed\"));\n+        parser.declareObject(constructorArg(), TaskInfo.PARSER, new ParseField(\"task\"));\n         ObjectParserHelper<TaskResult, Void> parserHelper = new ObjectParserHelper<>();\n-        parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"error\"));\n-        parserHelper.declareRawObject(builder, optionalConstructorArg(), new ParseField(\"response\"));\n-        PARSER = builder.build();\n+        parserHelper.declareRawObject(parser, optionalConstructorArg(), new ParseField(\"error\"));\n+        parserHelper.declareRawObject(parser, optionalConstructorArg(), new ParseField(\"response\"));\n+        PARSER = parser.build();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMDkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412420902", "bodyText": "Can this stay private?", "author": "nik9000", "createdAt": "2020-04-21T19:11:10Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskResult.java", "diffHunk": "@@ -79,7 +79,7 @@ public TaskResult(TaskInfo task, ToXContent response) throws IOException {\n         this(true, task, null, XContentHelper.toXContent(response, Requests.INDEX_CONTENT_TYPE, true));\n     }\n \n-    private TaskResult(boolean completed, TaskInfo task, @Nullable BytesReference error, @Nullable BytesReference result) {\n+    public TaskResult(boolean completed, TaskInfo task, @Nullable BytesReference error, @Nullable BytesReference result) {", "originalCommit": "c19f6da14f10397369b4f3e1c7f071aa18b2a14d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3OTk1NA==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412479954", "bodyText": "I don't know how to do it without making security manager upset.", "author": "imotov", "createdAt": "2020-04-21T20:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMDkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyNDQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55483#discussion_r412524466", "bodyText": "Oh! Because you can't making an explicit reference to the ctor, you are digging the ctor from the public reflection information. Got it! Ignore this comment.", "author": "nik9000", "createdAt": "2020-04-21T22:06:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMDkwMg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "8e9a16103ab0a00b285e075ddf9f11ec2855ad1c", "url": "https://github.com/elastic/elasticsearch/commit/8e9a16103ab0a00b285e075ddf9f11ec2855ad1c", "message": "builder -> parser", "committedDate": "2020-04-22T12:08:58Z", "type": "commit"}, {"oid": "80fa4cd5e4040c91830d6fc251710a5f45751772", "url": "https://github.com/elastic/elasticsearch/commit/80fa4cd5e4040c91830d6fc251710a5f45751772", "message": "Merge remote-tracking branch 'elastic/master' into issue-52499-new-instance", "committedDate": "2020-04-22T12:09:24Z", "type": "commit"}]}