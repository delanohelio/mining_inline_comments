{"pr_number": 50868, "pr_title": "Fix SLM check for restore in progress", "pr_createdAt": "2020-01-10T18:28:33Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50868", "timeline": [{"oid": "bf6e8fdddb978bfed9b7c9a6147efaab4547fd90", "url": "https://github.com/elastic/elasticsearch/commit/bf6e8fdddb978bfed9b7c9a6147efaab4547fd90", "message": "Fix SLM check for restore in progress\n\nThis commit fixes the check in SLM where the `RestoreInProgress`\nmetadata was checked for existence. Rather than check existence we\nshould instead check the `isEmpty` method. Prior to this, a successful\nrestore for a repository that used SLM retention would prevent SLM\nretention from running in subsequent invocations, due to SLM thinking\nthat a restore was still running.", "committedDate": "2020-01-10T18:27:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3Mjk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50868#discussion_r365372995", "bodyText": "Don't need to block this PR on it, but we should check if this hack is still necessary.", "author": "gwbrown", "createdAt": "2020-01-10T18:37:03Z", "path": "x-pack/plugin/ilm/src/test/java/org/elasticsearch/xpack/slm/SLMSnapshotBlockingIntegTests.java", "diffHunk": "@@ -385,6 +390,74 @@ private void testUnsuccessfulSnapshotRetention(boolean partialSuccess) throws Ex\n         }\n     }\n \n+    public void testSLMRetentionAfterRestore() throws Exception {\n+        final String indexName = \"test\";\n+        final String policyName = \"test-policy\";\n+        int docCount = 20;\n+        for (int i = 0; i < docCount; i++) {\n+            index(indexName, i + \"\", Collections.singletonMap(\"foo\", \"bar\"));\n+        }\n+\n+        // Create a snapshot repo\n+        initializeRepo(REPO);\n+\n+        logger.info(\"--> creating policy {}\", policyName);\n+        createSnapshotPolicy(policyName, \"snap\", NEVER_EXECUTE_CRON_SCHEDULE, REPO, indexName, true, false,\n+            new SnapshotRetentionConfiguration(TimeValue.ZERO, null, null));\n+\n+        logger.info(\"--> executing snapshot lifecycle\");\n+        final String snapshotName = executePolicy(policyName);\n+\n+        // Check that the executed snapshot shows up in the SLM output\n+        assertBusy(() -> {\n+            GetSnapshotLifecycleAction.Response getResp =\n+                client().execute(GetSnapshotLifecycleAction.INSTANCE, new GetSnapshotLifecycleAction.Request(policyName)).get();\n+            logger.info(\"--> checking for in progress snapshot...\");\n+\n+            assertThat(getResp.getPolicies().size(), greaterThan(0));\n+            SnapshotLifecyclePolicyItem item = getResp.getPolicies().get(0);\n+            SnapshotInvocationRecord lastSuccess = item.getLastSuccess();\n+            assertNotNull(lastSuccess);\n+            assertThat(lastSuccess.getSnapshotName(), equalTo(snapshotName));\n+        });\n+\n+        logger.info(\"--> restoring index\");\n+        RestoreSnapshotRequest restoreReq = new RestoreSnapshotRequest(REPO, snapshotName);\n+        restoreReq.indices(indexName);\n+        restoreReq.renamePattern(\"(.+)\");\n+        restoreReq.renameReplacement(\"restored_$1\");\n+        restoreReq.waitForCompletion(true);\n+        RestoreSnapshotResponse resp = client().execute(RestoreSnapshotAction.INSTANCE, restoreReq).get();\n+        assertThat(resp.status(), equalTo(RestStatus.OK));\n+\n+        logger.info(\"--> executing SLM retention\");\n+        assertAcked(client().execute(ExecuteSnapshotRetentionAction.INSTANCE, new ExecuteSnapshotRetentionAction.Request()).get());\n+        logger.info(\"--> waiting for {} snapshot to be deleted\", snapshotName);\n+        assertBusy(() -> {\n+            try {\n+                try {\n+                    GetSnapshotsResponse snapshotsStatusResponse = client().admin().cluster()\n+                        .prepareGetSnapshots(REPO).setSnapshots(snapshotName).get();\n+                    assertThat(snapshotsStatusResponse.getSnapshots(REPO), empty());\n+                } catch (SnapshotMissingException e) {\n+                    // This is what we want to happen\n+                }\n+                logger.info(\"--> snapshot [{}] has been deleted\", snapshotName);\n+            } catch (RepositoryException re) {\n+                // Concurrent status calls and write operations may lead to failures in determining the current repository generation\n+                // TODO: Remove this hack once tracking the current repository generation has been made consistent", "originalCommit": "bf6e8fdddb978bfed9b7c9a6147efaab4547fd90", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "616e2bbe4dd74cec8bb671683d4f83efaf5c3f4b", "url": "https://github.com/elastic/elasticsearch/commit/616e2bbe4dd74cec8bb671683d4f83efaf5c3f4b", "message": "Add additional unit test", "committedDate": "2020-01-10T19:50:20Z", "type": "commit"}]}