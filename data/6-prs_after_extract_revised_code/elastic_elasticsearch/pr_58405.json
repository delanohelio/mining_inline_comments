{"pr_number": 58405, "pr_title": "Remove anonymous PublicationContext implementation", "pr_createdAt": "2020-06-23T07:08:29Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58405", "timeline": [{"oid": "2f33afbebe7bb774afbca40cc91485d15ca9197f", "url": "https://github.com/elastic/elasticsearch/commit/2f33afbebe7bb774afbca40cc91485d15ca9197f", "message": "Remove anonymous PublicationContext implementation\n\nToday the `PublicationContext` interface has a single anonymous\nimplementation, and `PublicationTransportHandler` has various methods\nthat take the variables that this anonymous class captures. This commit\nrefactors this into a proper class with proper fields and moves the\nrelevant methods onto this class.", "committedDate": "2020-06-23T07:07:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007278", "bodyText": "Reworded comment", "author": "DaveCTurner", "createdAt": "2020-06-23T07:09:08Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.", "originalCommit": "2f33afbebe7bb774afbca40cc91485d15ca9197f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzQyOA==", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007428", "bodyText": "Added a TRACE log to record the size of the state here.", "author": "DaveCTurner", "createdAt": "2020-06-23T07:09:26Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.\n+        publicationContext.buildDiffAndSerializeStates();\n+        return publicationContext;\n+    }\n+\n+    private static BytesReference serializeFullClusterState(ClusterState clusterState, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(true);\n+            clusterState.writeTo(stream);\n+        }\n+        final BytesReference serializedState = bStream.bytes();\n+        logger.trace(\"serialized full cluster state version [{}] for node version [{}] with size [{}]\",", "originalCommit": "2f33afbebe7bb774afbca40cc91485d15ca9197f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwNzQ4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/58405#discussion_r444007485", "bodyText": "Added a TRACE log to record the size of the state here.", "author": "DaveCTurner", "createdAt": "2020-06-23T07:09:35Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PublicationTransportHandler.java", "diffHunk": "@@ -406,4 +198,216 @@ private PublishWithJoinResponse acceptState(ClusterState incomingState) {\n         }\n         return handlePublishRequest.apply(new PublishRequest(incomingState));\n     }\n+\n+    public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+        final PublicationContext publicationContext = new PublicationContext(clusterChangedEvent);\n+\n+        // Build the serializations we expect to need now, early in the process, so that an error during serialization fails the publication\n+        // straight away. This isn't watertight since we send diffs on a best-effort basis and may fall back to sending a full state (and\n+        // therefore serializing it) if the diff-based publication fails.\n+        publicationContext.buildDiffAndSerializeStates();\n+        return publicationContext;\n+    }\n+\n+    private static BytesReference serializeFullClusterState(ClusterState clusterState, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(true);\n+            clusterState.writeTo(stream);\n+        }\n+        final BytesReference serializedState = bStream.bytes();\n+        logger.trace(\"serialized full cluster state version [{}] for node version [{}] with size [{}]\",\n+            clusterState.version(), nodeVersion, serializedState.length());\n+        return serializedState;\n+    }\n+\n+    private static BytesReference serializeDiffClusterState(Diff<ClusterState> diff, Version nodeVersion) throws IOException {\n+        final BytesStreamOutput bStream = new BytesStreamOutput();\n+        try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {\n+            stream.setVersion(nodeVersion);\n+            stream.writeBoolean(false);\n+            diff.writeTo(stream);\n+        }\n+        return bStream.bytes();\n+    }\n+\n+    /**\n+     * Publishing a cluster state typically involves sending the same cluster state (or diff) to every node, so the work of diffing,\n+     * serializing, and compressing the state can be done once and the results shared across publish requests. The\n+     * {@code PublicationContext} implements this sharing.\n+     */\n+    public class PublicationContext {\n+\n+        private final DiscoveryNodes discoveryNodes;\n+        private final ClusterState newState;\n+        private final ClusterState previousState;\n+        private final boolean sendFullVersion;\n+        private final Map<Version, BytesReference> serializedStates = new HashMap<>();\n+        private final Map<Version, BytesReference> serializedDiffs = new HashMap<>();\n+\n+        PublicationContext(ClusterChangedEvent clusterChangedEvent) {\n+            discoveryNodes = clusterChangedEvent.state().nodes();\n+            newState = clusterChangedEvent.state();\n+            previousState = clusterChangedEvent.previousState();\n+            sendFullVersion = previousState.getBlocks().disableStatePersistence();\n+        }\n+\n+        void buildDiffAndSerializeStates() {\n+            Diff<ClusterState> diff = null;\n+            for (DiscoveryNode node : discoveryNodes) {\n+                try {\n+                    if (sendFullVersion || previousState.nodes().nodeExists(node) == false) {\n+                        if (serializedStates.containsKey(node.getVersion()) == false) {\n+                            serializedStates.put(node.getVersion(), serializeFullClusterState(newState, node.getVersion()));\n+                        }\n+                    } else {\n+                        // will send a diff\n+                        if (diff == null) {\n+                            diff = newState.diff(previousState);\n+                        }\n+                        if (serializedDiffs.containsKey(node.getVersion()) == false) {\n+                            final BytesReference serializedDiff = serializeDiffClusterState(diff, node.getVersion());\n+                            serializedDiffs.put(node.getVersion(), serializedDiff);\n+                            logger.trace(\"serialized cluster state diff for version [{}] in for node version [{}] with size [{}]\",", "originalCommit": "2f33afbebe7bb774afbca40cc91485d15ca9197f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "cdf58064dbe9d621af736ac72f08976f7c316319", "url": "https://github.com/elastic/elasticsearch/commit/cdf58064dbe9d621af736ac72f08976f7c316319", "message": "Merge branch 'master' into 2020-06-22-tidy-PublicationTransportHandler", "committedDate": "2020-06-23T07:39:50Z", "type": "commit"}, {"oid": "787a52dfa44d950281b37e2fa8a14cbf131c1dc0", "url": "https://github.com/elastic/elasticsearch/commit/787a52dfa44d950281b37e2fa8a14cbf131c1dc0", "message": "final", "committedDate": "2020-06-23T08:26:08Z", "type": "commit"}]}