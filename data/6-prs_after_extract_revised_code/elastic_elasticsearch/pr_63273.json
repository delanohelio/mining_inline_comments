{"pr_number": 63273, "pr_title": "Check docs limit before indexing on primary", "pr_createdAt": "2020-10-05T17:42:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63273", "timeline": [{"oid": "8451e9613ad8b302eefc9618f25d411a9314af3e", "url": "https://github.com/elastic/elasticsearch/commit/8451e9613ad8b302eefc9618f25d411a9314af3e", "message": "Check docs limit before indexing on primary", "committedDate": "2020-10-05T17:40:31Z", "type": "commit"}, {"oid": "12aaf83f775411b369a0dc504ec04a9d46f868df", "url": "https://github.com/elastic/elasticsearch/commit/12aaf83f775411b369a0dc504ec04a9d46f868df", "message": "unused import", "committedDate": "2020-10-05T18:54:07Z", "type": "commit"}, {"oid": "f5e10be04004d2c735f20a5daf342ce44235cf53", "url": "https://github.com/elastic/elasticsearch/commit/f5e10be04004d2c735f20a5daf342ce44235cf53", "message": "Merge branch 'master' into check-docs-limit-on-primary", "committedDate": "2020-10-06T01:41:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500099869", "bodyText": "I'm wondering why we use a margin of 1000 docs here. IIUC the index writer will only under-count the total by at most one doc per write thread?\nOTOH if there is more severe under-counting under concurrent load then is 1000 enough?", "author": "DaveCTurner", "createdAt": "2020-10-06T08:33:44Z", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -176,6 +176,16 @@\n     private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n+    /**\n+     * If multiple writes passed {@link InternalEngine#testReserveDocs(Operation, int)} (int)} but haven't adjusted\n+     * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case,\n+     * we have to fail the engine because we already generated sequence numbers for write operations; otherwise we\n+     * will have gaps in sequence numbers. To avoid this (best-effort), we use a lower limit when trying to reserve\n+     * documents in InternalEngine.\n+     */\n+    static final int DEFAULT_MAX_DOCS = IndexWriter.MAX_DOCS - 1000;", "originalCommit": "f5e10be04004d2c735f20a5daf342ce44235cf53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI0MDgyNg==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500240826", "bodyText": "IIUC the index writer will only under-count the total by at most one doc per write thread?\n\nYes, but IW can under-count more than one with nested documents.\n\nOTOH if there is more severe under-counting under concurrent load then is 1000 enough?\n\nI think 1000 is enough because all writes should execute using the WRITE thread pool, which has no more threads than the number of cores. Do you have a suggestion for this?", "author": "dnhatn", "createdAt": "2020-10-06T12:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1MDY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500250661", "bodyText": "Ah darn it yes, nested docs strike again. In which case I don't think 1000 is enough for all users. Can we instead acquire a proper reservation for the right number of docs in testReserveDocs (e.g. using a Semaphore) and then release them once they're tracked by the IndexWriter?", "author": "DaveCTurner", "createdAt": "2020-10-06T12:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4Mzk4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500383987", "bodyText": "That would lead to double counting as adding documents will be counted twice in InternalEngine and IndexWriter. But I think that's okay if we want to make this check more watertight (than the current best-effort). I can make that change. WDYT?", "author": "dnhatn", "createdAt": "2020-10-06T15:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1NzYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500457618", "bodyText": "Yes, it'd mean some temporary double-counting so that we potentially reject some docs when we get very close to the limit, and then accept some more docs, but I think that's ok. We have that behaviour anyway today because after a merge the doc count may decrease permitting some more docs to be indexed.", "author": "DaveCTurner", "createdAt": "2020-10-06T17:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5Mjc4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501092783", "bodyText": "Adjusted in efa8145", "author": "dnhatn", "createdAt": "2020-10-07T15:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA5OTg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nindex 910e85e69b4..f6655d37b2f 100644\n--- a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n\n@@ -177,13 +177,16 @@ public class InternalEngine extends Engine {\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n     /**\n-     * If multiple writes passed {@link InternalEngine#testReserveDocs(Operation, int)} (int)} but haven't adjusted\n+     * If multiple writes passed {@link InternalEngine#tryReserveDocs(Operation, int)} but they haven't adjusted\n      * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case,\n      * we have to fail the engine because we already generated sequence numbers for write operations; otherwise we\n-     * will have gaps in sequence numbers. To avoid this (best-effort), we use a lower limit when trying to reserve\n-     * documents in InternalEngine.\n+     * will have gaps in sequence numbers. To avoid this, we keep track the number of documents that are being added\n+     * to IndexWriter, and account it in {@link InternalEngine#tryReserveDocs(Operation, int)}. Although we can double\n+     * count some adding documents twice (in both IW and Engine), this shouldn't be an issue because it should happen\n+     * for a short window and we adjust the reservingNumDocs once an indexing is completed.\n      */\n-    static final int DEFAULT_MAX_DOCS = IndexWriter.MAX_DOCS - 1000;\n+    private final AtomicLong reservingNumDocs = new AtomicLong();\n+\n     private final int maxDocs;\n \n     @Nullable\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMDYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500100614", "bodyText": "Could we run this test (or a similar one) with concurrent indexing too, to demonstrate that we only exceed the limit by a bounded amount?", "author": "DaveCTurner", "createdAt": "2020-10-06T08:35:01Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.engine;\n+\n+import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.plugins.EnginePlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class MaxDocsLimitIT extends ESIntegTestCase {\n+\n+    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n+        public static final int maxDocs = randomIntBetween(1, 20);\n+\n+        @Override\n+        public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n+            return Optional.of(config -> EngineTestCase.createEngine(config, maxDocs));\n+        }\n+    }\n+\n+    @Override\n+    protected boolean addMockInternalEngine() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(TestEnginePlugin.class);\n+        return plugins;\n+    }\n+\n+    public void testMaxDocsLimit() throws Exception {\n+        final int maxDocs = TestEnginePlugin.maxDocs;\n+        IndexWriterMaxDocsChanger.setMaxDocs(maxDocs);\n+        try {\n+            internalCluster().ensureAtLeastNumDataNodes(1);\n+            assertAcked(client().admin().indices().prepareCreate(\"test\")\n+                .setSettings(Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+                    .put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.REQUEST)));\n+            int numDocs = randomIntBetween(maxDocs + 1, maxDocs * 2);\n+            for (int i = 0; i < numDocs; i++) {", "originalCommit": "f5e10be04004d2c735f20a5daf342ce44235cf53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI0MTA2OA==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r500241068", "bodyText": "++, I will add a new test.", "author": "dnhatn", "createdAt": "2020-10-06T12:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMDYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5MjY3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501092671", "bodyText": "added in efa8145.", "author": "dnhatn", "createdAt": "2020-10-07T15:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMDYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "chunk": "diff --git a/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java b/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\nindex a2b5a2a51f9..ca94884cf2c 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\n\n@@ -20,37 +20,52 @@\n package org.elasticsearch.index.engine;\n \n import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n+import org.apache.lucene.store.AlreadyClosedException;\n import org.elasticsearch.action.index.IndexResponse;\n import org.elasticsearch.action.search.SearchResponse;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexService;\n import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.IndexShardTestCase;\n import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.plugins.EnginePlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.rest.RestStatus;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n \n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.both;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n \n public class MaxDocsLimitIT extends ESIntegTestCase {\n \n-    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n-        public static final int maxDocs = randomIntBetween(1, 20);\n+    private static final AtomicInteger maxDocs = new AtomicInteger();\n \n+    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n         @Override\n         public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n-            return Optional.of(config -> EngineTestCase.createEngine(config, maxDocs));\n+            return Optional.of(config -> {\n+                assert maxDocs.get() > 0 : \"maxDocs is unset\";\n+                return EngineTestCase.createEngine(config, maxDocs.get());\n+            });\n         }\n     }\n \n"}}, {"oid": "efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "url": "https://github.com/elastic/elasticsearch/commit/efa8145303e98c3a1b9f4886691a5cfbd5c548b4", "message": "Keep track reserving docs", "committedDate": "2020-10-07T14:48:57Z", "type": "commit"}, {"oid": "25ee199696d3beda0fed96025e5df5ffb72063b1", "url": "https://github.com/elastic/elasticsearch/commit/25ee199696d3beda0fed96025e5df5ffb72063b1", "message": "Merge branch 'master' into check-docs-limit-on-primary", "committedDate": "2020-10-07T14:51:29Z", "type": "commit"}, {"oid": "a1d7ade6034dd18c94afa2d7d1d68aaa910e7f39", "url": "https://github.com/elastic/elasticsearch/commit/a1d7ade6034dd18c94afa2d7d1d68aaa910e7f39", "message": "wording", "committedDate": "2020-10-07T15:01:09Z", "type": "commit"}, {"oid": "95189c54bf1269c540f16a757d7063821b13fdbe", "url": "https://github.com/elastic/elasticsearch/commit/95189c54bf1269c540f16a757d7063821b13fdbe", "message": "more wording", "committedDate": "2020-10-07T15:05:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501106250", "bodyText": "Can we make this assertion more generally too? IIRC there are some other assertions that check that things have settled down after a test (no in-flight operations, for instance) although I'm not quite sure where they are.", "author": "DaveCTurner", "createdAt": "2020-10-07T15:28:53Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.index.engine;\n+\n+import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n+import org.apache.lucene.store.AlreadyClosedException;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexService;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.IndexShardTestCase;\n+import org.elasticsearch.index.translog.Translog;\n+import org.elasticsearch.indices.IndicesService;\n+import org.elasticsearch.plugins.EnginePlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.hamcrest.ElasticsearchAssertions;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\n+import static org.hamcrest.Matchers.both;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.lessThanOrEqualTo;\n+\n+public class MaxDocsLimitIT extends ESIntegTestCase {\n+\n+    private static final AtomicInteger maxDocs = new AtomicInteger();\n+\n+    public static class TestEnginePlugin extends Plugin implements EnginePlugin {\n+        @Override\n+        public Optional<EngineFactory> getEngineFactory(IndexSettings indexSettings) {\n+            return Optional.of(config -> {\n+                assert maxDocs.get() > 0 : \"maxDocs is unset\";\n+                return EngineTestCase.createEngine(config, maxDocs.get());\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected boolean addMockInternalEngine() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected Collection<Class<? extends Plugin>> nodePlugins() {\n+        List<Class<? extends Plugin>> plugins = new ArrayList<>(super.nodePlugins());\n+        plugins.add(TestEnginePlugin.class);\n+        return plugins;\n+    }\n+\n+    @Before\n+    public void setMaxDocs() {\n+        maxDocs.set(randomIntBetween(10, 100)); // Do not set this too low as we can fail to write the cluster state\n+        IndexWriterMaxDocsChanger.setMaxDocs(maxDocs.get());\n+    }\n+\n+    @After\n+    public void restoreMaxDocs() {\n+        IndexWriterMaxDocsChanger.restoreMaxDocs();\n+    }\n+\n+    public static void assertNoOutstandingReservingDocs() throws Exception {\n+        assertBusy(() -> {\n+            for (IndicesService indicesService : internalCluster().getDataNodeInstances(IndicesService.class)) {\n+                for (IndexService indexService : indicesService) {\n+                    for (IndexShard indexShard : indexService) {\n+                        try {\n+                            assertThat(EngineTestCase.getReservingDocs(IndexShardTestCase.getEngine(indexShard)), equalTo(0L));", "originalCommit": "95189c54bf1269c540f16a757d7063821b13fdbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0Mjg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501142872", "bodyText": "This assertion should be very lightweight. I added it in 290806d.", "author": "dnhatn", "createdAt": "2020-10-07T16:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNjI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "290806d102a5f63ecd2af1476ba0fffb360ffc77", "chunk": "diff --git a/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java b/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\nindex ca94884cf2c..700e1488cf6 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/index/engine/MaxDocsLimitIT.java\n\n@@ -20,19 +20,14 @@\n package org.elasticsearch.index.engine;\n \n import org.apache.lucene.index.IndexWriterMaxDocsChanger;\n-import org.apache.lucene.store.AlreadyClosedException;\n import org.elasticsearch.action.index.IndexResponse;\n import org.elasticsearch.action.search.SearchResponse;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.xcontent.XContentType;\n-import org.elasticsearch.index.IndexService;\n import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.query.MatchAllQueryBuilder;\n-import org.elasticsearch.index.shard.IndexShard;\n-import org.elasticsearch.index.shard.IndexShardTestCase;\n import org.elasticsearch.index.translog.Translog;\n-import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.plugins.EnginePlugin;\n import org.elasticsearch.plugins.Plugin;\n import org.elasticsearch.rest.RestStatus;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNzY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501107693", "bodyText": "Naming nit: reserved feels rather too general a term for me, how would you feel about renaming this something like inFlightDocCount instead?", "author": "DaveCTurner", "createdAt": "2020-10-07T15:30:39Z", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -176,6 +176,18 @@\n     private final KeyedLock<Long> noOpKeyedLock = new KeyedLock<>();\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n+    /**\n+     * If multiple writes passed {@link InternalEngine#tryReserveDocs(Operation, int)} but they haven't adjusted\n+     * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case, we have to fail\n+     * the engine because we already generated sequence numbers for write operations; otherwise we will have gaps in sequence numbers.\n+     * To avoid this, we keep track the number of documents that are being added to IndexWriter, and account it in\n+     * {@link InternalEngine#tryReserveDocs(Operation, int)}. Although we can double count some adding documents in both IW and Engine,\n+     * this shouldn't be an issue because it happens for a short window and we adjust the reservingNumDocs once an indexing is completed.\n+     */\n+    private final AtomicLong reservingNumDocs = new AtomicLong();", "originalCommit": "95189c54bf1269c540f16a757d7063821b13fdbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MjQzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501142431", "bodyText": "++", "author": "dnhatn", "createdAt": "2020-10-07T16:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "294fcb478194df3b0ab9f659e42a9946ad5ab519", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nindex 9c8b36974fe..2e4fc7b340c 100644\n--- a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n\n@@ -177,14 +177,14 @@ public class InternalEngine extends Engine {\n     private final AtomicBoolean shouldPeriodicallyFlushAfterBigMerge = new AtomicBoolean(false);\n \n     /**\n-     * If multiple writes passed {@link InternalEngine#tryReserveDocs(Operation, int)} but they haven't adjusted\n+     * If multiple writes passed {@link InternalEngine#tryAcquireInFlightDocs(Operation, int)} but they haven't adjusted\n      * {@link IndexWriter#getPendingNumDocs()} yet, then IndexWriter can fail with too many documents. In this case, we have to fail\n      * the engine because we already generated sequence numbers for write operations; otherwise we will have gaps in sequence numbers.\n      * To avoid this, we keep track the number of documents that are being added to IndexWriter, and account it in\n-     * {@link InternalEngine#tryReserveDocs(Operation, int)}. Although we can double count some adding documents in both IW and Engine,\n-     * this shouldn't be an issue because it happens for a short window and we adjust the reservingNumDocs once an indexing is completed.\n+     * {@link InternalEngine#tryAcquireInFlightDocs(Operation, int)}. Although we can double count some adding documents in both IW and Engine,\n+     * this shouldn't be an issue because it happens for a short window and we adjust the inFlightDocCount once an indexing is completed.\n      */\n-    private final AtomicLong reservingNumDocs = new AtomicLong();\n+    private final AtomicLong inFlightDocCount = new AtomicLong();\n \n     private final int maxDocs;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTE0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501109147", "bodyText": "Since we only ever use this to release the docs, how about renaming this to something like releaseInFlightDocs  and accepting a positive parameter instead?", "author": "DaveCTurner", "createdAt": "2020-10-07T15:32:45Z", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -1275,11 +1308,35 @@ public DeleteResult delete(Delete delete) throws IOException {\n                 e.addSuppressed(inner);\n             }\n             throw e;\n+        } finally {\n+            adjustReservingDocs(-reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n+    private Exception tryReserveDocs(Operation operation, int addingDocs) {\n+        assert operation.origin() == Operation.Origin.PRIMARY : operation;\n+        assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO : operation;\n+        final long totalDocs = indexWriter.getPendingNumDocs() + reservingNumDocs.addAndGet(addingDocs);\n+        if (totalDocs > maxDocs) {\n+            adjustReservingDocs(-addingDocs);\n+            return new IllegalArgumentException(\"Number of documents in the index can't exceed [\" + maxDocs + \"]\");\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private void adjustReservingDocs(int numDocs) {\n+        assert numDocs <= 0 : numDocs;", "originalCommit": "95189c54bf1269c540f16a757d7063821b13fdbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MjM1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501142355", "bodyText": "Good suggestion. I pushed 294fcb4.", "author": "dnhatn", "createdAt": "2020-10-07T16:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "294fcb478194df3b0ab9f659e42a9946ad5ab519", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nindex 9c8b36974fe..2e4fc7b340c 100644\n--- a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n\n@@ -1309,32 +1309,33 @@ public class InternalEngine extends Engine {\n             }\n             throw e;\n         } finally {\n-            adjustReservingDocs(-reservedDocs);\n+            releaseInFlightDocs(reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n-    private Exception tryReserveDocs(Operation operation, int addingDocs) {\n+    private Exception tryAcquireInFlightDocs(Operation operation, int addingDocs) {\n         assert operation.origin() == Operation.Origin.PRIMARY : operation;\n         assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO : operation;\n-        final long totalDocs = indexWriter.getPendingNumDocs() + reservingNumDocs.addAndGet(addingDocs);\n+        assert addingDocs > 0 : addingDocs;\n+        final long totalDocs = indexWriter.getPendingNumDocs() + inFlightDocCount.addAndGet(addingDocs);\n         if (totalDocs > maxDocs) {\n-            adjustReservingDocs(-addingDocs);\n+            releaseInFlightDocs(addingDocs);\n             return new IllegalArgumentException(\"Number of documents in the index can't exceed [\" + maxDocs + \"]\");\n         } else {\n             return null;\n         }\n     }\n \n-    private void adjustReservingDocs(int numDocs) {\n-        assert numDocs <= 0 : numDocs;\n-        final long newValue = reservingNumDocs.addAndGet(numDocs);\n-        assert newValue >= 0 : \"reservingNumDocs must not be negative [\" + newValue + \"]\";\n+    private void releaseInFlightDocs(int numDocs) {\n+        assert numDocs >= 0 : numDocs;\n+        final long newValue = inFlightDocCount.addAndGet(-numDocs);\n+        assert newValue >= 0 : \"inFlightDocCount must not be negative [\" + newValue + \"]\";\n     }\n \n-    long getReservingNumDocs() {\n-        return reservingNumDocs.get();\n+    long getInFlightDocCount() {\n+        return inFlightDocCount.get();\n     }\n \n     protected DeletionStrategy deletionStrategyForOperation(final Delete delete) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTQ3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501109476", "bodyText": "Contrasting with releaseInFlightDocs how about tryAcquireInFlightDocs?", "author": "DaveCTurner", "createdAt": "2020-10-07T15:33:13Z", "path": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java", "diffHunk": "@@ -1275,11 +1308,35 @@ public DeleteResult delete(Delete delete) throws IOException {\n                 e.addSuppressed(inner);\n             }\n             throw e;\n+        } finally {\n+            adjustReservingDocs(-reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n+    private Exception tryReserveDocs(Operation operation, int addingDocs) {", "originalCommit": "95189c54bf1269c540f16a757d7063821b13fdbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MjU1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63273#discussion_r501142556", "bodyText": "Ok, see 294fcb4", "author": "dnhatn", "createdAt": "2020-10-07T16:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "294fcb478194df3b0ab9f659e42a9946ad5ab519", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\nindex 9c8b36974fe..2e4fc7b340c 100644\n--- a/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n+++ b/server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java\n\n@@ -1309,32 +1309,33 @@ public class InternalEngine extends Engine {\n             }\n             throw e;\n         } finally {\n-            adjustReservingDocs(-reservedDocs);\n+            releaseInFlightDocs(reservedDocs);\n         }\n         maybePruneDeletes();\n         return deleteResult;\n     }\n \n-    private Exception tryReserveDocs(Operation operation, int addingDocs) {\n+    private Exception tryAcquireInFlightDocs(Operation operation, int addingDocs) {\n         assert operation.origin() == Operation.Origin.PRIMARY : operation;\n         assert operation.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO : operation;\n-        final long totalDocs = indexWriter.getPendingNumDocs() + reservingNumDocs.addAndGet(addingDocs);\n+        assert addingDocs > 0 : addingDocs;\n+        final long totalDocs = indexWriter.getPendingNumDocs() + inFlightDocCount.addAndGet(addingDocs);\n         if (totalDocs > maxDocs) {\n-            adjustReservingDocs(-addingDocs);\n+            releaseInFlightDocs(addingDocs);\n             return new IllegalArgumentException(\"Number of documents in the index can't exceed [\" + maxDocs + \"]\");\n         } else {\n             return null;\n         }\n     }\n \n-    private void adjustReservingDocs(int numDocs) {\n-        assert numDocs <= 0 : numDocs;\n-        final long newValue = reservingNumDocs.addAndGet(numDocs);\n-        assert newValue >= 0 : \"reservingNumDocs must not be negative [\" + newValue + \"]\";\n+    private void releaseInFlightDocs(int numDocs) {\n+        assert numDocs >= 0 : numDocs;\n+        final long newValue = inFlightDocCount.addAndGet(-numDocs);\n+        assert newValue >= 0 : \"inFlightDocCount must not be negative [\" + newValue + \"]\";\n     }\n \n-    long getReservingNumDocs() {\n-        return reservingNumDocs.get();\n+    long getInFlightDocCount() {\n+        return inFlightDocCount.get();\n     }\n \n     protected DeletionStrategy deletionStrategyForOperation(final Delete delete) throws IOException {\n"}}, {"oid": "294fcb478194df3b0ab9f659e42a9946ad5ab519", "url": "https://github.com/elastic/elasticsearch/commit/294fcb478194df3b0ab9f659e42a9946ad5ab519", "message": "Naming", "committedDate": "2020-10-07T16:02:06Z", "type": "commit"}, {"oid": "290806d102a5f63ecd2af1476ba0fffb360ffc77", "url": "https://github.com/elastic/elasticsearch/commit/290806d102a5f63ecd2af1476ba0fffb360ffc77", "message": "Assert after test", "committedDate": "2020-10-07T16:03:21Z", "type": "commit"}, {"oid": "c4f74408057ee81b3fab8cedc2d50a39275da120", "url": "https://github.com/elastic/elasticsearch/commit/c4f74408057ee81b3fab8cedc2d50a39275da120", "message": "line length", "committedDate": "2020-10-07T16:41:21Z", "type": "commit"}]}