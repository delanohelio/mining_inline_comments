{"pr_number": 61442, "pr_title": "Speed up XContent Collection Parsing", "pr_createdAt": "2020-08-22T19:13:28Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61442", "timeline": [{"oid": "e294233dd8aeada42e237953c13a7c13453bf08b", "url": "https://github.com/elastic/elasticsearch/commit/e294233dd8aeada42e237953c13a7c13453bf08b", "message": "bck", "committedDate": "2020-08-22T12:10:25Z", "type": "commit"}, {"oid": "b34636a2d9fa9fbcaad49b362b15f0d1309620b8", "url": "https://github.com/elastic/elasticsearch/commit/b34636a2d9fa9fbcaad49b362b15f0d1309620b8", "message": "Speed up XContent Collection Parsing\n\n1. Get rid of the capturing lambda on the hot path that inlines very badly\n2. Remove as many bounds checks as possible, thereby reducing method size and improving inlining\n3. Return singletons for empty collections instead of eagerly creating potentially redundant empty collections", "committedDate": "2020-08-22T19:09:11Z", "type": "commit"}, {"oid": "44810dbcb0696c66d552343461118e7217b6e507", "url": "https://github.com/elastic/elasticsearch/commit/44810dbcb0696c66d552343461118e7217b6e507", "message": "weird corner case", "committedDate": "2020-08-22T19:40:37Z", "type": "commit"}, {"oid": "d6daddf566740963ea194fd7e7028463e267dbfd", "url": "https://github.com/elastic/elasticsearch/commit/d6daddf566740963ea194fd7e7028463e267dbfd", "message": "ingest ...", "committedDate": "2020-08-22T20:09:05Z", "type": "commit"}, {"oid": "53d9f00d5b52cdc6c0c1b500b6dc5084b73a46c2", "url": "https://github.com/elastic/elasticsearch/commit/53d9f00d5b52cdc6c0c1b500b6dc5084b73a46c2", "message": "weirdness be gone", "committedDate": "2020-08-22T20:15:24Z", "type": "commit"}, {"oid": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02", "url": "https://github.com/elastic/elasticsearch/commit/d3d50cd642c724afda9a4f4d4de6e37f2af2cc02", "message": "even faster", "committedDate": "2020-08-22T22:37:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE4NTM1MA==", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r475185350", "bodyText": "Duplicating this loop here since there's not efficient way of not having either a capturing lambda (and even a non-capturing one might not inline so great) or a strange API here.", "author": "original-brownbear", "createdAt": "2020-08-23T07:39:45Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {", "originalCommit": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r477577217", "bodyText": "If I am not mistaken, this will return true when the parser is already at a field name and I'm not sure that's what we want?\nMaybe the last few lines of this method should be:\n        if (token == XContentParser.Token.START_OBJECT) {\n            return parser.nextToken() == Token.FIELD_NAME;\n        } else {\n            return false;\n        }", "author": "jaymode", "createdAt": "2020-08-26T20:42:43Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/support/AbstractXContentParser.java", "diffHunk": "@@ -263,117 +263,141 @@ public CharBuffer charBufferOrNull() throws IOException {\n \n     @Override\n     public Map<String, Object> map() throws IOException {\n-        return readMap(this);\n+        return readMapSafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, Object> mapOrdered() throws IOException {\n-        return readOrderedMap(this);\n+        return readMapSafe(this, ORDERED_MAP_FACTORY);\n     }\n \n     @Override\n     public Map<String, String> mapStrings() throws IOException {\n-        return readMapStrings(this);\n+        return map(HashMap::new, XContentParser::text);\n     }\n \n     @Override\n     public <T> Map<String, T> map(\n             Supplier<Map<String, T>> mapFactory, CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        return readGenericMap(this, mapFactory, mapValueParser);\n+        final Map<String, T> map = mapFactory.get();\n+        if (findNonEmptyMapStart(this) == false) {\n+            return map;\n+        }\n+        assert currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = currentName();\n+            // And then the value...\n+            nextToken();\n+            T value = mapValueParser.apply(this);\n+            map.put(fieldName, value);\n+        } while (nextToken() == XContentParser.Token.FIELD_NAME);\n+        return map;\n     }\n \n     @Override\n     public List<Object> list() throws IOException {\n-        return readList(this);\n+        skipToListStart(this);\n+        return readListUnsafe(this, SIMPLE_MAP_FACTORY);\n     }\n \n     @Override\n     public List<Object> listOrderedMap() throws IOException {\n-        return readListOrderedMap(this);\n-    }\n-\n-    static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n-\n-    static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n-\n-    static final Supplier<Map<String, String>> SIMPLE_MAP_STRINGS_FACTORY = HashMap::new;\n-\n-    static Map<String, Object> readMap(XContentParser parser) throws IOException {\n-        return readMap(parser, SIMPLE_MAP_FACTORY);\n+        skipToListStart(this);\n+        return readListUnsafe(this, ORDERED_MAP_FACTORY);\n     }\n \n-    static Map<String, Object> readOrderedMap(XContentParser parser) throws IOException {\n-        return readMap(parser, ORDERED_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> SIMPLE_MAP_FACTORY = HashMap::new;\n \n-    static Map<String, String> readMapStrings(XContentParser parser) throws IOException {\n-        return readGenericMap(parser, SIMPLE_MAP_STRINGS_FACTORY, XContentParser::text);\n-    }\n-\n-    static List<Object> readList(XContentParser parser) throws IOException {\n-        return readList(parser, SIMPLE_MAP_FACTORY);\n-    }\n+    private static final Supplier<Map<String, Object>> ORDERED_MAP_FACTORY = LinkedHashMap::new;\n \n-    static List<Object> readListOrderedMap(XContentParser parser) throws IOException {\n-        return readList(parser, ORDERED_MAP_FACTORY);\n+    private static Map<String, Object> readMapSafe(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n+        final Map<String, Object> map = mapFactory.get();\n+        return findNonEmptyMapStart(parser) ? readMapEntries(parser, mapFactory, map) : map;\n     }\n \n-    static Map<String, Object> readMap(XContentParser parser, Supplier<Map<String, Object>> mapFactory) throws IOException {\n-        return readGenericMap(parser, mapFactory, p -> readValue(p, mapFactory));\n+    // Read a map without bounds checks from a parser that is assumed to be at the map's first field's name token\n+    private static Map<String, Object> readMapEntries(XContentParser parser, Supplier<Map<String, Object>> mapFactory,\n+                                                      Map<String, Object> map) throws IOException {\n+        assert parser.currentToken() == Token.FIELD_NAME : \"Expected field name but saw [\" + parser.currentToken() + \"]\";\n+        do {\n+            // Must point to field name\n+            String fieldName = parser.currentName();\n+            // And then the value...\n+            Object value = readValueUnsafe(parser.nextToken(), parser, mapFactory);\n+            map.put(fieldName, value);\n+        } while (parser.nextToken() == Token.FIELD_NAME);\n+        return map;\n     }\n \n-    static <T> Map<String, T> readGenericMap(\n-            XContentParser parser,\n-            Supplier<Map<String, T>> mapFactory,\n-            CheckedFunction<XContentParser, T, IOException> mapValueParser) throws IOException {\n-        Map<String, T> map = mapFactory.get();\n-        XContentParser.Token token = parser.currentToken();\n+    /**\n+     * Checks if the next current token in the supplied parser is a map start for a non-empty map.\n+     * Skips to the next token if the parser does not yet have a current token (i.e. {@link #currentToken()} returns {@code null}) and then\n+     * checks it.\n+     *\n+     * @return true if a map start for a non-empty map is found\n+     */\n+    private static boolean findNonEmptyMapStart(XContentParser parser) throws IOException {\n+        Token token = parser.currentToken();\n         if (token == null) {\n             token = parser.nextToken();\n         }\n         if (token == XContentParser.Token.START_OBJECT) {\n             token = parser.nextToken();\n         }\n-        for (; token == XContentParser.Token.FIELD_NAME; token = parser.nextToken()) {\n-            // Must point to field name\n-            String fieldName = parser.currentName();\n-            // And then the value...\n-            parser.nextToken();\n-            T value = mapValueParser.apply(parser);\n-            map.put(fieldName, value);\n-        }\n-        return map;\n+        return token == Token.FIELD_NAME;", "originalCommit": "d3d50cd642c724afda9a4f4d4de6e37f2af2cc02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU4NDM3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r477584373", "bodyText": "The behavior was already that way, so no need for you to change it.", "author": "jaymode", "createdAt": "2020-08-26T20:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwOTI1OA==", "url": "https://github.com/elastic/elasticsearch/pull/61442#discussion_r478209258", "bodyText": "The behavior was already that way, so no need for you to change it.\n\nYea this is+was really weird. I actually tried changing it here initially but we made use of this behaviour in a bunch of places (tests mostly) and it was not trivial to adjust those (would've blown up the PR size a lot) so I kept it for now.", "author": "original-brownbear", "createdAt": "2020-08-27T07:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NzIxNw=="}], "type": "inlineReview", "revised_code": null}]}