{"pr_number": 51508, "pr_title": "Implement ephemeral reindex with a persistent task", "pr_createdAt": "2020-01-28T00:19:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51508", "timeline": [{"oid": "1a10e9d500a6b00b40ccec3cca342c4afd75a354", "url": "https://github.com/elastic/elasticsearch/commit/1a10e9d500a6b00b40ccec3cca342c4afd75a354", "message": "Implement ephemeral reindex with a persistent task\n\nThis commit implements the non-resilient reindex process by using a the\nsame persistent task that the resilient reindex process uses. The\ndifference is that failover is not supported. If a persistent task\ndetects that it is not the initial assignement, it immediately stops.", "committedDate": "2020-01-28T00:16:35Z", "type": "commit"}, {"oid": "7353ebb9bf3a80d26341fe608593bc524a8be434", "url": "https://github.com/elastic/elasticsearch/commit/7353ebb9bf3a80d26341fe608593bc524a8be434", "message": "Fix checkstyle", "committedDate": "2020-01-28T00:46:57Z", "type": "commit"}, {"oid": "1a71a5b3a5399bdee303dacf73bd93ff397d679b", "url": "https://github.com/elastic/elasticsearch/commit/1a71a5b3a5399bdee303dacf73bd93ff397d679b", "message": "Merge remote-tracking branch 'upstream/reindex_v2' into ephemeral_through_persistent_task", "committedDate": "2020-01-28T01:08:14Z", "type": "commit"}, {"oid": "5230df4c0b698e2bc02234222b06c5633016963d", "url": "https://github.com/elastic/elasticsearch/commit/5230df4c0b698e2bc02234222b06c5633016963d", "message": "Fix issue", "committedDate": "2020-01-28T05:04:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzMDg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r371630891", "bodyText": "Maybe call this resilient like in ReindexTaskParams?", "author": "henningandersen", "createdAt": "2020-01-28T06:44:23Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java", "diffHunk": "@@ -45,19 +45,22 @@\n     private final ThreadPool threadPool;\n     private final String taskId;\n     private final long allocationId;\n+    private final boolean persistent;\n     private final ActionListener<ReindexTaskStateDoc> finishedListener;\n     private final Runnable onCheckpointAssignmentConflict;\n     private ThrottlingConsumer<Tuple<ScrollableHitSource.Checkpoint, BulkByScrollTask.Status>> checkpointThrottler;\n \n     private ReindexTaskState lastState;\n     private AtomicBoolean isDone = new AtomicBoolean();\n \n-    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String persistentTaskId, long allocationId,\n-                                   ActionListener<ReindexTaskStateDoc> finishedListener, Runnable onCheckpointAssignmentConflict) {\n+    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String taskId, long allocationId,\n+                                   boolean persistent, ActionListener<ReindexTaskStateDoc> finishedListener,\n+                                   Runnable onCheckpointAssignmentConflict) {\n         this.reindexIndexClient = reindexIndexClient;\n         this.threadPool = threadPool;\n-        this.taskId = persistentTaskId;\n+        this.taskId = taskId;\n         this.allocationId = allocationId;\n+        this.persistent = persistent;", "originalCommit": "5230df4c0b698e2bc02234222b06c5633016963d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c437597f5551e470155d514f1375460833a15af1", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\nindex 83f2db85f44..067176abcad 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\n\n@@ -45,7 +45,7 @@ public class ReindexTaskStateUpdater implements Reindexer.CheckpointListener {\n     private final ThreadPool threadPool;\n     private final String taskId;\n     private final long allocationId;\n-    private final boolean persistent;\n+    private final boolean resilient;\n     private final ActionListener<ReindexTaskStateDoc> finishedListener;\n     private final Runnable onCheckpointAssignmentConflict;\n     private ThrottlingConsumer<Tuple<ScrollableHitSource.Checkpoint, BulkByScrollTask.Status>> checkpointThrottler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzMzAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r371633022", "bodyText": "I think that we should ensure that this always runs in all both modes (i.e. the test runs in 3 modes total) to ensure that we cannot break one of the modes in a PR without noticing. This can be done in a follow-up.", "author": "henningandersen", "createdAt": "2020-01-28T06:53:59Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexRunAsPersistentAndEphemeralTaskTestCase.java", "diffHunk": "@@ -46,7 +46,7 @@\n                 @Override\n                 public ActionFuture<BulkByScrollResponse> execute() {\n                     PlainActionFuture<BulkByScrollResponse> futureResult = new PlainActionFuture<>();\n-                    client.execute(StartReindexTaskAction.INSTANCE, new StartReindexTaskAction.Request(request(), true),\n+                    client.execute(StartReindexTaskAction.INSTANCE, new StartReindexTaskAction.Request(request(), true, randomBoolean()),", "originalCommit": "5230df4c0b698e2bc02234222b06c5633016963d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c437597f5551e470155d514f1375460833a15af1", "chunk": "diff --git a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexRunAsPersistentAndEphemeralTaskTestCase.java b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexRunAsPersistentAndEphemeralTaskTestCase.java\nindex a08214bdbc2..801704ce3c0 100644\n--- a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexRunAsPersistentAndEphemeralTaskTestCase.java\n+++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexRunAsPersistentAndEphemeralTaskTestCase.java\n\n@@ -40,13 +40,24 @@ public abstract class ReindexRunAsPersistentAndEphemeralTaskTestCase extends Rei\n \n     private static final Map<String, ReindexRequestBuilderFactory> requestBuilderFactories = new LinkedHashMap<>();\n     static {\n-        requestBuilderFactories.put(\"task\", client -> new ReindexRequestBuilder(client, ReindexAction.INSTANCE));\n-        requestBuilderFactories.put(\"job\",\n+        requestBuilderFactories.put(\"ephemeral task\", client -> new ReindexRequestBuilder(client, ReindexAction.INSTANCE));\n+        requestBuilderFactories.put(\"non-resilient persistent task\",\n             client -> new ReindexRequestBuilder(client, ReindexAction.INSTANCE) {\n                 @Override\n                 public ActionFuture<BulkByScrollResponse> execute() {\n                     PlainActionFuture<BulkByScrollResponse> futureResult = new PlainActionFuture<>();\n-                    client.execute(StartReindexTaskAction.INSTANCE, new StartReindexTaskAction.Request(request(), true, randomBoolean()),\n+                    client.execute(StartReindexTaskAction.INSTANCE, new StartReindexTaskAction.Request(request(), true, false),\n+                        ActionListener.delegateFailure(futureResult, (future, result) -> future.onResponse(result.getReindexResponse())));\n+\n+                    return futureResult;\n+                }\n+            });\n+        requestBuilderFactories.put(\"resilient persistent task\",\n+            client -> new ReindexRequestBuilder(client, ReindexAction.INSTANCE) {\n+                @Override\n+                public ActionFuture<BulkByScrollResponse> execute() {\n+                    PlainActionFuture<BulkByScrollResponse> futureResult = new PlainActionFuture<>();\n+                    client.execute(StartReindexTaskAction.INSTANCE, new StartReindexTaskAction.Request(request(), true, true),\n                         ActionListener.delegateFailure(futureResult, (future, result) -> future.onResponse(result.getReindexResponse())));\n \n                     return futureResult;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzOTQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r371639461", "bodyText": "For a non-resilient reindex, I think we could change the failure message in waitForReindexDone further down to signal more precisely that the original coordinator has failed?\nI think this is the only real way to get assignment_failed out anyway, since we  now retry indefinitely.", "author": "henningandersen", "createdAt": "2020-01-28T07:19:24Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportStartReindexTaskAction.java", "diffHunk": "@@ -108,7 +108,7 @@ protected void doExecute(Task task, StartReindexTaskAction.Request request, Acti\n \n         // In the current implementation, we only need to store task results if we do not wait for completion\n         boolean storeTaskResult = request.getWaitForCompletion() == false;\n-        ReindexTaskParams job = new ReindexTaskParams(storeTaskResult, included);\n+        ReindexTaskParams job = new ReindexTaskParams(storeTaskResult, request.isResilient(), included);", "originalCommit": "5230df4c0b698e2bc02234222b06c5633016963d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ3MzIwMw==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372473203", "bodyText": "I added a new failure message in the case where assignment fails and resilient=false. I left a failure message when resilient=true. I don't think that scenario should happen. But it is nice to have the feedback in case in does happen and we can investigate.", "author": "tbrooks8", "createdAt": "2020-01-29T16:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzOTQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportStartReindexTaskAction.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportStartReindexTaskAction.java\nindex e35b7bb755d..7bdd50c9a65 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportStartReindexTaskAction.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/TransportStartReindexTaskAction.java\n\n@@ -108,9 +108,9 @@ public class TransportStartReindexTaskAction\n \n         // In the current implementation, we only need to store task results if we do not wait for completion\n         boolean storeTaskResult = request.getWaitForCompletion() == false;\n-        ReindexTaskParams job = new ReindexTaskParams(storeTaskResult, request.isResilient(), included);\n+        ReindexTaskParams job = new ReindexTaskParams(storeTaskResult, included);\n \n-        ReindexTaskStateDoc reindexState = new ReindexTaskStateDoc(request.getReindexRequest());\n+        ReindexTaskStateDoc reindexState = new ReindexTaskStateDoc(request.getReindexRequest(), request.isResilient());\n         reindexIndexClient.createReindexTaskDoc(generatedId, reindexState, new ActionListener<>() {\n             @Override\n             public void onResponse(ReindexTaskState taskState) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzOTkwNg==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r371639906", "bodyText": "Maybe we need a 7.x escape hatch to do the old transport action too? For those weird cases (if any) where they use lots of very small reindexes.", "author": "henningandersen", "createdAt": "2020-01-28T07:21:03Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java", "diffHunk": "@@ -62,16 +63,16 @@ public String getName() {\n     public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n         // todo: remove system property escape hatch in 8.0\n         // todo: fix version constant on backport to 7.x\n-        if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)\n-                || System.getProperty(\"es.reindex.resilience\", \"true\").equals(\"false\")) {\n+        if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)) {", "originalCommit": "5230df4c0b698e2bc02234222b06c5633016963d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c437597f5551e470155d514f1375460833a15af1", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\nindex 7f4667ead18..0f36c369431 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n\n@@ -63,11 +62,12 @@ public class RestReindexAction extends AbstractBaseReindexRestHandler<ReindexReq\n     public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n         // todo: remove system property escape hatch in 8.0\n         // todo: fix version constant on backport to 7.x\n-        if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)) {\n+        if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)\n+                || System.getProperty(\"es.reindex.resilience\", \"true\").equals(\"false\")) {\n             return doPrepareRequest(request, client, true, true);\n         }\n \n-        boolean resilient = Booleans.parseBoolean(System.getProperty(\"es.reindex.resilience\", \"true\"));\n+        boolean resilient = request.paramAsBoolean(\"resilient\", true);\n         boolean waitForCompletion = request.paramAsBoolean(\"wait_for_completion\", true);\n \n         // Build the internal request\n"}}, {"oid": "c437597f5551e470155d514f1375460833a15af1", "url": "https://github.com/elastic/elasticsearch/commit/c437597f5551e470155d514f1375460833a15af1", "message": "Review changes", "committedDate": "2020-01-28T19:34:24Z", "type": "commit"}, {"oid": "fe31baf2b92ff1a1f0ccc0a96deac89a7efbc53d", "url": "https://github.com/elastic/elasticsearch/commit/fe31baf2b92ff1a1f0ccc0a96deac89a7efbc53d", "message": "Add test", "committedDate": "2020-01-28T20:20:25Z", "type": "commit"}, {"oid": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "url": "https://github.com/elastic/elasticsearch/commit/f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "message": "Store in index", "committedDate": "2020-01-28T21:05:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzNzk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372837997", "bodyText": "nit: move one line up to maintain same order as in constructor and xcontent parsing.", "author": "henningandersen", "createdAt": "2020-01-30T09:25:57Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java", "diffHunk": "@@ -33,11 +33,13 @@\n public class ReindexTaskStateDoc implements ToXContentObject {\n \n     public static final ConstructingObjectParser<ReindexTaskStateDoc, Void> PARSER =\n-        new ConstructingObjectParser<>(\"reindex/index_state\", a -> new ReindexTaskStateDoc((ReindexRequest) a[0], (Long) a[1],\n-            (BulkByScrollResponse) a[2], (ElasticsearchException) a[3], (Integer) a[4], (ScrollableHitSource.Checkpoint) a[5]));\n+        new ConstructingObjectParser<>(\"reindex/index_state\", a -> new ReindexTaskStateDoc((ReindexRequest) a[0], (Boolean) a[1],\n+            (Long) a[2], (BulkByScrollResponse) a[3], (ElasticsearchException) a[4], (Integer) a[5],\n+            (ScrollableHitSource.Checkpoint) a[6]));\n \n     private static final String REINDEX_REQUEST = \"request\";\n     private static final String ALLOCATION = \"allocation\";\n+    private static final String RESILIENT = \"resilient\";", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\nindex 96492d2953b..4bb237d012b 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n\n@@ -30,6 +30,7 @@ import org.elasticsearch.rest.RestStatus;\n \n import java.io.IOException;\n \n+// TODO: This class has become complicated enough that we should implement a xcontent serialization test\n public class ReindexTaskStateDoc implements ToXContentObject {\n \n     public static final ConstructingObjectParser<ReindexTaskStateDoc, Void> PARSER =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgzODA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372838079", "bodyText": "nit: move one line up to maintain same order as in constructor and xcontent parsing.", "author": "henningandersen", "createdAt": "2020-01-30T09:26:09Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java", "diffHunk": "@@ -58,34 +61,37 @@\n \n     private final ReindexRequest reindexRequest;\n     private final Long allocationId;\n+    private final boolean resilient;", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\nindex 96492d2953b..4bb237d012b 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n\n@@ -60,8 +61,8 @@ public class ReindexTaskStateDoc implements ToXContentObject {\n     }\n \n     private final ReindexRequest reindexRequest;\n-    private final Long allocationId;\n     private final boolean resilient;\n+    private final Long allocationId;\n     private final BulkByScrollResponse reindexResponse;\n     private final ElasticsearchException exception;\n     private final RestStatus failureStatusCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NzMxOA==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372847318", "bodyText": "nit: not sure I understand the name oldAllocationUpdater (seems to be a copy-paste from another test)? I would call this one failedOverUpdater or something similar?", "author": "henningandersen", "createdAt": "2020-01-30T09:45:02Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdaterTests.java", "diffHunk": "@@ -84,6 +84,52 @@ public void onFailure(Exception exception) {\n         assertThat(exceptionRef.get().getMessage(), equalTo(\"A newer task has already been allocated\"));\n     }\n \n+    public void testFailoverAssignmentFailsIfNonResilient() throws Exception {\n+        String taskId = randomAlphaOfLength(10);\n+        ReindexIndexClient reindexClient = getReindexClient();\n+        createDoc(reindexClient, taskId, false);\n+\n+        ReindexTaskStateUpdater updater = new ReindexTaskStateUpdater(reindexClient, client().threadPool(),\n+            taskId, 0, ActionListener.wrap(() -> {}), () -> {});\n+        CountDownLatch successLatch = new CountDownLatch(1);\n+\n+        updater.assign(new ActionListener<>() {\n+            @Override\n+            public void onResponse(ReindexTaskStateDoc stateDoc) {\n+                successLatch.countDown();\n+            }\n+\n+            @Override\n+            public void onFailure(Exception exception) {\n+                successLatch.countDown();\n+                fail();\n+            }\n+        });\n+        successLatch.await();\n+\n+        ReindexTaskStateUpdater oldAllocationUpdater = new ReindexTaskStateUpdater(reindexClient, client().threadPool(),", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdaterTests.java b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdaterTests.java\nindex 1c7698eee5f..6284e346c11 100644\n--- a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdaterTests.java\n+++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdaterTests.java\n\n@@ -107,12 +107,12 @@ public class ReindexTaskStateUpdaterTests extends ReindexTestCase {\n         });\n         successLatch.await();\n \n-        ReindexTaskStateUpdater oldAllocationUpdater = new ReindexTaskStateUpdater(reindexClient, client().threadPool(),\n+        ReindexTaskStateUpdater failedOverUpdater = new ReindexTaskStateUpdater(reindexClient, client().threadPool(),\n             taskId, 1, ActionListener.wrap(() -> {}), () -> {});\n         CountDownLatch failureLatch = new CountDownLatch(1);\n         AtomicReference<Exception> exceptionRef = new AtomicReference<>();\n \n-        oldAllocationUpdater.assign(new ActionListener<>() {\n+        failedOverUpdater.assign(new ActionListener<>() {\n             @Override\n             public void onResponse(ReindexTaskStateDoc stateDoc) {\n                 failureLatch.countDown();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1MDU1OA==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372850558", "bodyText": "My rethrottle PR does the opposite rename. We can discuss that on that PR. I think I would prefer to leave the rename of the parameter out here, in order to avoid conflicts, but we can also sort that out as is.", "author": "henningandersen", "createdAt": "2020-01-30T09:51:28Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java", "diffHunk": "@@ -52,11 +52,11 @@\n     private ReindexTaskState lastState;\n     private AtomicBoolean isDone = new AtomicBoolean();\n \n-    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String persistentTaskId, long allocationId,\n+    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String taskId, long allocationId,\n                                    ActionListener<ReindexTaskStateDoc> finishedListener, Runnable onCheckpointAssignmentConflict) {\n         this.reindexIndexClient = reindexIndexClient;\n         this.threadPool = threadPool;\n-        this.taskId = persistentTaskId;\n+        this.taskId = taskId;", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\nindex f5dfb44ec3e..5afce877c7d 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java\n\n@@ -52,11 +52,11 @@ public class ReindexTaskStateUpdater implements Reindexer.CheckpointListener {\n     private ReindexTaskState lastState;\n     private AtomicBoolean isDone = new AtomicBoolean();\n \n-    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String taskId, long allocationId,\n+    public ReindexTaskStateUpdater(ReindexIndexClient reindexIndexClient, ThreadPool threadPool, String persistentTaskId, long allocationId,\n                                    ActionListener<ReindexTaskStateDoc> finishedListener, Runnable onCheckpointAssignmentConflict) {\n         this.reindexIndexClient = reindexIndexClient;\n         this.threadPool = threadPool;\n-        this.taskId = taskId;\n+        this.taskId = persistentTaskId;\n         this.allocationId = allocationId;\n         this.finishedListener = finishedListener;\n         this.onCheckpointAssignmentConflict = onCheckpointAssignmentConflict;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NjMzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372856331", "bodyText": "I believe we settled on making this a cluster setting and not a parameter?\nEdit: Now that I think back, we ended up making this choice be based on the specified sorting. I am not really sure that opt-in that way will work very well.\nI think we should change this to read a system property instead until settled.", "author": "henningandersen", "createdAt": "2020-01-30T10:02:23Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java", "diffHunk": "@@ -67,11 +67,12 @@ public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client\n             return doPrepareRequest(request, client, true, true);\n         }\n \n+        boolean resilient = request.paramAsBoolean(\"resilient\", true);", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NDYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r373284619", "bodyText": "I thought I remember that we decided to make it on a per-request basis. Anyway I changed it to a system property for now.\nLong term I think a system property == bad since it is node dependent. Sorting seems bad to me since it is super implicit. And cluster setting seems bad to me since there might be valid reasons why you want to faster performance in some circumstances.", "author": "tbrooks8", "createdAt": "2020-01-31T01:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NjMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\nindex 0f36c369431..61d8a215dbe 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n\n@@ -63,11 +63,11 @@ public class RestReindexAction extends AbstractBaseReindexRestHandler<ReindexReq\n         // todo: remove system property escape hatch in 8.0\n         // todo: fix version constant on backport to 7.x\n         if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)\n-                || System.getProperty(\"es.reindex.resilience\", \"true\").equals(\"false\")) {\n+                || System.getProperty(\"es.reindex.persistent\", \"true\").equals(\"false\")) {\n             return doPrepareRequest(request, client, true, true);\n         }\n \n-        boolean resilient = request.paramAsBoolean(\"resilient\", true);\n+        boolean resilient = System.getProperty(\"es.reindex.persistent.resilient\", \"true\").equals(\"false\") == false;\n         boolean waitForCompletion = request.paramAsBoolean(\"wait_for_completion\", true);\n \n         // Build the internal request\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1Njc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372856793", "bodyText": "I think we should rename the system property (one line up, cannot comment on that one) to be \"es.reindex.persistent\".", "author": "henningandersen", "createdAt": "2020-01-30T10:03:16Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java", "diffHunk": "@@ -67,11 +67,12 @@ public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client\n             return doPrepareRequest(request, client, true, true);", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\nindex 0f36c369431..61d8a215dbe 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/RestReindexAction.java\n\n@@ -63,11 +63,11 @@ public class RestReindexAction extends AbstractBaseReindexRestHandler<ReindexReq\n         // todo: remove system property escape hatch in 8.0\n         // todo: fix version constant on backport to 7.x\n         if (clusterService.state().nodes().getMinNodeVersion().before(Version.V_8_0_0)\n-                || System.getProperty(\"es.reindex.resilience\", \"true\").equals(\"false\")) {\n+                || System.getProperty(\"es.reindex.persistent\", \"true\").equals(\"false\")) {\n             return doPrepareRequest(request, client, true, true);\n         }\n \n-        boolean resilient = request.paramAsBoolean(\"resilient\", true);\n+        boolean resilient = System.getProperty(\"es.reindex.persistent.resilient\", \"true\").equals(\"false\") == false;\n         boolean waitForCompletion = request.paramAsBoolean(\"wait_for_completion\", true);\n \n         // Build the internal request\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NzMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372857317", "bodyText": "I think we should add a reference to the cluster level setting, mentioning its name here. This could nudge some users into trying it out.\nIf you defer adding the cluster level setting to a follow-up, let us add a todo here so that we remember it.", "author": "henningandersen", "createdAt": "2020-01-30T10:04:20Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateUpdater.java", "diffHunk": "@@ -122,6 +125,24 @@ public void onFailure(Exception ex) {\n         });\n     }\n \n+    private ElasticsearchException assignmentFailureReason(ReindexTaskStateDoc oldDoc) {\n+        if (oldDoc.isResilient()) {\n+            if (oldDoc.getAllocationId() == null || allocationId > oldDoc.getAllocationId()) {\n+                return null;\n+            } else {\n+                return new ElasticsearchException(\"A newer task has already been allocated\");\n+            }\n+        } else {\n+            if (oldDoc.getAllocationId() == null) {\n+                return null;\n+            } else {\n+                return new ElasticsearchException(\"A prior task has already been allocated and reindexing is configured to be \" +", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1ODI1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/51508#discussion_r372858256", "bodyText": "I think we should add a xcontent serialization test too. Can be done in a follow-up if you prefer.", "author": "henningandersen", "createdAt": "2020-01-30T10:06:14Z", "path": "modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java", "diffHunk": "@@ -33,11 +33,13 @@\n public class ReindexTaskStateDoc implements ToXContentObject {\n \n     public static final ConstructingObjectParser<ReindexTaskStateDoc, Void> PARSER =\n-        new ConstructingObjectParser<>(\"reindex/index_state\", a -> new ReindexTaskStateDoc((ReindexRequest) a[0], (Long) a[1],\n-            (BulkByScrollResponse) a[2], (ElasticsearchException) a[3], (Integer) a[4], (ScrollableHitSource.Checkpoint) a[5]));\n+        new ConstructingObjectParser<>(\"reindex/index_state\", a -> new ReindexTaskStateDoc((ReindexRequest) a[0], (Boolean) a[1],", "originalCommit": "f59e0cfdfaedbdfefafcd5d9297853ec08e94ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "chunk": "diff --git a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\nindex 96492d2953b..4bb237d012b 100644\n--- a/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n+++ b/modules/reindex/src/main/java/org/elasticsearch/index/reindex/ReindexTaskStateDoc.java\n\n@@ -30,6 +30,7 @@ import org.elasticsearch.rest.RestStatus;\n \n import java.io.IOException;\n \n+// TODO: This class has become complicated enough that we should implement a xcontent serialization test\n public class ReindexTaskStateDoc implements ToXContentObject {\n \n     public static final ConstructingObjectParser<ReindexTaskStateDoc, Void> PARSER =\n"}}, {"oid": "b08b739e9395bc4a676e0b629b7233cbecdd9572", "url": "https://github.com/elastic/elasticsearch/commit/b08b739e9395bc4a676e0b629b7233cbecdd9572", "message": "Changes", "committedDate": "2020-01-31T01:51:36Z", "type": "commit"}]}