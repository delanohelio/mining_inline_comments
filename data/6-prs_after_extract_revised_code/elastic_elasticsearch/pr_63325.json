{"pr_number": 63325, "pr_title": "Allow mixing set-based and regexp-based include and exclude", "pr_createdAt": "2020-10-06T13:05:03Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63325", "timeline": [{"oid": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "url": "https://github.com/elastic/elasticsearch/commit/c37c0a5a5037073d533e5f5dd4c3672f393d2969", "message": "Allow mixing set-based and regexp-based include and exclude", "committedDate": "2020-10-06T12:52:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MzMwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r501183301", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (valids != null && !valids.contains(value)) {\n          \n          \n            \n                        if (valids != null && (valids.contains(value) == false)) {\n          \n      \n    \n    \n  \n\nElastic coding standard prefers this form for readability", "author": "not-napoleon", "createdAt": "2020-10-07T17:22:29Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java", "diffHunk": "@@ -196,46 +188,39 @@ public boolean accept(BytesRef value) {\n         }\n     }\n \n-    static class AutomatonBackedStringFilter extends StringFilter {\n+    class SetAndRegexStringFilter extends StringFilter {\n \n         private final ByteRunAutomaton runAutomaton;\n-\n-        private AutomatonBackedStringFilter(Automaton automaton) {\n-            this.runAutomaton = new ByteRunAutomaton(automaton);\n-        }\n-\n-        /**\n-         * Returns whether the given value is accepted based on the {@code include} &amp; {@code exclude} patterns.\n-         */\n-        @Override\n-        public boolean accept(BytesRef value) {\n-            return runAutomaton.run(value.bytes, value.offset, value.length);\n-        }\n-    }\n-\n-    static class TermListBackedStringFilter extends StringFilter {\n-\n         private final Set<BytesRef> valids;\n         private final Set<BytesRef> invalids;\n \n-        TermListBackedStringFilter(Set<BytesRef> includeValues, Set<BytesRef> excludeValues) {\n-            this.valids = includeValues;\n-            this.invalids = excludeValues;\n+        private SetAndRegexStringFilter(DocValueFormat format) {\n+            Automaton automaton = toAutomaton();\n+            this.runAutomaton = automaton == null ?  null : new ByteRunAutomaton(automaton);\n+            this.valids = parseForDocValues(includeValues, format);\n+            this.invalids = parseForDocValues(excludeValues, format);\n         }\n \n         /**\n-         * Returns whether the given value is accepted based on the\n-         * {@code include} &amp; {@code exclude} sets.\n+         * Returns whether the given value is accepted based on the {@code includeValues} &amp; {@code excludeValues}\n+         * sets, as well as the {@code include} &amp; {@code exclude} patterns.\n          */\n         @Override\n         public boolean accept(BytesRef value) {\n-            return ((valids == null) || (valids.contains(value))) && ((invalids == null) || (!invalids.contains(value)));\n+            if (valids != null && !valids.contains(value)) {", "originalCommit": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNTUwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r505705505", "bodyText": "Done", "author": "hchargois", "createdAt": "2020-10-15T17:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MzMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a2b7ab3f4a25f1968ce6f20046bf4bc17769590", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\nindex 33fd7256c0f..fd26d12db68 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n\n@@ -207,15 +207,15 @@ public class IncludeExclude implements Writeable, ToXContentFragment {\n          */\n         @Override\n         public boolean accept(BytesRef value) {\n-            if (valids != null && !valids.contains(value)) {\n+            if (valids != null && valids.contains(value) == false) {\n                 return false;\n             }\n \n-            if (runAutomaton != null && !runAutomaton.run(value.bytes, value.offset, value.length)) {\n+            if (runAutomaton != null && runAutomaton.run(value.bytes, value.offset, value.length) == false) {\n                 return false;\n             }\n \n-            return invalids == null || !invalids.contains(value);\n+            return invalids == null || invalids.contains(value) == false;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NDE1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r501184156", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (runAutomaton != null && !runAutomaton.run(value.bytes, value.offset, value.length)) {\n          \n          \n            \n                        if (runAutomaton != null && (runAutomaton.run(value.bytes, value.offset, value.length) == false)) {", "author": "not-napoleon", "createdAt": "2020-10-07T17:23:58Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java", "diffHunk": "@@ -196,46 +188,39 @@ public boolean accept(BytesRef value) {\n         }\n     }\n \n-    static class AutomatonBackedStringFilter extends StringFilter {\n+    class SetAndRegexStringFilter extends StringFilter {\n \n         private final ByteRunAutomaton runAutomaton;\n-\n-        private AutomatonBackedStringFilter(Automaton automaton) {\n-            this.runAutomaton = new ByteRunAutomaton(automaton);\n-        }\n-\n-        /**\n-         * Returns whether the given value is accepted based on the {@code include} &amp; {@code exclude} patterns.\n-         */\n-        @Override\n-        public boolean accept(BytesRef value) {\n-            return runAutomaton.run(value.bytes, value.offset, value.length);\n-        }\n-    }\n-\n-    static class TermListBackedStringFilter extends StringFilter {\n-\n         private final Set<BytesRef> valids;\n         private final Set<BytesRef> invalids;\n \n-        TermListBackedStringFilter(Set<BytesRef> includeValues, Set<BytesRef> excludeValues) {\n-            this.valids = includeValues;\n-            this.invalids = excludeValues;\n+        private SetAndRegexStringFilter(DocValueFormat format) {\n+            Automaton automaton = toAutomaton();\n+            this.runAutomaton = automaton == null ?  null : new ByteRunAutomaton(automaton);\n+            this.valids = parseForDocValues(includeValues, format);\n+            this.invalids = parseForDocValues(excludeValues, format);\n         }\n \n         /**\n-         * Returns whether the given value is accepted based on the\n-         * {@code include} &amp; {@code exclude} sets.\n+         * Returns whether the given value is accepted based on the {@code includeValues} &amp; {@code excludeValues}\n+         * sets, as well as the {@code include} &amp; {@code exclude} patterns.\n          */\n         @Override\n         public boolean accept(BytesRef value) {\n-            return ((valids == null) || (valids.contains(value))) && ((invalids == null) || (!invalids.contains(value)));\n+            if (valids != null && !valids.contains(value)) {\n+                return false;\n+            }\n+\n+            if (runAutomaton != null && !runAutomaton.run(value.bytes, value.offset, value.length)) {", "originalCommit": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNTU3NA==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r505705574", "bodyText": "Done", "author": "hchargois", "createdAt": "2020-10-15T17:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NDE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a2b7ab3f4a25f1968ce6f20046bf4bc17769590", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\nindex 33fd7256c0f..fd26d12db68 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n\n@@ -207,15 +207,15 @@ public class IncludeExclude implements Writeable, ToXContentFragment {\n          */\n         @Override\n         public boolean accept(BytesRef value) {\n-            if (valids != null && !valids.contains(value)) {\n+            if (valids != null && valids.contains(value) == false) {\n                 return false;\n             }\n \n-            if (runAutomaton != null && !runAutomaton.run(value.bytes, value.offset, value.length)) {\n+            if (runAutomaton != null && runAutomaton.run(value.bytes, value.offset, value.length) == false) {\n                 return false;\n             }\n \n-            return invalids == null || !invalids.contains(value);\n+            return invalids == null || invalids.contains(value) == false;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzNjA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r501236071", "bodyText": "I think the intention here is that at most one of (include, includeValues) and at most one of (exclude, excludeValues) will be non-null.  In other words, while you can mix set-based includes and regex excludes (or vice versa), you can't have both set-based and regex-based includes.  That seems like a requirement of the precedence rules, among other things.\nI think we should enforce that rule here.  I know the parser doesn't currently allow for specifying both a regex and a set at the same time, but it's ultimately this class's contract that both not be set, and this class should check it.", "author": "not-napoleon", "createdAt": "2020-10-07T18:48:26Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java", "diffHunk": "@@ -332,17 +322,30 @@ public LongBitSet acceptedGlobalOrdinals(SortedSetDocValues globalOrdinals) thro\n      * @param exclude   The regular expression pattern for the terms to be excluded\n      */\n     public IncludeExclude(RegExp include, RegExp exclude) {\n-        if (include == null && exclude == null) {\n+        this(include, exclude, null, null);\n+    }\n+\n+    public IncludeExclude(RegExp include, RegExp exclude, SortedSet<BytesRef> includeValues, SortedSet<BytesRef> excludeValues) {\n+        if (include == null && exclude == null && includeValues == null && excludeValues == null) {", "originalCommit": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MTgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r502561815", "bodyText": "I think that in IncludeExclude any combination of the 4 (include, includeValues, exclude, excludeValues) can work correctly. Meaning that we can have both kinds of includes and/or both kind of excludes and it would \"do the right/logical thing\", i.e. it would accept terms that are in any of the include(s) but not in any of the exclude(s). I don't think there is precedence between both kinds of includes, nor between both kinds of excludes, just between include(s) and exclude(s).\nAlso, I don't think restricting to a single include and a single exclude would be more efficient (e.g. allow optimizations in the accept functions).\nThat's why I didn't forbid having both types of includes or both types of excludes. But I can definitely add a check to forbid it.", "author": "hchargois", "createdAt": "2020-10-09T17:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzNjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMyMDU0OA==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r503320548", "bodyText": "The case I am worried about, if you have something like include = \"foo.*\" and includeValues = [\"bar\", \"quux\"], it will incorrectly reject the term \"foo\" by returning false on line 211, I think.  I don't think we need to support that case, but we do need to explicitly reject it, by not allowing both include and includeValues to be set.", "author": "not-napoleon", "createdAt": "2020-10-12T14:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzNjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r505707305", "bodyText": "You're right, I was wrong in my previous comment. I think the accept from the ordinals filter can work with both kinds of includes (or excludes), but indeed not the string filter, where I assumed there was only one kind of each.\nI've added a check to forbid this", "author": "hchargois", "createdAt": "2020-10-15T17:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzNjA3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a2b7ab3f4a25f1968ce6f20046bf4bc17769590", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\nindex 33fd7256c0f..fd26d12db68 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java\n\n@@ -338,13 +338,13 @@ public class IncludeExclude implements Writeable, ToXContentFragment {\n     }\n \n     public IncludeExclude(String include, String exclude, String[] includeValues, String[] excludeValues) {\n-            this(\n-                include == null ? null : new RegExp(include),\n-                exclude == null ? null : new RegExp(exclude),\n-                convertToBytesRefSet(includeValues),\n-                convertToBytesRefSet(excludeValues)\n-            );\n-        }\n+        this(\n+            include == null ? null : new RegExp(include),\n+            exclude == null ? null : new RegExp(exclude),\n+            convertToBytesRefSet(includeValues),\n+            convertToBytesRefSet(excludeValues)\n+        );\n+    }\n \n     public IncludeExclude(String include, String exclude) {\n         this(include == null ? null : new RegExp(include), exclude == null ? null : new RegExp(exclude));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0ODE2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r501248166", "bodyText": "I appreciate that you added tests to make sure that the precedence is preserved with the new possible configurations, but I think we should test this on IncludeExcludeTests as well.", "author": "not-napoleon", "createdAt": "2020-10-07T19:10:29Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/terms/TermsAggregatorTests.java", "diffHunk": "@@ -455,6 +455,42 @@ public void testStringIncludeExclude() throws Exception {\n                     assertEquals(\"val010\", result.getBuckets().get(1).getKeyAsString());\n                     assertEquals(1L, result.getBuckets().get(1).getDocCount());\n                     assertTrue(AggregationInspectionHelper.hasValue((InternalTerms)result));\n+\n+                    aggregationBuilder = new TermsAggregationBuilder(\"_name\").userValueTypeHint(ValueType.STRING)\n+                        .executionHint(executionHint)\n+                        .includeExclude(new IncludeExclude(\"val00.+\", null, null,\n+                            new String[]{\"val001\", \"val002\", \"val003\", \"val004\", \"val005\", \"val006\", \"val007\", \"val008\"}))", "originalCommit": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r505707972", "bodyText": "I've refactored/added tests for all possible combinations of include/exclude in IncludeExcludeTests.", "author": "hchargois", "createdAt": "2020-10-15T17:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0ODE2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1Nzk0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r501257940", "bodyText": "I think this version string is fine for now.  When we backport it, we'll update it accordingly.  There's a process for doing that, but it's on the person merging the backport to do it, so you shouldn't have to worry about it.", "author": "not-napoleon", "createdAt": "2020-10-07T19:28:41Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/IncludeExclude.java", "diffHunk": "@@ -395,18 +390,21 @@ public IncludeExclude(int partition, int numPartitions) {\n      */\n     public IncludeExclude(StreamInput in) throws IOException {\n         if (in.readBoolean()) {\n-            includeValues = null;\n-            excludeValues = null;\n-            incZeroBasedPartition = 0;\n-            incNumPartitions = 0;\n             String includeString = in.readOptionalString();\n             include = includeString == null ? null : new RegExp(includeString);\n             String excludeString = in.readOptionalString();\n             exclude = excludeString == null ? null : new RegExp(excludeString);\n-            return;\n+            if (in.getVersion().before(Version.V_8_0_0)) {", "originalCommit": "c37c0a5a5037073d533e5f5dd4c3672f393d2969", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2OTI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r502569272", "bodyText": "All right, thanks. Do you think this process can be applied on our end so that we could build our own backport? For example. let's say this feature gets backported to v7.x, but we are still on v6.y and we can't upgrade to v7.x just yet. We would like to build our own patched v6.y version (v6.y-patched) to get the feature.\nI can't seem to think of a simple foolproof way to backport this so that we don't have a problem when:\n\nupgrading from v6.y to v6.y-patched\nupgrading from v6.y-patched to a later version v6.z-patched\nupgrading from v6-z.patched to a vanilla v7.x\n\nMaybe this is not (easily) possible, but I prefer to ask, maybe you have some idea or pointers!", "author": "hchargois", "createdAt": "2020-10-09T17:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1Nzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM0NDQ4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r503344486", "bodyText": "I would strongly caution you against backporting this to 6.x.  There's no clear upgrade path, since 7.x will not recognize the new serialization format comming from the modified 6.x (since the version marker will be for 7.11 or something close to that) and you'll be in unsupported territory.  Also, if we need to change the API or the serialization format for this again, you could end up in a very incompatible place.\nYou're welcome to try if you want to, but about all I can offer you is \"good luck\".", "author": "not-napoleon", "createdAt": "2020-10-12T14:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1Nzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwODg1MA==", "url": "https://github.com/elastic/elasticsearch/pull/63325#discussion_r505708850", "bodyText": "Thank you for your advice. I think we'll skip the backport to v6 and just upgrade to v7 as soon as possible :)", "author": "hchargois", "createdAt": "2020-10-15T17:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1Nzk0MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "0a2b7ab3f4a25f1968ce6f20046bf4bc17769590", "url": "https://github.com/elastic/elasticsearch/commit/0a2b7ab3f4a25f1968ce6f20046bf4bc17769590", "message": "Coding style", "committedDate": "2020-10-15T15:34:54Z", "type": "commit"}, {"oid": "0754ea71335da452c95b2b3aceea64e61a89e79e", "url": "https://github.com/elastic/elasticsearch/commit/0754ea71335da452c95b2b3aceea64e61a89e79e", "message": "Disallow having both set and regexp include (resp. exclude)", "committedDate": "2020-10-15T15:34:54Z", "type": "commit"}, {"oid": "3e90b78906dc8e8e8b98409246fc07558d7e52e3", "url": "https://github.com/elastic/elasticsearch/commit/3e90b78906dc8e8e8b98409246fc07558d7e52e3", "message": "Test correctness of every combination of include/exclude", "committedDate": "2020-10-15T15:34:54Z", "type": "commit"}, {"oid": "9af13530778309ec30356142175d8b24645e3b23", "url": "https://github.com/elastic/elasticsearch/commit/9af13530778309ec30356142175d8b24645e3b23", "message": "Merge branch 'master' into allow-mixing-set-and-regexp-include-exclude", "committedDate": "2020-10-19T13:50:36Z", "type": "commit"}]}