{"pr_number": 56961, "pr_title": "Serialize Outbound Messages on IO Threads", "pr_createdAt": "2020-05-19T18:40:15Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56961", "timeline": [{"oid": "6841cd69fced5fa15dbe14a0d89fc9cd4a12af0c", "url": "https://github.com/elastic/elasticsearch/commit/6841cd69fced5fa15dbe14a0d89fc9cd4a12af0c", "message": "Serialize Outbound Messages on IO Threads\n\nAlmost every outbound message is serialized to buffers of 16k pagesize.\nWe were serializing these messages off the IO loop (and retaining the concrete message\ninstance as well) and would then enqueue it on the IO loop to be dealt with as soon as the\nchannel is ready.\n1. This would cause buffers to be held onto for longer than necessary, causing less reuse on average.\n2. If a channel was slow for some reason, not only would concrete message instances queue up for it,\nbut also 16k of buffers would be reserved for each message until it would be written+flushed physically.\n\nWith this change, the serialization happens on the event loop which effectively limits the number of buffers\nthat `N` IO-threads will ever use so long as messages are small and channels writable.\nAlso, this change dereferences the reference to the concrete outbound message as soon as it has been serialized\nto save some more on GC.\n\nThis reduces the GC time for a default PMC run by about 50% in experiments (3 nodes, 2G heap each, loopback).\nI also expect it to be helpful for maste node stability by causing less of a spike if master is e.g. hit by a large\nnumber of requests that are processed batched (e.g. shard snapshot status updates) and responded to in a short time frame\nall at once.", "committedDate": "2020-05-19T18:36:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3MDAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/56961#discussion_r428970002", "bodyText": "Can we do this in Netty4MessageChannelHandler#write? So that any uncaught exceptions going through the normal channel exception handling?", "author": "tbrooks8", "createdAt": "2020-05-21T23:37:44Z", "path": "modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4TcpChannel.java", "diffHunk": "@@ -142,11 +145,20 @@ public InetSocketAddress getRemoteAddress() {\n     }\n \n     @Override\n-    public void sendMessage(BytesReference reference, ActionListener<Void> listener) {\n-        channel.writeAndFlush(Netty4Utils.toByteBuf(reference), addPromise(listener, channel));\n-\n-        if (channel.eventLoop().isShutdown()) {\n-            listener.onFailure(new TransportException(\"Cannot send message, event loop is shutting down.\"));\n+    public void sendMessage(OutboundHandler.SendContext sendContext) {\n+        try {\n+            channel.eventLoop().execute(() -> {", "originalCommit": "6841cd69fced5fa15dbe14a0d89fc9cd4a12af0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3MTA1NA==", "url": "https://github.com/elastic/elasticsearch/pull/56961#discussion_r429271054", "bodyText": "Done in 6a85d40, that's much better indeed thanks :)", "author": "original-brownbear", "createdAt": "2020-05-22T14:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3MDAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "6a85d40edf28313ae3c68f909e52fb5cb48673ca", "chunk": "diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4TcpChannel.java b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4TcpChannel.java\nindex 3eb60946f48..8001056bad9 100644\n--- a/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4TcpChannel.java\n+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/transport/netty4/Netty4TcpChannel.java\n\n@@ -146,18 +143,9 @@ public class Netty4TcpChannel implements TcpChannel {\n \n     @Override\n     public void sendMessage(OutboundHandler.SendContext sendContext) {\n-        try {\n-            channel.eventLoop().execute(() -> {\n-                final BytesReference bytesReference;\n-                try {\n-                    bytesReference = sendContext.get();\n-                } catch (IOException e) {\n-                    sendContext.onFailure(e);\n-                    return;\n-                }\n-                channel.writeAndFlush(Netty4Utils.toByteBuf(bytesReference), addPromise(sendContext, channel));\n-            });\n-        } catch (RejectedExecutionException e) {\n+        channel.writeAndFlush(sendContext, addPromise(sendContext, channel));\n+\n+        if (channel.eventLoop().isShutdown()) {\n             sendContext.onFailure(new TransportException(\"Cannot send message, event loop is shutting down.\"));\n         }\n     }\n"}}, {"oid": "af907e886b12ce23da65d9ea7422be43d9c09ecf", "url": "https://github.com/elastic/elasticsearch/commit/af907e886b12ce23da65d9ea7422be43d9c09ecf", "message": "Merge remote-tracking branch 'elastic/master' into cheaper-outbound-serialization", "committedDate": "2020-05-22T12:50:35Z", "type": "commit"}, {"oid": "6a85d40edf28313ae3c68f909e52fb5cb48673ca", "url": "https://github.com/elastic/elasticsearch/commit/6a85d40edf28313ae3c68f909e52fb5cb48673ca", "message": "CR: move logic to message handler", "committedDate": "2020-05-22T14:11:42Z", "type": "commit"}]}