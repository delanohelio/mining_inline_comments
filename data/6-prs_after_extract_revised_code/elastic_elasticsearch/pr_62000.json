{"pr_number": 62000, "pr_title": "Improve Snapshot State Machine Performance", "pr_createdAt": "2020-09-04T14:57:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/62000", "timeline": [{"oid": "70a5927ac0c146506b7a75b0188c2f50468d71a1", "url": "https://github.com/elastic/elasticsearch/commit/70a5927ac0c146506b7a75b0188c2f50468d71a1", "message": "Improve Snapshot State Machine Performance\n\nJust a few random things to optimize motivated by somewhat sub-standard performance\nfor large snapshot cluster states with many concurrent snapshots observed in production.", "committedDate": "2020-09-04T14:55:24Z", "type": "commit"}, {"oid": "7f0fc0a02bf022098961f38bc3266444059dec80", "url": "https://github.com/elastic/elasticsearch/commit/7f0fc0a02bf022098961f38bc3266444059dec80", "message": "Merge remote-tracking branch 'elastic/master' into no-duplicate-snapshot-shard-id", "committedDate": "2020-09-04T17:57:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNDE3NA==", "url": "https://github.com/elastic/elasticsearch/pull/62000#discussion_r484104174", "bodyText": "Not a huge win but if we have a large number of snapshots this one might be the most common status and since there's logic that compares with this status in a hot loop it's worth it IMO.", "author": "original-brownbear", "createdAt": "2020-09-06T19:10:48Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -450,14 +450,20 @@ private boolean assertConsistent() {\n             // If the state is failed we have to have a reason for this failure\n             assert state.failed() == false || reason != null;\n             assert (state != ShardState.INIT && state != ShardState.WAITING) || nodeId != null : \"Null node id for state [\" + state + \"]\";\n+            assert state != ShardState.QUEUED || (nodeId == null && generation == null && reason == null) :\n+                    \"Found unexpected non-null values for queued state shard nodeId[\" + nodeId + \"][\" + generation + \"][\" + reason + \"]\";\n             return true;\n         }\n \n-        public ShardSnapshotStatus(StreamInput in) throws IOException {\n-            nodeId = in.readOptionalString();\n-            state = ShardState.fromValue(in.readByte());\n-            generation = in.readOptionalString();\n-            reason = in.readOptionalString();\n+        public static ShardSnapshotStatus readFrom(StreamInput in) throws IOException {\n+            String nodeId = in.readOptionalString();\n+            final ShardState state = ShardState.fromValue(in.readByte());\n+            final String generation = in.readOptionalString();\n+            final String reason = in.readOptionalString();\n+            if (state == ShardState.QUEUED) {", "originalCommit": "7f0fc0a02bf022098961f38bc3266444059dec80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNDIwOA==", "url": "https://github.com/elastic/elasticsearch/pull/62000#discussion_r484104208", "bodyText": "This is executed on all shard of all snapshots so it's super hot for large clusters, much cheaper to check state before doing the more expensive node id check.", "author": "original-brownbear", "createdAt": "2020-09-06T19:11:20Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java", "diffHunk": "@@ -205,8 +205,8 @@ private void startNewSnapshots(SnapshotsInProgress snapshotsInProgress) {\n                     // Add all new shards to start processing on\n                     final ShardId shardId = shard.key;\n                     final ShardSnapshotStatus shardSnapshotStatus = shard.value;\n-                    if (localNodeId.equals(shardSnapshotStatus.nodeId())\n-                        && shardSnapshotStatus.state() == ShardState.INIT\n+                    if (shardSnapshotStatus.state() == ShardState.INIT", "originalCommit": "7f0fc0a02bf022098961f38bc3266444059dec80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNDMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/62000#discussion_r484104302", "bodyText": "This whole logic could be made more efficient I suppose by computing the reassignments differently (compared to computing them the first time around), but for now this is an easy change that saves a ton of cycles if there's multiple snapshots running concurrently for a repo.", "author": "original-brownbear", "createdAt": "2020-09-06T19:12:26Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1602,6 +1602,8 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n             boolean changed = false;\n \n             final String repoName = deleteEntry.repository();\n+            // Computing the new assignments can be quite costly, only do it once below if actually needed\n+            ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;", "originalCommit": "7f0fc0a02bf022098961f38bc3266444059dec80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNDM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/62000#discussion_r484104378", "bodyText": "No need to create a new shard id, especially not when we use that shard id for comparisons all over the place (doesn't help that much because we eventually read other instances back from the wire but it's a freebie IMO).", "author": "original-brownbear", "createdAt": "2020-09-06T19:13:17Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1728,7 +1732,7 @@ public static ClusterState updateWithSnapshots(ClusterState state,\n                 final IndexRoutingTable indexRoutingTable = routingTable.index(indexName);\n                 assert indexRoutingTable != null;\n                 for (int i = 0; i < indexMetadata.getNumberOfShards(); i++) {\n-                    ShardId shardId = new ShardId(indexMetadata.getIndex(), i);\n+                    final ShardId shardId = indexRoutingTable.shard(i).shardId();", "originalCommit": "7f0fc0a02bf022098961f38bc3266444059dec80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwNDQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/62000#discussion_r484104459", "bodyText": "This is very hot code (shard state updates path) so it's worth saving one map lookup here IMO.", "author": "original-brownbear", "createdAt": "2020-09-06T19:14:24Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1902,11 +1906,10 @@ public boolean assertAllListenersResolved() {\n                     } else {\n                         final String updatedRepository = updateSnapshotState.snapshot().getRepository();\n                         final Set<ShardId> reusedShardIds = reusedShardIdsByRepo.computeIfAbsent(updatedRepository, k -> new HashSet<>());\n-                        if (entry.repository().equals(updatedRepository) &&\n-                            entry.state().completed() == false && reusedShardIds.contains(finishedShardId) == false\n-                                && entry.shards().keys().contains(finishedShardId)) {\n+                        if (entry.state().completed() == false && entry.repository().equals(updatedRepository)\n+                                && reusedShardIds.contains(finishedShardId) == false) {\n                             final ShardSnapshotStatus existingStatus = entry.shards().get(finishedShardId);\n-                            if (existingStatus.state() != ShardState.QUEUED) {\n+                            if (existingStatus == null || existingStatus.state() != ShardState.QUEUED) {", "originalCommit": "7f0fc0a02bf022098961f38bc3266444059dec80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}