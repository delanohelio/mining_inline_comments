{"pr_number": 56804, "pr_title": "[TEST] Fix log tail mocking in native process unit tests", "pr_createdAt": "2020-05-15T07:31:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56804", "timeline": [{"oid": "1290e5bf3a72881a70e0c2362d91dcd565eaed18", "url": "https://github.com/elastic/elasticsearch/commit/1290e5bf3a72881a70e0c2362d91dcd565eaed18", "message": "[TEST] Fix log tail mocking in native process unit tests\n\nThis is a followup to #56632. Tests that had to be changed\nto mock the C++ log handler more accurately need to be more\ncareful about when that stream ends, as ending of that\nstream is used to detect crashes in the production system.\n\nFixes #56796", "committedDate": "2020-05-15T07:25:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyMTY1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56804#discussion_r425621656", "bodyText": "Should it be in the finally block just like the other tests? If not, what's the difference?", "author": "przemekwitek", "createdAt": "2020-05-15T07:39:30Z", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java", "diffHunk": "@@ -82,29 +87,34 @@ public void testStart_DoNotDetectCrashWhenNoInputPipeProvided() throws Exception\n         when(processPipes.getProcessInStream()).thenReturn(Optional.empty());\n         try (AbstractNativeProcess process = new TestNativeProcess()) {\n             process.start(executorService);\n-            wait.countDown();\n+        } finally {\n+            mockNativeProcessLoggingStreamEnds.countDown();\n+            // Not detecting a crash is confirmed in terminateExecutorService()\n         }\n     }\n \n     public void testStart_DoNotDetectCrashWhenProcessIsBeingClosed() throws Exception {\n         try (AbstractNativeProcess process = new TestNativeProcess()) {\n             process.start(executorService);\n-            wait.countDown();\n+        } finally {\n+            mockNativeProcessLoggingStreamEnds.countDown();\n+            // Not detecting a crash is confirmed in terminateExecutorService()\n         }\n     }\n \n     public void testStart_DoNotDetectCrashWhenProcessIsBeingKilled() throws Exception {\n         try (AbstractNativeProcess process = new TestNativeProcess()) {\n             process.start(executorService);\n             process.kill();\n-            wait.countDown();\n+            mockNativeProcessLoggingStreamEnds.countDown();", "originalCommit": "1290e5bf3a72881a70e0c2362d91dcd565eaed18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyNzA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/56804#discussion_r425627040", "bodyText": "This is testing what happens if the process is killed.  The finally block will run after close().\nThis does actually create an inefficiency, in that if start() or kill() throws an exception then the countdown won't happen and the @After method will block for 10 seconds waiting for the countdown that will never come.\nThis was always a problem even before my changes, but I will change the test so that it doesn't use a try-with-resources so this can be avoided.", "author": "droberts195", "createdAt": "2020-05-15T07:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyMTY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMjM0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/56804#discussion_r425632343", "bodyText": "This does actually create an inefficiency, in that if start() or kill() throws an exception then the countdown won't happen and the @After method will block for 10 seconds waiting for the countdown that will never come.\n\nActually this isn't true.  Terminating the threadpool will interrupt all the threads in it, and that will exit the countdown await() with an InterruptedException.  So it wouldn't block for 10 seconds.\nStill I will change the code as it obviously wasn't clear what was going on.", "author": "droberts195", "createdAt": "2020-05-15T08:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyMTY1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "88850b16c168e6d7fa0396a804144481c436177f", "chunk": "diff --git a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java\nindex 5c9dd47becd..cf102c563e3 100644\n--- a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java\n+++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java\n\n@@ -103,11 +103,17 @@ public class AbstractNativeProcessTests extends ESTestCase {\n     }\n \n     public void testStart_DoNotDetectCrashWhenProcessIsBeingKilled() throws Exception {\n-        try (AbstractNativeProcess process = new TestNativeProcess()) {\n+        AbstractNativeProcess process = new TestNativeProcess();\n+        try {\n             process.start(executorService);\n             process.kill();\n+        } finally {\n+            // It is critical that this comes after kill() but before close(), otherwise we\n+            // would not be accurately simulating a kill().  This is why try-with-resources\n+            // is not used in this case.\n             mockNativeProcessLoggingStreamEnds.countDown();\n             // Not detecting a crash is confirmed in terminateExecutorService()\n+            process.close();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/56804#discussion_r425630034", "bodyText": "final?", "author": "przemekwitek", "createdAt": "2020-05-15T07:56:47Z", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/process/AbstractNativeProcessTests.java", "diffHunk": "@@ -43,18 +43,23 @@\n     private ProcessPipes processPipes;\n     private Consumer<String> onProcessCrash;\n     private ExecutorService executorService;\n-    private CountDownLatch wait = new CountDownLatch(1);\n+    // This must be counted down at the point where a real native process would terminate, thus\n+    // causing an end-of-file on the stream tailing its logs.  This will be:\n+    // 1) After close() for jobs that stop gracefully\n+    // 2) After kill() for jobs that are forcefully terminated\n+    // 3) After a simulated crash when we test simulated crash\n+    private CountDownLatch mockNativeProcessLoggingStreamEnds = new CountDownLatch(1);", "originalCommit": "1290e5bf3a72881a70e0c2362d91dcd565eaed18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "88850b16c168e6d7fa0396a804144481c436177f", "url": "https://github.com/elastic/elasticsearch/commit/88850b16c168e6d7fa0396a804144481c436177f", "message": "Address review comments", "committedDate": "2020-05-15T08:07:37Z", "type": "commit"}]}