{"pr_number": 55982, "pr_title": "Handle merging dotted object names when merging V2 template mappings", "pr_createdAt": "2020-04-29T21:21:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55982", "timeline": [{"oid": "f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "url": "https://github.com/elastic/elasticsearch/commit/f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "message": "Handle merging dotted object names when merging V2 template mappings\n\nWhen merging component template, index template, and request mappings, we now treat any declaration\nof a top-level field the same as replacing all sub-objects. For example, assuming two component\ntemplates with mappings and template B taking precedence:\n\n```\nA: {foo: {...}}\nB: {foo.bar: {...}}\nResult: {foo.bar: {...}}\n\nA: {foo.bar: {...}}\nB: {foo: {...}}\nResult: {foo: {...}}\n\nA: {foo.bar: {...}}\nB: {foo.baz: {...}}\nResult: {foo.baz: {...}}\n```\n\nRelates to #53101", "committedDate": "2020-04-29T20:48:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg1ODA0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55982#discussion_r417858043", "bodyText": "If I understand this correctly it can be simplified:\nstatic Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {\n    Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\n    Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\n    Map<String, Object> results = new HashMap<>(first);\n    Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n    results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\n    results.putAll(second);\n    return results;\n}\n\nprivate static String prefix(String s) {\n    return s.split(\"\\\\.\", 2)[0];\n}", "author": "probakowski", "createdAt": "2020-04-30T08:54:38Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -596,6 +597,52 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n         return Collections.singletonMap(MapperService.SINGLE_MAPPING_NAME, finalMappings);\n     }\n \n+    /**\n+     * Add the objects in the second map to the first, where the keys in the {@code second} map have\n+     * higher predecence and overwrite the keys in the {@code first} map. In the event of a key with\n+     * a dot in it (ie, \"foo.bar\"), the keys are treated as only the prefix counting towards\n+     * equality. If the {@code second} map has a key such as \"foo\", all keys starting from \"foo.\" in\n+     * the {@code first} map are discarded.\n+     */\n+    static Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {", "originalCommit": "f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MzcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/55982#discussion_r418053713", "bodyText": "Sounds good, that works and passes the tests, updated the function.", "author": "dakrone", "createdAt": "2020-04-30T14:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg1ODA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6a08f44a277323999aca45db01b9052916f5f432", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\nindex 5581782085d..75fa66585c4 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n\n@@ -608,41 +608,16 @@ public class MetadataCreateIndexService {\n         Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\n         Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\n         Map<String, Object> results = new HashMap<>(first);\n-        Set<String> firstKeys = first.keySet();\n-        for (String secondKey : second.keySet()) {\n-\n-            // First, ensure that we remove any exact duplicate keys (field names), because the\n-            // \"second\" map's values are going to take precedence\n-            if (firstKeys.contains(secondKey)) {\n-                results.remove(secondKey);\n-            }\n-\n-            // If the \"second\" key has a dot, remove all keys that share the prefix, so if it were\n-            // \"foo.bar\" this removes the \"foo\" key as well as all keys starting with \"foo.\"\n-            if (secondKey.indexOf(\".\") > 0) {\n-                String secondKeyPrefix = secondKey.substring(0, secondKey.indexOf(\".\")).toLowerCase(Locale.ROOT);\n-                for (String key : firstKeys) {\n-                    String lowercaseKey = key.toLowerCase(Locale.ROOT);\n-                    if (lowercaseKey.equals(secondKeyPrefix) || lowercaseKey.startsWith(secondKeyPrefix + \".\")) {\n-                        results.remove(key);\n-                    }\n-                }\n-            } else {\n-                // If the \"second\" key doesn't have a dot, remove all the keys that share the same\n-                // exact prefix, for example, if the \"second\" key were \"foo\" this removes \"foo.bar\"\n-                // \"foo.baz.eggplant\", etc\n-                for (String key : firstKeys) {\n-                    int dotIndex = key.indexOf(\".\");\n-                    if (dotIndex == secondKey.length() && key.substring(0, dotIndex).toLowerCase(Locale.ROOT).equals(secondKey)) {\n-                        results.remove(key);\n-                    }\n-                }\n-            }\n-            results.put(secondKey, second.get(secondKey));\n-        }\n+        Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n+        results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\n+        results.putAll(second);\n         return results;\n     }\n \n+    private static String prefix(String s) {\n+        return s.split(\"\\\\.\", 2)[0];\n+    }\n+\n     /**\n      * Parses the provided mappings json and the inheritable mappings from the templates (if any)\n      * into a map.\n"}}, {"oid": "6a08f44a277323999aca45db01b9052916f5f432", "url": "https://github.com/elastic/elasticsearch/commit/6a08f44a277323999aca45db01b9052916f5f432", "message": "Use simplified function", "committedDate": "2020-04-30T14:29:29Z", "type": "commit"}]}