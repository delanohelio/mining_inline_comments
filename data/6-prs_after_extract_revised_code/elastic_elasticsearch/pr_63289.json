{"pr_number": 63289, "pr_title": "Add support for histogram fields to rate aggregation", "pr_createdAt": "2020-10-05T21:39:58Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63289", "timeline": [{"oid": "26085c5878b5e0784be23dacfe14853394e0de78", "url": "https://github.com/elastic/elasticsearch/commit/26085c5878b5e0784be23dacfe14853394e0de78", "message": "Add support for histogram fields to rate aggregation\n\nThe rate aggregation now supports histogram fields. At the moment only sum\nis supported. The value count mode will be added as a follow up.\n\nCloses #60674", "committedDate": "2020-10-05T21:37:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNjI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/63289#discussion_r500316299", "bodyText": "Rather than using an instanceof check and having one aggregator that supports both ValuesSourceTypes, we should create a new aggregator for histogram types, and add a second mapping in the register aggregators method on the factory.", "author": "not-napoleon", "createdAt": "2020-10-06T14:11:09Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/RateAggregator.java", "diffHunk": "@@ -78,33 +81,53 @@ public ScoreMode scoreMode() {\n     @Override\n     public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {\n         final BigArrays bigArrays = context.bigArrays();\n-        final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx);\n         final CompensatedSum kahanSummation = new CompensatedSum(0, 0);\n-\n-        return new LeafBucketCollectorBase(sub, values) {\n-            @Override\n-            public void collect(int doc, long bucket) throws IOException {\n-                sums = bigArrays.grow(sums, bucket + 1);\n-                compensations = bigArrays.grow(compensations, bucket + 1);\n-\n-                if (values.advanceExact(doc)) {\n-                    final int valuesCount = values.docValueCount();\n-                    // Compute the sum of double values with Kahan summation algorithm which is more\n-                    // accurate than naive summation.\n-                    double sum = sums.get(bucket);\n-                    double compensation = compensations.get(bucket);\n-                    kahanSummation.reset(sum, compensation);\n-\n-                    for (int i = 0; i < valuesCount; i++) {\n-                        double value = values.nextValue();\n-                        kahanSummation.add(value);\n+        if (valuesSource instanceof HistogramValuesSource.Histogram) {", "originalCommit": "26085c5878b5e0784be23dacfe14853394e0de78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM1NTYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/63289#discussion_r500355608", "bodyText": "Oh, didn't think about that! Great idea.", "author": "imotov", "createdAt": "2020-10-06T14:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNjI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2791eb91d1e2325cd4fd2a6ab70765882d834f09", "chunk": "diff --git a/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/RateAggregator.java b/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/AbstractRateAggregator.java\nsimilarity index 50%\nrename from x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/RateAggregator.java\nrename to x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/AbstractRateAggregator.java\nindex 60a8f6bcd31..937e9257030 100644\n--- a/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/RateAggregator.java\n+++ b/x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/AbstractRateAggregator.java\n\n@@ -78,58 +69,6 @@ public class RateAggregator extends NumericMetricsAggregator.SingleValue {\n         return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n     }\n \n-    @Override\n-    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {\n-        final BigArrays bigArrays = context.bigArrays();\n-        final CompensatedSum kahanSummation = new CompensatedSum(0, 0);\n-        if (valuesSource instanceof HistogramValuesSource.Histogram) {\n-            final HistogramValues values = ((HistogramValuesSource.Histogram)valuesSource).getHistogramValues(ctx);\n-            return new LeafBucketCollectorBase(sub, values) {\n-                @Override public void collect(int doc, long bucket) throws IOException {\n-                    sums = bigArrays.grow(sums, bucket + 1);\n-                    compensations = bigArrays.grow(compensations, bucket + 1);\n-\n-                    if (values.advanceExact(doc)) {\n-                        final HistogramValue sketch = values.histogram();\n-                        while (sketch.next()) {\n-                            double sum = sums.get(bucket);\n-                            double compensation = compensations.get(bucket);\n-                            kahanSummation.reset(sum, compensation);\n-                            kahanSummation.add(sketch.value());\n-                            compensations.set(bucket, kahanSummation.delta());\n-                            sums.set(bucket, kahanSummation.value());\n-                        }\n-                    }\n-                }\n-            };\n-        } else {\n-            final SortedNumericDoubleValues values = ((ValuesSource.Numeric)valuesSource).doubleValues(ctx);\n-            return new LeafBucketCollectorBase(sub, values) {\n-                @Override public void collect(int doc, long bucket) throws IOException {\n-                    sums = bigArrays.grow(sums, bucket + 1);\n-                    compensations = bigArrays.grow(compensations, bucket + 1);\n-\n-                    if (values.advanceExact(doc)) {\n-                        final int valuesCount = values.docValueCount();\n-                        // Compute the sum of double values with Kahan summation algorithm which is more\n-                        // accurate than naive summation.\n-                        double sum = sums.get(bucket);\n-                        double compensation = compensations.get(bucket);\n-                        kahanSummation.reset(sum, compensation);\n-\n-                        for (int i = 0; i < valuesCount; i++) {\n-                            double value = values.nextValue();\n-                            kahanSummation.add(value);\n-                        }\n-\n-                        compensations.set(bucket, kahanSummation.delta());\n-                        sums.set(bucket, kahanSummation.value());\n-                    }\n-                }\n-            };\n-        }\n-    }\n-\n     @Override\n     public double metric(long owningBucketOrd) {\n         if (sizedBucketAggregator == null || valuesSource == null || owningBucketOrd >= sums.size()) {\n"}}, {"oid": "011b2c9c7f53350d786304c84a6c4793ffded73c", "url": "https://github.com/elastic/elasticsearch/commit/011b2c9c7f53350d786304c84a6c4793ffded73c", "message": "Merge remote-tracking branch 'elastic/master' into issue-62939-add-rate-support-for-histogram-fields", "committedDate": "2020-10-07T18:12:56Z", "type": "commit"}, {"oid": "2791eb91d1e2325cd4fd2a6ab70765882d834f09", "url": "https://github.com/elastic/elasticsearch/commit/2791eb91d1e2325cd4fd2a6ab70765882d834f09", "message": "Split RateAggregator into type specific classes", "committedDate": "2020-10-07T19:41:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyMTkyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/63289#discussion_r501821929", "bodyText": "I think this is fine, but just for the sake of mentioning options, we could push getting the values source into the concrete subclasses and do the cast in the constructor, rather than at access time in the leaf reader.", "author": "not-napoleon", "createdAt": "2020-10-08T15:41:38Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/AbstractRateAggregator.java", "diffHunk": "@@ -46,7 +40,7 @@ public RateAggregator(\n         Map<String, Object> metadata\n     ) throws IOException {\n         super(name, context, parent, metadata);\n-        this.valuesSource = (ValuesSource.Numeric) valuesSourceConfig.getValuesSource();\n+        this.valuesSource = valuesSourceConfig.getValuesSource();", "originalCommit": "2791eb91d1e2325cd4fd2a6ab70765882d834f09", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNDcxOA==", "url": "https://github.com/elastic/elasticsearch/pull/63289#discussion_r501824718", "bodyText": "Is it a BWC break that we're dropping boolean here?", "author": "not-napoleon", "createdAt": "2020-10-08T15:45:30Z", "path": "x-pack/plugin/analytics/src/main/java/org/elasticsearch/xpack/analytics/rate/RateAggregatorFactory.java", "diffHunk": "@@ -44,15 +45,21 @@\n     static void registerAggregators(ValuesSourceRegistry.Builder builder) {\n         builder.register(\n             RateAggregationBuilder.REGISTRY_KEY,\n-            List.of(CoreValuesSourceType.NUMERIC, CoreValuesSourceType.BOOLEAN),\n-            RateAggregator::new,\n+            Collections.singletonList(CoreValuesSourceType.NUMERIC),", "originalCommit": "2791eb91d1e2325cd4fd2a6ab70765882d834f09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzNjQzMA==", "url": "https://github.com/elastic/elasticsearch/pull/63289#discussion_r501836430", "bodyText": "Technically, yes. But this behavior was never documented, and it doesn't make any sense in this context. I am not even sure what would be an interpretation of this number in case of boolean field.", "author": "imotov", "createdAt": "2020-10-08T16:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNDcxOA=="}], "type": "inlineReview", "revised_code": null}]}