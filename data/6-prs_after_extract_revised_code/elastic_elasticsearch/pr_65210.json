{"pr_number": 65210, "pr_title": "Make document parsing aware of runtime fields", "pr_createdAt": "2020-11-18T15:26:41Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65210", "timeline": [{"oid": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "url": "https://github.com/elastic/elasticsearch/commit/4a871ffa32c0affe92d60b38dbf08990c89b7800", "message": "Make document parsing aware of runtime fields\n\nRuntime fields are defined in a separate runtime section in the mappings. Since the runtime section was introduced, runtime fields are not taken into account when parsing documents. That means that if a document gets indexed that holds a field that's already defined as a runtime field, the field gets dynamically mapped as a concrete field although it will always be shadowed by the runtime field defined with the same name.\n\nA more sensible default would be to instead consider runtime fields like ordinary mapped fields, so a dynamic update is not necessary whenever a field is defined as part of the runtime section. As a consequence, the field does not get indexed. If users prefer to keep indexing the field although it is shadowed, we consider this an exception, and they can do so by mapping the field under properties explicitly.\n\nRelates to #62906", "committedDate": "2020-11-18T15:24:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526176644", "bodyText": "It is quite a shame to have to define all these methods (not all of them are abstract but I wanted to make sure that none of them is called), as only two are effectively needed: parseCreateField and copyTo.", "author": "javanna", "createdAt": "2020-11-18T15:27:41Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {", "originalCommit": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NDA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526194071", "bodyText": "It is, but \ud83e\udd37. I think there are worse things.", "author": "nik9000", "createdAt": "2020-11-18T15:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1OTEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526759106", "bodyText": "Yeah it would be nice to somehow build an interface here but I can't see how that would easily work with ObjectMappers.  For the future.", "author": "romseygeek", "createdAt": "2020-11-19T10:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NjY0NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MjY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526192670", "bodyText": "When we hit this file with the formatter one day it'll make this look like garbage. Would you be ok running the formatter on this now and playing with the output some to make it look ok when the formatter runs?", "author": "nik9000", "createdAt": "2020-11-18T15:47:19Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -59,20 +60,50 @@\n         return List.of(new DocumentParserTestsPlugin(), new TestRuntimeField.Plugin());\n     }\n \n-    public void testDynamicUpdateWithRuntimeField() throws Exception {\n+    public void testParseWithRuntimeField() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n-        ParsedDocument doc = mapper.parse(source(b -> b.field(\"test\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"test\"));\n+        ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n+        //field defined as runtime field but not under properties: no dynamic updates, the field does not get indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNull(doc.rootDoc().getField(\"field\"));\n     }\n \n-    public void testDynamicUpdateWithRuntimeFieldSameName() throws Exception {\n-        DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n+    public void testParseWithShadowedField() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n+                .endObject()\n+            .endObject().endObject();", "originalCommit": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2MDg0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526760847", "bodyText": "You can do something like:\ncreateDocumentMapper(topMapping(b -> {\n    b.startObject(\"runtime\");\n    {\n        b.startObject(\"field\").field(\"type\", \"test\").endObject();\n    }\n    b.endObject();\n    b.startObject(\"properties\");\n    {\n        b.startObject(\"field\").field(\"type\", \"keyword\").endObject();\n    }\n    b.endObject();\n});\n\nKeeps the formatter happy and there's a bit less ceremony around builders.", "author": "romseygeek", "createdAt": "2020-11-19T10:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MjY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java b/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\nindex 738d9667491..ca9eb5598b3 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\n\n@@ -69,15 +69,13 @@ public class DocumentParserTests extends MapperServiceTestCase {\n     }\n \n     public void testParseWithShadowedField() throws Exception {\n-        XContentBuilder builder = XContentFactory.jsonBuilder()\n-            .startObject().startObject(\"_doc\")\n-                .startObject(\"runtime\")\n-                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n-                .endObject()\n-                .startObject(\"properties\")\n-                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n-                .endObject()\n-            .endObject().endObject();\n+        XContentBuilder builder = XContentFactory.jsonBuilder().startObject().startObject(\"_doc\");\n+        builder.startObject(\"runtime\");\n+        builder.startObject(\"field\").field(\"type\", \"test\").endObject();\n+        builder.endObject();\n+        builder.startObject(\"properties\");\n+        builder.startObject(\"field\").field(\"type\", \"keyword\").endObject();\n+        builder.endObject().endObject().endObject();\n \n         DocumentMapper mapper = createDocumentMapper(builder);\n         ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NjEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526196100", "bodyText": "What happens if enabled isn't set? I think we should continue to do nothing if enabled is actually true.", "author": "nik9000", "createdAt": "2020-11-18T15:51:37Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java", "diffHunk": "@@ -59,20 +60,50 @@\n         return List.of(new DocumentParserTestsPlugin(), new TestRuntimeField.Plugin());\n     }\n \n-    public void testDynamicUpdateWithRuntimeField() throws Exception {\n+    public void testParseWithRuntimeField() throws Exception {\n         DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n-        ParsedDocument doc = mapper.parse(source(b -> b.field(\"test\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"test\"));\n+        ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n+        //field defined as runtime field but not under properties: no dynamic updates, the field does not get indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNull(doc.rootDoc().getField(\"field\"));\n     }\n \n-    public void testDynamicUpdateWithRuntimeFieldSameName() throws Exception {\n-        DocumentMapper mapper = createDocumentMapper(runtimeFieldMapping(b -> b.field(\"type\", \"test\")));\n+    public void testParseWithShadowedField() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n+                .endObject()\n+            .endObject().endObject();\n+\n+        DocumentMapper mapper = createDocumentMapper(builder);\n         ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n-        RootObjectMapper root = doc.dynamicMappingsUpdate().root;\n-        assertEquals(0, root.runtimeFieldTypes().size());\n-        assertNotNull(root.getMapper(\"field\"));\n+        //field defined as runtime field as well as under properties: no dynamic updates, the field gets indexed\n+        assertNull(doc.dynamicMappingsUpdate());\n+        assertNotNull(doc.rootDoc().getField(\"field\"));\n+    }\n+\n+    public void testParseWithRuntimeFieldDottedNameDisabledObject() throws Exception {\n+        XContentBuilder builder = XContentFactory.jsonBuilder()\n+            .startObject().startObject(\"_doc\")\n+                .startObject(\"runtime\")\n+                    .startObject(\"path1.path2.path3.field\").field(\"type\", \"test\").endObject()\n+                .endObject()\n+                .startObject(\"properties\")\n+                    .startObject(\"path1\").field(\"type\", \"object\").field(\"enabled\", false).endObject()", "originalCommit": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwOTQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526209478", "bodyText": "look at the test below for dynamic mappings. We map the objects but not the leaves. I agree it is debatable. The point is the objects get mapped the first time they are seen regardless of what they hold. For instance if you index a doc with an empty object, the object still gets mapped, which makes me think that it is the correct behaviour to map objects under properties as they may hold concrete fields in the future.\nOn the other hand, when we introduce the dynamic:runtime mode, given that everything is runtime we may not want to create objects under properties at all.", "author": "javanna", "createdAt": "2020-11-18T16:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NjEwMA=="}], "type": "inlineReview", "revised_code": {"commit": "e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java b/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\nindex 738d9667491..ca9eb5598b3 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/DocumentParserTests.java\n\n@@ -69,15 +69,13 @@ public class DocumentParserTests extends MapperServiceTestCase {\n     }\n \n     public void testParseWithShadowedField() throws Exception {\n-        XContentBuilder builder = XContentFactory.jsonBuilder()\n-            .startObject().startObject(\"_doc\")\n-                .startObject(\"runtime\")\n-                  .startObject(\"field\").field(\"type\", \"test\").endObject()\n-                .endObject()\n-                .startObject(\"properties\")\n-                  .startObject(\"field\").field(\"type\", \"keyword\").endObject()\n-                .endObject()\n-            .endObject().endObject();\n+        XContentBuilder builder = XContentFactory.jsonBuilder().startObject().startObject(\"_doc\");\n+        builder.startObject(\"runtime\");\n+        builder.startObject(\"field\").field(\"type\", \"test\").endObject();\n+        builder.endObject();\n+        builder.startObject(\"properties\");\n+        builder.startObject(\"field\").field(\"type\", \"keyword\").endObject();\n+        builder.endObject().endObject().endObject();\n \n         DocumentMapper mapper = createDocumentMapper(builder);\n         ParsedDocument doc = mapper.parse(source(b -> b.field(\"field\", \"value\")));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjMwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526236306", "bodyText": "Is this going to cause problems if there is a dynamic mapper added elsewhere?  Let's say we send a document with two fields, one of which gets mapped by the dynamic template as a keyword, and the other as a runtime field. In that case, there will be a call back to the master with the new Mapping which will contain the new dynamic mapper, plus this NoOpFieldMapper, and it will blow up when we try to serialize it I think?", "author": "romseygeek", "createdAt": "2020-11-18T16:41:25Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java", "diffHunk": "@@ -900,6 +905,93 @@ private static Mapper getMapper(final ParseContext context, ObjectMapper objectM\n                         + mapper.name() + \"]\");\n             }\n         }\n-        return objectMapper.getMapper(subfields[subfields.length - 1]);\n+        String leafName = subfields[subfields.length - 1];\n+        mapper = objectMapper.getMapper(leafName);\n+        if (mapper != null) {\n+            return mapper;\n+        }\n+        //concrete fields take the precedence over runtime fields when parsing documents, though when a field is defined as runtime field\n+        //only, and not under properties, it is ignored when it is sent as part of _source\n+        RuntimeFieldType runtimeFieldType = context.docMapper().mapping().root.getRuntimeFieldType(fieldPath);\n+        if (runtimeFieldType != null) {\n+            return new NoOpFieldMapper(leafName, runtimeFieldType);\n+        }\n+        return null;\n+    }\n+\n+    private static class NoOpFieldMapper extends FieldMapper {\n+        NoOpFieldMapper(String simpleName, RuntimeFieldType runtimeField) {\n+            super(simpleName, new MappedFieldType(runtimeField.name(), false, false, false, TextSearchInfo.NONE, Collections.emptyMap()) {\n+                @Override\n+                public ValueFetcher valueFetcher(QueryShardContext context, SearchLookup searchLookup, String format) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String typeName() {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public Query termQuery(Object value, QueryShardContext context) {\n+                    throw new UnsupportedOperationException();\n+                }\n+            }, MultiFields.empty(), CopyTo.empty());\n+        }\n+\n+        @Override\n+        protected void parseCreateField(ParseContext context) throws IOException {\n+            //field defined as runtime field, don't index anything\n+        }\n+\n+        @Override\n+        public String name() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MappedFieldType fieldType() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MultiFields multiFields() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Iterator<Mapper> iterator() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void doValidate(MappingLookup mappers) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void checkIncomingMergeType(FieldMapper mergeWith) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Builder getMergeBuilder() {\n+            throw new UnsupportedOperationException();\n+        }", "originalCommit": "4a871ffa32c0affe92d60b38dbf08990c89b7800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1MDc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526250749", "bodyText": "I don't think so because the purpose of the no-op mapper at the moment is only to be used when parsing a document. It is not added to the dynamic mappers. Actually, its purpose is solely not to cause a dynamic mapping update. Keep me honest though :)", "author": "javanna", "createdAt": "2020-11-18T16:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1OTM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65210#discussion_r526759361", "bodyText": "Gotcha, I had misunderstood where we were creating these.", "author": "romseygeek", "createdAt": "2020-11-19T10:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzNjMwNg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "url": "https://github.com/elastic/elasticsearch/commit/e6ce5a89c5f1bec8926ca2c8b14238f3a20fbe95", "message": "formatting", "committedDate": "2020-11-19T11:14:46Z", "type": "commit"}, {"oid": "542fa16bab08bd936ec62cdee804b9a72a3d290a", "url": "https://github.com/elastic/elasticsearch/commit/542fa16bab08bd936ec62cdee804b9a72a3d290a", "message": "Merge branch 'master' into enhancement/runtime_fields_document_parsing", "committedDate": "2020-11-19T12:33:20Z", "type": "commit"}, {"oid": "40ff98662625260ca0ff79d8a1a7349f2022cd82", "url": "https://github.com/elastic/elasticsearch/commit/40ff98662625260ca0ff79d8a1a7349f2022cd82", "message": "more tests", "committedDate": "2020-11-19T12:56:28Z", "type": "commit"}]}