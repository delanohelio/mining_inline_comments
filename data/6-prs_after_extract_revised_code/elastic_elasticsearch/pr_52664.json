{"pr_number": 52664, "pr_title": "EQL: Expand verification tests", "pr_createdAt": "2020-02-21T21:17:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52664", "timeline": [{"oid": "f12b5f98900dd1ae95478e2f579f31a2a3f39bd6", "url": "https://github.com/elastic/elasticsearch/commit/f12b5f98900dd1ae95478e2f579f31a2a3f39bd6", "message": "EQL: Expand verification tests\n\nFix some error messaging consistency in EqlParser\n\nRelated to https://github.com/elastic/elasticsearch/issues/51873", "committedDate": "2020-02-21T21:12:56Z", "type": "commit"}, {"oid": "30b29463dd4ac494a99207b6557525316a537532", "url": "https://github.com/elastic/elasticsearch/commit/30b29463dd4ac494a99207b6557525316a537532", "message": "Merge branch 'master' into feature/eql_verification_expanded", "committedDate": "2020-02-21T22:06:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383126914", "bodyText": "Single line, please.", "author": "astefan", "createdAt": "2020-02-24T08:21:59Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");", "originalCommit": "30b29463dd4ac494a99207b6557525316a537532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3ODkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383278937", "bodyText": "will update", "author": "aleksmaus", "createdAt": "2020-02-24T13:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "948f45835e36acde9d2807b556199fcc8315a6cf", "chunk": "diff --git a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\nindex 7c378605cd3..57396b7340d 100644\n--- a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n+++ b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n\n@@ -117,7 +117,6 @@ public class VerifierTests extends ESTestCase {\n     }\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n-    // TODO (@costin): Should we make the error messaging consistent?\n     public void testFunctionParsingUnknown() {\n         assertEquals(\"1:15: Unknown function [matchLite]\",\n                 errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzQ0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383127446", "bodyText": "Please, remove extra empty line.", "author": "astefan", "createdAt": "2020-02-24T08:23:41Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+", "originalCommit": "30b29463dd4ac494a99207b6557525316a537532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI1OTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383259948", "bodyText": "I kind of liked the one line visual separation between successful and failure cases in here", "author": "aleksmaus", "createdAt": "2020-02-24T13:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MTAwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383261001", "bodyText": "This empty line is at the end of the method, before the closing } bracket...", "author": "astefan", "createdAt": "2020-02-24T13:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3OTEwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383279105", "bodyText": "will fix", "author": "aleksmaus", "createdAt": "2020-02-24T13:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "948f45835e36acde9d2807b556199fcc8315a6cf", "chunk": "diff --git a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\nindex 7c378605cd3..57396b7340d 100644\n--- a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n+++ b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n\n@@ -117,7 +117,6 @@ public class VerifierTests extends ESTestCase {\n     }\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n-    // TODO (@costin): Should we make the error messaging consistent?\n     public void testFunctionParsingUnknown() {\n         assertEquals(\"1:15: Unknown function [matchLite]\",\n                 errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzgyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383127827", "bodyText": "I think this error message is wrong, unless EQL plans to support MATCH/QUERY predicates.", "author": "astefan", "createdAt": "2020-02-24T08:24:56Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+\n+    }\n+\n+    public void testNested() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nested.json\");\n+        accept(idxr, \"foo where processes.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [processe.pid], did you mean any of [processes.pid, processes.path, processes.path.keyword]?\",\n+                error(idxr, \"foo where processe.pid == 0\"));\n+    }\n+\n+    public void testGeo() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-geo.json\");\n+        assertEquals(\"1:11: Cannot use field [location] with unsupported type [geo_point]\",\n+                error(idxr, \"foo where location == 0\"));\n+        assertEquals(\"1:11: Cannot use field [site] with unsupported type [geo_shape]\",\n+                error(idxr, \"foo where site == 0\"));\n+    }\n+\n+    public void testIP() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-ip.json\");\n+        accept(idxr, \"foo where ip_addr == 0\");\n+    }\n+\n+    public void testJoin() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-join.json\");\n+        accept(idxr, \"foo where serial_event_id == 0\");\n+    }\n+\n+    public void testMultiField() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-multi-field.json\");\n+        accept(idxr, \"foo where multi_field.raw == 'bar'\");\n+\n+        assertEquals(\"1:11: [multi_field.english == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [english]; define one or use MATCH/QUERY instead\",", "originalCommit": "30b29463dd4ac494a99207b6557525316a537532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MDUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383260500", "bodyText": "@costin", "author": "aleksmaus", "createdAt": "2020-02-24T13:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3Njc4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383276786", "bodyText": "@aleksmaus please raise an issue and mark it as discuss to get consensus about how we deal with exact matches on analyzed fields - whether we prevent any exact comparison against them or introduce some other type of comparison (inexact matches - say ~=).", "author": "costin", "createdAt": "2020-02-24T13:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNzgyNw=="}], "type": "inlineReview", "revised_code": {"commit": "948f45835e36acde9d2807b556199fcc8315a6cf", "chunk": "diff --git a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\nindex 7c378605cd3..57396b7340d 100644\n--- a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n+++ b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n\n@@ -117,7 +117,6 @@ public class VerifierTests extends ESTestCase {\n     }\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n-    // TODO (@costin): Should we make the error messaging consistent?\n     public void testFunctionParsingUnknown() {\n         assertEquals(\"1:15: Unknown function [matchLite]\",\n                 errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyODAwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383128003", "bodyText": "Same here about MATCH/QUERY predicates.", "author": "astefan", "createdAt": "2020-02-24T08:25:26Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java", "diffHunk": "@@ -58,8 +81,280 @@ public void testMisspelledColumnWithMultipleOptions() {\n         assertEquals(\"1:11: Unknown column [pib], did you mean any of [pid, ppid]?\", error(\"foo where pib == 1\"));\n     }\n \n+    public void testPipesUnsupported() {\n+        assertEquals(\"1:20: Pipes are not supported\", errorParsing(\"process where true | head 6\"));\n+    }\n \n-    private static Map<String, EsField> loadEqlMapping(String name) {\n-        return TypesTests.loadMapping(name);\n+    public void testProcessRelationshipsUnsupported() {\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where opcode=1 and process_name == \\\"csrss.exe\\\"\\n\" +\n+                        \"  and descendant of [file where file_name == \\\"csrss.exe\\\" and opcode=0]\"));\n+        assertEquals(\"2:7: Process relationships are not supported\",\n+                errorParsing(\"process where process_name=\\\"svchost.exe\\\"\\n\" +\n+                        \"  and child of [file where file_name=\\\"svchost.exe\\\" and opcode=0]\"));\n+    }\n+\n+    public void testSequencesUnsupported() {\n+        assertEquals(\"1:1: Sequence is not supported\", errorParsing(\"sequence\\n\" +\n+                \"  [process where serial_event_id = 1]\\n\" +\n+                \"  [process where serial_event_id = 2]\"));\n+    }\n+\n+    public void testJoinUnsupported() {\n+        assertEquals(\"1:1: Join is not supported\", errorParsing(\"join by user_name\\n\" +\n+                \"  [process where opcode in (1,3) and process_name=\\\"smss.exe\\\"]\\n\" +\n+                \"  [process where opcode in (1,3) and process_name == \\\"python.exe\\\"]\"));\n+    }\n+\n+    // Some functions fail with \"Unsupported\" message at the parse stage\n+    public void testArrayFunctionsUnsupported() {\n+        assertEquals(\"1:16: Unsupported function [arrayContains]\",\n+                errorParsing(\"registry where arrayContains(bytes_written_string_list, 'En')\"));\n+        assertEquals(\"1:16: Unsupported function [arraySearch]\",\n+                errorParsing(\"registry where arraySearch(bytes_written_string_list, a, a == 'en-us')\"));\n+        assertEquals(\"1:16: Unsupported function [arrayCount]\",\n+                errorParsing(\"registry where arrayCount(bytes_written_string_list, s, s == '*-us') == 1\"));\n+    }\n+\n+    // Some functions fail with \"Unknown\" message at the parse stage\n+    // TODO (@costin): Should we make the error messaging consistent?\n+    public void testFunctionParsingUnknown() {\n+        assertEquals(\"1:15: Unknown function [matchLite]\",\n+                errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n+        assertEquals(\"1:15: Unknown function [safe]\",\n+                errorParsing(\"network where safe(divide(process_name, process_name))\"));\n+    }\n+\n+    // Test the known EQL functions that are not supported\n+    public void testFunctionVerificationUnknown() {\n+        assertEquals(\"1:26: Unknown function [substring]\",\n+                error(\"foo where user_domain == substring('abcdfeg', 0, 5)\"));\n+        assertEquals(\"1:25: Unknown function [endsWith]\",\n+                error(\"file where opcode=0 and endsWith(file_name, 'loREr.exe')\"));\n+        assertEquals(\"1:25: Unknown function [startsWith]\",\n+                error(\"file where opcode=0 and startsWith(file_name, 'explORER.EXE')\"));\n+        assertEquals(\"1:25: Unknown function [stringContains]\",\n+                error(\"file where opcode=0 and stringContains('ABCDEFGHIexplorer.exeJKLMNOP', file_name)\"));\n+        assertEquals(\"1:25: Unknown function [indexOf]\",\n+                error(\"file where opcode=0 and indexOf(file_name, 'plore') == 2\"));\n+        assertEquals(\"1:15: Unknown function [add]\",\n+                error(\"process where add(serial_event_id, 0) == 1\"));\n+        assertEquals(\"1:15: Unknown function [subtract]\",\n+                error(\"process where subtract(serial_event_id, -5) == 6\"));\n+        assertEquals(\"1:15: Unknown function [multiply]\",\n+                error(\"process where multiply(6, serial_event_id) == 30\"));\n+        assertEquals(\"1:15: Unknown function [divide]\",\n+                error(\"process where divide(30, 4.0) == 7.5\"));\n+        assertEquals(\"1:34: Unknown function [number]\",\n+                error(\"process where serial_event_id == number('5')\"));\n+        assertEquals(\"1:15: Unknown function [concat]\",\n+                error(\"process where concat(serial_event_id, ':', process_name, opcode) == '5:winINIT.exe3'\"));\n+        assertEquals(\"1:15: Unknown function [between]\",\n+                error(\"process where between(process_name, \\\"s\\\", \\\"e\\\") == \\\"yst\\\"\"));\n+        assertEquals(\"1:15: Unknown function [cidrMatch]\",\n+                error(\"network where cidrMatch(source_address, \\\"192.168.0.0/16\\\", \\\"10.6.48.157/8\\\")\"));\n+        assertEquals(\"1:22: Unknown function [between]\",\n+                error(\"process where length(between(process_name, 'g', 'e')) > 0\"));\n+    }\n+\n+    // Test unsupported array indexes\n+    public void testArrayIndexesUnsupported() {\n+        assertEquals(\"1:84: Array indexes are not supported\",\n+                errorParsing(\"registry where length(bytes_written_string_list) > 0 and bytes_written_string_list[0] == 'EN-us\"));\n+    }\n+\n+    // Test valid/supported queries\n+    public void testQueryOk() {\n+        // Mismatched type, still ok\n+        accept(\"process where serial_event_id = 'abcdef'\");\n+\n+        // Equals condition\n+        accept(\"process where serial_event_id = 1\");\n+\n+        // Less then condition\n+        accept(\"process where serial_event_id < 4\");\n+\n+        // Greater than\n+        accept(\"process where exit_code > -1\");\n+        accept(\"process where -1 < exit_code\");\n+\n+        // Or and And/And Not\n+        accept(\"process where process_name == \\\"impossible name\\\" or (serial_event_id < 4.5 and serial_event_id >= 3.1)\");\n+        accept(\"process where (serial_event_id<=8 and not serial_event_id > 7) and (opcode=3 and opcode>2)\");\n+\n+        // In statement\n+        accept(\"process where not (exit_code > -1)\\n\" +\n+                \"  and serial_event_id in (58, 64, 69, 74, 80, 85, 90, 93, 94)\");\n+\n+        // Combination\n+        accept(\"file where serial_event_id == 82 and (true == (process_name in ('svchost.EXE', 'bad.exe', 'bad2.exe')))\");\n+\n+        // String handling\n+        accept(\"process where process_path == \\\"*\\\\\\\\MACHINE\\\\\\\\SAM\\\\\\\\SAM\\\\\\\\*\\\\\\\\Account\\\\\\\\Us*ers\\\\\\\\00*03E9\\\\\\\\F\\\"\");\n+\n+        // Arithmetic operators\n+        accept(\"file where serial_event_id - 1 == 81\");\n+        accept(\"file where serial_event_id + 1 == 83\");\n+        accept(\"file where serial_event_id * 2 == 164\");\n+        accept(\"file where serial_event_id / 2 == 41\");\n+        accept(\"file where serial_event_id % 40 == 2\");\n+    }\n+\n+    // Test mapping that doesn't have property event_type defined\n+    public void testMissingEventType() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-missing-event-type.json\");\n+        assertEquals(\"1:1: Unknown column [event_type]\", error(idxr, \"foo where true\"));\n+    }\n+\n+    public void testAliasErrors() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-alias.json\");\n+\n+        // Check unsupported\n+        assertEquals(\"1:11: Cannot use field [user_name_alias] with unsupported type [alias]\",\n+                error(idxr, \"foo where user_name_alias == 'bob'\"));\n+\n+        // Check alias name typo\n+        assertEquals(\"1:11: Unknown column [user_name_alia], did you mean any of [user_name, user_domain]?\",\n+                error(idxr, \"foo where user_name_alia == 'bob'\"));\n+    }\n+\n+    // Test all elasticsearch numeric field types\n+    public void testNumeric() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-numeric.json\");\n+        accept(idxr, \"foo where long_field == 0\");\n+        accept(idxr, \"foo where integer_field == \" +\n+                \"0\");\n+        accept(idxr, \"foo where short_field == 0\");\n+        accept(idxr, \"foo where byte_field == 0\");\n+        accept(idxr, \"foo where double_field == 0\");\n+        accept(idxr, \"foo where float_field == 0\");\n+        accept(idxr, \"foo where half_float_field == 0\");\n+        accept(idxr, \"foo where scaled_float_field == 0\");\n+\n+        // Test query against unsupported field type int\n+        assertEquals(\"1:11: Cannot use field [wrong_int_type_field] with unsupported type [int]\",\n+                error(idxr, \"foo where wrong_int_type_field == 0\"));\n+    }\n+\n+    public void testNoDoc() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nodoc.json\");\n+        accept(idxr, \"foo where description_nodoc == ''\");\n+        // TODO: add sort test on nodoc field once we have pipes support\n+    }\n+\n+    public void testDate() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-date.json\");\n+        accept(idxr, \"foo where date == ''\");\n+        accept(idxr, \"foo where date == '2020-02-02'\");\n+        accept(idxr, \"foo where date == '2020-02-41'\");\n+        accept(idxr, \"foo where date == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_format == ''\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_format == '20200241'\");\n+\n+        accept(idxr, \"foo where date_with_multi_format == ''\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-02'\");\n+        accept(idxr, \"foo where date_with_multi_format == '2020-02-41'\");\n+        accept(idxr, \"foo where date_with_multi_format == '20200241'\");\n+        accept(idxr, \"foo where date_with_multi_format == '11:12:13'\");\n+\n+        // Test query against unsupported field type date_nanos\n+        assertEquals(\"1:11: Cannot use field [date_nanos_field] with unsupported type [date_nanos]\",\n+                error(idxr, \"foo where date_nanos_field == ''\"));\n+    }\n+\n+    public void testBoolean() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-boolean.json\");\n+        accept(idxr, \"foo where boolean_field == true\");\n+        accept(idxr, \"foo where boolean_field == 'bar'\");\n+        accept(idxr, \"foo where boolean_field == 0\");\n+        accept(idxr, \"foo where boolean_field == 123456\");\n+    }\n+\n+    public void testBinary() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-binary.json\");\n+        accept(idxr, \"foo where blob == ''\");\n+        accept(idxr, \"foo where blob == 'bar'\");\n+        accept(idxr, \"foo where blob == 0\");\n+        accept(idxr, \"foo where blob == 123456\");\n+    }\n+\n+    public void testRange() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-range.json\");\n+        assertEquals(\"1:11: Cannot use field [integer_range_field] with unsupported type [integer_range]\",\n+                error(idxr, \"foo where integer_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [float_range_field] with unsupported type [float_range]\",\n+                error(idxr, \"foo where float_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [long_range_field] with unsupported type [long_range]\",\n+                error(idxr, \"foo where long_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [double_range_field] with unsupported type [double_range]\",\n+                error(idxr, \"foo where double_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [date_range_field] with unsupported type [date_range]\",\n+                error(idxr, \"foo where date_range_field == ''\"));\n+        assertEquals(\"1:11: Cannot use field [ip_range_field] with unsupported type [ip_range]\",\n+                error(idxr, \"foo where ip_range_field == ''\"));\n+    }\n+\n+    public void testObject() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-object.json\");\n+        accept(idxr, \"foo where endgame.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [endgame.pi], did you mean [endgame.pid]?\",\n+                error(idxr, \"foo where endgame.pi == 0\"));\n+\n+    }\n+\n+    public void testNested() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-nested.json\");\n+        accept(idxr, \"foo where processes.pid == 0\");\n+\n+        assertEquals(\"1:11: Unknown column [processe.pid], did you mean any of [processes.pid, processes.path, processes.path.keyword]?\",\n+                error(idxr, \"foo where processe.pid == 0\"));\n+    }\n+\n+    public void testGeo() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-geo.json\");\n+        assertEquals(\"1:11: Cannot use field [location] with unsupported type [geo_point]\",\n+                error(idxr, \"foo where location == 0\"));\n+        assertEquals(\"1:11: Cannot use field [site] with unsupported type [geo_shape]\",\n+                error(idxr, \"foo where site == 0\"));\n+    }\n+\n+    public void testIP() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-ip.json\");\n+        accept(idxr, \"foo where ip_addr == 0\");\n+    }\n+\n+    public void testJoin() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-join.json\");\n+        accept(idxr, \"foo where serial_event_id == 0\");\n+    }\n+\n+    public void testMultiField() {\n+        final IndexResolution idxr = loadIndexResolution(\"mapping-multi-field.json\");\n+        accept(idxr, \"foo where multi_field.raw == 'bar'\");\n+\n+        assertEquals(\"1:11: [multi_field.english == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [english]; define one or use MATCH/QUERY instead\",\n+                error(idxr, \"foo where multi_field.english == 'bar'\"));\n+\n+        accept(idxr, \"foo where multi_field_options.raw == 'bar'\");\n+        accept(idxr, \"foo where multi_field_options.key == 'bar'\");\n+\n+        accept(idxr, \"foo where multi_field_ambiguous.one == 'bar'\");\n+        accept(idxr, \"foo where multi_field_ambiguous.two == 'bar'\");\n+        assertEquals(\"1:11: [multi_field_ambiguous.normalized == 'bar'] cannot operate on first argument field of data type [keyword]: \" +\n+                        \"Normalized keyword field cannot be used for exact match operations\",\n+                error(idxr, \"foo where multi_field_ambiguous.normalized == 'bar'\"));\n+\n+        assertEquals(\"1:11: [multi_field_nested.dep_name == 'bar'] cannot operate on first argument field of data type [text]: \" +\n+                        \"No keyword/multi-field defined exact matches for [dep_name]; define one or use MATCH/QUERY instead\",", "originalCommit": "30b29463dd4ac494a99207b6557525316a537532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3NzgzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52664#discussion_r383277832", "bodyText": "Discussed with Costin, the behavior is correct, the error message can be improved in the context of EQL. Agreed  on leaving the test as is and open an \"issue\" for error messaging improvement for this particular case. Possibly can bring up for discussion for our weekly.", "author": "aleksmaus", "createdAt": "2020-02-24T13:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyODAwMw=="}], "type": "inlineReview", "revised_code": {"commit": "948f45835e36acde9d2807b556199fcc8315a6cf", "chunk": "diff --git a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\nindex 7c378605cd3..57396b7340d 100644\n--- a/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n+++ b/x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/analysis/VerifierTests.java\n\n@@ -117,7 +117,6 @@ public class VerifierTests extends ESTestCase {\n     }\n \n     // Some functions fail with \"Unknown\" message at the parse stage\n-    // TODO (@costin): Should we make the error messaging consistent?\n     public void testFunctionParsingUnknown() {\n         assertEquals(\"1:15: Unknown function [matchLite]\",\n                 errorParsing(\"process where matchLite(?'.*?net1\\\\s+localgroup\\\\s+.*?', command_line)\"));\n"}}, {"oid": "948f45835e36acde9d2807b556199fcc8315a6cf", "url": "https://github.com/elastic/elasticsearch/commit/948f45835e36acde9d2807b556199fcc8315a6cf", "message": "Address code review comments", "committedDate": "2020-02-24T14:00:49Z", "type": "commit"}, {"oid": "bce5c56090bf3075e1758622d71290a841d5ce50", "url": "https://github.com/elastic/elasticsearch/commit/bce5c56090bf3075e1758622d71290a841d5ce50", "message": "Add the test for bad query that starts with number", "committedDate": "2020-02-24T14:40:43Z", "type": "commit"}, {"oid": "c9e4c1f07c2bced0dee26653b8712a2b5e5199c4", "url": "https://github.com/elastic/elasticsearch/commit/c9e4c1f07c2bced0dee26653b8712a2b5e5199c4", "message": "Merge branch 'master' into feature/eql_verification_expanded", "committedDate": "2020-02-24T15:05:16Z", "type": "commit"}]}