{"pr_number": 55223, "pr_title": "SQL: Implement TIME_PARSE function for parsing strings into TIME values", "pr_createdAt": "2020-04-15T10:14:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55223", "timeline": [{"oid": "0c35a1756b3a030e867c792a428811504ad05b7d", "url": "https://github.com/elastic/elasticsearch/commit/0c35a1756b3a030e867c792a428811504ad05b7d", "message": "Issue #37303 - Invalid variance fix", "committedDate": "2019-01-12T12:09:28Z", "type": "commit"}, {"oid": "36c886273da56cfb7872c65437b37af534da608a", "url": "https://github.com/elastic/elasticsearch/commit/36c886273da56cfb7872c65437b37af534da608a", "message": "Testcase added for #37303", "committedDate": "2019-01-14T19:04:38Z", "type": "commit"}, {"oid": "966c46c51edffa3ba4e75aeab9de5b73a45e29dd", "url": "https://github.com/elastic/elasticsearch/commit/966c46c51edffa3ba4e75aeab9de5b73a45e29dd", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2019-01-23T17:25:34Z", "type": "commit"}, {"oid": "f9b0ec9582bc2fc62473cb72e2bfe693a5db335d", "url": "https://github.com/elastic/elasticsearch/commit/f9b0ec9582bc2fc62473cb72e2bfe693a5db335d", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2019-01-24T19:55:36Z", "type": "commit"}, {"oid": "f65c03a0ba584b9964c7828ce9fcf2116968535f", "url": "https://github.com/elastic/elasticsearch/commit/f65c03a0ba584b9964c7828ce9fcf2116968535f", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2019-02-25T08:09:15Z", "type": "commit"}, {"oid": "28a493719af0963d5ba6978b14bcb3f5da5d2c0b", "url": "https://github.com/elastic/elasticsearch/commit/28a493719af0963d5ba6978b14bcb3f5da5d2c0b", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2019-12-24T07:30:41Z", "type": "commit"}, {"oid": "617d6969a814c5b2bc21f8389dd106846d3bb8b4", "url": "https://github.com/elastic/elasticsearch/commit/617d6969a814c5b2bc21f8389dd106846d3bb8b4", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-01-04T17:58:30Z", "type": "commit"}, {"oid": "18b6cbbd36e12d1877d36f8d1534490dfc861470", "url": "https://github.com/elastic/elasticsearch/commit/18b6cbbd36e12d1877d36f8d1534490dfc861470", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-04-10T19:13:13Z", "type": "commit"}, {"oid": "734e75bf0764be61153d2460f943261c9203f957", "url": "https://github.com/elastic/elasticsearch/commit/734e75bf0764be61153d2460f943261c9203f957", "message": "SQL: Implementing TIME_PARSE function for parsing strings", "committedDate": "2020-04-11T10:37:42Z", "type": "commit"}, {"oid": "7033b27aabb886ae8e3ccb8ac81dddfbae5906b3", "url": "https://github.com/elastic/elasticsearch/commit/7033b27aabb886ae8e3ccb8ac81dddfbae5906b3", "message": "review comments fixes", "committedDate": "2020-04-11T17:40:15Z", "type": "commit"}, {"oid": "fc2e46b87da72c79de990cc66fc0096e4bf68ef8", "url": "https://github.com/elastic/elasticsearch/commit/fc2e46b87da72c79de990cc66fc0096e4bf68ef8", "message": "LocalTime To OffsetTime", "committedDate": "2020-04-11T18:52:02Z", "type": "commit"}, {"oid": "8694b1159e231e42f287c80098c21c847402210a", "url": "https://github.com/elastic/elasticsearch/commit/8694b1159e231e42f287c80098c21c847402210a", "message": "Added docs for time_parse", "committedDate": "2020-04-11T19:01:05Z", "type": "commit"}, {"oid": "e496c212c328a335252b4256a1502105076c6559", "url": "https://github.com/elastic/elasticsearch/commit/e496c212c328a335252b4256a1502105076c6559", "message": "Modify license and remove unused import", "committedDate": "2020-04-15T16:08:45Z", "type": "commit"}, {"oid": "274f461d4ce2171bb9c1527a4ca70b3727629bd8", "url": "https://github.com/elastic/elasticsearch/commit/274f461d4ce2171bb9c1527a4ca70b3727629bd8", "message": "\u201cre-ci\u201d", "committedDate": "2020-04-15T16:35:58Z", "type": "commit"}, {"oid": "6164e6be1c12e7166d07f991fc968108486eb1d0", "url": "https://github.com/elastic/elasticsearch/commit/6164e6be1c12e7166d07f991fc968108486eb1d0", "message": "modify processor and pip", "committedDate": "2020-04-26T06:44:39Z", "type": "commit"}, {"oid": "e7fdf0de0d5c29af3aa8574bcfb36f3d9ef6939e", "url": "https://github.com/elastic/elasticsearch/commit/e7fdf0de0d5c29af3aa8574bcfb36f3d9ef6939e", "message": "remove TimeParseProcessor", "committedDate": "2020-04-26T07:06:33Z", "type": "commit"}, {"oid": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "url": "https://github.com/elastic/elasticsearch/commit/403b773da5362d4c8e790e5e4b55768e0a8f1799", "message": "modify some tests", "committedDate": "2020-04-27T08:37:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415687531", "bodyText": "I don't think that's necessary, did it cause any problems?", "author": "matriv", "createdAt": "2020-04-27T10:14:55Z", "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -78,6 +79,7 @@ protected boolean logEsResultSet() {\n \n     @Override\n     protected final void doTest() throws Throwable {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwODc0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416408746", "bodyText": "In csvjdbc, it parse time string with SimpleDateFormat. In the constructor of SimpleDateFormat, calendar will be initialized by  the initializeCalendar function.\nprivate void initializeCalendar(Locale loc) {\n        if (calendar == null) {\n            assert loc != null;\n            // The format object must be constructed using the symbols for this zone.\n            // However, the calendar should use the current default TimeZone.\n            // If this is not contained in the locale zone strings, then the zone\n            // will be formatted using generic GMT+/-H:MM nomenclature.\n            calendar = Calendar.getInstance(TimeZone.getDefault(), loc);\n        }\n    }\n\nAnd In parseTime function, it will get milliseconds from parsedDate. In different TimeZone, there will be different milliseconds.\npublic Time parseTime(String str){              \n\tjava.util.Date parsedDate = simpleTimeFormat.parse(str);\n\tlong millis = parsedDate.getTime();\n\tsqlResult = new Time(millis);\n\treturn sqlResult;\n}\nIs there a better way to solve this problem?", "author": "Patrick0308", "createdAt": "2020-04-28T07:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416481609", "bodyText": "Cant' you use the timezone parsing pattern here: https://github.com/elastic/elasticsearch/pull/55223/files#diff-3dd1dabda293f7c99cda3ed7e09b2cacR66\ncsvProperties.setProperty(\"timeFormat\", \"HH:mm:ss.SSSX\");", "author": "matriv", "createdAt": "2020-04-28T09:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU5ODYwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416598601", "bodyText": "It can't work.", "author": "Patrick0308", "createdAt": "2020-04-28T13:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1NjU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r416656591", "bodyText": "I tried with your branch and it worked.", "author": "matriv", "createdAt": "2020-04-28T14:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA1MDAwNA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417050004", "bodyText": "Sorry, it works, I made an another mistake.", "author": "Patrick0308", "createdAt": "2020-04-29T03:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NzUzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c495eb9b49ac3057be8a21e23b53442234fc830", "chunk": "diff --git a/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\nindex e47dee141ec..a95e1550212 100644\n--- a/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\n+++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\n\n@@ -79,7 +79,6 @@ public class JdbcDocCsvSpecIT extends SpecBaseIntegrationTestCase {\n \n     @Override\n     protected final void doTest() throws Throwable {\n-        TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n         try (Connection csv = csvConnection(testCase); Connection es = esJdbc()) {\n \n             // pass the testName as table for debugging purposes (in case the underlying reader is missing)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODk5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415688998", "bodyText": "You should override hashCode() and equals() and include the new attribute.", "author": "matriv", "createdAt": "2020-04-27T10:17:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,33 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.DateTimeParseExtractor;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final DateTimeParseExtractor dateTimeParseExtractor;\n \n-    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right) {\n+    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, DateTimeParseExtractor dateTimeParseExtractor) {\n         super(source, expression, left, right, null);\n+        this.dateTimeParseExtractor = dateTimeParseExtractor;\n     }\n \n     @Override\n     protected NodeInfo<DateTimeParsePipe> info() {\n-        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right());\n+        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), dateTimeParseExtractor);\n     }\n \n     @Override\n     protected DateTimeParsePipe replaceChildren(Pipe left, Pipe right) {\n-        return new DateTimeParsePipe(source(), expression(), left, right);\n+        return new DateTimeParsePipe(source(), expression(), left, right, dateTimeParseExtractor);\n     }\n \n     @Override\n     protected Processor makeProcessor(Processor left, Processor right, ZoneId zoneId) {\n-        return new DateTimeParseProcessor(left, right);\n+        return new DateTimeParseProcessor(left, right, dateTimeParseExtractor);\n     }", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\nindex d72eec6ca6c..394f55c7078 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\n\n@@ -8,33 +8,54 @@ package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n-import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.DateTimeParseExtractor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n+import java.util.Objects;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n     \n-    private final DateTimeParseExtractor dateTimeParseExtractor;\n+    private final Parser parser;\n \n-    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, DateTimeParseExtractor dateTimeParseExtractor) {\n+    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, Parser parser) {\n         super(source, expression, left, right, null);\n-        this.dateTimeParseExtractor = dateTimeParseExtractor;\n+        this.parser = parser;\n     }\n \n     @Override\n     protected NodeInfo<DateTimeParsePipe> info() {\n-        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), dateTimeParseExtractor);\n+        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), parser);\n     }\n \n     @Override\n     protected DateTimeParsePipe replaceChildren(Pipe left, Pipe right) {\n-        return new DateTimeParsePipe(source(), expression(), left, right, dateTimeParseExtractor);\n+        return new DateTimeParsePipe(source(), expression(), left, right, parser);\n     }\n \n     @Override\n     protected Processor makeProcessor(Processor left, Processor right, ZoneId zoneId) {\n-        return new DateTimeParseProcessor(left, right, dateTimeParseExtractor);\n+        return new DateTimeParseProcessor(left, right, parser);\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), this.parser);\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        DateTimeParsePipe that = (DateTimeParsePipe) o;\n+        return super.equals(o) && this.parser == that.parser;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4OTg3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415689871", "bodyText": "wrong identation.", "author": "matriv", "createdAt": "2020-04-27T10:18:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;\n+\n+    public static final String NAME = \"dtparse\";\n+\n+    public DateTimeParseProcessor(Processor source1, Processor source2, DateTimeParseExtractor extractor) {\n+        super(source1, source2, null);\n+        this.extractor = extractor;\n+    }\n \n+    public DateTimeParseProcessor(StreamInput in) throws IOException {\n+        super(in);\n+        this.extractor = in.readEnum(DateTimeParseExtractor.class);\n+    }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(extractor);\n+    }\n+    \n     @Override\n     public String getWriteableName() {\n         return NAME;\n     }\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern);\n+            return this.extractor.extract(timestamp, pattern);", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MDkzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415690937", "bodyText": "I would rename it to DateTimeParser or plain Parser since it's already under a class so it would be: DateTimeParseProcessor.Parser.", "author": "matriv", "createdAt": "2020-04-27T10:20:28Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MTU3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415691576", "bodyText": "Please rename it apply -> parser.", "author": "matriv", "createdAt": "2020-04-27T10:21:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjA3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692071", "bodyText": "Please rename extactor -> parser.", "author": "matriv", "createdAt": "2020-04-27T10:22:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n             }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n         }\n     }\n+    \n+    private final DateTimeParseExtractor extractor;", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692274", "bodyText": "Please rename to parse()", "author": "matriv", "createdAt": "2020-04-27T10:22:35Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MjkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415692939", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "author": "matriv", "createdAt": "2020-04-27T10:23:42Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid date/time/datetime string [{}] or pattern [{}] is received; {}\",", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MzAzOA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r415693038", "bodyText": "date shouldn't be there, should be added with DATE_PARSE function.", "author": "matriv", "createdAt": "2020-04-27T10:23:50Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum DateTimeParseExtractor {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> apply;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n+            this.apply = apply;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object extract(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = apply.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = \"Unable to convert parsed text into [datetime or date or time]\";", "originalCommit": "403b773da5362d4c8e790e5e4b55768e0a8f1799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 542d4bdb66f..b667dce2511 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -28,19 +28,19 @@ import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public enum DateTimeParseExtractor {\n+    public enum Parser {\n         DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n         TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                 .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-        private final BiFunction<String, String, TemporalAccessor> apply;\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-        DateTimeParseExtractor(BiFunction<String, String, TemporalAccessor> apply) {\n-            this.apply = apply;\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        public Object extract(Object timestamp, Object pattern) {\n+        public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n                 return null;\n             }\n"}}, {"oid": "37703deaf11e7130097fd9f18e79556d8a200d1f", "url": "https://github.com/elastic/elasticsearch/commit/37703deaf11e7130097fd9f18e79556d8a200d1f", "message": "revert strip", "committedDate": "2020-04-28T06:38:56Z", "type": "commit"}, {"oid": "87ee4b0c3eaaed9a87701ed9fd94e026b887942b", "url": "https://github.com/elastic/elasticsearch/commit/87ee4b0c3eaaed9a87701ed9fd94e026b887942b", "message": "remove unnecessary extra new line", "committedDate": "2020-04-28T06:42:36Z", "type": "commit"}, {"oid": "fe8f9dba3a9c778de54c491004d8fe063b1e511b", "url": "https://github.com/elastic/elasticsearch/commit/fe8f9dba3a9c778de54c491004d8fe063b1e511b", "message": "Modify DateTimeParseExtractor to Parser.", "committedDate": "2020-04-28T07:33:10Z", "type": "commit"}, {"oid": "ffbb897297290880700e314597ac83714ba48b69", "url": "https://github.com/elastic/elasticsearch/commit/ffbb897297290880700e314597ac83714ba48b69", "message": "Remove date from message", "committedDate": "2020-04-28T07:35:35Z", "type": "commit"}, {"oid": "dfbb7c7df2e4401e3fce591e78796eec2a23cc1f", "url": "https://github.com/elastic/elasticsearch/commit/dfbb7c7df2e4401e3fce591e78796eec2a23cc1f", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-04-28T14:25:41Z", "type": "commit"}, {"oid": "7c495eb9b49ac3057be8a21e23b53442234fc830", "url": "https://github.com/elastic/elasticsearch/commit/7c495eb9b49ac3057be8a21e23b53442234fc830", "message": "unset default time zone", "committedDate": "2020-04-29T02:59:52Z", "type": "commit"}, {"oid": "d55e0e393aa01a065f6b3608a3396a42c711329f", "url": "https://github.com/elastic/elasticsearch/commit/d55e0e393aa01a065f6b3608a3396a42c711329f", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse", "committedDate": "2020-04-29T03:00:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MTg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417181872", "bodyText": "Please revert changes to this file.", "author": "matriv", "createdAt": "2020-04-29T09:26:39Z", "path": "x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java", "diffHunk": "@@ -18,6 +18,7 @@\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.util.List;\n+import java.util.TimeZone;", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\nindex a95e1550212..f9f609f17ff 100644\n--- a/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\n+++ b/x-pack/plugin/sql/qa/single-node/src/test/java/org/elasticsearch/xpack/sql/qa/single_node/JdbcDocCsvSpecIT.java\n\n@@ -18,7 +18,6 @@ import java.sql.Connection;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.util.List;\n-import java.util.TimeZone;\n \n import static org.elasticsearch.xpack.sql.qa.jdbc.CsvTestUtils.csvConnection;\n import static org.elasticsearch.xpack.sql.qa.jdbc.CsvTestUtils.executeCsvQuery;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4MjUzOA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417182538", "bodyText": "Please keep the alphabetical ordering here.", "author": "matriv", "createdAt": "2020-04-29T09:27:47Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java", "diffHunk": "@@ -77,17 +77,17 @@ private Processors() {}\n         entries.add(new Entry(Processor.class, NullIfProcessor.NAME, NullIfProcessor::new));\n \n         // datetime\n-        entries.add(new Entry(Processor.class, DateTimeProcessor.NAME, DateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, TimeProcessor.NAME, TimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NamedDateTimeProcessor.NAME, NamedDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, NonIsoDateTimeProcessor.NAME, NonIsoDateTimeProcessor::new));\n-        entries.add(new Entry(Processor.class, QuarterProcessor.NAME, QuarterProcessor::new));\n         entries.add(new Entry(Processor.class, DateAddProcessor.NAME, DateAddProcessor::new));\n         entries.add(new Entry(Processor.class, DateDiffProcessor.NAME, DateDiffProcessor::new));\n         entries.add(new Entry(Processor.class, DatePartProcessor.NAME, DatePartProcessor::new));\n-        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));\n         entries.add(new Entry(Processor.class, DateTimeParseProcessor.NAME, DateTimeParseProcessor::new));\n+        entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java\nindex 65a5bc49440..ff5621617d3 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/Processors.java\n\n@@ -80,8 +80,8 @@ public final class Processors {\n         entries.add(new Entry(Processor.class, DateAddProcessor.NAME, DateAddProcessor::new));\n         entries.add(new Entry(Processor.class, DateDiffProcessor.NAME, DateDiffProcessor::new));\n         entries.add(new Entry(Processor.class, DatePartProcessor.NAME, DatePartProcessor::new));\n-        entries.add(new Entry(Processor.class, DateTimeParseProcessor.NAME, DateTimeParseProcessor::new));\n         entries.add(new Entry(Processor.class, DateTimeFormatProcessor.NAME, DateTimeFormatProcessor::new));\n+        entries.add(new Entry(Processor.class, DateTimeParseProcessor.NAME, DateTimeParseProcessor::new));\n         entries.add(new Entry(Processor.class, DateTimeProcessor.NAME, DateTimeProcessor::new));\n         entries.add(new Entry(Processor.class, DateTruncProcessor.NAME, DateTruncProcessor::new));\n         entries.add(new Entry(Processor.class, NamedDateTimeProcessor.NAME, NamedDateTimeProcessor::new));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NDgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417184822", "bodyText": "You should distinguish based on the enum value, this way you can have a specialized message for each and not a generic one that refers to both datetime and time.", "author": "matriv", "createdAt": "2020-04-29T09:31:47Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n+            this.parser = parser;\n         }\n \n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n \n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n             }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418665", "bodyText": "See my code changes, is it ok?", "author": "Patrick0308", "createdAt": "2020-05-01T05:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NDgyMg=="}], "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex a8b460cc70b..556214eefb2 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -20,25 +20,30 @@ import java.time.ZonedDateTime;\n import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n     public enum Parser {\n-        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n-        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n-\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n         private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n \n-        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n-            this.parser = parser;\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n         }\n+        \n \n         public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185098", "bodyText": "Minor: empty line", "author": "matriv", "createdAt": "2020-04-29T09:32:16Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;\n+\n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+        parser = Parser.TIME;\n+", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex fda48e1e56d..df240f38ba3 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -27,7 +27,6 @@ public class TimeParse extends BinaryDateTimeFunction {\n     public TimeParse(Source source, Expression timestamp, Expression pattern) {\n         super(source, timestamp, pattern, UTC);\n         parser = Parser.TIME;\n-\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185237", "bodyText": "Minor: extra empty line.", "author": "matriv", "createdAt": "2020-04-29T09:32:33Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java", "diffHunk": "@@ -294,9 +294,14 @@ public static String dateTimeFormat(Object dateTime, String pattern, String tzId\n     }\n \n     public static Object dateTimeParse(String dateField, String pattern, String tzId) {\n-        return DateTimeParseProcessor.process(dateField, pattern);\n+        return Parser.DATE_TIME.parse(dateField, pattern);\n     }\n \n+    public static Object timeParse(String dateField, String pattern, String tzId) {\n+        return Parser.TIME.parse(dateField, pattern);\n+    }\n+\n+", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java\nindex cd612f39e32..2b001796c00 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/whitelist/InternalSqlScriptUtils.java\n\n@@ -300,8 +300,7 @@ public class InternalSqlScriptUtils extends InternalQlScriptUtils {\n     public static Object timeParse(String dateField, String pattern, String tzId) {\n         return Parser.TIME.parse(dateField, pattern);\n     }\n-\n-\n+    \n     public static ZonedDateTime asDateTime(Object dateTime) {\n         return (ZonedDateTime) asDateTime(dateTime, false);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4NTUyNA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417185524", "bodyText": "Minor: whitespaces.", "author": "matriv", "createdAt": "2020-04-29T09:33:05Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -25,10 +26,11 @@\n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())\n         );\n     }\n-\n+    ", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 32e0f1a45ea..625a712f71e 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -30,7 +30,7 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n                 randomFrom(Parser.values())\n         );\n     }\n-    \n+        \n     @Override\n     protected DateTimeParseProcessor createTestInstance() {\n         return randomDateTimeParseProcessor();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4OTc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417189782", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                    DATE_TIME(ZonedDateTime::from),\n          \n          \n            \n                    TIME(OffsetTime::from);", "author": "matriv", "createdAt": "2020-04-29T09:40:53Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418686", "bodyText": "See my code changes, is it ok?", "author": "Patrick0308", "createdAt": "2020-05-01T05:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4OTc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex a8b460cc70b..556214eefb2 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -20,25 +20,30 @@ import java.time.ZonedDateTime;\n import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n     public enum Parser {\n-        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n-        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n-\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n         private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n \n-        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n-            this.parser = parser;\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n         }\n+        \n \n         public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5MDU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r417190562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(BiFunction<String, String, TemporalAccessor> parser) {\n          \n          \n            \n                    Parser(TemporalQuery<?> query) {\n          \n          \n            \n                        this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n          \n          \n            \n                            .parseBest(timestampStr, query, LocalTime::from));", "author": "matriv", "createdAt": "2020-04-29T09:42:18Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,110 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n+\n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n-    public static final String NAME = \"dtparse\";\n+    public enum Parser {\n+        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n+        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n-        super(source1, source2, null);\n-    }\n+        private final BiFunction<String, String, TemporalAccessor> parser;\n \n-    public DateTimeParseProcessor(StreamInput in) throws IOException {\n-        super(in);\n-    }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+        Parser(BiFunction<String, String, TemporalAccessor> parser) {", "originalCommit": "d55e0e393aa01a065f6b3608a3396a42c711329f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxODY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418418699", "bodyText": "See my code changes, is it ok?", "author": "Patrick0308", "createdAt": "2020-05-01T05:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5MDU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a7107639003808a9651e5190cefe1c3f731fae7a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex a8b460cc70b..556214eefb2 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -20,25 +20,30 @@ import java.time.ZonedDateTime;\n import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n     public enum Parser {\n-        DATE_TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, ZonedDateTime::from, LocalDateTime::from)),\n-        TIME((timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                .parseBest(timestampStr, OffsetTime::from, LocalTime::from));\n-\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n         private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n \n-        Parser(BiFunction<String, String, TemporalAccessor> parser) {\n-            this.parser = parser;\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n         }\n+        \n \n         public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n"}}, {"oid": "a7107639003808a9651e5190cefe1c3f731fae7a", "url": "https://github.com/elastic/elasticsearch/commit/a7107639003808a9651e5190cefe1c3f731fae7a", "message": "optimize some codes", "committedDate": "2020-05-01T04:52:49Z", "type": "commit"}, {"oid": "5e8e42744a6c6a29bbbbfe3ee0bf8c8a44c92ef8", "url": "https://github.com/elastic/elasticsearch/commit/5e8e42744a6c6a29bbbbfe3ee0bf8c8a44c92ef8", "message": "modify doc", "committedDate": "2020-05-01T04:54:36Z", "type": "commit"}, {"oid": "b3635693998fcc4f4d04e95e7370b4003b67f257", "url": "https://github.com/elastic/elasticsearch/commit/b3635693998fcc4f4d04e95e7370b4003b67f257", "message": "format code", "committedDate": "2020-05-01T04:59:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTcwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431700", "bodyText": "Could be static and initialized here instead of the constructor.", "author": "matriv", "createdAt": "2020-05-01T06:17:51Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+\n+    private final Parser parser;", "originalCommit": "b3635693998fcc4f4d04e95e7370b4003b67f257", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c0ab4abf0a03c662d3aba02faff2808d7ecfeb27", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex df240f38ba3..68b16114af2 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -22,11 +22,10 @@ import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n \n public class TimeParse extends BinaryDateTimeFunction {\n \n-    private final Parser parser;\n+    private static final Parser parser = Parser.TIME;\n \n     public TimeParse(Source source, Expression timestamp, Expression pattern) {\n         super(source, timestamp, pattern, UTC);\n-        parser = Parser.TIME;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTc0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431747", "bodyText": "same here.", "author": "matriv", "createdAt": "2020-05-01T06:18:05Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java", "diffHunk": "@@ -8,29 +8,54 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.time.ZoneId;\n+import java.util.Objects;\n \n public class DateTimeParsePipe extends BinaryDateTimePipe {\n+    \n+    private final Parser parser;", "originalCommit": "b3635693998fcc4f4d04e95e7370b4003b67f257", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c2390a90f74727bbb02e82717943445f890f010", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\nindex 394f55c7078..74c843c79a6 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipe.java\n\n@@ -19,24 +19,24 @@ public class DateTimeParsePipe extends BinaryDateTimePipe {\n     \n     private final Parser parser;\n \n-    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, Parser parser) {\n-        super(source, expression, left, right, null);\n+    public DateTimeParsePipe(Source source, Expression expression, Pipe left, Pipe right, ZoneId zoneId, Parser parser) {\n+        super(source, expression, left, right, zoneId);\n         this.parser = parser;\n     }\n \n     @Override\n     protected NodeInfo<DateTimeParsePipe> info() {\n-        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), parser);\n+        return NodeInfo.create(this, DateTimeParsePipe::new, expression(), left(), right(), zoneId(), parser);\n     }\n \n     @Override\n     protected DateTimeParsePipe replaceChildren(Pipe left, Pipe right) {\n-        return new DateTimeParsePipe(source(), expression(), left, right, parser);\n+        return new DateTimeParsePipe(source(), expression(), left, right, zoneId(), parser);\n     }\n \n     @Override\n     protected Processor makeProcessor(Processor left, Processor right, ZoneId zoneId) {\n-        return new DateTimeParseProcessor(left, right, parser);\n+        return new DateTimeParseProcessor(left, right, zoneId, parser);\n     }\n     \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMTk0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418431948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n          \n          \n            \n                    Parser(String parseType,  TemporalQuery<?> queries...) {", "author": "matriv", "createdAt": "2020-05-01T06:18:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {", "originalCommit": "b3635693998fcc4f4d04e95e7370b4003b67f257", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 2c116d7c066..2dc33302262 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -37,12 +37,11 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         \n         private final String parseType;\n \n-        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n             this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                    .parseBest(timestampStr, query, localQuery);\n+                    .parseBest(timestampStr, queries);\n             this.parseType = parseType;\n         }\n-        \n \n         public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQzMjEzNA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418432134", "bodyText": "whitespaces", "author": "matriv", "createdAt": "2020-05-01T06:19:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,86 +6,115 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, query, localQuery);\n+            this.parseType = parseType;\n+        }\n+        \n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, Parser parser) {\n         super(source1, source2, null);\n+        this.parser = parser;\n     }\n \n     public DateTimeParseProcessor(StreamInput in) throws IOException {\n         super(in);\n+        this.parser = in.readEnum(Parser.class);\n     }\n-\n-    /**\n-     * Used in Painless scripting\n-     */\n-    public static Object process(Object timestampStr, Object pattern) {\n-        if (timestampStr == null || pattern == null) {\n-            return null;\n-        }\n-        if (timestampStr instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestampStr);\n-        }\n-        if (pattern instanceof String == false) {\n-            throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n-        }\n-\n-        if (((String) timestampStr).isEmpty() || ((String) pattern).isEmpty()) {\n-            return null;\n-        }\n-\n-        try {\n-            TemporalAccessor ta = DateTimeFormatter.ofPattern((String) pattern, Locale.ROOT)\n-                .parseBest((String) timestampStr, ZonedDateTime::from, LocalDateTime::from);\n-            if (ta instanceof LocalDateTime) {\n-                return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n-            } else {\n-                return ta;\n-            }\n-        } catch (IllegalArgumentException | DateTimeException e) {\n-            String msg = e.getMessage();\n-            if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                msg = \"Unable to convert parsed text into [datetime]\";\n-            }\n-            throw new SqlIllegalArgumentException(\n-                \"Invalid date/time string [{}] or pattern [{}] is received; {}\",\n-                timestampStr,\n-                pattern,\n-                msg\n-            );\n-        }\n+    \n+    @Override\n+    public void doWrite(StreamOutput out) throws IOException {\n+        out.writeEnum(parser);\n     }\n-\n+    ", "originalCommit": "b3635693998fcc4f4d04e95e7370b4003b67f257", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 2c116d7c066..2dc33302262 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -37,12 +37,11 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         \n         private final String parseType;\n \n-        Parser(String parseType,  TemporalQuery<?> query, TemporalQuery<?> localQuery) {\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n             this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n-                    .parseBest(timestampStr, query, localQuery);\n+                    .parseBest(timestampStr, queries);\n             this.parseType = parseType;\n         }\n-        \n \n         public Object parse(Object timestamp, Object pattern) {\n             if (timestamp == null || pattern == null) {\n"}}, {"oid": "c0ab4abf0a03c662d3aba02faff2808d7ecfeb27", "url": "https://github.com/elastic/elasticsearch/commit/c0ab4abf0a03c662d3aba02faff2808d7ecfeb27", "message": "change parser to static", "committedDate": "2020-05-01T09:09:47Z", "type": "commit"}, {"oid": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "url": "https://github.com/elastic/elasticsearch/commit/84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "message": "add tests and optimize codes", "committedDate": "2020-05-01T16:54:02Z", "type": "commit"}, {"oid": "52424abfc36dacb842ed444dab906f53c603e25b", "url": "https://github.com/elastic/elasticsearch/commit/52424abfc36dacb842ed444dab906f53c603e25b", "message": "whitespaces", "committedDate": "2020-05-01T17:00:25Z", "type": "commit"}, {"oid": "64c48208ca8c579e92e448b494ee81ad994d3b8a", "url": "https://github.com/elastic/elasticsearch/commit/64c48208ca8c579e92e448b494ee81ad994d3b8a", "message": "remove whitespaces", "committedDate": "2020-05-01T17:03:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDg3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n          \n          \n            \n                                msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);", "author": "matriv", "createdAt": "2020-05-02T11:06:33Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);", "originalCommit": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 2dc33302262..8194e5f6f03 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -69,10 +69,10 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n                 }\n                 throw new SqlIllegalArgumentException(\n-                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",\n                     this.parseType,\n                     timestamp,\n                     pattern,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk0NDkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r418944901", "bodyText": "I think it's better to keep the square brackets.", "author": "matriv", "createdAt": "2020-05-02T11:06:47Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -70,10 +69,10 @@ public Object parse(Object timestamp, Object pattern) {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n                 }\n                 throw new SqlIllegalArgumentException(\n-                    \"Invalid [{}] string [{}] or pattern [{}] is received; {} \",\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",", "originalCommit": "84cad8b6eb419f945667ae72cd31ff4dd8c641fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 2dc33302262..8194e5f6f03 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -69,10 +69,10 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n             } catch (IllegalArgumentException | DateTimeException e) {\n                 String msg = e.getMessage();\n                 if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n-                    msg = format(null,\"Unable to convert parsed text into [{}]\", this.parseType);\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n                 }\n                 throw new SqlIllegalArgumentException(\n-                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",\n                     this.parseType,\n                     timestamp,\n                     pattern,\n"}}, {"oid": "b3a3c92a16fc2e97c271d3c69dcb30d0a4f44540", "url": "https://github.com/elastic/elasticsearch/commit/b3a3c92a16fc2e97c271d3c69dcb30d0a4f44540", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-05-02T11:32:01Z", "type": "commit"}, {"oid": "6f2706d27066a1fcb62e70b8675cbb297f0ddff9", "url": "https://github.com/elastic/elasticsearch/commit/6f2706d27066a1fcb62e70b8675cbb297f0ddff9", "message": "add timeGroupBy tests", "committedDate": "2020-05-02T14:48:09Z", "type": "commit"}, {"oid": "6bfa6d080888a62102ac8d4074ee740c7fb9b694", "url": "https://github.com/elastic/elasticsearch/commit/6bfa6d080888a62102ac8d4074ee740c7fb9b694", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse", "committedDate": "2020-05-02T14:50:23Z", "type": "commit"}, {"oid": "fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "url": "https://github.com/elastic/elasticsearch/commit/fd3dcbb0b6648b964878f4444eec7c5d23ca4576", "message": "modify error message", "committedDate": "2020-05-02T14:52:26Z", "type": "commit"}, {"oid": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "url": "https://github.com/elastic/elasticsearch/commit/e9148b5a3b303d6e1701edec186cd4d5796bc22b", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-05-02T16:19:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MzQ3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419473477", "bodyText": "I don't understand this comment.", "author": "astefan", "createdAt": "2020-05-04T14:21:34Z", "path": "x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java", "diffHunk": "@@ -62,6 +62,8 @@ public static Connection csvConnection(CsvTestCase csvTest) throws IOException,\n         csvProperties.setProperty(\"charset\", \"UTF-8\");\n         csvProperties.setProperty(\"separator\", \"|\");\n         csvProperties.setProperty(\"trimValues\", \"true\");\n+        // Converter when type is java.sql.Time use this property", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MDc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419660777", "bodyText": "Should be rephrased to Format to read and compare java.sql.Time values", "author": "matriv", "createdAt": "2020-05-04T19:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MzQ3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java\nindex d63a4d1a03e..f6571a10e72 100644\n--- a/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java\n+++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/CsvTestUtils.java\n\n@@ -62,7 +62,7 @@ public final class CsvTestUtils {\n         csvProperties.setProperty(\"charset\", \"UTF-8\");\n         csvProperties.setProperty(\"separator\", \"|\");\n         csvProperties.setProperty(\"trimValues\", \"true\");\n-        // Converter when type is java.sql.Time use this property\n+        // Format to read and compare java.sql.Time values\n         csvProperties.setProperty(\"timeFormat\", \"HH:mm:ss.SSSX\");\n         Tuple<String, String> resultsAndTypes = extractColumnTypesAndStripCli(csvTest.earlySchema, csvTest.expectedResults);\n         csvProperties.setProperty(\"columnTypes\", resultsAndTypes.v2());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3OTc1MA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419479750", "bodyText": "This package import I think it was ok where it was.", "author": "astefan", "createdAt": "2020-05-04T14:29:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -8,16 +8,17 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.type.DataTypes;", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c2390a90f74727bbb02e82717943445f890f010", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\nindex cdbe953dcc9..16008980d84 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n\n@@ -8,22 +8,22 @@ package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n \n+\n public class DateTimeParse extends BinaryDateTimeFunction {\n \n-    public DateTimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTI0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515249", "bodyText": "Indentation issue.", "author": "astefan", "createdAt": "2020-05-04T15:18:29Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex e5992305ca1..338061db000 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -91,7 +91,7 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n                 f.right(),\n-                    DATE_TIME\n+                DATE_TIME\n             )\n         );\n         randoms.add(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTM4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515389", "bodyText": "Indentation issue.", "author": "astefan", "createdAt": "2020-05-04T15:18:41Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -88,23 +90,26 @@ protected DateTimeParsePipe mutate(DateTimeParsePipe instance) {\n                 f.source(),\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n-                f.right()\n+                f.right(),\n+                    DATE_TIME\n             )\n         );\n         randoms.add(\n             f -> new DateTimeParsePipe(\n                 f.source(),\n                 f.expression(),\n                 f.left(),\n-                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral)))\n+                pipe(((Expression) randomValueOtherThan(f.right(), FunctionTestUtils::randomStringLiteral))),\n+                    DATE_TIME", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex e5992305ca1..338061db000 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -91,7 +91,7 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n                 f.expression(),\n                 pipe(((Expression) randomValueOtherThan(f.left(), FunctionTestUtils::randomDatetimeLiteral))),\n                 f.right(),\n-                    DATE_TIME\n+                DATE_TIME\n             )\n         );\n         randoms.add(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNTYzNA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419515634", "bodyText": "Indentation issue.", "author": "astefan", "createdAt": "2020-05-04T15:19:02Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -12,20 +12,24 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.sql.AbstractSqlWireSerializingTestCase;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n+import org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n import java.time.ZoneId;\n+import java.time.ZoneOffset;\n \n import static org.elasticsearch.xpack.ql.expression.Literal.NULL;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.l;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.dateTime;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeTestUtils.time;\n \n public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestCase<DateTimeParseProcessor> {\n \n     public static DateTimeParseProcessor randomDateTimeParseProcessor() {\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128))\n+            new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n+                randomFrom(Parser.values())", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c2390a90f74727bbb02e82717943445f890f010", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex d12ab0d845d..3597ba2428a 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -29,7 +29,8 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         return new DateTimeParseProcessor(\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n             new ConstantProcessor(randomRealisticUnicodeOfLengthBetween(0, 128)),\n-                randomFrom(Parser.values())\n+            randomZone(),\n+            randomFrom(Parser.values())\n         );\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNzczMA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419517730", "bodyText": "Extra white space after bracket.", "author": "astefan", "createdAt": "2020-05-04T15:21:55Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -126,5 +184,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time( 10, 20, 30, 123000000),", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex d12ab0d845d..97dd1701308 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -185,14 +185,12 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n                 .process(null)\n         );\n         // TimeParse\n-        assertEquals(\n-                time( 10, 20, 30, 123000000),\n+        assertEquals(time( 10, 20, 30, 123000000),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\")).makePipe()\n                         .asProcessor()\n                         .process(null)\n         );\n-        assertEquals(\n-                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\")),\n+        assertEquals(time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\")),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\")).makePipe()\n                         .asProcessor()\n                         .process(null)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419540561", "bodyText": "I don't think I like the square brackets for the first argument.\nThe original message in this class was \"Invalid date/time string [{}] or pattern [{}] is received; {}\". Notice date/time that now was replaced by [{}] which means it will generate an error message like Invalid [datetime] string [07/05/2020] or pattern [dd/MM/uuuu] is received. I think it's better without square brackets.", "author": "astefan", "createdAt": "2020-05-04T15:54:07Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+            this.parseType = parseType;\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return ZonedDateTime.ofInstant((LocalDateTime) ta, ZoneOffset.UTC, UTC);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid [{}] string [{}] or pattern [{}] is received; {}\",", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MTczMA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419661730", "bodyText": "I commented to add the square brackets there, thought it made it more visible, but I'm fine without them as well.", "author": "matriv", "createdAt": "2020-05-04T19:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg3OTcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419879723", "bodyText": "We use the square brackets for values taken from the user context (like an expression the user used in the query) whereas here it's just a smart way of reusing code to build multiple error messages. This is in the same area as {}argument of [{}] must be [{}], found value [{}] type [{}] where the first argument can be first, second, third etc.", "author": "astefan", "createdAt": "2020-05-05T06:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NTEzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419975137", "bodyText": "Ok. I agree, thx!", "author": "matriv", "createdAt": "2020-05-05T09:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDczOA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r420510738", "bodyText": "We use the square brackets for values taken from the user context\n\nOk, I know the rules now.", "author": "Patrick0308", "createdAt": "2020-05-06T02:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MDU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 8194e5f6f03..6f80bf6d29e 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -38,9 +38,9 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         private final String parseType;\n \n         Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n             this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                     .parseBest(timestampStr, queries);\n-            this.parseType = parseType;\n         }\n \n         public Object parse(Object timestamp, Object pattern) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419545322", "bodyText": "Do the assignments in the order received as parameters (ie this.parseType = parseType should come before this.parser=...).", "author": "astefan", "createdAt": "2020-05-04T16:00:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,71 +6,99 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n-import java.time.ZoneOffset;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.util.DateUtils.UTC;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 8194e5f6f03..6f80bf6d29e 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -38,9 +38,9 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         private final String parseType;\n \n         Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n             this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n                     .parseBest(timestampStr, queries);\n-            this.parseType = parseType;\n         }\n \n         public Object parse(Object timestamp, Object pattern) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1Nzg1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419557851", "bodyText": "TimeParse and DateTimeParse have common methods (for example resolveType). Maybe have a common class handle those and extend TimeParse and DateTimeParse from that.", "author": "astefan", "createdAt": "2020-05-04T16:18:57Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c2390a90f74727bbb02e82717943445f890f010", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex d61c9f237e0..14f8ee8e9f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -60,11 +60,11 @@ public class TimeParse extends BinaryDateTimeFunction {\n \n     @Override\n     public Object fold() {\n-        return TIME.parse(left().fold(), right().fold());\n+        return TIME.parse(left().fold(), right().fold(), zoneId());\n     }\n \n     @Override\n     protected Pipe createPipe(Pipe timestamp, Pipe pattern, ZoneId zoneId) {\n-        return new DateTimeParsePipe(source(), this, timestamp, pattern, TIME);\n+        return new DateTimeParsePipe(source(), this, timestamp, pattern, zoneId(), TIME);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419558893", "bodyText": "Shouldn't the pattern be isStringAndExact? What do you think, @matriv ? Same question for timestamp.\nOne concerning aspect, especially for pattern is that if the user provides a field as a pattern and that field is text (vs. keyword) any text in it will be analyzed. Think of capital letters being lowercased with a standard analyzer. Should we be concerned about this?", "author": "astefan", "createdAt": "2020-05-04T16:20:29Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BinaryDateTimeFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);", "originalCommit": "e9148b5a3b303d6e1701edec186cd4d5796bc22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2MjI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419662298", "bodyText": "I understand the concern, but we don't check for exact (keyword only) in a various of other cases, like DATE_TRUNC, DATE_PART, etc.", "author": "matriv", "createdAt": "2020-05-04T19:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4ODA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419888048", "bodyText": "Maybe we should. Haven't given a lot of thought to something else other than the pattern but a text field can lowercase letters in a pattern and change the meaning of that pattern.", "author": "astefan", "createdAt": "2020-05-05T06:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NjEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r419976123", "bodyText": "I'd say to keep it with accepting also text for this PR.\nWe'll have to revisit all functions if we decide to exclude them and only accept exacts ('keyword'), and change the behavior consistently.", "author": "matriv", "createdAt": "2020-05-05T09:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1ODg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5c2390a90f74727bbb02e82717943445f890f010", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex d61c9f237e0..14f8ee8e9f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -60,11 +60,11 @@ public class TimeParse extends BinaryDateTimeFunction {\n \n     @Override\n     public Object fold() {\n-        return TIME.parse(left().fold(), right().fold());\n+        return TIME.parse(left().fold(), right().fold(), zoneId());\n     }\n \n     @Override\n     protected Pipe createPipe(Pipe timestamp, Pipe pattern, ZoneId zoneId) {\n-        return new DateTimeParsePipe(source(), this, timestamp, pattern, TIME);\n+        return new DateTimeParsePipe(source(), this, timestamp, pattern, zoneId(), TIME);\n     }\n }\n"}}, {"oid": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "url": "https://github.com/elastic/elasticsearch/commit/151042ac8c1ebd16368d0c632c23d88a576ecce1", "message": "optimize code", "committedDate": "2020-05-06T05:26:33Z", "type": "commit"}, {"oid": "5c2390a90f74727bbb02e82717943445f890f010", "url": "https://github.com/elastic/elasticsearch/commit/5c2390a90f74727bbb02e82717943445f890f010", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse", "committedDate": "2020-05-06T06:17:13Z", "type": "commit"}, {"oid": "5813066992b78c306863af85f633585e52b9a518", "url": "https://github.com/elastic/elasticsearch/commit/5813066992b78c306863af85f633585e52b9a518", "message": "modify tests", "committedDate": "2020-05-06T07:51:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMDcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r420630729", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(time( 10, 20, 30, 123000000),\n          \n          \n            \n                    assertEquals(time(10, 20, 30, 123000000),", "author": "matriv", "createdAt": "2020-05-06T08:39:49Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -185,14 +185,12 @@ public void testParsing() {\n                 .process(null)\n         );\n         // TimeParse\n-        assertEquals(\n-                time( 10, 20, 30, 123000000),\n+        assertEquals(time( 10, 20, 30, 123000000),", "originalCommit": "151042ac8c1ebd16368d0c632c23d88a576ecce1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f674d01d573f0be79b02eae953c9f285c6f9b0c9", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 97dd1701308..9fabb7d35d4 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -166,31 +168,35 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         // DateTimeParse\n         ZoneId zoneId = ZoneId.of(\"America/Sao_Paulo\");\n         assertEquals(\n-            dateTime(2020, 4, 7, 10, 20, 30, 123000000),\n-            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123\"), l(\"dd/MM/uuuu HH:mm:ss.SSS\")).makePipe()\n+            dateTime(2020, 4, 7, 10, 20, 30, 123000000, zoneId),\n+            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123\"), l(\"dd/MM/uuuu HH:mm:ss.SSS\"), zoneId)\n+                .makePipe()\n                 .asProcessor()\n                 .process(null)\n         );\n         assertEquals(\n-            dateTime(2020, 4, 7, 10, 20, 30, 123456789, zoneId),\n-            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 America/Sao_Paulo\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS VV\"))\n+            dateTime(2020, 4, 7, 5, 20, 30, 123456789, zoneId),\n+            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 Europe/Berlin\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS VV\"), zoneId)\n                 .makePipe()\n                 .asProcessor()\n                 .process(null)\n         );\n         assertEquals(\n-            dateTime(2020, 4, 7, 10, 20, 30, 123456789, ZoneId.of(\"+05:30\")),\n-            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 +05:30\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS zz\")).makePipe()\n+            dateTime(2020, 4, 7, 1, 50, 30, 123456789, zoneId),\n+            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 +05:30\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS zz\"), zoneId)\n+                .makePipe()\n                 .asProcessor()\n                 .process(null)\n         );\n         // TimeParse\n-        assertEquals(time( 10, 20, 30, 123000000),\n+        assertEquals(\n+                time(10, 20, 30, 123000000),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\")).makePipe()\n                         .asProcessor()\n                         .process(null)\n         );\n-        assertEquals(time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\")),\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\")),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\")).makePipe()\n                         .asProcessor()\n                         .process(null)\n"}}, {"oid": "f674d01d573f0be79b02eae953c9f285c6f9b0c9", "url": "https://github.com/elastic/elasticsearch/commit/f674d01d573f0be79b02eae953c9f285c6f9b0c9", "message": "extract BaseDateTimeParseFunction", "committedDate": "2020-05-07T02:46:12Z", "type": "commit"}, {"oid": "e4704af2ebf67c05c291bff25977492c8ba8615c", "url": "https://github.com/elastic/elasticsearch/commit/e4704af2ebf67c05c291bff25977492c8ba8615c", "message": "modify tests", "committedDate": "2020-05-07T04:23:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2ODgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421368837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Parser extractor() {\n          \n          \n            \n                public Parser parser() {", "author": "matriv", "createdAt": "2020-05-07T09:30:40Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){\n+        return parser.toString();\n+    }\n+    \n+    public Parser extractor() {", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..21979f1c115 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -130,8 +121,8 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n+                && Objects.equals(parser, other.parser);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTAxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {\n          \n          \n            \n                public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId, Parser parser) {", "author": "matriv", "createdAt": "2020-05-07T09:31:01Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);\n+                } else if (ta instanceof ZonedDateTime){\n+                    return ((ZonedDateTime) ta).withZoneSameInstant(zoneId);\n+                } else {\n+                    return ta;\n+                }\n+            } catch (IllegalArgumentException | DateTimeException e) {\n+                String msg = e.getMessage();\n+                if (msg.contains(\"Unable to convert parsed text using any of the specified queries\")) {\n+                    msg = format(null, \"Unable to convert parsed text into [{}]\", this.parseType);\n+                }\n+                throw new SqlIllegalArgumentException(\n+                    \"Invalid {} string [{}] or pattern [{}] is received; {}\",\n+                    this.parseType,\n+                    timestamp,\n+                    pattern,\n+                    msg\n+                );\n+            }\n+        }\n+    }\n+    \n+    private final Parser parser;\n+\n     public static final String NAME = \"dtparse\";\n \n-    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId) {\n+    public DateTimeParseProcessor(Processor source1, Processor source2, ZoneId zoneId , Parser parser) {", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..21979f1c115 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -18,7 +18,6 @@ import java.time.LocalTime;\n import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n-import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.time.temporal.TemporalQuery;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369302", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.hash(parser, left(), right());\n          \n          \n            \n                    return Objects.hash(left(), right(), parser);", "author": "matriv", "createdAt": "2020-05-07T09:31:27Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -79,12 +111,12 @@ public String getWriteableName() {\n \n     @Override\n     protected Object doProcess(Object timestamp, Object pattern) {\n-        return process(timestamp, pattern, zoneId());\n+        return this.parser.parse(timestamp, pattern, zoneId());\n     }\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right());\n+        return Objects.hash(parser, left(), right());", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMzU1MA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421913550", "bodyText": "What's the difference?", "author": "Patrick0308", "createdAt": "2020-05-08T03:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5ODU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421998588", "bodyText": "Minor, just to have the same order as in the constructor.", "author": "matriv", "createdAt": "2020-05-08T07:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..5c412b0d19d 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -116,7 +107,7 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(parser, left(), right());\n+        return Objects.hash(left(), right(), parser);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2OTY3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421369677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.equals(parser, other.parser)\n          \n          \n            \n                    return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n          \n          \n            \n                        && Objects.equals(parser, other.parser);", "author": "matriv", "createdAt": "2020-05-07T09:32:01Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..21979f1c115 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -130,8 +121,8 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n+                && Objects.equals(parser, other.parser);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDE1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421370156", "bodyText": "Is this used? If so it shouldn't contain only the parser.toString() but also left & and right.", "author": "matriv", "createdAt": "2020-05-07T09:32:46Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -98,6 +130,16 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(parser, other.parser)\n+            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+    }\n+\n+    @Override\n+    public String toString(){", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk5OTkwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421999909", "bodyText": "It's useless, I remove it.", "author": "Patrick0308", "createdAt": "2020-05-08T07:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MDE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..21979f1c115 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -130,8 +121,8 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n+                && Objects.equals(parser, other.parser);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MjEwNA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421372104", "bodyText": "The zoneId should be passed and used, please check out the changes in #56158", "author": "matriv", "createdAt": "2020-05-07T09:36:02Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex e2ee7c0421b..77cb2f1d4fd 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -7,7 +7,6 @@ package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421373537", "bodyText": "The user session zoneId should be used.\nAn if for the OffsetTime should be added to apply the session zoneId also for times with a zone in the pattern.", "author": "matriv", "createdAt": "2020-05-07T09:38:26Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -6,70 +6,102 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.xpack.ql.expression.gen.processor.Processor;\n import org.elasticsearch.xpack.sql.SqlIllegalArgumentException;\n import org.elasticsearch.xpack.sql.util.DateUtils;\n \n import java.io.IOException;\n import java.time.DateTimeException;\n import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n import java.util.Locale;\n import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n \n public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n+    public enum Parser {\n+        DATE_TIME(\"datetime\", ZonedDateTime::from, LocalDateTime::from), \n+        TIME(\"time\", OffsetTime::from, LocalTime::from);\n+        \n+        private final BiFunction<String, String, TemporalAccessor> parser;\n+        \n+        private final String parseType;\n+\n+        Parser(String parseType,  TemporalQuery<?>... queries) {\n+            this.parseType = parseType;\n+            this.parser = (timestampStr, pattern) -> DateTimeFormatter.ofPattern(pattern, Locale.ROOT)\n+                    .parseBest(timestampStr, queries);\n+        }\n+\n+        public Object parse(Object timestamp, Object pattern, ZoneId zoneId) {\n+            if (timestamp == null || pattern == null) {\n+                return null;\n+            }\n+            if (timestamp instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", timestamp);\n+            }\n+            if (pattern instanceof String == false) {\n+                throw new SqlIllegalArgumentException(\"A string is required; received [{}]\", pattern);\n+            }\n+\n+            if (((String) timestamp).isEmpty() || ((String) pattern).isEmpty()) {\n+                return null;\n+            }\n+            try {\n+                TemporalAccessor ta = parser.apply((String) timestamp, (String) pattern);\n+                if (ta instanceof LocalDateTime) {\n+                    return DateUtils.atTimeZone((LocalDateTime) ta, zoneId);\n+                } else if (ta instanceof LocalTime) {\n+                    return OffsetTime.of((LocalTime) ta, ZoneOffset.UTC);", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzMTk3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421931979", "bodyText": "public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n}\nIs this the right way\uff1f", "author": "Patrick0308", "createdAt": "2020-05-08T04:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MzUzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 46d24dc3206..21979f1c115 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -18,7 +18,6 @@ import java.time.LocalTime;\n import java.time.OffsetTime;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n-import java.time.ZoneOffset;\n import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n import java.time.temporal.TemporalQuery;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NDI3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421374272", "bodyText": "Parent class could hold a parser variable which is set accordingly in the constructors of the sub classes so this method and createPipe can be moved to the parent class.", "author": "matriv", "createdAt": "2020-05-07T09:39:36Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n+\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n+\n+import java.time.ZoneId;\n+\n+import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+\n+public class TimeParse extends BaseDateTimeParseFunction {\n+    \n+    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n+        super(source, timestamp, pattern, UTC);\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return SqlDataTypes.TIME;\n+    }\n+\n+    @Override\n+    protected BinaryScalarFunction replaceChildren(Expression timestamp, Expression pattern) {\n+        return new TimeParse(source(), timestamp, pattern);\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, TimeParse::new, left(), right());\n+    }\n+\n+    @Override\n+    protected String scriptMethodName() {\n+        return \"timeParse\";\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return TIME.parse(left().fold(), right().fold(), zoneId());", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex e2ee7c0421b..77cb2f1d4fd 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -7,7 +7,6 @@ package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NTk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421375995", "bodyText": "DATE_TIME should be randomized with randomFrom(Parser.values())", "author": "matriv", "createdAt": "2020-05-07T09:42:24Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,12 +53,12 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId(), DATE_TIME);", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex ee04c9d2a8b..f9526a4bd77 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -53,12 +53,12 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId(), DATE_TIME);\n+        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId(), randomFrom(Parser.values()));\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), DATE_TIME);\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), randomFrom(Parser.values()));\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NzU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421377571", "bodyText": "Please change test tests similarly to https://github.com/elastic/elasticsearch/pull/55223/files#diff-4469bf63c6bd559fd4d04c24e52f23e4R172 where the session timezone is used for the resulting time.", "author": "matriv", "createdAt": "2020-05-07T09:44:50Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 9fabb7d35d4..80b07b77ab0 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -191,13 +191,13 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         // TimeParse\n         assertEquals(\n                 time(10, 20, 30, 123000000),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\")).makePipe()\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n                         .asProcessor()\n                         .process(null)\n         );\n         assertEquals(\n                 time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\")),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\")).makePipe()\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n                         .asProcessor()\n                         .process(null)\n         );\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDAwMg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r421380002", "bodyText": "DateTimeParse shouldn't be then only function used in the creation of the pipe, since the pipe now doesn't \"belong\" to one function but it's more generic. Check this example https://github.com/elastic/elasticsearch/blob/master/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/string/BinaryStringNumericPipeTests.java#L42 where you can randomize between the 2 functions DateTimeParse and TimeParse.", "author": "matriv", "createdAt": "2020-05-07T09:48:50Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -23,6 +23,8 @@\n import static org.elasticsearch.xpack.ql.expression.Expressions.pipe;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.ql.tree.SourceTests.randomSource;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+\n \n public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePipe, Pipe> {", "originalCommit": "e4704af2ebf67c05c291bff25977492c8ba8615c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex ee04c9d2a8b..f9526a4bd77 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -23,7 +23,7 @@ import java.util.function.Function;\n import static org.elasticsearch.xpack.ql.expression.Expressions.pipe;\n import static org.elasticsearch.xpack.ql.expression.function.scalar.FunctionTestUtils.randomStringLiteral;\n import static org.elasticsearch.xpack.ql.tree.SourceTests.randomSource;\n-import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n \n public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePipe, Pipe> {\n"}}, {"oid": "ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "url": "https://github.com/elastic/elasticsearch/commit/ab81a18cf90eb507ca38c75204bb4e7788d7b4b0", "message": "optimize code and offset time apply the session zoneId", "committedDate": "2020-05-08T07:30:16Z", "type": "commit"}, {"oid": "c8f808e52d241c69799659c9a92b4b3694b6792a", "url": "https://github.com/elastic/elasticsearch/commit/c8f808e52d241c69799659c9a92b4b3694b6792a", "message": "Revert: optimize code and offset time apply the session zoneId (ab81a18c)", "committedDate": "2020-05-08T07:33:17Z", "type": "commit"}, {"oid": "6d562e8c26767ddaef586d198b08c3f42c7c53ea", "url": "https://github.com/elastic/elasticsearch/commit/6d562e8c26767ddaef586d198b08c3f42c7c53ea", "message": "remove DateTimeParseProcessor.toString", "committedDate": "2020-05-08T07:46:35Z", "type": "commit"}, {"oid": "0e4ad4e3f7cabc2ecbfb650d7effffc48306c12b", "url": "https://github.com/elastic/elasticsearch/commit/0e4ad4e3f7cabc2ecbfb650d7effffc48306c12b", "message": "format DateTimeParsePipeTests", "committedDate": "2020-05-08T07:47:43Z", "type": "commit"}, {"oid": "a4981fabd5aeea09ff4a26a59dabc1616ebde234", "url": "https://github.com/elastic/elasticsearch/commit/a4981fabd5aeea09ff4a26a59dabc1616ebde234", "message": "modify atTimeZone", "committedDate": "2020-05-08T07:48:57Z", "type": "commit"}, {"oid": "6b511e5420dea6f0eb47188f49978d50fd4db4ff", "url": "https://github.com/elastic/elasticsearch/commit/6b511e5420dea6f0eb47188f49978d50fd4db4ff", "message": "Modify DateTimeParseProcessorTests.testParsing", "committedDate": "2020-05-08T08:09:19Z", "type": "commit"}, {"oid": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "url": "https://github.com/elastic/elasticsearch/commit/1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "message": "Optimize code", "committedDate": "2020-05-08T08:11:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMTgzNg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422011836", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(lt.atDate(LocalDate.EPOCH)).get(0));", "author": "matriv", "createdAt": "2020-05-08T08:17:55Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n+    }\n+    \n+    public static OffsetTime atTimeZone(LocalTime lt, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));", "originalCommit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4a59795536910406852cc7703cedaef062ce8f2e", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\nindex d8dafa61ee0..fc7d13d7a8a 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\n\n@@ -213,12 +213,12 @@ public final class DateUtils {\n     }\n     \n     public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n-        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        LocalDateTime ldt = ot.atDate(LocalDate.EPOCH).toLocalDateTime();\n         return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n     }\n     \n     public static OffsetTime atTimeZone(LocalTime lt, ZoneId zoneId) {\n-        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        LocalDateTime ldt = lt.atDate(LocalDate.EPOCH);\n         return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));\n     }\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422012831", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n          \n          \n            \n                    return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ot.atDate(LocalDate.EPOCH).toLocalDateTime()).get(0));", "author": "matriv", "createdAt": "2020-05-08T08:20:10Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java", "diffHunk": "@@ -209,4 +211,32 @@ public static int getNanoPrecision(Expression precisionExpression, int nano) {\n     public static ZonedDateTime atTimeZone(LocalDateTime ldt, ZoneId zoneId) {\n         return ZonedDateTime.ofInstant(ldt, zoneId.getRules().getValidOffsets(ldt).get(0), zoneId);\n     }\n+    \n+    public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n+        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));", "originalCommit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4a59795536910406852cc7703cedaef062ce8f2e", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\nindex d8dafa61ee0..fc7d13d7a8a 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/util/DateUtils.java\n\n@@ -213,12 +213,12 @@ public final class DateUtils {\n     }\n     \n     public static OffsetTime atTimeZone(OffsetTime ot, ZoneId zoneId) {\n-        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        LocalDateTime ldt = ot.atDate(LocalDate.EPOCH).toLocalDateTime();\n         return ot.withOffsetSameInstant(zoneId.getRules().getValidOffsets(ldt).get(0));\n     }\n     \n     public static OffsetTime atTimeZone(LocalTime lt, ZoneId zoneId) {\n-        LocalDateTime ldt = ZonedDateTime.now(zoneId).toLocalDateTime();\n+        LocalDateTime ldt = lt.atDate(LocalDate.EPOCH);\n         return OffsetTime.of(lt, zoneId.getRules().getValidOffsets(ldt).get(0));\n     }\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013265", "bodyText": "Suggested change", "author": "matriv", "createdAt": "2020-05-08T08:21:08Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    \n     @Override\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return DateTimeParse::new;\n     }\n-\n+    ", "originalCommit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698ae838dcafda5a82c66f1dd1a44fac651191ae", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\nindex a7428b3da7a..e5fa3b9ca69 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n\n@@ -22,17 +22,17 @@ public class DateTimeParse extends BaseDateTimeParseFunction {\n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-    \n+\n     @Override\n     protected Parser parser() {\n         return DATE_TIME;\n     }\n-    \n+\n     @Override\n     protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n         return DateTimeParse::new;\n     }\n-    \n+\n     @Override\n     public DataType dataType() {\n         return DataTypes.DATETIME;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzMwNg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013306", "bodyText": "Suggested change", "author": "matriv", "createdAt": "2020-05-08T08:21:14Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DATETIME;\n+    protected Parser parser() {\n+        return DATE_TIME;\n     }\n-\n+    ", "originalCommit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698ae838dcafda5a82c66f1dd1a44fac651191ae", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\nindex a7428b3da7a..e5fa3b9ca69 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n\n@@ -22,17 +22,17 @@ public class DateTimeParse extends BaseDateTimeParseFunction {\n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-    \n+\n     @Override\n     protected Parser parser() {\n         return DATE_TIME;\n     }\n-    \n+\n     @Override\n     protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n         return DateTimeParse::new;\n     }\n-    \n+\n     @Override\n     public DataType dataType() {\n         return DataTypes.DATETIME;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMzM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r422013366", "bodyText": "Suggested change", "author": "matriv", "createdAt": "2020-05-08T08:21:23Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java", "diffHunk": "@@ -6,64 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.DATE_TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class DateTimeParse extends BinaryDateTimeFunction {\n+public class DateTimeParse extends BaseDateTimeParseFunction {\n \n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "originalCommit": "1124bc69f6cc6cbaa4c51262a242d00a4c4e8cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698ae838dcafda5a82c66f1dd1a44fac651191ae", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\nindex a7428b3da7a..e5fa3b9ca69 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParse.java\n\n@@ -22,17 +22,17 @@ public class DateTimeParse extends BaseDateTimeParseFunction {\n     public DateTimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-    \n+\n     @Override\n     protected Parser parser() {\n         return DATE_TIME;\n     }\n-    \n+\n     @Override\n     protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n         return DateTimeParse::new;\n     }\n-    \n+\n     @Override\n     public DataType dataType() {\n         return DataTypes.DATETIME;\n"}}, {"oid": "4a59795536910406852cc7703cedaef062ce8f2e", "url": "https://github.com/elastic/elasticsearch/commit/4a59795536910406852cc7703cedaef062ce8f2e", "message": "optimize code", "committedDate": "2020-05-08T08:48:36Z", "type": "commit"}, {"oid": "698ae838dcafda5a82c66f1dd1a44fac651191ae", "url": "https://github.com/elastic/elasticsearch/commit/698ae838dcafda5a82c66f1dd1a44fac651191ae", "message": "remove whitespaces", "committedDate": "2020-05-08T08:50:23Z", "type": "commit"}, {"oid": "d9e7f955ebff15b548189508977093ecd2327415", "url": "https://github.com/elastic/elasticsearch/commit/d9e7f955ebff15b548189508977093ecd2327415", "message": "modify unit test", "committedDate": "2020-05-08T10:11:06Z", "type": "commit"}, {"oid": "39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa", "url": "https://github.com/elastic/elasticsearch/commit/39bbb3fdb5bfa9297bf17a0214319bdd603fdeaa", "message": "Modify csv tests", "committedDate": "2020-05-08T10:28:07Z", "type": "commit"}, {"oid": "e5b3345ed6a1f22859c8a9e58cea9d19ed8557ad", "url": "https://github.com/elastic/elasticsearch/commit/e5b3345ed6a1f22859c8a9e58cea9d19ed8557ad", "message": "add note", "committedDate": "2020-05-08T14:22:15Z", "type": "commit"}, {"oid": "9cbaf5ff63d4f94479cf8027d16d7380c7fead8b", "url": "https://github.com/elastic/elasticsearch/commit/9cbaf5ff63d4f94479cf8027d16d7380c7fead8b", "message": "modify unit test", "committedDate": "2020-05-08T14:23:28Z", "type": "commit"}, {"oid": "74fb5ddf3c2cd233606cdf91c575b425b612f5bd", "url": "https://github.com/elastic/elasticsearch/commit/74fb5ddf3c2cd233606cdf91c575b425b612f5bd", "message": "modify docs", "committedDate": "2020-05-08T14:28:43Z", "type": "commit"}, {"oid": "1ebd5f883f5fdc1808f6ab815c64c1d21c716eec", "url": "https://github.com/elastic/elasticsearch/commit/1ebd5f883f5fdc1808f6ab815c64c1d21c716eec", "message": "modify note", "committedDate": "2020-05-08T15:44:27Z", "type": "commit"}, {"oid": "5dcd01fac5478906983ea422589b736d1c23ec45", "url": "https://github.com/elastic/elasticsearch/commit/5dcd01fac5478906983ea422589b736d1c23ec45", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-05-08T16:51:58Z", "type": "commit"}, {"oid": "7f20c85f7c0534b92c53d6be131cb6019faef965", "url": "https://github.com/elastic/elasticsearch/commit/7f20c85f7c0534b92c53d6be131cb6019faef965", "message": "modify docs", "committedDate": "2020-05-09T00:32:40Z", "type": "commit"}, {"oid": "04f50cac49a64cd4f73aaed73c99024999a5029c", "url": "https://github.com/elastic/elasticsearch/commit/04f50cac49a64cd4f73aaed73c99024999a5029c", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse", "committedDate": "2020-05-09T00:32:57Z", "type": "commit"}, {"oid": "d06031745f00b2772cc3935365572826bc4226b3", "url": "https://github.com/elastic/elasticsearch/commit/d06031745f00b2772cc3935365572826bc4226b3", "message": "rename function name to randomDateTimeParsePipe", "committedDate": "2020-05-11T04:51:13Z", "type": "commit"}, {"oid": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "url": "https://github.com/elastic/elasticsearch/commit/9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-05-13T14:00:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0MjIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427142202", "bodyText": "zoneId() should be part of equals and hashCode methods, through super method calls.", "author": "astefan", "createdAt": "2020-05-19T08:58:40Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -128,16 +121,11 @@ public boolean equals(Object obj) {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(parser, other.parser)\n-            && Objects.equals(left(), other.left()) && Objects.equals(right(), other.right());\n-    }\n-\n-    @Override\n-    public String toString(){\n-        return parser.toString();\n+        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e76b1182ad651a7484fc8be95909e229be6f641d", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 5c412b0d19d..3e66b27a816 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -122,7 +122,7 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n         return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n-                && Objects.equals(parser, other.parser);\n+                && Objects.equals(zoneId(), other.zoneId()) && Objects.equals(parser, other.parser);\n     }\n     \n     public Parser parser() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146599", "bodyText": "Please, remove these whitespaces.", "author": "astefan", "createdAt": "2020-05-19T09:05:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    ", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex 77cb2f1d4fd..968e30cb15f 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -22,7 +22,7 @@ public class TimeParse extends BaseDateTimeParseFunction {\n     public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-    \n+\n     @Override\n     protected Parser parser() {\n         return TIME;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NjY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427146674", "bodyText": "Please, remove these whitespaces.", "author": "astefan", "createdAt": "2020-05-19T09:05:25Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java", "diffHunk": "@@ -6,65 +6,46 @@\n package org.elasticsearch.xpack.sql.expression.function.scalar.datetime;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.function.scalar.BinaryScalarFunction;\n-import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.sql.type.SqlDataTypes;\n \n import java.time.ZoneId;\n \n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isString;\n-import static org.elasticsearch.xpack.ql.type.DateUtils.UTC;\n import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser.TIME;\n+import static org.elasticsearch.xpack.sql.expression.function.scalar.datetime.DateTimeParseProcessor.Parser;\n \n-public class TimeParse extends BinaryDateTimeFunction {\n+public class TimeParse extends BaseDateTimeParseFunction {\n     \n-    public TimeParse(Source source, Expression timestamp, Expression pattern) {\n-        super(source, timestamp, pattern, UTC);\n+    public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n+        super(source, timestamp, pattern, zoneId);\n     }\n-\n+    \n     @Override\n-    public DataType dataType() {\n-        return SqlDataTypes.TIME;\n+    protected Parser parser() {\n+        return TIME;\n     }\n-\n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = isString(left(), sourceText(), Expressions.ParamOrdinal.FIRST);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        resolution = isString(right(), sourceText(), Expressions.ParamOrdinal.SECOND);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-        return TypeResolution.TYPE_RESOLVED;\n+    \n+    @Override\n+    protected NodeInfo.NodeCtor3<Expression, Expression, ZoneId, BaseDateTimeParseFunction> ctorForInfo() {\n+        return TimeParse::new;\n     }\n-\n+    ", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\nindex 77cb2f1d4fd..968e30cb15f 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/TimeParse.java\n\n@@ -22,7 +22,7 @@ public class TimeParse extends BaseDateTimeParseFunction {\n     public TimeParse(Source source, Expression timestamp, Expression pattern, ZoneId zoneId) {\n         super(source, timestamp, pattern, zoneId);\n     }\n-    \n+\n     @Override\n     protected Parser parser() {\n         return TIME;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjcxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427166711", "bodyText": "This should be new DateTimeParsePipe(b3.source().....). You change here the Parser not the Source. Source was changed and asserted before this.", "author": "astefan", "createdAt": "2020-05-19T09:37:19Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -53,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), DATE_TIME);\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), DATE_TIME);\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(newLoc, b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "590b1585608e862f9fba6532940ab2cc05b5dfeb", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex 544c3abdcfe..58f35ae1b04 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -77,8 +78,13 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n     \n         DateTimeParsePipe b3 = randomInstance();\n         Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n-        newB = new DateTimeParsePipe(newLoc, b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n+        newB = new DateTimeParsePipe(b3.source(), b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n         assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n+    \n+        DateTimeParsePipe b4 = randomInstance();\n+        ZoneId newZI = ESTestCase.randomZone();\n+        newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNTU2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427205565", "bodyText": "In testTransform I think you need to test a new zoneId, as well.", "author": "astefan", "createdAt": "2020-05-19T10:45:03Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +61,38 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "590b1585608e862f9fba6532940ab2cc05b5dfeb", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex 544c3abdcfe..58f35ae1b04 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -77,8 +78,13 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n     \n         DateTimeParsePipe b3 = randomInstance();\n         Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n-        newB = new DateTimeParsePipe(newLoc, b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n+        newB = new DateTimeParsePipe(b3.source(), b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n         assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n+    \n+        DateTimeParsePipe b4 = randomInstance();\n+        ZoneId newZI = ESTestCase.randomZone();\n+        newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245670", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "author": "astefan", "createdAt": "2020-05-19T11:59:33Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -76,7 +82,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"2020-04-07\"), l(\"MM/dd\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [2020-04-07] or pattern [MM/dd] is received; Text '2020-04-07' could not be parsed at index 2\",\n+            \"Invalid datetime string [2020-04-07] or pattern [MM/dd] is received; \" +\n+                    \"Text '2020-04-07' could not be parsed at index 2\",", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 265f9fa9291..926172ac84b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -82,8 +82,7 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n             () -> new DateTimeParse(Source.EMPTY, l(\"2020-04-07\"), l(\"MM/dd\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid datetime string [2020-04-07] or pattern [MM/dd] is received; \" +\n-                    \"Text '2020-04-07' could not be parsed at index 2\",\n+            \"Invalid datetime string [2020-04-07] or pattern [MM/dd] is received; Text '2020-04-07' could not be parsed at index 2\",\n             siae.getMessage()\n         );\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTczNg==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245736", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "author": "astefan", "createdAt": "2020-05-19T11:59:41Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -85,7 +92,8 @@ public void testInvalidInputs() {\n             () -> new DateTimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [07/05/2020] or pattern [dd/MM/uuuu] is received; Unable to convert parsed text into [datetime]\",\n+            \"Invalid datetime string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                    \"Unable to convert parsed text into [datetime]\",", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 265f9fa9291..926172ac84b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -92,8 +91,7 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n             () -> new DateTimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid datetime string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n-                    \"Unable to convert parsed text into [datetime]\",\n+            \"Invalid datetime string [07/05/2020] or pattern [dd/MM/uuuu] is received; Unable to convert parsed text into [datetime]\",\n             siae.getMessage()\n         );\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NTg3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427245878", "bodyText": "Why did you split these on two separate lines? They fit on a single line.", "author": "astefan", "createdAt": "2020-05-19T11:59:58Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -94,20 +102,70 @@ public void testInvalidInputs() {\n                 Source.EMPTY, l(\"10:20:30.123456789\"), l(\"HH:mm:ss.SSSSSSSSS\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-            \"Invalid date/time string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n+            \"Invalid datetime string [10:20:30.123456789] or pattern [HH:mm:ss.SSSSSSSSS] is received; \"\n                 + \"Unable to convert parsed text into [datetime]\",\n             siae.getMessage()\n         );\n     }\n+    \n+    public void testTimeInvalidInputs() {\n+        SqlIllegalArgumentException siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(10), randomStringLiteral(), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [10]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, randomStringLiteral(), l(20), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\"A string is required; received [20]\", siae.getMessage());\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"invalid\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [invalid] is received; Unknown pattern letter: i\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"11:04:07\"), l(\"HH:mm\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [11:04:07] or pattern [HH:mm] is received; \" +\n+                        \"Text '11:04:07' could not be parsed, unparsed text found at index 5\",\n+                siae.getMessage()\n+        );\n+        \n+        siae = expectThrows(\n+                SqlIllegalArgumentException.class,\n+                () -> new TimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n+        );\n+        assertEquals(\n+                \"Invalid time string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n+                        \"Unable to convert parsed text into [time]\",", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 265f9fa9291..926172ac84b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -145,8 +143,7 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n                 () -> new TimeParse(Source.EMPTY, l(\"07/05/2020\"), l(\"dd/MM/uuuu\"), randomZone()).makePipe().asProcessor().process(null)\n         );\n         assertEquals(\n-                \"Invalid time string [07/05/2020] or pattern [dd/MM/uuuu] is received; \" +\n-                        \"Unable to convert parsed text into [time]\",\n+                \"Invalid time string [07/05/2020] or pattern [dd/MM/uuuu] is received; Unable to convert parsed text into [time]\",\n                 siae.getMessage()\n         );\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NjgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427246837", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "author": "astefan", "createdAt": "2020-05-19T12:01:45Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 265f9fa9291..926172ac84b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -192,14 +189,14 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         assertEquals(\n                 time(10, 20, 30, 123000000, zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)\n         );\n         assertEquals(\n                 time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)\n         );\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NzA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427247048", "bodyText": "These lines do not align with the previous tests in the same method. Please, use the same indentation rules.", "author": "astefan", "createdAt": "2020-05-19T12:02:11Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +188,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                        .asProcessor()\n+                        .process(null)", "originalCommit": "9d3e9a22ecf4c5f4e2c2e8692abc132335d0e2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bf2a6410481e822740514c54370b3ef67b3fde7", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 265f9fa9291..926172ac84b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -192,14 +189,14 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         assertEquals(\n                 time(10, 20, 30, 123000000, zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)\n         );\n         assertEquals(\n                 time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)\n         );\n     }\n }\n"}}, {"oid": "5bf2a6410481e822740514c54370b3ef67b3fde7", "url": "https://github.com/elastic/elasticsearch/commit/5bf2a6410481e822740514c54370b3ef67b3fde7", "message": "code format", "committedDate": "2020-05-20T08:05:34Z", "type": "commit"}, {"oid": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e", "url": "https://github.com/elastic/elasticsearch/commit/6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e", "message": "Merge remote-tracking branch 'origin/sql-time-parse' into sql-time-parse", "committedDate": "2020-05-20T08:05:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgzODM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r427838346", "bodyText": "All these four lines do not align with the rest of the calls in the same method. Compare these with the ones above and, please, change them to have a consistent look and feel.", "author": "astefan", "createdAt": "2020-05-20T08:39:24Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -192,14 +189,14 @@ public void testParsing() {\n         assertEquals(\n                 time(10, 20, 30, 123000000, zoneId),\n                 new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                        .asProcessor()\n-                        .process(null)\n+                    .asProcessor()\n+                    .process(null)", "originalCommit": "6a030e9c770b87f0f8b24b1cfb0ba809c1239e6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0290575d9bf90d6e3f102eda48b71316582a998d", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 926172ac84b..a035affd24b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -187,16 +187,16 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         );\n         // TimeParse\n         assertEquals(\n-                time(10, 20, 30, 123000000, zoneId),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                    .asProcessor()\n-                    .process(null)\n+            time(10, 20, 30, 123000000, zoneId),\n+            new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                .asProcessor()\n+                .process(null)\n         );\n         assertEquals(\n-                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n-                    .asProcessor()\n-                    .process(null)\n+            time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+            new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                .asProcessor()\n+                .process(null)\n         );\n     }\n }\n"}}, {"oid": "590b1585608e862f9fba6532940ab2cc05b5dfeb", "url": "https://github.com/elastic/elasticsearch/commit/590b1585608e862f9fba6532940ab2cc05b5dfeb", "message": "add zone transform test", "committedDate": "2020-05-21T04:26:12Z", "type": "commit"}, {"oid": "e76b1182ad651a7484fc8be95909e229be6f641d", "url": "https://github.com/elastic/elasticsearch/commit/e76b1182ad651a7484fc8be95909e229be6f641d", "message": "hashcode and equals include zoneId", "committedDate": "2020-05-21T04:27:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDU3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504574", "bodyText": "Please use super.hashCode() and add only the parser here.", "author": "matriv", "createdAt": "2020-05-21T08:00:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -107,7 +107,7 @@ protected Object doProcess(Object timestamp, Object pattern) {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right(), parser);\n+        return Objects.hash(left(), right(), zoneId(), parser);", "originalCommit": "e76b1182ad651a7484fc8be95909e229be6f641d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 3e66b27a816..cafd33d5e84 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -107,7 +107,7 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(left(), right(), zoneId(), parser);\n+        return Objects.hash(super.hashCode(), parser);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNDg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r428504890", "bodyText": "Please use super.equals() and only check the equality on parser here.", "author": "matriv", "createdAt": "2020-05-21T08:01:16Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java", "diffHunk": "@@ -122,7 +122,7 @@ public boolean equals(Object obj) {\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n         return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n-                && Objects.equals(parser, other.parser);\n+                && Objects.equals(zoneId(), other.zoneId()) && Objects.equals(parser, other.parser);", "originalCommit": "e76b1182ad651a7484fc8be95909e229be6f641d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\nindex 3e66b27a816..cafd33d5e84 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessor.java\n\n@@ -121,8 +121,7 @@ public class DateTimeParseProcessor extends BinaryDateTimeProcessor {\n         }\n \n         DateTimeParseProcessor other = (DateTimeParseProcessor) obj;\n-        return Objects.equals(left(), other.left()) && Objects.equals(right(), other.right())\n-                && Objects.equals(zoneId(), other.zoneId()) && Objects.equals(parser, other.parser);\n+        return super.equals(other) && Objects.equals(parser, other.parser);\n     }\n     \n     public Parser parser() {\n"}}, {"oid": "1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "url": "https://github.com/elastic/elasticsearch/commit/1f1a0df813b0738c7ff450e72b43fe16c36fbc8d", "message": "use super's hashcode and equal", "committedDate": "2020-05-23T09:22:07Z", "type": "commit"}, {"oid": "e2f346a1f5705d0e63388eafd684e15460fbfed9", "url": "https://github.com/elastic/elasticsearch/commit/e2f346a1f5705d0e63388eafd684e15460fbfed9", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse", "committedDate": "2020-05-25T02:32:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNTkyMA==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430535920", "bodyText": "This is wrong again. It should be\n        DateTimeParsePipe b4 = randomInstance();\n        ZoneId newZI = randomValueOtherThan(b4.zoneId(), ESTestCase::randomZone);\n        newB = new DateTimeParsePipe(b4.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n        assertEquals(newB, b4.transformPropertiesOnly(v -> Objects.equals(v, b4.zoneId()) ? newZI : v, ZoneId.class));", "author": "astefan", "createdAt": "2020-05-26T16:13:11Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java", "diffHunk": "@@ -51,21 +62,43 @@ public void testTransform() {\n         DateTimeParsePipe b1 = randomInstance();\n \n         Expression newExpression = randomValueOtherThan(b1.expression(), this::randomDateTimeParsePipeExpression);\n-        DateTimeParsePipe newB = new DateTimeParsePipe(b1.source(), newExpression, b1.left(), b1.right(), b1.zoneId());\n+        DateTimeParsePipe newB = new DateTimeParsePipe(\n+                b1.source(), \n+                newExpression, \n+                b1.left(), \n+                b1.right(), \n+                b1.zoneId(), \n+                b1.parser());\n         assertEquals(newB, b1.transformPropertiesOnly(v -> Objects.equals(v, b1.expression()) ? newExpression : v, Expression.class));\n \n         DateTimeParsePipe b2 = randomInstance();\n         Source newLoc = randomValueOtherThan(b2.source(), SourceTests::randomSource);\n-        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId());\n+        newB = new DateTimeParsePipe(newLoc, b2.expression(), b2.left(), b2.right(), b2.zoneId(), b2.parser());\n         assertEquals(newB, b2.transformPropertiesOnly(v -> Objects.equals(v, b2.source()) ? newLoc : v, Source.class));\n+    \n+        DateTimeParsePipe b3 = randomInstance();\n+        Parser newPr = randomValueOtherThan(b3.parser(), () -> randomFrom(Parser.values()));\n+        newB = new DateTimeParsePipe(b3.source(), b3.expression(), b3.left(), b3.right(), b3.zoneId(), newPr);\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n+    \n+        DateTimeParsePipe b4 = randomInstance();\n+        ZoneId newZI = ESTestCase.randomZone();\n+        newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n+        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));", "originalCommit": "e2f346a1f5705d0e63388eafd684e15460fbfed9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0290575d9bf90d6e3f102eda48b71316582a998d", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\nindex 58f35ae1b04..d6ada03b114 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParsePipeTests.java\n\n@@ -82,9 +82,9 @@ public class DateTimeParsePipeTests extends AbstractNodeTestCase<DateTimeParsePi\n         assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.parser()) ? newPr : v, Parser.class));\n     \n         DateTimeParsePipe b4 = randomInstance();\n-        ZoneId newZI = ESTestCase.randomZone();\n+        ZoneId newZI = randomValueOtherThan(b4.zoneId(), ESTestCase::randomZone);\n         newB = new DateTimeParsePipe(b3.source(), b4.expression(), b4.left(), b4.right(), newZI, b4.parser());\n-        assertEquals(newB, b3.transformPropertiesOnly(v -> Objects.equals(v, b3.zoneId()) ? newZI : v, ZoneId.class));\n+        assertEquals(newB, b4.transformPropertiesOnly(v -> Objects.equals(v, b4.zoneId()) ? newZI : v, ZoneId.class));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTI3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55223#discussion_r430539273", "bodyText": "Again, indentation should be consistent. This method should look like below. As it is now, it is not like I commented in my review.\n    public void testParsing() {\n        // DateTimeParse\n        ZoneId zoneId = ZoneId.of(\"America/Sao_Paulo\");\n        assertEquals(\n            dateTime(2020, 4, 7, 10, 20, 30, 123000000, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123\"), l(\"dd/MM/uuuu HH:mm:ss.SSS\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 5, 20, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 Europe/Berlin\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS VV\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            dateTime(2020, 4, 7, 1, 50, 30, 123456789, zoneId),\n            new DateTimeParse(Source.EMPTY, l(\"07/04/2020 10:20:30.123456789 +05:30\"), l(\"dd/MM/uuuu HH:mm:ss.SSSSSSSSS zz\"), zoneId)\n                .makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        // TimeParse\n        assertEquals(\n            time(10, 20, 30, 123000000, zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n        assertEquals(\n            time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n            new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n                .asProcessor()\n                .process(null)\n        );\n    }", "author": "astefan", "createdAt": "2020-05-26T16:18:07Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java", "diffHunk": "@@ -130,5 +185,18 @@ public void testParsing() {\n                 .asProcessor()\n                 .process(null)\n         );\n+        // TimeParse\n+        assertEquals(\n+                time(10, 20, 30, 123000000, zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );\n+        assertEquals(\n+                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                    .asProcessor()\n+                    .process(null)\n+        );", "originalCommit": "e2f346a1f5705d0e63388eafd684e15460fbfed9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0290575d9bf90d6e3f102eda48b71316582a998d", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\nindex 926172ac84b..a035affd24b 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/datetime/DateTimeParseProcessorTests.java\n\n@@ -187,16 +187,16 @@ public class DateTimeParseProcessorTests extends AbstractSqlWireSerializingTestC\n         );\n         // TimeParse\n         assertEquals(\n-                time(10, 20, 30, 123000000, zoneId),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n-                    .asProcessor()\n-                    .process(null)\n+            time(10, 20, 30, 123000000, zoneId),\n+            new TimeParse(Source.EMPTY, l(\"10:20:30.123\"), l(\"HH:mm:ss.SSS\"), zoneId).makePipe()\n+                .asProcessor()\n+                .process(null)\n         );\n         assertEquals(\n-                time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n-                new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n-                    .asProcessor()\n-                    .process(null)\n+            time(10, 20, 30, 123456789, ZoneOffset.of(\"+05:30\"), zoneId),\n+            new TimeParse(Source.EMPTY, l(\"10:20:30.123456789 +05:30\"), l(\"HH:mm:ss.SSSSSSSSS zz\"), zoneId).makePipe()\n+                .asProcessor()\n+                .process(null)\n         );\n     }\n }\n"}}, {"oid": "0290575d9bf90d6e3f102eda48b71316582a998d", "url": "https://github.com/elastic/elasticsearch/commit/0290575d9bf90d6e3f102eda48b71316582a998d", "message": "modify tests", "committedDate": "2020-05-27T10:11:24Z", "type": "commit"}, {"oid": "e3a04ddc3e4472fb0c7d30f520327c3ffead34c2", "url": "https://github.com/elastic/elasticsearch/commit/e3a04ddc3e4472fb0c7d30f520327c3ffead34c2", "message": "Merge remote-tracking branch 'upstream/master' into sql-time-parse", "committedDate": "2020-05-28T01:44:04Z", "type": "commit"}, {"oid": "128c7ca95d70fde8b30d6135596de1496092964e", "url": "https://github.com/elastic/elasticsearch/commit/128c7ca95d70fde8b30d6135596de1496092964e", "message": "override instanceZoneId", "committedDate": "2020-05-28T03:25:24Z", "type": "commit"}, {"oid": "6aafb36a0f75a82413fe65cbfe44c5deb82d6885", "url": "https://github.com/elastic/elasticsearch/commit/6aafb36a0f75a82413fe65cbfe44c5deb82d6885", "message": "Merge branch 'master' into sql-time-parse", "committedDate": "2020-05-28T17:17:01Z", "type": "commit"}]}