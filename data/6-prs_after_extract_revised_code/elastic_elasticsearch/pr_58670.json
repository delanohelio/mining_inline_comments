{"pr_number": 58670, "pr_title": "Accounting for model size when models are not cached.", "pr_createdAt": "2020-06-29T13:33:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/58670", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447000735", "bodyText": "We might want to make this package private. It seems that if we want to make sure that the circuit breaker stuff is handled correctly, that only things within this package should be able to ctor the model", "author": "benwtrent", "createdAt": "2020-06-29T14:09:56Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -39,14 +50,17 @@\n     private volatile long persistenceQuotient = 100;\n     private final LongAdder currentInferenceCount;\n     private final InferenceConfig inferenceConfig;\n+    private final CircuitBreaker trainedModelCircuitBreaker;\n+    private final AtomicLong referenceCount;\n \n     public LocalModel(String modelId,", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6920e9a57e3da6128701a547fef8ab8eb0812b3b", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 27f72715180..26bb1ef2d67 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -53,7 +53,7 @@ public class LocalModel {\n     private final CircuitBreaker trainedModelCircuitBreaker;\n     private final AtomicLong referenceCount;\n \n-    public LocalModel(String modelId,\n+    LocalModel(String modelId,\n                       String nodeId,\n                       InferenceDefinition trainedModelDefinition,\n                       TrainedModelInput input,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMDg2OA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447000868", "bodyText": "What do you think of adding a check on referenceCount to throw if it is 0?", "author": "benwtrent", "createdAt": "2020-06-29T14:10:07Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -97,7 +97,6 @@ void persistStats(boolean flush) {\n         }\n     }\n \n-    @Override\n     public void infer(Map<String, Object> fields, InferenceConfigUpdate update, ActionListener<InferenceResults> listener) {", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26801a5e2d6e9ca59ca2e1823af0360647b11396", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 27f72715180..7a6ada30a98 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -97,6 +99,20 @@ public class LocalModel {\n         }\n     }\n \n+    /**\n+     * Infers without updating the stats.\n+     * This is mainly for usage by data frame analytics jobs\n+     * when they do inference against test data.\n+     */\n+    public InferenceResults inferNoStats(Map<String, Object> fields) {\n+        LocalModel.mapFieldsIfNecessary(fields, defaultFieldMap);\n+        Map<String, Object> flattenedFields = MapHelper.dotCollapse(fields, fieldNames);\n+        if (flattenedFields.isEmpty()) {\n+            new WarningInferenceResults(Messages.getMessage(INFERENCE_WARNING_ALL_FIELDS_MISSING, modelId));\n+        }\n+        return trainedModelDefinition.infer(flattenedFields, inferenceConfig);\n+    }\n+\n     public void infer(Map<String, Object> fields, InferenceConfigUpdate update, ActionListener<InferenceResults> listener) {\n         if (update.isSupported(this.inferenceConfig) == false) {\n             listener.onFailure(ExceptionsHelper.badRequestException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMjg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447002842", "bodyText": "think we need a test here or something?\nWe might also want some tests to verify that our circuit breaker ends up back as zero. (Could be this same test).", "author": "benwtrent", "createdAt": "2020-06-29T14:12:48Z", "path": "x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingServiceTests.java", "diffHunk": "@@ -451,6 +451,10 @@ public void testCircuitBreakerBreak() throws Exception {\n         });\n     }\n \n+    public void testReferenceCounting() {", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26801a5e2d6e9ca59ca2e1823af0360647b11396", "chunk": "diff --git a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingServiceTests.java b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingServiceTests.java\nindex b3cc5bc400e..0cf1ea94b56 100644\n--- a/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingServiceTests.java\n+++ b/x-pack/plugin/ml/src/test/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingServiceTests.java\n\n@@ -451,8 +452,87 @@ public class ModelLoadingServiceTests extends ESTestCase {\n         });\n     }\n \n-    public void testReferenceCounting() {\n+    public void testReferenceCounting() throws ExecutionException, InterruptedException, IOException {\n+        String modelId = \"test-reference-counting\";\n+        withTrainedModel(modelId, 1L);\n+\n+        ModelLoadingService modelLoadingService = new ModelLoadingService(trainedModelProvider,\n+            auditor,\n+            threadPool,\n+            clusterService,\n+            trainedModelStatsService,\n+            Settings.EMPTY,\n+            \"test-node\",\n+            circuitBreaker);\n+\n+        modelLoadingService.clusterChanged(ingestChangedEvent(modelId));\n+\n+        PlainActionFuture<LocalModel> forPipeline = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, forPipeline);\n+        LocalModel model = forPipeline.get();\n+        assertEquals(2, model.getReferenceCount());\n \n+        PlainActionFuture<LocalModel> forSearch = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, forSearch);\n+        model = forSearch.get();\n+        assertEquals(3, model.getReferenceCount());\n+\n+        model.release();\n+\n+        PlainActionFuture<LocalModel> forSearch2 = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, forSearch2);\n+        model = forSearch2.get();\n+        assertEquals(3, model.getReferenceCount());\n+    }\n+\n+    public void testReferenceCountingForPipeline() throws ExecutionException, InterruptedException, IOException {\n+        String modelId = \"test-reference-counting-for-pipeline\";\n+        withTrainedModel(modelId, 1L);\n+\n+        ModelLoadingService modelLoadingService = new ModelLoadingService(trainedModelProvider,\n+            auditor,\n+            threadPool,\n+            clusterService,\n+            trainedModelStatsService,\n+            Settings.EMPTY,\n+            \"test-node\",\n+            circuitBreaker);\n+\n+        modelLoadingService.clusterChanged(ingestChangedEvent(modelId));\n+\n+        PlainActionFuture<LocalModel> forPipeline = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, forPipeline);\n+        LocalModel model = forPipeline.get();\n+        assertEquals(2, model.getReferenceCount());\n+\n+        PlainActionFuture<LocalModel> forPipeline2 = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, forPipeline2);\n+        model = forPipeline2.get();\n+        assertEquals(3, model.getReferenceCount());\n+\n+        // will cause the model to be evicted\n+        modelLoadingService.clusterChanged(ingestChangedEvent());\n+\n+        assertEquals(2, model.getReferenceCount());\n+    }\n+\n+    public void testReferenceCounting_ModelIsNotCached() throws ExecutionException, InterruptedException {\n+        String modelId = \"test-reference-counting-not-cached\";\n+        withTrainedModel(modelId, 1L);\n+\n+        ModelLoadingService modelLoadingService = new ModelLoadingService(trainedModelProvider,\n+            auditor,\n+            threadPool,\n+            clusterService,\n+            trainedModelStatsService,\n+            Settings.EMPTY,\n+            \"test-node\",\n+            circuitBreaker);\n+\n+        PlainActionFuture<LocalModel> future = new PlainActionFuture<>();\n+        modelLoadingService.getModelForPipeline(modelId, future);\n+        LocalModel model = future.get();\n+        assertEquals(1, model.getReferenceCount());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMzc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447003793", "bodyText": "package private? The only way to \"get\" a trained model object should be through a known code path. so, we should restrict their construction and restrict this method as well.", "author": "benwtrent", "createdAt": "2020-06-29T14:14:17Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -135,4 +134,39 @@ public void infer(Map<String, Object> fields, InferenceConfigUpdate update, Acti\n         }\n     }\n \n+    public long acquire() {", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6920e9a57e3da6128701a547fef8ab8eb0812b3b", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 27f72715180..26bb1ef2d67 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -134,7 +134,7 @@ public class LocalModel {\n         }\n     }\n \n-    public long acquire() {\n+    long acquire() {\n         return referenceCount.incrementAndGet();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwNzEyNA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447007124", "bodyText": "referenceCount.incrementAndGet() should always be > 1 correct? Do we want to prevent an acquire if the reference count has already reached zero?", "author": "benwtrent", "createdAt": "2020-06-29T14:18:39Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -135,4 +134,39 @@ public void infer(Map<String, Object> fields, InferenceConfigUpdate update, Acti\n         }\n     }\n \n+    public long acquire() {\n+        return referenceCount.incrementAndGet();", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6920e9a57e3da6128701a547fef8ab8eb0812b3b", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 27f72715180..26bb1ef2d67 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -134,7 +134,7 @@ public class LocalModel {\n         }\n     }\n \n-    public long acquire() {\n+    long acquire() {\n         return referenceCount.incrementAndGet();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxMjIxNw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447012217", "bodyText": "I wish our ActionListener classes had a finally clause....Not to signal the listener but to do things like our release or close here.", "author": "benwtrent", "createdAt": "2020-06-29T14:25:34Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportInternalInferModelAction.java", "diffHunk": "@@ -65,9 +65,14 @@ protected void doExecute(Task task, Request request, ActionListener<Response> li\n                         model.infer(stringObjectMap, request.getUpdate(), chainedTask)));\n \n                 typedChainTaskExecutor.execute(ActionListener.wrap(", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6920e9a57e3da6128701a547fef8ab8eb0812b3b", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportInternalInferModelAction.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportInternalInferModelAction.java\nindex e6424ad1050..c94c668a87b 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportInternalInferModelAction.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportInternalInferModelAction.java\n\n@@ -78,7 +78,7 @@ public class TransportInternalInferModelAction extends HandledTransportAction<Re\n             listener::onFailure\n         );\n \n-        if (licenseState.isAllowed(XPackLicenseState.Feature.MACHINE_LEARNING)) {\n+        if (licenseState.checkFeature(XPackLicenseState.Feature.MACHINE_LEARNING)) {\n             responseBuilder.setLicensed(true);\n             this.modelLoadingService.getModelForPipeline(request.getModelId(), getModelListener);\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNzY3NA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r447027674", "bodyText": "This might have a race condition (will think more)\n\nModel is grabbed from cache in 203. Model has a ref count of 1\nModel is evicted from cache due to size or something\nRef count is now 0\nModel is attempted to acquire again but ref count 0 and the bytes are already removed from the breaker", "author": "benwtrent", "createdAt": "2020-06-29T14:46:08Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -193,10 +199,11 @@ public void getModelForSearch(String modelId, ActionListener<Model> modelActionL\n      * @param consumer            which feature is requesting the model\n      * @param modelActionListener the listener to alert when the model has been retrieved.\n      */\n-    private void getModel(String modelId, Consumer consumer, ActionListener<Model> modelActionListener) {\n+    private void getModel(String modelId, Consumer consumer, ActionListener<LocalModel> modelActionListener) {\n         ModelAndConsumer cachedModel = localModelCache.get(modelId);\n         if (cachedModel != null) {\n             cachedModel.consumers.add(consumer);\n+            cachedModel.model.acquire();\n             modelActionListener.onResponse(cachedModel.model);\n             logger.trace(() -> new ParameterizedMessage(\"[{}] loaded from cache\", modelId));\n             return;", "originalCommit": "c2ca0c55d0734f92b7707577870a1076413a21fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY3MTI2OA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453671268", "bodyText": "I made a change so that if the ref count == 0 then the model bytes are added back to the circuit breaker. In some cases this means acquire could throw so I have to handle that", "author": "davidkyle", "createdAt": "2020-07-13T14:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNzY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "26801a5e2d6e9ca59ca2e1823af0360647b11396", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\nindex 2e55db91572..effcf0b5a4f 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n\n@@ -203,7 +203,12 @@ public class ModelLoadingService implements ClusterStateListener {\n         ModelAndConsumer cachedModel = localModelCache.get(modelId);\n         if (cachedModel != null) {\n             cachedModel.consumers.add(consumer);\n-            cachedModel.model.acquire();\n+            try {\n+                cachedModel.model.acquire();\n+            } catch (CircuitBreakingException e) {\n+                modelActionListener.onFailure(e);\n+                return;\n+            }\n             modelActionListener.onResponse(cachedModel.model);\n             logger.trace(() -> new ParameterizedMessage(\"[{}] loaded from cache\", modelId));\n             return;\n"}}, {"oid": "6920e9a57e3da6128701a547fef8ab8eb0812b3b", "url": "https://github.com/elastic/elasticsearch/commit/6920e9a57e3da6128701a547fef8ab8eb0812b3b", "message": "Add javadoc", "committedDate": "2020-07-01T08:04:23Z", "type": "forcePushed"}, {"oid": "26801a5e2d6e9ca59ca2e1823af0360647b11396", "url": "https://github.com/elastic/elasticsearch/commit/26801a5e2d6e9ca59ca2e1823af0360647b11396", "message": "Reference counting tests", "committedDate": "2020-07-13T12:03:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY1NzM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453657377", "bodyText": "The diff is bad. The change here is this line then indenting everything", "author": "davidkyle", "createdAt": "2020-07-13T13:40:59Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java", "diffHunk": "@@ -49,69 +49,74 @@ public InferencePipelineAggregator(String name, Map<String,\n     @Override\n     public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n \n-        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n-            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n-        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n-\n-        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n-        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n-            Map<String, Object> inputFields = new HashMap<>();\n-\n-            if (bucket.getDocCount() == 0) {\n-                // ignore this empty bucket unless the doc count is used\n-                if (bucketPathMap.containsKey(\"_count\") == false) {\n-                    newBuckets.add(bucket);\n-                    continue;\n+        try (model) {", "originalCommit": "26801a5e2d6e9ca59ca2e1823af0360647b11396", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java\nindex 8d4aa5c4785..8a0eb04df34 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/aggs/InferencePipelineAggregator.java\n\n@@ -49,74 +49,69 @@ public class InferencePipelineAggregator extends PipelineAggregator {\n     @Override\n     public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {\n \n-        try (model) {\n-            InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n-                (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n-            List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n-\n-            List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n-            for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n-                Map<String, Object> inputFields = new HashMap<>();\n-\n-                if (bucket.getDocCount() == 0) {\n-                    // ignore this empty bucket unless the doc count is used\n-                    if (bucketPathMap.containsKey(\"_count\") == false) {\n-                        newBuckets.add(bucket);\n-                        continue;\n-                    }\n+        InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg =\n+            (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation;\n+        List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets();\n+\n+        List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>();\n+        for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {\n+            Map<String, Object> inputFields = new HashMap<>();\n+\n+            if (bucket.getDocCount() == 0) {\n+                // ignore this empty bucket unless the doc count is used\n+                if (bucketPathMap.containsKey(\"_count\") == false) {\n+                    newBuckets.add(bucket);\n+                    continue;\n                 }\n+            }\n \n-                for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n-                    String aggName = entry.getKey();\n-                    String bucketPath = entry.getValue();\n-                    Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n-\n-                    if (propertyValue instanceof Number) {\n-                        double doubleVal = ((Number) propertyValue).doubleValue();\n-                        // NaN or infinite values indicate a missing value or a\n-                        // valid result of an invalid calculation. Either way only\n-                        // a valid number will do\n-                        if (Double.isFinite(doubleVal)) {\n-                            inputFields.put(aggName, doubleVal);\n-                        }\n-                    } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n-                        double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n-                        if (Double.isFinite(doubleVal)) {\n-                            inputFields.put(aggName, doubleVal);\n-                        }\n-                    } else if (propertyValue instanceof StringTerms.Bucket) {\n-                        StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n-                        inputFields.put(aggName, b.getKeyAsString());\n-                    } else if (propertyValue instanceof String) {\n-                        inputFields.put(aggName, propertyValue);\n-                    } else if (propertyValue != null) {\n-                        // Doubles, String terms or null are valid, any other type is an error\n-                        throw invalidAggTypeError(bucketPath, propertyValue);\n+            for (Map.Entry<String, String> entry : bucketPathMap.entrySet()) {\n+                String aggName = entry.getKey();\n+                String bucketPath = entry.getValue();\n+                Object propertyValue = resolveBucketValue(originalAgg, bucket, bucketPath);\n+\n+                if (propertyValue instanceof Number) {\n+                    double doubleVal = ((Number) propertyValue).doubleValue();\n+                    // NaN or infinite values indicate a missing value or a\n+                    // valid result of an invalid calculation. Either way only\n+                    // a valid number will do\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n                     }\n+                } else if (propertyValue instanceof InternalNumericMetricsAggregation.SingleValue) {\n+                    double doubleVal = ((InternalNumericMetricsAggregation.SingleValue) propertyValue).value();\n+                    if (Double.isFinite(doubleVal)) {\n+                        inputFields.put(aggName, doubleVal);\n+                    }\n+                } else if (propertyValue instanceof StringTerms.Bucket) {\n+                    StringTerms.Bucket b = (StringTerms.Bucket) propertyValue;\n+                    inputFields.put(aggName, b.getKeyAsString());\n+                } else if (propertyValue instanceof String) {\n+                    inputFields.put(aggName, propertyValue);\n+                } else if (propertyValue != null) {\n+                    // Doubles, String terms or null are valid, any other type is an error\n+                    throw invalidAggTypeError(bucketPath, propertyValue);\n                 }\n+            }\n \n \n-                InferenceResults inference;\n-                try {\n-                    inference = model.infer(inputFields, configUpdate);\n-                } catch (Exception e) {\n-                    inference = new WarningInferenceResults(e.getMessage());\n-                }\n-\n-                final List<InternalAggregation> aggs = bucket.getAggregations().asList().stream().map(\n-                    (p) -> (InternalAggregation) p).collect(Collectors.toList());\n-\n-                InternalInferenceAggregation aggResult = new InternalInferenceAggregation(name(), metadata(), inference);\n-                aggs.add(aggResult);\n-                InternalMultiBucketAggregation.InternalBucket newBucket = originalAgg.createBucket(InternalAggregations.from(aggs), bucket);\n-                newBuckets.add(newBucket);\n+            InferenceResults inference;\n+            try {\n+                inference = model.infer(inputFields, configUpdate);\n+            } catch (Exception e) {\n+                inference = new WarningInferenceResults(e.getMessage());\n             }\n \n-            // the model is released at the end of this block.\n-            assert model.getReferenceCount() > 0;\n+            final List<InternalAggregation> aggs = bucket.getAggregations().asList().stream().map(\n+                (p) -> (InternalAggregation) p).collect(Collectors.toList());\n \n-            return originalAgg.create(newBuckets);\n+            InternalInferenceAggregation aggResult = new InternalInferenceAggregation(name(), metadata(), inference);\n+            aggs.add(aggResult);\n+            InternalMultiBucketAggregation.InternalBucket newBucket = originalAgg.createBucket(InternalAggregations.from(aggs), bucket);\n+            newBuckets.add(newBucket);\n         }\n+\n+        return originalAgg.create(newBuckets);\n     }\n \n     public static Object resolveBucketValue(MultiBucketsAggregation agg,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5MTQzOA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453691438", "bodyText": "Do we need this with the call to updateCircuitBreakerEstimate", "author": "benwtrent", "createdAt": "2020-07-13T14:29:43Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -256,8 +274,16 @@ private void loadModel(String modelId, Consumer consumer) {\n                 trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelConfig.getEstimatedHeapMemory(), modelId);\n                 provider.getTrainedModelForInference(modelId, ActionListener.wrap(\n                     inferenceDefinition -> {\n-                        // Since we have used the previously stored estimate to help guard against OOM we need to adjust the memory\n-                        // So that the memory this model uses in the circuit breaker is the most accurate estimate.\n+                        try {\n+                            // Since we have used the previously stored estimate to help guard against OOM we need\n+                            // to adjust the memory so that the memory this model uses in the circuit breaker\n+                            // is the most accurate estimate.\n+                            updateCircuitBreakerEstimate(modelId, inferenceDefinition, trainedModelConfig);\n+                        } catch (CircuitBreakingException ex) {\n+                            handleLoadFailure(modelId, ex);\n+                            return;\n+                        }\n+\n                         long estimateDiff = inferenceDefinition.ramBytesUsed() - trainedModelConfig.getEstimatedHeapMemory();", "originalCommit": "fb2073f0bd69868b46f4e80089ee1ccb83183dc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMDMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453730313", "bodyText": "\ud83e\udd26", "author": "davidkyle", "createdAt": "2020-07-13T15:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5MTQzOA=="}], "type": "inlineReview", "revised_code": {"commit": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\nindex a30fad7035a..507a2a69863 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n\n@@ -274,16 +257,8 @@ public class ModelLoadingService implements ClusterStateListener {\n                 trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelConfig.getEstimatedHeapMemory(), modelId);\n                 provider.getTrainedModelForInference(modelId, ActionListener.wrap(\n                     inferenceDefinition -> {\n-                        try {\n-                            // Since we have used the previously stored estimate to help guard against OOM we need\n-                            // to adjust the memory so that the memory this model uses in the circuit breaker\n-                            // is the most accurate estimate.\n-                            updateCircuitBreakerEstimate(modelId, inferenceDefinition, trainedModelConfig);\n-                        } catch (CircuitBreakingException ex) {\n-                            handleLoadFailure(modelId, ex);\n-                            return;\n-                        }\n-\n+                        // Since we have used the previously stored estimate to help guard against OOM we need to adjust the memory\n+                        // So that the memory this model uses in the circuit breaker is the most accurate estimate.\n                         long estimateDiff = inferenceDefinition.ramBytesUsed() - trainedModelConfig.getEstimatedHeapMemory();\n                         if (estimateDiff < 0) {\n                             trainedModelCircuitBreaker.addWithoutBreaking(estimateDiff);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5ODQ1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453698456", "bodyText": "\ud83e\udd14\nacquire() could throw.\nI know it is rare, but there is nothing preventing the model being evicted from cache before these listeners are notified.\nMaybe call acquire before putting in cache.\nThen, outside the sync block, calling loadedModel.release() once all the listeners have been notified?\nIt seems funky, but it guarantees the acquire in the listener loop will not throw as it will never reach 0.", "author": "benwtrent", "createdAt": "2020-07-13T14:39:18Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -337,19 +385,21 @@ private void handleLoadSuccess(String modelId,\n             trainedModelConfig.getInput(),\n             trainedModelConfig.getDefaultFieldMap(),\n             inferenceConfig,\n-            modelStatsService);\n+            modelStatsService,\n+            trainedModelCircuitBreaker);\n         synchronized (loadingListeners) {\n             listeners = loadingListeners.remove(modelId);\n             // If there is no loadingListener that means the loading was canceled and the listener was already notified as such\n             // Consequently, we should not store the retrieved model\n             if (listeners == null) {\n-                trainedModelCircuitBreaker.addWithoutBreaking(-inferenceDefinition.ramBytesUsed());\n+                loadedModel.release();\n                 return;\n             }\n             localModelCache.put(modelId, new ModelAndConsumer(loadedModel, consumer));\n             shouldNotAudit.remove(modelId);\n         } // synchronized (loadingListeners)\n         for (ActionListener<LocalModel> listener = listeners.poll(); listener != null; listener = listeners.poll()) {\n+            loadedModel.acquire();", "originalCommit": "fb2073f0bd69868b46f4e80089ee1ccb83183dc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0MjAxOA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453742018", "bodyText": "Seems funky but it's the simplest and most efficient way to prevent the race \ud83d\udc4d", "author": "davidkyle", "createdAt": "2020-07-13T15:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5ODQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\nindex a30fad7035a..507a2a69863 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n\n@@ -385,6 +340,7 @@ public class ModelLoadingService implements ClusterStateListener {\n             trainedModelConfig.getInput(),\n             trainedModelConfig.getDefaultFieldMap(),\n             inferenceConfig,\n+            trainedModelConfig.getLicenseLevel(),\n             modelStatsService,\n             trainedModelCircuitBreaker);\n         synchronized (loadingListeners) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453700457", "bodyText": "Could you add a comment about how this is to protect the reference race condition where release was called but then it was acquired again?", "author": "benwtrent", "createdAt": "2020-07-13T14:41:58Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -169,4 +188,33 @@ public static void mapFieldsIfNecessary(Map<String, Object> fields, Map<String,\n             });\n         }\n     }\n+\n+    long acquire() {\n+        long count = referenceCount.incrementAndGet();\n+        if (count == 1) {\n+            trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelDefinition.ramBytesUsed(), modelId);\n+        }", "originalCommit": "fb2073f0bd69868b46f4e80089ee1ccb83183dc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 7a6ada30a98..a79fd363ff0 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -190,18 +186,10 @@ public class LocalModel implements Closeable {\n     }\n \n     long acquire() {\n-        long count = referenceCount.incrementAndGet();\n-        if (count == 1) {\n-            trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelDefinition.ramBytesUsed(), modelId);\n-        }\n-        return count;\n+        return referenceCount.incrementAndGet();\n     }\n \n-    public long getReferenceCount() {\n-        return referenceCount.get();\n-    }\n-\n-    public long release() {\n+    long release() {\n         if (referenceCount.decrementAndGet() == 0) {\n             // no references to this model, it no longer needs to be accounted for\n             trainedModelCircuitBreaker.addWithoutBreaking(-ramBytesUsed());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453700787", "bodyText": "should we prevent release from ever decrementing below 0?", "author": "benwtrent", "createdAt": "2020-07-13T14:42:26Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java", "diffHunk": "@@ -169,4 +188,33 @@ public static void mapFieldsIfNecessary(Map<String, Object> fields, Map<String,\n             });\n         }\n     }\n+\n+    long acquire() {\n+        long count = referenceCount.incrementAndGet();\n+        if (count == 1) {\n+            trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelDefinition.ramBytesUsed(), modelId);\n+        }\n+        return count;\n+    }\n+\n+    public long getReferenceCount() {\n+        return referenceCount.get();\n+    }\n+\n+    public long release() {\n+        if (referenceCount.decrementAndGet() == 0) {", "originalCommit": "fb2073f0bd69868b46f4e80089ee1ccb83183dc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0MTE0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453741146", "bodyText": "I added an assertion", "author": "davidkyle", "createdAt": "2020-07-13T15:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwMDc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\nindex 7a6ada30a98..a79fd363ff0 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/LocalModel.java\n\n@@ -190,18 +186,10 @@ public class LocalModel implements Closeable {\n     }\n \n     long acquire() {\n-        long count = referenceCount.incrementAndGet();\n-        if (count == 1) {\n-            trainedModelCircuitBreaker.addEstimateBytesAndMaybeBreak(trainedModelDefinition.ramBytesUsed(), modelId);\n-        }\n-        return count;\n+        return referenceCount.incrementAndGet();\n     }\n \n-    public long getReferenceCount() {\n-        return referenceCount.get();\n-    }\n-\n-    public long release() {\n+    long release() {\n         if (referenceCount.decrementAndGet() == 0) {\n             // no references to this model, it no longer needs to be accounted for\n             trainedModelCircuitBreaker.addWithoutBreaking(-ramBytesUsed());\n"}}, {"oid": "84647658e1ad55010f90dd946f3f5ab4c39a5776", "url": "https://github.com/elastic/elasticsearch/commit/84647658e1ad55010f90dd946f3f5ab4c39a5776", "message": "Add reference counting to LocalModel", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "325c3992a3cfcd5fef1ffbf7c19805a6b1c21edb", "url": "https://github.com/elastic/elasticsearch/commit/325c3992a3cfcd5fef1ffbf7c19805a6b1c21edb", "message": "Remove the Model interface", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "b8ffd813f8ee9a308a82455b666811ae93098baa", "url": "https://github.com/elastic/elasticsearch/commit/b8ffd813f8ee9a308a82455b666811ae93098baa", "message": "Add javadoc", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "fc76cfe3e5191c70b75364a0f6bfd967da49ecaf", "url": "https://github.com/elastic/elasticsearch/commit/fc76cfe3e5191c70b75364a0f6bfd967da49ecaf", "message": "Better accounting and tests", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "895d8f5b856566622941785ab0554ec67fc47e5d", "url": "https://github.com/elastic/elasticsearch/commit/895d8f5b856566622941785ab0554ec67fc47e5d", "message": "Close the model used in pipeline agg", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "6793176018a96542152c71409d605adc1c8d9dff", "url": "https://github.com/elastic/elasticsearch/commit/6793176018a96542152c71409d605adc1c8d9dff", "message": "Release model used in pipeline agg", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "62a9b83888b42c0c36113b708c01d8102e91e6f2", "url": "https://github.com/elastic/elasticsearch/commit/62a9b83888b42c0c36113b708c01d8102e91e6f2", "message": "Reference counting tests", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "2ed04a0fbceb16c1b48da4f62db426a6121fd34d", "url": "https://github.com/elastic/elasticsearch/commit/2ed04a0fbceb16c1b48da4f62db426a6121fd34d", "message": "tidy up", "committedDate": "2020-07-13T14:51:59Z", "type": "commit"}, {"oid": "a922826cfe4fd29020c6c5f2df3d785bcaea1500", "url": "https://github.com/elastic/elasticsearch/commit/a922826cfe4fd29020c6c5f2df3d785bcaea1500", "message": "review comments", "committedDate": "2020-07-13T15:17:51Z", "type": "commit"}, {"oid": "a922826cfe4fd29020c6c5f2df3d785bcaea1500", "url": "https://github.com/elastic/elasticsearch/commit/a922826cfe4fd29020c6c5f2df3d785bcaea1500", "message": "review comments", "committedDate": "2020-07-13T15:17:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNDM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/58670#discussion_r453734394", "bodyText": "I am not sure about calling listener.onResponse(loadedModel); while locked.\nWe have no control over what listener.onResponse executes.\nDo you think it is OK?", "author": "benwtrent", "createdAt": "2020-07-13T15:28:29Z", "path": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java", "diffHunk": "@@ -339,21 +375,23 @@ private void handleLoadSuccess(String modelId,\n             trainedModelConfig.getDefaultFieldMap(),\n             inferenceConfig,\n             trainedModelConfig.getLicenseLevel(),\n-            modelStatsService);\n+            modelStatsService,\n+            trainedModelCircuitBreaker);\n         synchronized (loadingListeners) {\n             listeners = loadingListeners.remove(modelId);\n             // If there is no loadingListener that means the loading was canceled and the listener was already notified as such\n             // Consequently, we should not store the retrieved model\n             if (listeners == null) {\n-                trainedModelCircuitBreaker.addWithoutBreaking(-inferenceDefinition.ramBytesUsed());\n+                loadedModel.release();\n                 return;\n             }\n+            for (ActionListener<LocalModel> listener = listeners.poll(); listener != null; listener = listeners.poll()) {\n+                loadedModel.acquire();\n+                listener.onResponse(loadedModel);", "originalCommit": "a922826cfe4fd29020c6c5f2df3d785bcaea1500", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "051f35edc1dab7f9c3a969a2f900b7f936bc90ec", "chunk": "diff --git a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\nindex 4e9b1e9f65c..89b99ab9830 100644\n--- a/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n+++ b/x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/inference/loadingservice/ModelLoadingService.java\n\n@@ -385,13 +385,20 @@ public class ModelLoadingService implements ClusterStateListener {\n                 loadedModel.release();\n                 return;\n             }\n-            for (ActionListener<LocalModel> listener = listeners.poll(); listener != null; listener = listeners.poll()) {\n-                loadedModel.acquire();\n-                listener.onResponse(loadedModel);\n-            }\n+\n+            // temporarily increase the reference count before adding to\n+            // the cache in case the model is evicted before the listeners\n+            // are called in which case acquire() would throw.\n+            loadedModel.acquire();\n             localModelCache.put(modelId, new ModelAndConsumer(loadedModel, consumer));\n             shouldNotAudit.remove(modelId);\n         } // synchronized (loadingListeners)\n+        for (ActionListener<LocalModel> listener = listeners.poll(); listener != null; listener = listeners.poll()) {\n+            loadedModel.acquire();\n+            listener.onResponse(loadedModel);\n+        }\n+        // account for the acquire in the synchronized block above\n+        loadedModel.release();\n     }\n \n     private void handleLoadFailure(String modelId, Exception failure) {\n"}}, {"oid": "051f35edc1dab7f9c3a969a2f900b7f936bc90ec", "url": "https://github.com/elastic/elasticsearch/commit/051f35edc1dab7f9c3a969a2f900b7f936bc90ec", "message": "rework", "committedDate": "2020-07-13T15:36:57Z", "type": "commit"}]}