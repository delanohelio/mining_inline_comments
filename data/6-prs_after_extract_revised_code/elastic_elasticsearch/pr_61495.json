{"pr_number": 61495, "pr_title": "Speed up Compression Logic by Pooling Resources (#61358)", "pr_createdAt": "2020-08-24T16:22:25Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61495", "timeline": [{"oid": "9dae32c4a1759472ed4f9e1bcae1656069c3d455", "url": "https://github.com/elastic/elasticsearch/commit/9dae32c4a1759472ed4f9e1bcae1656069c3d455", "message": "Speed up Compression Logic by Pooling Resources (#61358)\n\nThis is mostly motivated by the performance issues we are seeing around the GET mappings\nREST API which (in case of a large number of indices) will create decompressing streams in a hot loop\nwhich takes a significant amount of time for the system calls involved in instantiating deflaters\nand inflaters.\nAlso, this fixes a leaked deflater when deserializing cached repository data.", "committedDate": "2020-08-24T16:21:13Z", "type": "commit"}, {"oid": "3ae4b5c3e547452cd947d1dfca6e3e877e77b216", "url": "https://github.com/elastic/elasticsearch/commit/3ae4b5c3e547452cd947d1dfca6e3e877e77b216", "message": "fix java 8", "committedDate": "2020-08-24T16:57:32Z", "type": "commit"}, {"oid": "7a81987fba728c6bfddcf42c6febbc55be5772a5", "url": "https://github.com/elastic/elasticsearch/commit/7a81987fba728c6bfddcf42c6febbc55be5772a5", "message": "bah output only", "committedDate": "2020-08-24T17:03:30Z", "type": "commit"}, {"oid": "0bf93c50c7ebaa5e6ebb1add3d808734e61aa07d", "url": "https://github.com/elastic/elasticsearch/commit/0bf93c50c7ebaa5e6ebb1add3d808734e61aa07d", "message": "urgh java8", "committedDate": "2020-08-24T18:26:39Z", "type": "commit"}, {"oid": "e34eaccd4480c127d169d33477145be540160407", "url": "https://github.com/elastic/elasticsearch/commit/e34eaccd4480c127d169d33477145be540160407", "message": "comment and non-concurrent", "committedDate": "2020-08-24T19:15:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkxODMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61495#discussion_r475918335", "bodyText": "Need this flag still and move the super.close into the flag check also due to a Java8 bug: https://bugs.openjdk.java.net/browse/JDK-8054565 that otherwise forces another .finish on the underlying stream after the deflater has already been reset (thus adding another 5 bytes to it and breaking things).", "author": "original-brownbear", "createdAt": "2020-08-24T21:59:35Z", "path": "server/src/main/java/org/elasticsearch/common/compress/DeflateCompressor.java", "diffHunk": "@@ -88,56 +156,80 @@ public StreamInput streamInput(StreamInput in) throws IOException {\n             throw new IllegalArgumentException(\"Input stream is not compressed with DEFLATE!\");\n         }\n \n-        final boolean nowrap = true;\n-        final Inflater inflater = new Inflater(nowrap);\n-        InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE);\n-        decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE);\n-        return new InputStreamStreamInput(decompressedIn) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n-\n+        final Releasable releasable;\n+        final Inflater inflater;\n+        if (threadLocal) {\n+            final ReleasableReference<Inflater> current = inflaterForStreamRef.get();\n+            if (current.inUse) {\n+                // Nested de-compression streams should not happen but we still handle them safely by using a fresh Inflater\n+                inflater = new Inflater(true);\n+                releasable = inflater::end;\n+            } else {\n+                inflater = current.get();\n+                releasable = current;\n+            }\n+        } else {\n+            inflater = new Inflater(true);\n+            releasable = inflater::end;\n+        }\n+        return new BufferedInputStream(new InflaterInputStream(in, inflater, BUFFER_SIZE) {\n+            @Override\n             public void close() throws IOException {\n                 try {\n                     super.close();\n                 } finally {\n-                    if (closed.compareAndSet(false, true)) {\n-                        // important to release native memory\n-                        inflater.end();\n-                    }\n+                    // We are ensured to only call this once since we wrap this stream in a BufferedInputStream that will only close\n+                    // its delegate once\n+                    releasable.close();\n                 }\n             }\n-        };\n+        }, BUFFER_SIZE);\n     }\n \n     @Override\n-    public StreamOutput streamOutput(OutputStream out) throws IOException {\n+    public StreamOutput threadLocalStreamOutput(OutputStream out) throws IOException {\n         out.write(HEADER);\n-        final boolean nowrap = true;\n-        final Deflater deflater = new Deflater(LEVEL, nowrap);\n+        final ReleasableReference<Deflater> current = deflaterForStreamRef.get();\n+        final Releasable releasable;\n+        final Deflater deflater;\n+        if (current.inUse) {\n+            // Nested compression streams should not happen but we still handle them safely by using a fresh Deflater\n+            deflater = new Deflater(LEVEL, true);\n+            releasable = deflater::end;\n+        } else {\n+            deflater = current.get();\n+            releasable = current;\n+        }\n         final boolean syncFlush = true;\n         DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush);\n         OutputStream compressedOut = new BufferedOutputStream(deflaterOutputStream, BUFFER_SIZE);\n         return new OutputStreamStreamOutput(compressedOut) {\n-            final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+            // Due to https://bugs.openjdk.java.net/browse/JDK-8054565 we can't rely on the buffered output stream to only close once\n+            // in code that has to support Java 8 so we manually manage a close flag for this stream.\n+            private boolean closed = false;", "originalCommit": "e34eaccd4480c127d169d33477145be540160407", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}