{"pr_number": 65921, "pr_title": "Stop Copying Large Byte Arrays from Transport Messages", "pr_createdAt": "2020-12-06T18:52:31Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65921", "timeline": [{"oid": "6762a3ead2a8f7cc7cf3a02d892e04aff35cb90d", "url": "https://github.com/elastic/elasticsearch/commit/6762a3ead2a8f7cc7cf3a02d892e04aff35cb90d", "message": "Stop Copying Large Byte Arrays from Transport Messages\n\nWe were copying any byte arrays we would read streams that are backed by\na `BytesReference`. This would mean copying e.g. 500k chunks during\nfile based recovery, large chunks during CCR file copy, or many MB when\nreceiving a large cluster state for the first time.\n\nThis PR adds the ability to read shared bytes from streams that support it,\nadds reference counting to transport messages that make use of these bytes\nand makes use of the new functionality in recovery, CCR and CS publication.\n\nThis should reduce memory usage by all 3 adjusted transport APIs significantly\nand could be extended to other very large messages that currently get copied\nduring deserialization like e.g. bulk requests.", "committedDate": "2020-12-06T18:13:17Z", "type": "commit"}, {"oid": "b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "url": "https://github.com/elastic/elasticsearch/commit/b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "message": "shorter", "committedDate": "2020-12-06T18:52:14Z", "type": "commit"}, {"oid": "cdc3b672f758ee8ef4e6645723c8790ed13e8668", "url": "https://github.com/elastic/elasticsearch/commit/cdc3b672f758ee8ef4e6645723c8790ed13e8668", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2020-12-07T00:38:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE3MDU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r537170560", "bodyText": "Inlined this so that the reference count handling is all in one place and it's \"clear\" that there's no path to leaking a request (except for some corner cases where the threadPool is shutting down but we have that issue with all kinds of ref counted things and its only relevant for tests).", "author": "original-brownbear", "createdAt": "2020-12-07T01:15:12Z", "path": "server/src/main/java/org/elasticsearch/transport/InboundHandler.java", "diffHunk": "@@ -193,23 +194,58 @@ private void messageReceived(TcpChannel channel, InboundMessage message, long st\n                     final RequestHandlerRegistry<T> reg = requestHandlers.getHandler(action);\n                     assert reg != null;\n                     final T request = reg.newRequest(stream);\n-                    request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n-                    // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n-                    final int nextByte = stream.read();\n-                    // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n-                    if (nextByte != -1) {\n-                        throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n-                            + action + \"], available [\" + stream.available() + \"]; resetting\");\n-                    }\n-                    final String executor = reg.getExecutor();\n-                    if (ThreadPool.Names.SAME.equals(executor)) {\n-                        try {\n-                            reg.processMessageReceived(request, transportChannel);\n-                        } catch (Exception e) {\n-                            sendErrorResponse(reg.getAction(), transportChannel, e);\n+                    try {\n+                        request.remoteAddress(new TransportAddress(channel.getRemoteAddress()));\n+                        // in case we throw an exception, i.e. when the limit is hit, we don't want to verify\n+                        final int nextByte = stream.read();\n+                        // calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker\n+                        if (nextByte != -1) {\n+                            throw new IllegalStateException(\"Message not fully read (request) for requestId [\" + requestId + \"], action [\"\n+                                + action + \"], available [\" + stream.available() + \"]; resetting\");\n                         }\n-                    } else {\n-                        threadPool.executor(executor).execute(new RequestHandler<>(reg, request, transportChannel));\n+                        final String executor = reg.getExecutor();\n+                        if (ThreadPool.Names.SAME.equals(executor)) {\n+                            try {\n+                                reg.processMessageReceived(request, transportChannel);\n+                            } catch (Exception e) {\n+                                sendErrorResponse(reg.getAction(), transportChannel, e);\n+                            }\n+                        } else {\n+                            boolean success = false;\n+                            if (request instanceof RefCounted) {\n+                                ((RefCounted) request).incRef();\n+                            }\n+                            try {\n+                                threadPool.executor(executor).execute(new AbstractRunnable() {", "originalCommit": "b5d3b01c67462d4a6dccc372a4b03ebfe1a355b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/transport/InboundHandler.java b/server/src/main/java/org/elasticsearch/transport/InboundHandler.java\nindex 25823f567d5..a0bdb5200a6 100644\n--- a/server/src/main/java/org/elasticsearch/transport/InboundHandler.java\n+++ b/server/src/main/java/org/elasticsearch/transport/InboundHandler.java\n\n@@ -234,18 +239,18 @@ public class InboundHandler {\n \n                                     @Override\n                                     public void onAfter() {\n-                                        RefCounted.decRef(request);\n+                                        request.decRef();\n                                     }\n                                 });\n                                 success = true;\n                             } finally {\n                                 if (success == false) {\n-                                    RefCounted.decRef(request);\n+                                    request.decRef();\n                                 }\n                             }\n                         }\n                     } finally {\n-                        RefCounted.decRef(request);\n+                        request.decRef();\n                     }\n                 }\n             } catch (Exception e) {\n"}}, {"oid": "73e7de56c10b3e291e5072967864e9f8f5f9f792", "url": "https://github.com/elastic/elasticsearch/commit/73e7de56c10b3e291e5072967864e9f8f5f9f792", "message": "docs and less noise", "committedDate": "2020-12-07T01:17:55Z", "type": "commit"}, {"oid": "8f49cf97e9e3b0c5cfbd79595f54afc30295c2f6", "url": "https://github.com/elastic/elasticsearch/commit/8f49cf97e9e3b0c5cfbd79595f54afc30295c2f6", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2020-12-17T11:26:58Z", "type": "commit"}, {"oid": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "url": "https://github.com/elastic/elasticsearch/commit/1dc5bf34125cb7ff3e978e6873dff707ce979525", "message": "Merge remote-tracking branch 'origin/just-stop-copying' into just-stop-copying", "committedDate": "2020-12-17T11:27:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NjI5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551246290", "bodyText": "Alternative name suggestion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ReleasableBytesReference readUnsafeBytesReference() throws IOException {\n          \n          \n            \n                public ReleasableBytesReference readReleasableBytesReference() throws IOException {\n          \n      \n    \n    \n  \n\nMethods that return a ReleasableBytesReference should pretty much all have the expectation that the caller takes responsibility for releasing it later, so I don't think this is as unsafe as the proposed name indicates.", "author": "DaveCTurner", "createdAt": "2021-01-04T10:54:42Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java", "diffHunk": "@@ -129,14 +130,23 @@ public void setVersion(Version version) {\n     public abstract void readBytes(byte[] b, int offset, int len) throws IOException;\n \n     /**\n-     * Reads a bytes reference from this stream, might hold an actual reference to the underlying\n-     * bytes of the stream.\n+     * Reads a bytes reference from this stream, copying any bytes read to a new {@code byte[]}. Use {@link #readUnsafeBytesReference()}\n+     * when reading large bytes references where possible top avoid needless allocations and copying.\n      */\n     public BytesReference readBytesReference() throws IOException {\n         int length = readArraySize();\n         return readBytesReference(length);\n     }\n \n+    /**\n+     * Reads a releasable bytes reference from this stream. Unlike {@link #readBytesReference()} the returned bytes reference may reference\n+     * bytes in a pooled buffer and must be explicitly released via {@link ReleasableBytesReference#close()} once no longer used.\n+     * Prefer this method over {@link #readBytesReference()} when reading large bytes references to avoid allocations and copying.\n+     */\n+    public ReleasableBytesReference readUnsafeBytesReference() throws IOException {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java b/server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java\nindex cdf939d2272..a78b5153f21 100644\n--- a/server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java\n+++ b/server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java\n\n@@ -130,7 +130,7 @@ public abstract class StreamInput extends InputStream {\n     public abstract void readBytes(byte[] b, int offset, int len) throws IOException;\n \n     /**\n-     * Reads a bytes reference from this stream, copying any bytes read to a new {@code byte[]}. Use {@link #readUnsafeBytesReference()}\n+     * Reads a bytes reference from this stream, copying any bytes read to a new {@code byte[]}. Use {@link #readReleasableBytesReference()}\n      * when reading large bytes references where possible top avoid needless allocations and copying.\n      */\n     public BytesReference readBytesReference() throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NzQ5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551257496", "bodyText": "Would it be so bad to have TransportMessage implements RefCounted - I think it'll catch someone out in future. At least let's add Javadoc somewhere saying that subclasses that implement RefCounted are released by the transport service.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:18:44Z", "path": "libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java", "diffHunk": "@@ -65,4 +65,15 @@\n      * @return returns {@code true} if the ref count dropped to 0 as a result of calling this method\n      */\n     boolean decRef();\n+\n+    /**\n+     * Decrement the ref count on the given {@code object} by one if it is a {@link RefCounted}\n+     *\n+     * @param object object to decrement ref count for if it is a {@link RefCounted}\n+     */\n+    static void decRef(Object object) {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg2NjMxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551866311", "bodyText": "I went with TransportMessage implements RefCounted after all. I initially didn't like the idea of doing that because it felt dirty to force overriding either none or all 3 methods from RefCounted when creating a ref-counted message ... but in hindsight that's still a lot better than implicitly releasing via the interface type check :)", "author": "original-brownbear", "createdAt": "2021-01-05T11:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1NzQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java b/libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java\nindex 6ea18a591f2..e573ba54026 100644\n--- a/libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java\n+++ b/libs/core/src/main/java/org/elasticsearch/common/util/concurrent/RefCounted.java\n\n@@ -65,15 +65,4 @@ public interface RefCounted {\n      * @return returns {@code true} if the ref count dropped to 0 as a result of calling this method\n      */\n     boolean decRef();\n-\n-    /**\n-     * Decrement the ref count on the given {@code object} by one if it is a {@link RefCounted}\n-     *\n-     * @param object object to decrement ref count for if it is a {@link RefCounted}\n-     */\n-    static void decRef(Object object) {\n-        if (object instanceof RefCounted) {\n-            ((RefCounted) object).decRef();\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551258902", "bodyText": "Maybe avoid the casting?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final ReleasableBytesReference result = ((ReleasableBytesReference) bytesReference).retainedSlice(offset(), len);\n          \n          \n            \n                            final ReleasableBytesReference result = ReleasableBytesReference.this.retainedSlice(offset(), len);", "author": "DaveCTurner", "createdAt": "2021-01-04T11:21:51Z", "path": "server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java", "diffHunk": "@@ -104,26 +121,41 @@ public long ramBytesUsed() {\n \n     @Override\n     public StreamInput streamInput() throws IOException {\n-        return delegate.streamInput();\n+        assert refCount() > 0;\n+        return new BytesReferenceStreamInput(this) {\n+            @Override\n+            public ReleasableBytesReference readUnsafeBytesReference() throws IOException {\n+                final int len = readArraySize();\n+                // instead of reading the bytes from a stream we just create a slice of the underlying bytes\n+                final ReleasableBytesReference result = ((ReleasableBytesReference) bytesReference).retainedSlice(offset(), len);", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTI5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855297", "bodyText": "++", "author": "original-brownbear", "createdAt": "2021-01-05T10:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1ODkwMg=="}], "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java b/server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java\nindex 10892a704c4..4a6fb31c52d 100644\n--- a/server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java\n+++ b/server/src/main/java/org/elasticsearch/common/bytes/ReleasableBytesReference.java\n\n@@ -124,10 +124,10 @@ public final class ReleasableBytesReference implements RefCounted, Releasable, B\n         assert refCount() > 0;\n         return new BytesReferenceStreamInput(this) {\n             @Override\n-            public ReleasableBytesReference readUnsafeBytesReference() throws IOException {\n+            public ReleasableBytesReference readReleasableBytesReference() throws IOException {\n                 final int len = readArraySize();\n                 // instead of reading the bytes from a stream we just create a slice of the underlying bytes\n-                final ReleasableBytesReference result = ((ReleasableBytesReference) bytesReference).retainedSlice(offset(), len);\n+                final ReleasableBytesReference result = retainedSlice(offset(), len);\n                 // move the stream manually since creating the slice didn't move it\n                 skip(len);\n                 return result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1OTgyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551259821", "bodyText": "The chunk is already closed here, seems wrong to be accessing it still. Can we close it after the synchronised block?", "author": "DaveCTurner", "createdAt": "2021-01-04T11:23:53Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -210,7 +216,9 @@ void writeChunk(FileChunk newChunk) throws IOException {\n                     }\n                     pendingChunks.remove();\n                 }\n-                innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk);\n+                try (chunk) {\n+                    innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk);\n+                }\n                 synchronized (this) {\n                     assert lastPosition == chunk.position : \"last_position \" + lastPosition + \" != chunk_position \" + chunk.position;\n                     lastPosition += chunk.content.length();", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTYxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855613", "bodyText": "++ that was a little dirty, I made it close later now as suggested", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI1OTgyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java b/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\nindex cdb4610d9d2..2212d70eafb 100644\n--- a/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\n+++ b/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\n\n@@ -218,14 +218,14 @@ public class MultiFileWriter extends AbstractRefCounted implements Releasable {\n                 }\n                 try (chunk) {\n                     innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk);\n-                }\n-                synchronized (this) {\n-                    assert lastPosition == chunk.position : \"last_position \" + lastPosition + \" != chunk_position \" + chunk.position;\n-                    lastPosition += chunk.content.length();\n-                    if (chunk.lastChunk) {\n-                        assert pendingChunks.isEmpty() : \"still have pending chunks [\" + pendingChunks + \"]\";\n-                        fileChunkWriters.remove(chunk.md.name());\n-                        assert fileChunkWriters.containsValue(this) == false : \"chunk writer [\" + newChunk.md + \"] was not removed\";\n+                    synchronized (this) {\n+                        assert lastPosition == chunk.position : \"last_position \" + lastPosition + \" != chunk_position \" + chunk.position;\n+                        lastPosition += chunk.content.length();\n+                        if (chunk.lastChunk) {\n+                            assert pendingChunks.isEmpty() : \"still have pending chunks [\" + pendingChunks + \"]\";\n+                            fileChunkWriters.remove(chunk.md.name());\n+                            assert fileChunkWriters.containsValue(this) == false : \"chunk writer [\" + newChunk.md + \"] was not removed\";\n+                        }\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551262323", "bodyText": "I think we would leak these if a recovery fails: MultiFileWriter#closeInternal simply drops its FileChunkWriter objects on the floor.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:29:18Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -179,17 +180,22 @@ public void renameAllTempFiles() throws IOException {\n         store.renameTempFilesSafe(tempFileNames);\n     }\n \n-    static final class FileChunk {\n+    private static final class FileChunk implements Releasable {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg2NTQ1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551865459", "bodyText": "Right thanks for catching this! I pushed 19517e4 which I think should be fine since we never get into a state where we don't have a writing thread running but pending chunks in the queue.", "author": "original-brownbear", "createdAt": "2021-01-05T11:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551903080", "bodyText": "I don't follow the reasoning here. A recovery can fail for reasons external to writeFile(), e.g. the target node leaves the cluster and the shard is reassigned elsewhere.", "author": "DaveCTurner", "createdAt": "2021-01-05T12:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwODY1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551908658", "bodyText": "The reasoning is this:\nWe increment the ref count for the bytes when we create the FileChunk which we then pass directly to writeChunk No matter what happens externally one of two things can happen as a result in writeChunk. Either we put the chunk in the queue to drain or we write it out right away.\nIf we write it out right away then that will just fail and the reference will be decremented. If we put it in the queue, then whatever thread that is currently doing the writing will fail during its current write and as a result drain the queue and release all the chunks that way.\n=> since we always have a thread doing work in org.elasticsearch.indices.recovery.MultiFileWriter.FileChunkWriter#writeChunk we can be sure to never fail to release a queued chunk if we drain on exceptions.", "author": "original-brownbear", "createdAt": "2021-01-05T12:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkyNjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551926250", "bodyText": "We discussed this in another channel: the missing piece was that we sometimes receive these chunks out-of-order and may never fill in a gap if the chunk gets lost and then the recovery fails.", "author": "DaveCTurner", "createdAt": "2021-01-05T13:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzY0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r552103649", "bodyText": "Alright I pushed da56e83 here now, should be good for another review :) Thanks!", "author": "original-brownbear", "createdAt": "2021-01-05T18:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2MjMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "da56e8355ece729bd40c8828da8722b8f93409c9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java b/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\nindex cdb4610d9d2..abd385024e9 100644\n--- a/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\n+++ b/server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java\n\n@@ -198,7 +205,7 @@ public class MultiFileWriter extends AbstractRefCounted implements Releasable {\n         }\n     }\n \n-    private final class FileChunkWriter {\n+    private final class FileChunkWriter implements Releasable {\n         // chunks can be delivered out of order, we need to buffer chunks if there's a gap between them.\n         final PriorityQueue<FileChunk> pendingChunks = new PriorityQueue<>(Comparator.comparing(fc -> fc.position));\n         long lastPosition = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDUxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551264515", "bodyText": "content is actually already a ReleasableBytesReference (in prod code at least)", "author": "DaveCTurner", "createdAt": "2021-01-04T11:34:19Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java", "diffHunk": "@@ -64,7 +66,7 @@ public RecoveryFileChunkRequest(long recoveryId, final long requestSeqNo, ShardI\n         this.shardId = shardId;\n         this.metadata = metadata;\n         this.position = position;\n-        this.content = content;\n+        this.content = ReleasableBytesReference.wrap(content);", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTc2MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855760", "bodyText": "right + neat :) made use of that now", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NDUxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java b/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java\nindex 68624b73018..2b07b0cbc18 100644\n--- a/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java\n+++ b/server/src/main/java/org/elasticsearch/indices/recovery/RecoveryFileChunkRequest.java\n\n@@ -60,13 +59,14 @@ public final class RecoveryFileChunkRequest extends RecoveryTransportRequest imp\n     }\n \n     public RecoveryFileChunkRequest(long recoveryId, final long requestSeqNo, ShardId shardId, StoreFileMetadata metadata, long position,\n-                                    BytesReference content, boolean lastChunk, int totalTranslogOps, long sourceThrottleTimeInNanos) {\n+                                    ReleasableBytesReference content, boolean lastChunk, int totalTranslogOps,\n+                                    long sourceThrottleTimeInNanos) {\n         super(requestSeqNo);\n         this.recoveryId = recoveryId;\n         this.shardId = shardId;\n         this.metadata = metadata;\n         this.position = position;\n-        this.content = ReleasableBytesReference.wrap(content);\n+        this.content = content.retain();\n         this.lastChunk = lastChunk;\n         this.totalTranslogOps = totalTranslogOps;\n         this.sourceThrottleTimeInNanos = sourceThrottleTimeInNanos;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MDAyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551270028", "bodyText": "I think this means the comment above (\"This is currently safe to do ...\") isn't needed any more. I mean it's still safe to do, but not for the reason it gives any more.", "author": "DaveCTurner", "createdAt": "2021-01-04T11:46:51Z", "path": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java", "diffHunk": "@@ -72,27 +73,27 @@ protected void doExecute(Task task, GetCcrRestoreFileChunkRequest request,\n         }\n     }\n \n-    public static class GetCcrRestoreFileChunkResponse extends ActionResponse {\n+    public static class GetCcrRestoreFileChunkResponse extends ActionResponse implements RefCounted {", "originalCommit": "1dc5bf34125cb7ff3e978e6873dff707ce979525", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1NTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r551855941", "bodyText": "++ Removed the comment", "author": "original-brownbear", "createdAt": "2021-01-05T10:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI3MDAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "9f55f6c1cff21d3a898d369842689ee68318eed1", "chunk": "diff --git a/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java\nindex 044975a8b56..d32a5b8e914 100644\n--- a/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java\n+++ b/x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/action/repositories/GetCcrRestoreFileChunkAction.java\n\n@@ -81,7 +79,7 @@ public class GetCcrRestoreFileChunkAction extends ActionType<GetCcrRestoreFileCh\n         GetCcrRestoreFileChunkResponse(StreamInput streamInput) throws IOException {\n             super(streamInput);\n             offset = streamInput.readVLong();\n-            chunk = streamInput.readUnsafeBytesReference();\n+            chunk = streamInput.readReleasableBytesReference();\n         }\n \n         GetCcrRestoreFileChunkResponse(long offset, ReleasableBytesReference chunk) {\n"}}, {"oid": "153d4a8211cf785cd38ac80d4d10c7dc90211d2a", "url": "https://github.com/elastic/elasticsearch/commit/153d4a8211cf785cd38ac80d4d10c7dc90211d2a", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T07:23:41Z", "type": "commit"}, {"oid": "9f55f6c1cff21d3a898d369842689ee68318eed1", "url": "https://github.com/elastic/elasticsearch/commit/9f55f6c1cff21d3a898d369842689ee68318eed1", "message": "CR: comments round 1", "committedDate": "2021-01-05T10:12:58Z", "type": "commit"}, {"oid": "766abf7e1f5e7f5ea949897597a7da8b02c11b64", "url": "https://github.com/elastic/elasticsearch/commit/766abf7e1f5e7f5ea949897597a7da8b02c11b64", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T10:13:39Z", "type": "commit"}, {"oid": "19517e4b2b46f2568f077efb6aab1c851978d944", "url": "https://github.com/elastic/elasticsearch/commit/19517e4b2b46f2568f077efb6aab1c851978d944", "message": "CR: ensure pending chunks are released every time", "committedDate": "2021-01-05T11:06:08Z", "type": "commit"}, {"oid": "ed8df1a141387de04af50d89a21b4bda06bb9106", "url": "https://github.com/elastic/elasticsearch/commit/ed8df1a141387de04af50d89a21b4bda06bb9106", "message": "Merge remote-tracking branch 'elastic/master' into just-stop-copying", "committedDate": "2021-01-05T15:16:32Z", "type": "commit"}, {"oid": "da56e8355ece729bd40c8828da8722b8f93409c9", "url": "https://github.com/elastic/elasticsearch/commit/da56e8355ece729bd40c8828da8722b8f93409c9", "message": "CR: release pending chunks safely", "committedDate": "2021-01-05T16:24:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyMzk5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65921#discussion_r552423990", "bodyText": "All worked out pretty nicely here \ud83d\udc4d", "author": "DaveCTurner", "createdAt": "2021-01-06T08:04:36Z", "path": "server/src/main/java/org/elasticsearch/indices/recovery/MultiFileWriter.java", "diffHunk": "@@ -152,6 +158,7 @@ public void close() {\n \n     @Override\n     protected void closeInternal() {\n+        Releasables.close(fileChunkWriters.values());", "originalCommit": "da56e8355ece729bd40c8828da8722b8f93409c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}