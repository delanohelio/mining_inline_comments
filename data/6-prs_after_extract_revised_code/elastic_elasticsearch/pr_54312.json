{"pr_number": 54312, "pr_title": "Broadcast cancellation to only nodes have outstanding child tasks", "pr_createdAt": "2020-03-26T23:40:37Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54312", "timeline": [{"oid": "cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "url": "https://github.com/elastic/elasticsearch/commit/cd19eef0fbdc1eca9b828c1678de5dd4cc618a3f", "message": "Propagate cancellation to nodes have outstanding child tasks", "committedDate": "2020-03-26T23:38:06Z", "type": "commit"}, {"oid": "23ddc8aa0b0845e54666e8941791589b69c2b08e", "url": "https://github.com/elastic/elasticsearch/commit/23ddc8aa0b0845e54666e8941791589b69c2b08e", "message": "register child node when execute task locally", "committedDate": "2020-03-27T16:23:23Z", "type": "commit"}, {"oid": "2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "url": "https://github.com/elastic/elasticsearch/commit/2136f26af6e9ae409e8baf182b9ff1afcfdc3369", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-27T16:41:48Z", "type": "commit"}, {"oid": "dba2dbdc0a567cd12cd460c3a25e5472abdab898", "url": "https://github.com/elastic/elasticsearch/commit/dba2dbdc0a567cd12cd460c3a25e5472abdab898", "message": "only return when childTasks have completed", "committedDate": "2020-03-27T17:40:09Z", "type": "commit"}, {"oid": "a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "url": "https://github.com/elastic/elasticsearch/commit/a2286d1d0f86da3108c5ce27ccbc72fb9ad8043f", "message": "remove unneed synchronized", "committedDate": "2020-03-27T17:40:59Z", "type": "commit"}, {"oid": "b14efd3131591ae9522e39eacd3a294f5ee679fe", "url": "https://github.com/elastic/elasticsearch/commit/b14efd3131591ae9522e39eacd3a294f5ee679fe", "message": "javadocs", "committedDate": "2020-03-27T18:32:35Z", "type": "commit"}, {"oid": "f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "url": "https://github.com/elastic/elasticsearch/commit/f5753dc2a4d879ff14b77c6f3a034b648cd2081f", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-27T18:55:24Z", "type": "commit"}, {"oid": "0f51b4548ef55190e34a26a4309122cdc95df32d", "url": "https://github.com/elastic/elasticsearch/commit/0f51b4548ef55190e34a26a4309122cdc95df32d", "message": "remove assertion", "committedDate": "2020-03-27T19:47:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399953501", "bodyText": "should we check before the unblock that cancelFuture.isDone == false?", "author": "ywelsch", "createdAt": "2020-03-30T06:29:28Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -159,7 +162,9 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         logger.debug(\"unblocking the blocked update\");\n         ALLOWED_OPERATIONS.release(builder.request().getSlices());\n-\n+        ListTasksResponse cancelTasksResponse = cancelFuture.get();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "chunk": "diff --git a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\nindex a734d812e00..d73748f0595 100644\n--- a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\n+++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\n\n@@ -160,6 +160,7 @@ public class CancelTests extends ReindexTestCase {\n             assertTrue(\"Didn't find at least one sub task that was cancelled\", foundCancelled);\n         }\n \n+        assertFalse(cancelFuture.isDone());\n         logger.debug(\"unblocking the blocked update\");\n         ALLOWED_OPERATIONS.release(builder.request().getSlices());\n         ListTasksResponse cancelTasksResponse = cancelFuture.get();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NDQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399954403", "bodyText": "Given the test change here, I wonder if there should be an option for task cancellation to say whether it should wait for its children to be cancelled / completed before returning. As soon as the parent is cancelled, we know that eventually the children will be cancelled (not yet guaranteed by the current implementation, but something we eventually want with the keepalive).", "author": "ywelsch", "createdAt": "2020-03-30T06:31:59Z", "path": "modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java", "diffHunk": "@@ -131,16 +132,18 @@ private void testCancel(String action, AbstractBulkByScrollRequestBuilder<?, ?>\n \n         // Cancel the request while the action is blocked by the indexing operation listeners.\n         // This will prevent further requests from being sent.\n-        ListTasksResponse cancelTasksResponse = client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId()).get();\n-        cancelTasksResponse.rethrowFailures(\"Cancel\");\n-        assertThat(cancelTasksResponse.getTasks(), hasSize(1));\n+        ActionFuture<CancelTasksResponse> cancelFuture = client().admin().cluster().prepareCancelTasks()\n+            .setTaskId(mainTask.getTaskId()).execute();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "chunk": "diff --git a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\nindex a734d812e00..749901582b8 100644\n--- a/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\n+++ b/modules/reindex/src/test/java/org/elasticsearch/index/reindex/CancelTests.java\n\n@@ -132,18 +131,18 @@ public class CancelTests extends ReindexTestCase {\n \n         // Cancel the request while the action is blocked by the indexing operation listeners.\n         // This will prevent further requests from being sent.\n-        ActionFuture<CancelTasksResponse> cancelFuture = client().admin().cluster().prepareCancelTasks()\n-            .setTaskId(mainTask.getTaskId()).execute();\n-        ensureChildTasksCancelledOrBanned(mainTask.getTaskId());\n+        ListTasksResponse cancelTasksResponse = client().admin().cluster().prepareCancelTasks().setTaskId(mainTask.getTaskId())\n+            .setWaitForCompletion(false) // do wait for child tasks as they are being blocked\n+            .get();\n+        cancelTasksResponse.rethrowFailures(\"Cancel\");\n+        assertThat(cancelTasksResponse.getTasks(), hasSize(1));\n \n         /* The status should now show canceled. The request will still be in the\n          * list because it is (or its children are) still blocked. */\n-        assertBusy(() -> {\n-            TaskInfo cancellingTask = client().admin().cluster().prepareGetTask(mainTask.getTaskId()).get().getTask().getTask();\n-            BulkByScrollTask.Status cancellingStatus = (BulkByScrollTask.Status) cancellingTask.getStatus();\n-            logger.debug(\"asserting that parent is marked canceled {}\", cancellingStatus);\n-            assertEquals(CancelTasksRequest.DEFAULT_REASON, cancellingStatus.getReasonCancelled());\n-        });\n+        mainTask = client().admin().cluster().prepareGetTask(mainTask.getTaskId()).get().getTask().getTask();\n+        status = (BulkByScrollTask.Status) mainTask.getStatus();\n+        logger.debug(\"asserting that parent is marked canceled {}\", status);\n+        assertEquals(CancelTasksRequest.DEFAULT_REASON, status.getReasonCancelled());\n \n         if (builder.request().getSlices() > 1) {\n             boolean foundCancelled = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399956343", "bodyText": "In theory, we could coordinate the banning / unbanning on a per-node basis, i.e., as soon as the parent is cancelled, and all requests from a child node have completed, we can send an unban to that node. I don't think that this optimization is needed (as it might make the code unnecessarily more complex), just thought I should mention it.", "author": "ywelsch", "createdAt": "2020-03-30T06:37:15Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMDc3NA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400410774", "bodyText": "Ok, I will try to implement this in a follow-up if it's simple.", "author": "dnhatn", "createdAt": "2020-03-30T18:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NjM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 8eb0b7cdbba..9ef1bd05cb2 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -102,46 +102,40 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n                                               ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            final StepListener<Void> completeListener = new StepListener<>();\n-            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n-            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n-            final GroupedActionListener<Void> groupedListener =\n-                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n-            final Collection<DiscoveryNode> childNodes =\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n                 taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n-            completeListener.whenComplete(r -> {\n-                    removeBanOnNodes(cancellableTask, childNodes);\n-                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                },\n-                e -> {\n-                    try {\n-                        removeBanOnNodes(cancellableTask, childNodes);\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n-                    }\n-                    listener.onFailure(e);\n-                });\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n-            if (canceled) {\n-                // In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, groupedListener);\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n+            }\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.\n+            completedListener.whenComplete(\n+                r -> removeBanOnNodes(cancellableTask, childrenNodes),\n+                e -> removeBanOnNodes(cancellableTask, childrenNodes));\n+            // if wait_for_completion is true, then only return when (1) bans are placed on child nodes, (2) child tasks are\n+            // completed or failed, (3) the main task is cancelled. Otherwise, return after bans are placed on child nodes.\n+            if (request.waitForCompletion()) {\n+                completedListener.whenComplete(r -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)), listener::onFailure);\n+            } else {\n+                banOnNodesListener.whenComplete(r -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)), listener::onFailure);\n             }\n         } else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            logger.trace(\"task {} doesn't have any children that should be cancelled\", cancellableTask.getId());\n+            final boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(),\n                 () -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)));\n-            if (canceled) {\n-                logger.trace(\"task {} doesn't have any children that should be cancelled\", cancellableTask.getId());\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n         }\n-        if (canceled == false) {\n-            logger.trace(\"task {} is already cancelled\", cancellableTask.getId());\n-            throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n-        }\n     }\n \n     private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399957376", "bodyText": "let's also log the childNodes here", "author": "ywelsch", "createdAt": "2020-03-30T06:39:51Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 8eb0b7cdbba..2602710bfc8 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -149,7 +149,7 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n             listener.onResponse(null);\n             return;\n         }\n-        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        logger.trace(\"cancelling task {} on child nodes {}\", task.getId(), childNodes);\n         GroupedActionListener<Void> groupedListener =\n             new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n         final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959123", "bodyText": "if (canceled == false) we're not calling groupedListener?", "author": "ywelsch", "createdAt": "2020-03-30T06:44:28Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -104,48 +103,35 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n \n     @Override\n     protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+                                              ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n         final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n+            final StepListener<Void> completeListener = new StepListener<>();\n+            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n+            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n+            final GroupedActionListener<Void> groupedListener =\n+                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n+            final Collection<DiscoveryNode> childNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            completeListener.whenComplete(r -> {\n+                    removeBanOnNodes(cancellableTask, childNodes);\n+                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n+                },\n+                e -> {\n+                    try {\n+                        removeBanOnNodes(cancellableTask, childNodes);\n+                    } catch (Exception inner) {\n+                        e.addSuppressed(inner);\n                     }\n+                    listener.onFailure(e);\n                 });\n+            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (canceled) {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxODczNg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400418736", "bodyText": "We throw exception at the end. Anyway, I moved up that statement right after we cancel (see a5af596).", "author": "dnhatn", "createdAt": "2020-03-30T18:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 8eb0b7cdbba..9ef1bd05cb2 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -102,46 +102,40 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n                                               ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            final StepListener<Void> completeListener = new StepListener<>();\n-            // Only return when all these 3 actions completed: (1) bans are placed on nodes with outstanding child tasks,\n-            // (2) child tasks are completed or failed, (3) the parent task itself was cancelled.\n-            final GroupedActionListener<Void> groupedListener =\n-                new GroupedActionListener<>(ActionListener.map(completeListener, r -> null), 3);\n-            final Collection<DiscoveryNode> childNodes =\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n                 taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n-            completeListener.whenComplete(r -> {\n-                    removeBanOnNodes(cancellableTask, childNodes);\n-                    listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                },\n-                e -> {\n-                    try {\n-                        removeBanOnNodes(cancellableTask, childNodes);\n-                    } catch (Exception inner) {\n-                        e.addSuppressed(inner);\n-                    }\n-                    listener.onFailure(e);\n-                });\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n-            if (canceled) {\n-                // In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, groupedListener);\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n+            }\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.\n+            completedListener.whenComplete(\n+                r -> removeBanOnNodes(cancellableTask, childrenNodes),\n+                e -> removeBanOnNodes(cancellableTask, childrenNodes));\n+            // if wait_for_completion is true, then only return when (1) bans are placed on child nodes, (2) child tasks are\n+            // completed or failed, (3) the main task is cancelled. Otherwise, return after bans are placed on child nodes.\n+            if (request.waitForCompletion()) {\n+                completedListener.whenComplete(r -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)), listener::onFailure);\n+            } else {\n+                banOnNodesListener.whenComplete(r -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)), listener::onFailure);\n             }\n         } else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            logger.trace(\"task {} doesn't have any children that should be cancelled\", cancellableTask.getId());\n+            final boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(),\n                 () -> listener.onResponse(cancellableTask.taskInfo(nodeId, false)));\n-            if (canceled) {\n-                logger.trace(\"task {} doesn't have any children that should be cancelled\", cancellableTask.getId());\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n         }\n-        if (canceled == false) {\n-            logger.trace(\"task {} is already cancelled\", cancellableTask.getId());\n-            throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n-        }\n     }\n \n     private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1OTQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399959420", "bodyText": "log at trace level", "author": "ywelsch", "createdAt": "2020-03-30T06:45:17Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -158,74 +144,42 @@ private void processResponse() {\n         }\n     }\n \n-    private void setBanOnNodes(String reason, CancellableTask task, DiscoveryNodes nodes, ActionListener<Void> listener) {\n-        sendSetBanRequest(nodes,\n-            BanParentTaskRequest.createSetBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()), reason),\n-            listener);\n-    }\n-\n-    private void removeBanOnNodes(CancellableTask task, DiscoveryNodes nodes) {\n-        sendRemoveBanRequest(nodes,\n-            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId())));\n-    }\n-\n-    private void sendSetBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request, ActionListener<Void> listener) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.trace(\"Sending ban for tasks with the parent [{}] to the node [{}], ban [{}]\", request.parentTaskId, node.key,\n-                request.ban);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request,\n+    private void setBanOnNodes(String reason, CancellableTask task, Collection<DiscoveryNode> childNodes, ActionListener<Void> listener) {\n+        if (childNodes.isEmpty()) {\n+            listener.onResponse(null);\n+            return;\n+        }\n+        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        GroupedActionListener<Void> groupedListener =\n+            new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n+        final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n+            new TaskId(clusterService.localNode().getId(), task.getId()), reason);\n+        for (DiscoveryNode node : childNodes) {\n+            transportService.sendRequest(node, BAN_PARENT_ACTION_NAME, banRequest,\n                 new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {\n                     @Override\n                     public void handleResponse(TransportResponse.Empty response) {\n-                        listener.onResponse(null);\n+                        groupedListener.onResponse(null);\n                     }\n \n                     @Override\n                     public void handleException(TransportException exp) {\n-                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-                        listener.onFailure(exp);\n+                        logger.warn(\"Cannot send ban for tasks with the parent [{}] to the node [{}]\", banRequest.parentTaskId, node);\n+                        groupedListener.onFailure(exp);\n                     }\n                 });\n         }\n     }\n \n-    private void sendRemoveBanRequest(DiscoveryNodes nodes, BanParentTaskRequest request) {\n-        for (ObjectObjectCursor<String, DiscoveryNode> node : nodes.getNodes()) {\n-            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node.key);\n-            transportService.sendRequest(node.value, BAN_PARENT_ACTION_NAME, request, EmptyTransportResponseHandler\n-                .INSTANCE_SAME);\n+    private void removeBanOnNodes(CancellableTask task, Collection<DiscoveryNode> childNodes) {\n+        final BanParentTaskRequest request =\n+            BanParentTaskRequest.createRemoveBanParentTaskRequest(new TaskId(clusterService.localNode().getId(), task.getId()));\n+        for (DiscoveryNode node : childNodes) {\n+            logger.debug(\"Sending remove ban for tasks with the parent [{}] to the node [{}]\", request.parentTaskId, node);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 8eb0b7cdbba..2602710bfc8 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -149,7 +149,7 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n             listener.onResponse(null);\n             return;\n         }\n-        logger.trace(\"cancelling task {} on child nodes\", task.getId());\n+        logger.trace(\"cancelling task {} on child nodes {}\", task.getId(), childNodes);\n         GroupedActionListener<Void> groupedListener =\n             new GroupedActionListener<>(ActionListener.map(listener, r -> null), childNodes.size());\n         final BanParentTaskRequest banRequest = BanParentTaskRequest.createSetBanParentTaskRequest(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399961829", "bodyText": "I wonder if we should leave this optimization in (and add a comment as well). This avoids computing the hash of the task id in order to look it up in the map.", "author": "ywelsch", "createdAt": "2020-03-30T06:51:37Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -163,7 +178,7 @@ private void registerCancellableTask(Task task) {\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n         // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMTEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400411133", "bodyText": "I restored and added a comment 297b787", "author": "dnhatn", "createdAt": "2020-03-30T18:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MTgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "297b78726aeb4c7cae96db54e98903174745fd0b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..b43cf4f72f7 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -177,8 +176,9 @@ public class TaskManager implements ClusterStateApplier {\n         CancellableTaskHolder holder = new CancellableTaskHolder(cancellableTask);\n         CancellableTaskHolder oldHolder = cancellableTasks.put(task.getId(), holder);\n         assert oldHolder == null;\n-        // Check if this task was banned before we start it\n-        if (task.getParentTaskId().isSet()) {\n+        // Check if this task was banned before we start it. The empty check is used to avoid\n+        // computing the hash code of the parent taskId as most of the time banedParents is empty.\n+        if (task.getParentTaskId().isSet() && banedParents.isEmpty() == false) {\n             String reason = banedParents.get(task.getParentTaskId());\n             if (reason != null) {\n                 try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzM2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963368", "bodyText": "when do we expect this to happen?", "author": "ywelsch", "createdAt": "2020-03-30T06:55:15Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -417,8 +417,6 @@ public class TaskManager implements ClusterStateApplier {\n         if (holder != null) {\n             return holder.startBan(onEmptyChildNodes);\n         } else {\n-            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n-            // We still need to set ban on local node for persistent tasks\n             onEmptyChildNodes.run();\n             return Collections.emptySet();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963500", "bodyText": "I'm not sure I understand this comment. Can you elaborate on this?", "author": "ywelsch", "createdAt": "2020-03-30T06:55:35Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)\n+     * @return the set of current nodes that have outstanding child tasks\n+     */\n+    public Collection<DiscoveryNode> startBanOnChildrenNodes(long taskId, Runnable onEmptyChildNodes) {\n+        final CancellableTaskHolder holder = cancellableTasks.get(taskId);\n+        if (holder != null) {\n+            return holder.startBan(onEmptyChildNodes);\n+        } else {\n+            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n+            // We still need to set ban on local node for persistent tasks", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400412661", "bodyText": "I don't know either. It's from the draft version. Sorry.", "author": "dnhatn", "createdAt": "2020-03-30T18:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -417,8 +417,6 @@ public class TaskManager implements ClusterStateApplier {\n         if (holder != null) {\n             return holder.startBan(onEmptyChildNodes);\n         } else {\n-            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n-            // We still need to set ban on local node for persistent tasks\n             onEmptyChildNodes.run();\n             return Collections.emptySet();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2Mzk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399963945", "bodyText": "perhaps call this onChildTasksCompleted?", "author": "ywelsch", "createdAt": "2020-03-30T06:56:38Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -369,6 +397,33 @@ public void removeBan(TaskId parentTaskId) {\n         banedParents.remove(parentTaskId);\n     }\n \n+    // for testing\n+    public boolean childTasksCancelledOrBanned(TaskId parentTaskId) {\n+        if (banedParents.containsKey(parentTaskId)) {\n+            return true;\n+        }\n+        return cancellableTasks.values().stream().noneMatch(task -> task.hasParent(parentTaskId));\n+    }\n+\n+    /**\n+     * Start rejecting new child requests as the parent task was cancelled.\n+     *\n+     * @param taskId            the parent task id\n+     * @param onEmptyChildNodes called when all child nodes are unregistered (i.e, all child tasks are completed or failed)", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -417,8 +417,6 @@ public class TaskManager implements ClusterStateApplier {\n         if (holder != null) {\n             return holder.startBan(onEmptyChildNodes);\n         } else {\n-            logger.warn(\"Trying to cancel task without registered cancellable task \" + taskId);\n-            // We still need to set ban on local node for persistent tasks\n             onEmptyChildNodes.run();\n             return Collections.emptySet();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDk3MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399964970", "bodyText": "any child tasks", "author": "ywelsch", "createdAt": "2020-03-30T06:58:59Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -555,7 +553,7 @@ public class TaskManager implements ClusterStateApplier {\n \n         synchronized void registerChildNode(DiscoveryNode node) {\n             if (banChildren) {\n-                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any child tasks\");\n             }\n             if (childTasksPerNode == null) {\n                 childTasksPerNode = new ObjectIntHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399965692", "bodyText": "perhaps runnable = {}, which avoids the null check later down", "author": "ywelsch", "createdAt": "2020-03-30T07:00:43Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTEyMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415123", "bodyText": "onChildTasksCompleted is still null if we do not cancel the task.", "author": "dnhatn", "createdAt": "2020-03-30T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -555,7 +553,7 @@ public class TaskManager implements ClusterStateApplier {\n \n         synchronized void registerChildNode(DiscoveryNode node) {\n             if (banChildren) {\n-                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any child tasks\");\n             }\n             if (childTasksPerNode == null) {\n                 childTasksPerNode = new ObjectIntHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjI5OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966298", "bodyText": "why does this deserve a warning?\nWhen do we expect this to happen?", "author": "ywelsch", "createdAt": "2020-03-30T07:02:04Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -555,7 +553,7 @@ public class TaskManager implements ClusterStateApplier {\n \n         synchronized void registerChildNode(DiscoveryNode node) {\n             if (banChildren) {\n-                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any child tasks\");\n             }\n             if (childTasksPerNode == null) {\n                 childTasksPerNode = new ObjectIntHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399966679", "bodyText": "Why use empty set here and not the actual set? Will this not lead to incorrectness?", "author": "ywelsch", "createdAt": "2020-03-30T07:03:00Z", "path": "server/src/main/java/org/elasticsearch/tasks/TaskManager.java", "diffHunk": "@@ -495,6 +552,56 @@ public boolean hasParent(TaskId parentTaskId) {\n         public CancellableTask getTask() {\n             return task;\n         }\n+\n+        synchronized void registerChildNode(DiscoveryNode node) {\n+            if (banChildren) {\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+            }\n+            if (childTasksPerNode == null) {\n+                childTasksPerNode = new ObjectIntHashMap<>();\n+            }\n+            childTasksPerNode.addTo(node, 1);\n+        }\n+\n+        void unregisterChildNode(DiscoveryNode node) {\n+            final Runnable runnable;\n+            synchronized (this) {\n+                if (childTasksPerNode.addTo(node, -1) == 0) {\n+                    childTasksPerNode.remove(node);\n+                }\n+                if (childTasksPerNode.isEmpty()) {\n+                    runnable = onEmptyChildNodes;\n+                } else {\n+                    runnable = null;\n+                }\n+            }\n+            if (runnable != null) {\n+                runnable.run();\n+            }\n+        }\n+\n+        Set<DiscoveryNode> startBan(Runnable onEmptyChildNodes) {\n+            final Set<DiscoveryNode> pendingChildNodes;\n+            synchronized (this) {\n+                if (banChildren) {\n+                    logger.warn(\"Trying to start ban twice for task \" + task.getId());\n+                    pendingChildNodes = Collections.emptySet();", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTQ4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400415489", "bodyText": "Good catch. Fixed in 226a541", "author": "dnhatn", "createdAt": "2020-03-30T18:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "03ce7a816e1b89712ebd4057d3550646c315af2e", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\nindex 3f275d053ad..a7251cca1c2 100644\n--- a/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n+++ b/server/src/main/java/org/elasticsearch/tasks/TaskManager.java\n\n@@ -555,7 +553,7 @@ public class TaskManager implements ClusterStateApplier {\n \n         synchronized void registerChildNode(DiscoveryNode node) {\n             if (banChildren) {\n-                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any children tasks\");\n+                throw new TaskCancelledException(\"The parent task was cancelled, shouldn't start any child tasks\");\n             }\n             if (childTasksPerNode == null) {\n                 childTasksPerNode = new ObjectIntHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971293", "bodyText": "I think that we need to actually capture the connection (not the DiscoveryNode object). The reason for this is cross-cluster connections. In the task cancellation action, we assume that the DiscoveryNode is sufficient to resolve the target of the cancellation. This only works for nodes in the same cluster, however.\nI don't think that we need to solve this all in this PR, but we need to capture the issue properly, and add an item to the planning.", "author": "ywelsch", "createdAt": "2020-03-30T07:12:55Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzA1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400417053", "bodyText": "++ see 4f337de", "author": "dnhatn", "createdAt": "2020-03-30T18:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4f337decce08edd355621c9982559df34bc42ce6", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/transport/TransportService.java b/server/src/main/java/org/elasticsearch/transport/TransportService.java\nindex 2fec2216fde..35971a3ca0a 100644\n--- a/server/src/main/java/org/elasticsearch/transport/TransportService.java\n+++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java\n\n@@ -562,6 +562,7 @@ public class TransportService extends AbstractLifecycleComponent implements Tran\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n             if (request.getParentTask().isSet()) {\n+                // TODO: capture the connection instead so that we can cancel child tasks on the remote connections.\n                 final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n                 final TransportResponseHandler<T> delegate = handler;\n                 handler = new TransportResponseHandler<>() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971712", "bodyText": "should we call this in a finally block?", "author": "ywelsch", "createdAt": "2020-03-30T07:13:43Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f337decce08edd355621c9982559df34bc42ce6", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/transport/TransportService.java b/server/src/main/java/org/elasticsearch/transport/TransportService.java\nindex 2fec2216fde..35971a3ca0a 100644\n--- a/server/src/main/java/org/elasticsearch/transport/TransportService.java\n+++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java\n\n@@ -562,6 +562,7 @@ public class TransportService extends AbstractLifecycleComponent implements Tran\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n             if (request.getParentTask().isSet()) {\n+                // TODO: capture the connection instead so that we can cancel child tasks on the remote connections.\n                 final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n                 final TransportResponseHandler<T> delegate = handler;\n                 handler = new TransportResponseHandler<>() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MTc4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399971785", "bodyText": "should we call this in a finally block?", "author": "ywelsch", "createdAt": "2020-03-30T07:13:53Z", "path": "server/src/main/java/org/elasticsearch/transport/TransportService.java", "diffHunk": "@@ -560,6 +561,33 @@ public void removeConnectionListener(TransportConnectionListener listener) {\n                                                                 final TransportRequestOptions options,\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n+            if (request.getParentTask().isSet()) {\n+                final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n+                final TransportResponseHandler<T> delegate = handler;\n+                handler = new TransportResponseHandler<>() {\n+                    @Override\n+                    public void handleResponse(T response) {\n+                        unregisterChildNode.close();\n+                        delegate.handleResponse(response);\n+                    }\n+\n+                    @Override\n+                    public void handleException(TransportException exp) {\n+                        unregisterChildNode.close();\n+                        delegate.handleException(exp);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f337decce08edd355621c9982559df34bc42ce6", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/transport/TransportService.java b/server/src/main/java/org/elasticsearch/transport/TransportService.java\nindex 2fec2216fde..35971a3ca0a 100644\n--- a/server/src/main/java/org/elasticsearch/transport/TransportService.java\n+++ b/server/src/main/java/org/elasticsearch/transport/TransportService.java\n\n@@ -562,6 +562,7 @@ public class TransportService extends AbstractLifecycleComponent implements Tran\n                                                                 TransportResponseHandler<T> handler) {\n         try {\n             if (request.getParentTask().isSet()) {\n+                // TODO: capture the connection instead so that we can cancel child tasks on the remote connections.\n                 final Releasable unregisterChildNode = taskManager.registerChildNode(request.getParentTask().getId(), connection.getNode());\n                 final TransportResponseHandler<T> delegate = handler;\n                 handler = new TransportResponseHandler<>() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MjY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399972699", "bodyText": "assert that cancelFuture.isDone == false before disabling blocks?", "author": "ywelsch", "createdAt": "2020-03-30T07:15:45Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java", "diffHunk": "@@ -151,8 +151,9 @@ public void testCancellationDuringQueryPhase() throws Exception {\n             .execute();\n \n         awaitForBlock(plugins);\n-        cancelSearch(SearchAction.NAME);\n+        ActionFuture<CancelTasksResponse> cancelFuture = cancelSearch(SearchAction.NAME);\n         disableBlocks(plugins);", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java\nindex b60e262c82e..bc979c4c03c 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationIT.java\n\n@@ -152,6 +152,7 @@ public class SearchCancellationIT extends ESIntegTestCase {\n \n         awaitForBlock(plugins);\n         ActionFuture<CancelTasksResponse> cancelFuture = cancelSearch(SearchAction.NAME);\n+        assertFalse(cancelFuture.isDone());\n         disableBlocks(plugins);\n         cancelFuture.actionGet();\n         logger.info(\"Segments {}\", Strings.toString(client().admin().indices().prepareSegments(\"test\").get()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3MzczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r399973735", "bodyText": "testBanOnly...", "author": "ywelsch", "createdAt": "2020-03-30T07:18:01Z", "path": "server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.elasticsearch.action.admin.cluster.node.tasks;\n+\n+import org.elasticsearch.action.ActionFuture;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionRunnable;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.LatchedActionListener;\n+import org.elasticsearch.action.admin.cluster.node.tasks.cancel.CancelTasksResponse;\n+import org.elasticsearch.action.admin.cluster.node.tasks.list.ListTasksResponse;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.GroupedActionListener;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.common.util.concurrent.ConcurrentCollections;\n+import org.elasticsearch.plugins.ActionPlugin;\n+import org.elasticsearch.plugins.Plugin;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskCancelledException;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.tasks.TaskManager;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportResponse;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class CancellableTasksIT extends ESIntegTestCase {\n+    static final Map<ChildRequest, CountDownLatch> arrivedLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> beforeExecuteLatches = ConcurrentCollections.newConcurrentMap();\n+    static final Map<ChildRequest, CountDownLatch> completedLatches = ConcurrentCollections.newConcurrentMap();\n+\n+    @Before\n+    public void resetTestStates() {\n+        arrivedLatches.clear();\n+        beforeExecuteLatches.clear();\n+        completedLatches.clear();\n+    }\n+\n+    public void testBandOnlyNodesWithOutstandingChildTasks() throws Exception {", "originalCommit": "0f51b4548ef55190e34a26a4309122cdc95df32d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java b/server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java\nindex 8bdc899cc17..0c7c97bd2e2 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/cluster/node/tasks/CancellableTasksIT.java\n\n@@ -82,7 +82,7 @@ public class CancellableTasksIT extends ESIntegTestCase {\n         completedLatches.clear();\n     }\n \n-    public void testBandOnlyNodesWithOutstandingChildTasks() throws Exception {\n+    public void testBanOnlyNodesWithOutstandingChildTasks() throws Exception {\n         if (randomBoolean()) {\n             internalCluster().startNodes(randomIntBetween(1, 3));\n         }\n"}}, {"oid": "de680fc95020558a8889ca59bc89dcd2ea6537cb", "url": "https://github.com/elastic/elasticsearch/commit/de680fc95020558a8889ca59bc89dcd2ea6537cb", "message": "fix tests", "committedDate": "2020-03-30T12:52:25Z", "type": "commit"}, {"oid": "03ce7a816e1b89712ebd4057d3550646c315af2e", "url": "https://github.com/elastic/elasticsearch/commit/03ce7a816e1b89712ebd4057d3550646c315af2e", "message": "fix logging", "committedDate": "2020-03-30T13:00:14Z", "type": "commit"}, {"oid": "297b78726aeb4c7cae96db54e98903174745fd0b", "url": "https://github.com/elastic/elasticsearch/commit/297b78726aeb4c7cae96db54e98903174745fd0b", "message": "restore optimization", "committedDate": "2020-03-30T14:12:49Z", "type": "commit"}, {"oid": "226a5414320e8e4f725a1762e2226af6731a906a", "url": "https://github.com/elastic/elasticsearch/commit/226a5414320e8e4f725a1762e2226af6731a906a", "message": "ban children", "committedDate": "2020-03-30T14:48:48Z", "type": "commit"}, {"oid": "a5af596d79d4c663cb711f60f0f1011ad22b32d0", "url": "https://github.com/elastic/elasticsearch/commit/a5af596d79d4c663cb711f60f0f1011ad22b32d0", "message": "add wait_for_completion", "committedDate": "2020-03-30T18:31:12Z", "type": "commit"}, {"oid": "ff31a93604b5fe267e04a1b3bda5f06223df755d", "url": "https://github.com/elastic/elasticsearch/commit/ff31a93604b5fe267e04a1b3bda5f06223df755d", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-30T18:36:21Z", "type": "commit"}, {"oid": "4f337decce08edd355621c9982559df34bc42ce6", "url": "https://github.com/elastic/elasticsearch/commit/4f337decce08edd355621c9982559df34bc42ce6", "message": "Add TODO", "committedDate": "2020-03-30T18:49:13Z", "type": "commit"}, {"oid": "627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "url": "https://github.com/elastic/elasticsearch/commit/627e6a498a25618ffd8e7d0bc534f2d4ff4cf8db", "message": "format", "committedDate": "2020-03-30T18:55:44Z", "type": "commit"}, {"oid": "4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "url": "https://github.com/elastic/elasticsearch/commit/4abd0f54c7d799ce19b9ff9161fa664e1a176f8b", "message": "wait_for_completion -> wait_for_child_tasks", "committedDate": "2020-03-30T21:33:15Z", "type": "commit"}, {"oid": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "url": "https://github.com/elastic/elasticsearch/commit/e6a8b7c79b07cb841b041f2acae26df113e6c068", "message": "comment", "committedDate": "2020-03-30T21:35:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400715280", "bodyText": "I wonder if this message is misleading. The task could have been cancelled, but it could also have completed successfully before this request came in.", "author": "ywelsch", "createdAt": "2020-03-31T08:00:13Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716543", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.", "author": "ywelsch", "createdAt": "2020-03-31T08:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg5NDQ3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400894473", "bodyText": "Another issue I have with this is that this does not play nicely with wait_for_completion. Assume someone else has cancelled the task, and you now want to wait for completion. This gives you a hard exception instead of waiting for all child tasks to complete.\n\nI thought about that scenario but decided not to implement it as I worried about its complexity (we need to keep track of a list of cancellation listeners and childTasksCompleted listeners). Anyway, I will work on it.", "author": "dnhatn", "createdAt": "2020-03-31T13:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkwMDA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400900079", "bodyText": "Let's add a TODO for that part, and consider it in a follow-up", "author": "ywelsch", "createdAt": "2020-03-31T13:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401184839", "bodyText": "The cancel() method is a bit trappy. I have removed the return value and made it idempotent in 9a55fe4.", "author": "dnhatn", "createdAt": "2020-03-31T20:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNTI4MA=="}], "type": "inlineReview", "revised_code": {"commit": "9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 7525afa054f..55089a24740 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -109,10 +109,8 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n             GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n             Collection<DiscoveryNode> childrenNodes =\n                 taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n-            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n-            if (cancelled == false) {\n-                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n-            }\n+            taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+\n             StepListener<Void> banOnNodesListener = new StepListener<>();\n             setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n             banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400716960", "bodyText": "basis", "author": "ywelsch", "createdAt": "2020-03-31T08:03:02Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java", "diffHunk": "@@ -103,127 +102,75 @@ protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask\n     }\n \n     @Override\n-    protected synchronized void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask,\n-            ActionListener<TaskInfo> listener) {\n+    protected void taskOperation(CancelTasksRequest request, CancellableTask cancellableTask, ActionListener<TaskInfo> listener) {\n         String nodeId = clusterService.localNode().getId();\n-        final boolean canceled;\n         if (cancellableTask.shouldCancelChildrenOnCancellation()) {\n-            DiscoveryNodes childNodes = clusterService.state().nodes();\n-            final BanLock banLock = new BanLock(childNodes.getSize(), () -> removeBanOnNodes(cancellableTask, childNodes));\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(), banLock::onTaskFinished);\n-            if (canceled) {\n-                // /In case the task has some child tasks, we need to wait for until ban is set on all nodes\n-                logger.trace(\"cancelling task {} on child nodes\", cancellableTask.getId());\n-                AtomicInteger responses = new AtomicInteger(childNodes.getSize());\n-                List<Exception> failures = new ArrayList<>();\n-                setBanOnNodes(request.getReason(), cancellableTask, childNodes, new ActionListener<Void>() {\n-                    @Override\n-                    public void onResponse(Void aVoid) {\n-                        processResponse();\n-                    }\n-\n-                    @Override\n-                    public void onFailure(Exception e) {\n-                        synchronized (failures) {\n-                            failures.add(e);\n-                        }\n-                        processResponse();\n-                    }\n-\n-                    private void processResponse() {\n-                        banLock.onBanSet();\n-                        if (responses.decrementAndGet() == 0) {\n-                            if (failures.isEmpty() == false) {\n-                                IllegalStateException exception = new IllegalStateException(\"failed to cancel children of the task [\" +\n-                                    cancellableTask.getId() + \"]\");\n-                                failures.forEach(exception::addSuppressed);\n-                                listener.onFailure(exception);\n-                            } else {\n-                                listener.onResponse(cancellableTask.taskInfo(nodeId, false));\n-                            }\n-                        }\n-                    }\n-                });\n+            StepListener<Void> completedListener = new StepListener<>();\n+            GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n+            Collection<DiscoveryNode> childrenNodes =\n+                taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n+            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+            if (cancelled == false) {\n+                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n             }\n-        }  else {\n-            canceled = taskManager.cancel(cancellableTask, request.getReason(),\n+            StepListener<Void> banOnNodesListener = new StepListener<>();\n+            setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n+            banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n+            // We remove bans after all child tasks are completed although in theory we can do it on a per-node basic.", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175629", "bodyText": "thanks, fixed in a01325e", "author": "dnhatn", "createdAt": "2020-03-31T19:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcxNjk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\nindex 7525afa054f..55089a24740 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/TransportCancelTasksAction.java\n\n@@ -109,10 +109,8 @@ public class TransportCancelTasksAction extends TransportTasksAction<Cancellable\n             GroupedActionListener<Void> groupedListener = new GroupedActionListener<>(ActionListener.map(completedListener, r -> null), 3);\n             Collection<DiscoveryNode> childrenNodes =\n                 taskManager.startBanOnChildrenNodes(cancellableTask.getId(), () -> groupedListener.onResponse(null));\n-            boolean cancelled = taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n-            if (cancelled == false) {\n-                throw new IllegalStateException(\"task with id \" + cancellableTask.getId() + \" is already cancelled\");\n-            }\n+            taskManager.cancel(cancellableTask, request.getReason(), () -> groupedListener.onResponse(null));\n+\n             StepListener<Void> banOnNodesListener = new StepListener<>();\n             setBanOnNodes(request.getReason(), cancellableTask, childrenNodes, banOnNodesListener);\n             banOnNodesListener.whenComplete(groupedListener::onResponse, groupedListener::onFailure);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400861083", "bodyText": "shouldn't we get the default value from the cancelTasksRequest so we don't duplicate it?", "author": "javanna", "createdAt": "2020-03-31T12:10:12Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,7 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401175991", "bodyText": "yes, fixed in 8cff3b0.", "author": "dnhatn", "createdAt": "2020-03-31T19:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MTA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java b/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\nindex 7aee86d0766..a8d450fa0f7 100644\n--- a/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\n\n@@ -66,7 +66,8 @@ public class RestCancelTasksAction extends BaseRestHandler {\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n-        cancelTasksRequest.setWaitForChildTasks(request.paramAsBoolean(\"wait_for_child_tasks\", true));\n+        cancelTasksRequest.setWaitForCompletion(\n+            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));\n         return channel ->\n             client.admin().cluster().cancelTasks(cancelTasksRequest, listTasksResponseListener(nodesInCluster, groupBy, channel));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r400864528", "bodyText": "I am curious about this: the child tasks are already cancelled or banned before the delete async search call returns?", "author": "javanna", "createdAt": "2020-03-31T12:16:15Z", "path": "x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java", "diffHunk": "@@ -190,8 +193,11 @@ public void testDeleteCancelRunningTask() throws Exception {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        deleteAsyncSearch(initial.getId());\n+        ActionFuture<AcknowledgedResponse> cancelFuture =\n+            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n+        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());", "originalCommit": "e6a8b7c79b07cb841b041f2acae26df113e6c068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401177133", "bodyText": "Yes, but this is an async call. Anyway, I've reverted this change as wait_for_completion now defaults to false.", "author": "dnhatn", "createdAt": "2020-03-31T19:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2NDUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "chunk": "diff --git a/x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java b/x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java\nindex 5571486caff..83ace3a4293 100644\n--- a/x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java\n+++ b/x-pack/plugin/async-search/src/test/java/org/elasticsearch/xpack/search/AsyncSearchActionTests.java\n\n@@ -193,11 +190,8 @@ public class AsyncSearchActionTests extends AsyncSearchIntegTestCase {\n         SearchResponseIterator it =\n             assertBlockingIterator(indexName, new SearchSourceBuilder(), randomBoolean() ? 1 : 0, 2);\n         initial = it.next();\n-        ActionFuture<AcknowledgedResponse> cancelFuture =\n-            client().execute(DeleteAsyncSearchAction.INSTANCE, new DeleteAsyncSearchAction.Request(initial.getId()));\n-        ensureChildTasksCancelledOrBanned(AsyncSearchId.decode(initial.getId()).getTaskId());\n+        deleteAsyncSearch(initial.getId());\n         it.close();\n-        cancelFuture.actionGet();\n         ensureTaskCompletion(initial.getId());\n         ensureTaskRemoval(initial.getId());\n     }\n"}}, {"oid": "9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "url": "https://github.com/elastic/elasticsearch/commit/9a55fe41951f6bf0704ac5fe3690aa1206f832c5", "message": "Allow cancel multiple times", "committedDate": "2020-03-31T18:26:03Z", "type": "commit"}, {"oid": "a01325e069ff433165a0bdbc0da2854da8db729e", "url": "https://github.com/elastic/elasticsearch/commit/a01325e069ff433165a0bdbc0da2854da8db729e", "message": "wording", "committedDate": "2020-03-31T18:26:03Z", "type": "commit"}, {"oid": "8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "url": "https://github.com/elastic/elasticsearch/commit/8cff3b0a4998ef4f5de015c484c2f4389a807ce3", "message": "wait_for_completion to false", "committedDate": "2020-03-31T19:44:28Z", "type": "commit"}, {"oid": "b07d962385bea4ab2acc0afa887e2952baf3e44d", "url": "https://github.com/elastic/elasticsearch/commit/b07d962385bea4ab2acc0afa887e2952baf3e44d", "message": "Merge branch 'master' into track-child-tasks", "committedDate": "2020-03-31T19:44:41Z", "type": "commit"}, {"oid": "76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "url": "https://github.com/elastic/elasticsearch/commit/76f8fd128407aee9e3d7d99eaf7e89c55646bb8d", "message": "allow mock", "committedDate": "2020-03-31T20:17:36Z", "type": "commit"}, {"oid": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "url": "https://github.com/elastic/elasticsearch/commit/4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "message": "fix docs", "committedDate": "2020-03-31T22:02:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401463562", "bodyText": "Use this in TasksRequestConvertersTests?", "author": "ywelsch", "createdAt": "2020-04-01T09:05:11Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/tasks/CancelTasksRequest.java", "diffHunk": "@@ -138,13 +150,21 @@ public Builder withNodesFiltered(List<String> nodes){\n             return this;\n         }\n \n+        public Builder withWaitForCompletion(boolean waitForCompletion) {", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3OTU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401479596", "bodyText": "As well as in TasksClientDocumentationIT to document it there as well?", "author": "ywelsch", "createdAt": "2020-04-01T09:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MzU2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTMzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465335", "bodyText": "call this getWaitForCompletion", "author": "ywelsch", "createdAt": "2020-04-01T09:08:11Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java", "diffHunk": "@@ -68,4 +77,16 @@ public CancelTasksRequest setReason(String reason) {\n     public String getReason() {\n         return reason;\n     }\n+\n+    /**\n+     * If {@code true}, the request blocks until the cancellation of the task and its child tasks is completed.\n+     * Otherwise, the request can return soon after the cancellation is started. Defaults to {@code false}.\n+     */\n+    public void setWaitForCompletion(boolean waitForCompletion) {\n+        this.waitForCompletion = waitForCompletion;\n+    }\n+\n+    public boolean waitForChildTasks() {", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java\nindex 3e248e1febb..9ab414cdb72 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/cluster/node/tasks/cancel/CancelTasksRequest.java\n\n@@ -86,7 +86,7 @@ public class CancelTasksRequest extends BaseTasksRequest<CancelTasksRequest> {\n         this.waitForCompletion = waitForCompletion;\n     }\n \n-    public boolean waitForChildTasks() {\n+    public boolean waitForCompletion() {\n         return waitForCompletion;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NTQ2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54312#discussion_r401465468", "bodyText": "instead of introducing this constant, just use cancelTasksRequest.getWaitForCompletion() here", "author": "ywelsch", "createdAt": "2020-04-01T09:08:26Z", "path": "server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java", "diffHunk": "@@ -66,6 +66,8 @@ public RestChannelConsumer prepareRequest(final RestRequest request, final NodeC\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n+        cancelTasksRequest.setWaitForCompletion(\n+            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));", "originalCommit": "4572f23d998f8a2c4da28b2afe4132cfae1d64ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java b/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\nindex a8d450fa0f7..8dcf32f6244 100644\n--- a/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\n+++ b/server/src/main/java/org/elasticsearch/rest/action/admin/cluster/RestCancelTasksAction.java\n\n@@ -66,8 +66,7 @@ public class RestCancelTasksAction extends BaseRestHandler {\n         cancelTasksRequest.setNodes(nodesIds);\n         cancelTasksRequest.setActions(actions);\n         cancelTasksRequest.setParentTaskId(parentTaskId);\n-        cancelTasksRequest.setWaitForCompletion(\n-            request.paramAsBoolean(\"wait_for_child_tasks\", CancelTasksRequest.DEFAULT_WAIT_FOR_COMPLETION));\n+        cancelTasksRequest.setWaitForCompletion(request.paramAsBoolean(\"wait_for_completion\", cancelTasksRequest.waitForCompletion()));\n         return channel ->\n             client.admin().cluster().cancelTasks(cancelTasksRequest, listTasksResponseListener(nodesInCluster, groupBy, channel));\n     }\n"}}, {"oid": "2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "url": "https://github.com/elastic/elasticsearch/commit/2c8c1cdb941c2389fae5aad4462d0ba8c7d2fd72", "message": "nits", "committedDate": "2020-04-01T13:18:46Z", "type": "commit"}]}