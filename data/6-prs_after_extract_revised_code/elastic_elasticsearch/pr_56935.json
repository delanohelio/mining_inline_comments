{"pr_number": 56935, "pr_title": "Remove Needless Context Switches on Loading RepositoryData", "pr_createdAt": "2020-05-19T09:50:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56935", "timeline": [{"oid": "cbc7faff040ad46fadb37422df7b1f406aa191c7", "url": "https://github.com/elastic/elasticsearch/commit/cbc7faff040ad46fadb37422df7b1f406aa191c7", "message": "Remove Needless Context Switches on Loading RepositoryData\n\nWe don't need to switch to the generic or snapshot pool for loading\ncached repository data (i.e. most of the time in normal operation).\n\nThis makes `executeConsistentStateUpdate` less heavy if it has to retry\nand lowers the chance of having to retry in the first place.\nAlso, this change allowed simplifying a few other spots in the codebase\nwhere we would fork off to another pool just to load repository data.", "committedDate": "2020-05-19T09:48:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3ODAxNg==", "url": "https://github.com/elastic/elasticsearch/pull/56935#discussion_r427178016", "bodyText": "No need to fork for this here already, we might just be loading _current and never do any IO.", "author": "original-brownbear", "createdAt": "2020-05-19T09:55:56Z", "path": "server/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/get/TransportGetSnapshotsAction.java", "diffHunk": "@@ -122,18 +122,16 @@ private void getMultipleReposSnapshotInfo(@Nullable SnapshotsInProgress snapshot\n                             return new GetSnapshotsResponse(responses);\n                         }), repos.size());\n \n-        // run concurrently for all repos on GENERIC thread pool\n         for (final RepositoryMetadata repo : repos) {\n             final String repoName = repo.name();\n-            threadPool.generic().execute(ActionRunnable.wrap(\n-                ActionListener.delegateResponse(groupedActionListener, (groupedListener, e) -> {\n-                    if (e instanceof ElasticsearchException) {\n-                        groupedListener.onResponse(GetSnapshotsResponse.Response.error(repoName, (ElasticsearchException) e));\n-                    } else {\n-                        groupedListener.onFailure(e);\n-                    }\n-                }), wrappedListener -> getSingleRepoSnapshotInfo(snapshotsInProgress, repoName, snapshots, ignoreUnavailable, verbose,\n-                    ActionListener.map(wrappedListener, snInfos -> GetSnapshotsResponse.Response.snapshots(repoName, snInfos)))));\n+            getSingleRepoSnapshotInfo(snapshotsInProgress, repoName, snapshots, ignoreUnavailable, verbose, ActionListener.map(", "originalCommit": "cbc7faff040ad46fadb37422df7b1f406aa191c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3OTE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56935#discussion_r427179187", "bodyText": "Moved this here since we now don't have to fork to the snapshot pool in the only caller (SnapshotsService) so it's much simpler to fork here where we actually do the IO.", "author": "original-brownbear", "createdAt": "2020-05-19T09:57:56Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/BlobStoreRepository.java", "diffHunk": "@@ -552,17 +542,23 @@ public void deleteSnapshots(Collection<SnapshotId> snapshotIds, long repositoryS\n         if (isReadOnly()) {\n             listener.onFailure(new RepositoryException(metadata.name(), \"cannot delete snapshot from a readonly repository\"));\n         } else {\n-            try {\n-                final Map<String, BlobMetadata> rootBlobs = blobContainer().listBlobs();\n-                final RepositoryData repositoryData = safeRepositoryData(repositoryStateId, rootBlobs);\n-                // Cache the indices that were found before writing out the new index-N blob so that a stuck master will never\n-                // delete an index that was created by another master node after writing this index-N blob.\n-                final Map<String, BlobContainer> foundIndices = blobStore().blobContainer(indicesPath()).children();\n-                doDeleteShardSnapshots(snapshotIds, repositoryStateId, foundIndices, rootBlobs, repositoryData,\n-                    SnapshotsService.useShardGenerations(repositoryMetaVersion), listener);\n-            } catch (Exception ex) {\n-                listener.onFailure(new RepositoryException(metadata.name(), \"failed to delete snapshots \" + snapshotIds, ex));\n-            }\n+            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {", "originalCommit": "cbc7faff040ad46fadb37422df7b1f406aa191c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}