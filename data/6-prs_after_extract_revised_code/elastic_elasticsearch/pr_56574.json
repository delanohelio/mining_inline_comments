{"pr_number": 56574, "pr_title": "Ensure watcher email action message ids are always unique", "pr_createdAt": "2020-05-12T08:31:54Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56574", "timeline": [{"oid": "91b6a9fa33568e28b20316ec979aa4901ba39bb5", "url": "https://github.com/elastic/elasticsearch/commit/91b6a9fa33568e28b20316ec979aa4901ba39bb5", "message": "Ensure watcher email action message ids are always unique\n\nIf an email action is used in a foreach loop, message ids could have\nbeen duplicated, which then get rejected by the mail server.\n\nThis commit introduces an additional static counter in the email action\nin order to ensure that every message id is unique.", "committedDate": "2020-05-12T08:29:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwOTU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56574#discussion_r424009577", "bodyText": "I know integer max is pretty large w/r/t sending emails ... but wonder if appending a random UUID would be better suited to ensure uniqueness to avoid exceeding the max ?\nWould org.elasticsearch.common.RandomBasedUUIDGenerator#getBase64UUID() be a candidate instead ?\n(I tested it looks like if you exceed max it just rolls over to negative numbers, but that is likely an implementation detail since it is not the doc)", "author": "jakelandis", "createdAt": "2020-05-12T20:21:08Z", "path": "x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/actions/email/ExecutableEmailAction.java", "diffHunk": "@@ -25,9 +25,12 @@\n import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n public class ExecutableEmailAction extends ExecutableAction<EmailAction> {\n \n+    private static final AtomicInteger counter = new AtomicInteger(0);", "originalCommit": "91b6a9fa33568e28b20316ec979aa4901ba39bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA1Mjc3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56574#discussion_r424052775", "bodyText": "I considered a random UUID overkill (slow to generate), as creation seemed more expensive to me, and the message id already contained the action id and the Wid (which is unique per watch execution), so no need for more data from my point of view.\nI also was not worried about going negative, just another change in the message id.\nRereading RFC 2822 however states that the message id looks like this\nmsg-id          =       [CFWS] \"<\" id-left \"@\" id-right \">\" [CFWS]\n\nI  think it makes sense to adhere to the RFC and at least include a left and right part and an at sign, which however can be done indepent from this PR - so the main question remains, if you consider an integer enough given the fact that there is already rather unique information in the message id with the action id and the per-execution Wid.", "author": "spinscale", "createdAt": "2020-05-12T21:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwOTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NjgxMw==", "url": "https://github.com/elastic/elasticsearch/pull/56574#discussion_r424076813", "bodyText": "so no need for more data from my point of view\n\nfair enough .. though I am not sure if I agree with the assertion that random UUIDs are too slow for this workflow.\nTo avoid sending negative numbers you may want to consider masking the result with bitwise operator like incrementAndGet() & 0xffffff similar to TimeBasedUUIDGenerator. It doesn't prevent the internal counter from going into the negative but does prevent the output from going negative and makes it clear that going negative is OK and is part of the design.", "author": "jakelandis", "createdAt": "2020-05-12T22:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwOTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNzYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/56574#discussion_r424217632", "bodyText": "I found another solution. Using AtomicLong in combination with Long.toUnsignedString() - that seems easier to read to me than using the bitweise comparison.", "author": "spinscale", "createdAt": "2020-05-13T07:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAwOTU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "552f906b28b88c10d74994c5c641021b5e827669", "chunk": "diff --git a/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/actions/email/ExecutableEmailAction.java b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/actions/email/ExecutableEmailAction.java\nindex 82165a148dd..c9a8bfca0ad 100644\n--- a/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/actions/email/ExecutableEmailAction.java\n+++ b/x-pack/plugin/watcher/src/main/java/org/elasticsearch/xpack/watcher/actions/email/ExecutableEmailAction.java\n\n@@ -25,11 +25,11 @@ import org.elasticsearch.xpack.watcher.support.Variables;\n import java.io.IOException;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n public class ExecutableEmailAction extends ExecutableAction<EmailAction> {\n \n-    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static final AtomicLong counter = new AtomicLong(0);\n \n     private final EmailService emailService;\n     private final TextTemplateEngine templateEngine;\n"}}, {"oid": "552f906b28b88c10d74994c5c641021b5e827669", "url": "https://github.com/elastic/elasticsearch/commit/552f906b28b88c10d74994c5c641021b5e827669", "message": "Ensure no negative value is produced", "committedDate": "2020-05-13T07:07:52Z", "type": "commit"}, {"oid": "083ba126da7bd48f77fe9ba4f58b9e2eb4d212a8", "url": "https://github.com/elastic/elasticsearch/commit/083ba126da7bd48f77fe9ba4f58b9e2eb4d212a8", "message": "Merge branch 'master' into 2005-watcher-ensure-unique-message-ids", "committedDate": "2020-05-14T06:56:48Z", "type": "commit"}]}