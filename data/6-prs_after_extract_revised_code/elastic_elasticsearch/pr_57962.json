{"pr_number": 57962, "pr_title": "Fix bug in circuit-breaker check for geoshape grid aggregations", "pr_createdAt": "2020-06-10T23:25:48Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/57962", "timeline": [{"oid": "3333376f969531879d9d2118d8bbc5f5044ad101", "url": "https://github.com/elastic/elasticsearch/commit/3333376f969531879d9d2118d8bbc5f5044ad101", "message": "Fix bug in circuit-breaker check for geoshape grid aggregations\n\nThere was a bug in the geoshape circuit-breaker check where the\nhash values array was being allocated before its new size was\naccounted for by the circuit breaker.\n\nFixes #57847.", "committedDate": "2020-06-10T23:20:12Z", "type": "commit"}, {"oid": "2dba17fce7c8abdd3267e67634df722ae0acd50e", "url": "https://github.com/elastic/elasticsearch/commit/2dba17fce7c8abdd3267e67634df722ae0acd50e", "message": "take into account arraycopy size", "committedDate": "2020-06-11T15:32:26Z", "type": "commit"}, {"oid": "8c5406b9670d3f823cc83ce0f67107572a493082", "url": "https://github.com/elastic/elasticsearch/commit/8c5406b9670d3f823cc83ce0f67107572a493082", "message": "Merge remote-tracking branch 'elastic/master' into fixGeoTileOOM", "committedDate": "2020-06-11T15:46:26Z", "type": "commit"}, {"oid": "6a75d6f2ccff4ac902946f414f5020e79d786fcd", "url": "https://github.com/elastic/elasticsearch/commit/6a75d6f2ccff4ac902946f414f5020e79d786fcd", "message": "Merge remote-tracking branch 'elastic/master' into fixGeoTileOOM", "committedDate": "2020-07-14T18:34:43Z", "type": "commit"}, {"oid": "bc4e372ceb575ca2a4492493123d4499685098fd", "url": "https://github.com/elastic/elasticsearch/commit/bc4e372ceb575ca2a4492493123d4499685098fd", "message": "push the breaker up to SortingNumericDocValues", "committedDate": "2020-07-14T20:20:56Z", "type": "commit"}, {"oid": "92be53bcd920064492da89a3c78a983b8063dc49", "url": "https://github.com/elastic/elasticsearch/commit/92be53bcd920064492da89a3c78a983b8063dc49", "message": "fix default consumer", "committedDate": "2020-07-15T02:35:34Z", "type": "commit"}, {"oid": "dcb9693543769d63aca080d796e8c878e3637a4b", "url": "https://github.com/elastic/elasticsearch/commit/dcb9693543769d63aca080d796e8c878e3637a4b", "message": "Merge remote-tracking branch 'elastic/master' into fixGeoTileOOM", "committedDate": "2020-07-15T02:35:38Z", "type": "commit"}, {"oid": "42105ae128883438f663033d59bbd4c6afecf764", "url": "https://github.com/elastic/elasticsearch/commit/42105ae128883438f663033d59bbd4c6afecf764", "message": "checkstyle", "committedDate": "2020-07-15T03:00:29Z", "type": "commit"}, {"oid": "40b5388f2b6313d02b9996f51adec2fca25f5546", "url": "https://github.com/elastic/elasticsearch/commit/40b5388f2b6313d02b9996f51adec2fca25f5546", "message": "Merge remote-tracking branch 'elastic/master' into fixGeoTileOOM", "committedDate": "2020-07-15T15:57:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1ODQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455258436", "bodyText": "l -> {} is good enough. But this is cool too.", "author": "nik9000", "createdAt": "2020-07-15T18:31:17Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -33,8 +35,13 @@\n     protected long[] values;\n     protected int valuesCursor;\n     private final Sorter sorter;\n+    private LongConsumer circuitBreakerConsumer;\n \n     protected SortingNumericDocValues() {\n+        this((l) -> {});", "originalCommit": "40b5388f2b6313d02b9996f51adec2fca25f5546", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\nindex 0851c3c6f96..3e541885b09 100644\n--- a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n+++ b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n\n@@ -38,7 +38,7 @@ public abstract class SortingNumericDocValues extends SortedNumericDocValues {\n     private LongConsumer circuitBreakerConsumer;\n \n     protected SortingNumericDocValues() {\n-        this((l) -> {});\n+        this(l -> {});\n     }\n \n     protected SortingNumericDocValues(LongConsumer circuitBreakerConsumer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455260215", "bodyText": "Why not increment by the new size here and then decrement by the old size when we're done?", "author": "nik9000", "createdAt": "2020-07-15T18:34:18Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {\n+            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n+            circuitBreakerConsumer.accept(bytesDiff);", "originalCommit": "40b5388f2b6313d02b9996f51adec2fca25f5546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMzg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455303890", "bodyText": "I guess I was trying to keep consistent with the old logic, but I can see how this iterative addition can also be somewhat obtuse in this new logic.", "author": "talevy", "createdAt": "2020-07-15T19:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDIxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\nindex 0851c3c6f96..3e541885b09 100644\n--- a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n+++ b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n\n@@ -68,30 +68,25 @@ public abstract class SortingNumericDocValues extends SortedNumericDocValues {\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n-        int oldValuesLength = values.length;\n-        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        if (newSize <= values.length) {\n+            return;\n+        }\n \n-        // If array is expected to grow, increment the circuit breaker\n+        // Array is expected to grow so increment the circuit breaker\n         // to include both the additional bytes used by the grown array\n         // as well as the overhead of keeping both arrays in memory while\n         // copying.\n-        if (newSize > values.length) {\n-            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n-            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n-            circuitBreakerConsumer.accept(bytesDiff);\n-            circuitBreakerConsumer.accept(oldValuesSizeInBytes);\n-        }\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+        circuitBreakerConsumer.accept(newValuesLength * Long.BYTES);\n \n         // resize\n         count = newSize;\n-        values = ArrayUtil.grow(values, count);\n+        values = ArrayUtil.growExact(values, newValuesLength);\n         valuesCursor = 0;\n \n-        // old array is released, so its overhead is no longer accounted for\n-        // in the circuit breaker.\n-        if (oldValuesLength < values.length) {\n-            circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n-        }\n+        // clean up old values array\n+        circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MDcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455260723", "bodyText": "I think it'd be clearer to bail early if the newSize <= values.length rather than relying on the behavior of ArrayUtils.grow", "author": "nik9000", "createdAt": "2020-07-15T18:35:12Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {", "originalCommit": "40b5388f2b6313d02b9996f51adec2fca25f5546", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\nindex 0851c3c6f96..3e541885b09 100644\n--- a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n+++ b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n\n@@ -68,30 +68,25 @@ public abstract class SortingNumericDocValues extends SortedNumericDocValues {\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n-        int oldValuesLength = values.length;\n-        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        if (newSize <= values.length) {\n+            return;\n+        }\n \n-        // If array is expected to grow, increment the circuit breaker\n+        // Array is expected to grow so increment the circuit breaker\n         // to include both the additional bytes used by the grown array\n         // as well as the overhead of keeping both arrays in memory while\n         // copying.\n-        if (newSize > values.length) {\n-            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n-            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n-            circuitBreakerConsumer.accept(bytesDiff);\n-            circuitBreakerConsumer.accept(oldValuesSizeInBytes);\n-        }\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+        circuitBreakerConsumer.accept(newValuesLength * Long.BYTES);\n \n         // resize\n         count = newSize;\n-        values = ArrayUtil.grow(values, count);\n+        values = ArrayUtil.growExact(values, newValuesLength);\n         valuesCursor = 0;\n \n-        // old array is released, so its overhead is no longer accounted for\n-        // in the circuit breaker.\n-        if (oldValuesLength < values.length) {\n-            circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n-        }\n+        // clean up old values array\n+        circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MTU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455261543", "bodyText": "I think it'd be clearer overside on our side and then call growExact. That way you end up with a precise value that you are growing to for tracking. And I don't have to go and read the source of grow, just oversize.", "author": "nik9000", "createdAt": "2020-07-15T18:36:37Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,40 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        int oldValuesLength = values.length;\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+\n+        // If array is expected to grow, increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        if (newSize > values.length) {\n+            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n+            circuitBreakerConsumer.accept(bytesDiff);\n+            circuitBreakerConsumer.accept(oldValuesSizeInBytes);\n+        }\n+\n+        // resize\n         count = newSize;\n         values = ArrayUtil.grow(values, count);", "originalCommit": "40b5388f2b6313d02b9996f51adec2fca25f5546", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\nindex 0851c3c6f96..3e541885b09 100644\n--- a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n+++ b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n\n@@ -68,30 +68,25 @@ public abstract class SortingNumericDocValues extends SortedNumericDocValues {\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n-        int oldValuesLength = values.length;\n-        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        if (newSize <= values.length) {\n+            return;\n+        }\n \n-        // If array is expected to grow, increment the circuit breaker\n+        // Array is expected to grow so increment the circuit breaker\n         // to include both the additional bytes used by the grown array\n         // as well as the overhead of keeping both arrays in memory while\n         // copying.\n-        if (newSize > values.length) {\n-            int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n-            long bytesDiff = (newValuesLength - oldValuesLength) * Long.BYTES;\n-            circuitBreakerConsumer.accept(bytesDiff);\n-            circuitBreakerConsumer.accept(oldValuesSizeInBytes);\n-        }\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+        circuitBreakerConsumer.accept(newValuesLength * Long.BYTES);\n \n         // resize\n         count = newSize;\n-        values = ArrayUtil.grow(values, count);\n+        values = ArrayUtil.growExact(values, newValuesLength);\n         valuesCursor = 0;\n \n-        // old array is released, so its overhead is no longer accounted for\n-        // in the circuit breaker.\n-        if (oldValuesLength < values.length) {\n-            circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n-        }\n+        // clean up old values array\n+        circuitBreakerConsumer.accept(-oldValuesSizeInBytes);\n     }\n \n     /**\n"}}, {"oid": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "url": "https://github.com/elastic/elasticsearch/commit/1d470c72d3b1934d1a8fac06ed910a025a77252d", "message": "make better tests and cleanup", "committedDate": "2020-07-15T23:06:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1ODU1MA==", "url": "https://github.com/elastic/elasticsearch/pull/57962#discussion_r455758550", "bodyText": "s/clean up/account for freeing/?", "author": "nik9000", "createdAt": "2020-07-16T12:46:48Z", "path": "server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java", "diffHunk": "@@ -51,16 +58,35 @@ protected int compare(int i, int j) {\n                 return Long.compare(values[i], values[j]);\n             }\n         };\n+        this.circuitBreakerConsumer = circuitBreakerConsumer;\n+        // account for initial values size of 1\n+        this.circuitBreakerConsumer.accept(Long.BYTES);\n     }\n \n     /**\n      * Set the {@link #docValueCount()} and ensure that the {@link #values} array can\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        if (newSize <= values.length) {\n+            return;\n+        }\n+\n+        // Array is expected to grow so increment the circuit breaker\n+        // to include both the additional bytes used by the grown array\n+        // as well as the overhead of keeping both arrays in memory while\n+        // copying.\n+        long oldValuesSizeInBytes = values.length * Long.BYTES;\n+        int newValuesLength = ArrayUtil.oversize(newSize, Long.BYTES);\n+        circuitBreakerConsumer.accept(newValuesLength * Long.BYTES);\n+\n+        // resize\n         count = newSize;\n-        values = ArrayUtil.grow(values, count);\n+        values = ArrayUtil.growExact(values, newValuesLength);\n         valuesCursor = 0;\n+\n+        // clean up old values array", "originalCommit": "1d470c72d3b1934d1a8fac06ed910a025a77252d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f0568f84ee5384bd900778c750a92253025235b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\nindex 3e541885b09..eece8eaaf7c 100644\n--- a/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n+++ b/server/src/main/java/org/elasticsearch/index/fielddata/SortingNumericDocValues.java\n\n@@ -68,6 +68,9 @@ public abstract class SortingNumericDocValues extends SortedNumericDocValues {\n      * store at least that many entries.\n      */\n     protected final void resize(int newSize) {\n+        count = newSize;\n+        valuesCursor = 0;\n+\n         if (newSize <= values.length) {\n             return;\n         }\n"}}, {"oid": "8f0568f84ee5384bd900778c750a92253025235b", "url": "https://github.com/elastic/elasticsearch/commit/8f0568f84ee5384bd900778c750a92253025235b", "message": "fix up", "committedDate": "2020-07-16T18:01:42Z", "type": "commit"}, {"oid": "04d86e1ccfcea1d061065a929fb6eec05ab62c9f", "url": "https://github.com/elastic/elasticsearch/commit/04d86e1ccfcea1d061065a929fb6eec05ab62c9f", "message": "Merge remote-tracking branch 'elastic/master' into fixGeoTileOOM", "committedDate": "2020-07-16T18:01:52Z", "type": "commit"}, {"oid": "b1967f6f11b1c4fd462de88474927f25ff173da9", "url": "https://github.com/elastic/elasticsearch/commit/b1967f6f11b1c4fd462de88474927f25ff173da9", "message": "fix yaml tests", "committedDate": "2020-07-16T18:53:11Z", "type": "commit"}]}