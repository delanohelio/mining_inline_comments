{"pr_number": 53504, "pr_title": "Fix Term Vectors with artificial docs and keyword fields", "pr_createdAt": "2020-03-12T17:59:44Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53504", "timeline": [{"oid": "fb058c6dd8c6c73d7a4bb67905d8405f675d6aeb", "url": "https://github.com/elastic/elasticsearch/commit/fb058c6dd8c6c73d7a4bb67905d8405f675d6aeb", "message": "Fix Term Vectors with artificial docs and keyword fields\n\nPreviously, Term Vectors API was returning empty results for\nartificial documents with keyword fields. Checking only for `string()`\non `IndexableField` is not enough, since for `KeywordFieldType`\n`binaryValue()` must be used instead.\n\nFixes #53494", "committedDate": "2020-03-12T17:54:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MDQ4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53504#discussion_r391870485", "bodyText": "We cannot use the binary value without checking the type of the field. It could be a real binary field that doesn't store utf8 bytes. Since this function is only used in the terms vector service, can you move it there and adds a check to extract binary values only if the field is of type keyword ?", "author": "jimczi", "createdAt": "2020-03-12T20:15:06Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java", "diffHunk": "@@ -131,8 +131,12 @@ public IndexableField getByKey(Object key) {\n         public final String[] getValues(String name) {\n             List<String> result = new ArrayList<>();\n             for (IndexableField field : fields) {\n-                if (field.name().equals(name) && field.stringValue() != null) {\n-                    result.add(field.stringValue());\n+                if (field.name().equals(name)) {\n+                    if (field.stringValue() != null) {\n+                        result.add(field.stringValue());\n+                    } else if (field.binaryValue() != null) { // KeywordFieldType", "originalCommit": "fb058c6dd8c6c73d7a4bb67905d8405f675d6aeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5OTQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/53504#discussion_r391899465", "bodyText": "The method is called as you said only by TermVectorService and it's guarded by isValidField:\nhttps://github.com/elastic/elasticsearch/blob/master/server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java#L304 but I agree, it makes sense to move the method close to this so it's visible.", "author": "matriv", "createdAt": "2020-03-12T21:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MDQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7fd234c03ef48167b7e45914f4e72de8c95631ce", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java b/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java\nindex c6418d75f50..d675735834f 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/ParseContext.java\n\n@@ -120,28 +120,6 @@ public abstract class ParseContext implements Iterable<ParseContext.Document>{\n             return f.toArray(new IndexableField[f.size()]);\n         }\n \n-        /**\n-         * Returns an array of values of the field specified as the method parameter.\n-         * This method returns an empty array when there are no\n-         * matching fields.  It never returns null.\n-         * If you want the actual numeric field instances back, use {@link #getFields}.\n-         * @param name the name of the field\n-         * @return a <code>String[]</code> of field values\n-         */\n-        public final String[] getValues(String name) {\n-            List<String> result = new ArrayList<>();\n-            for (IndexableField field : fields) {\n-                if (field.name().equals(name)) {\n-                    if (field.stringValue() != null) {\n-                        result.add(field.stringValue());\n-                    } else if (field.binaryValue() != null) { // KeywordFieldType\n-                        result.add(field.binaryValue().utf8ToString());\n-                    }\n-                }\n-            }\n-            return result.toArray(new String[result.size()]);\n-        }\n-\n         public IndexableField getField(String name) {\n             for (IndexableField field : fields) {\n                 if (field.name().equals(name)) {\n"}}, {"oid": "5c6b6ec2e89322ac7436f028c7714b8c4cfc22b7", "url": "https://github.com/elastic/elasticsearch/commit/5c6b6ec2e89322ac7436f028c7714b8c4cfc22b7", "message": "Merge remote-tracking branch 'upstream/master' into fix-53494", "committedDate": "2020-03-12T22:26:29Z", "type": "commit"}, {"oid": "7fd234c03ef48167b7e45914f4e72de8c95631ce", "url": "https://github.com/elastic/elasticsearch/commit/7fd234c03ef48167b7e45914f4e72de8c95631ce", "message": "move getValues to TermVectorsService", "committedDate": "2020-03-12T22:53:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE1NjIzOA==", "url": "https://github.com/elastic/elasticsearch/pull/53504#discussion_r392156238", "bodyText": "I think that this will create duplicates due to doc values field that also use a binary value (SortedSetDocValuesField). You should change this to something like:\nif (field.fieldType() instanceof KeywordFieldMapper.KeywordFieldType) {\n  result.add(field.binaryValue().utf8ToString());\n} else if (field.fieldType() instanceof StringFieldType) {\n  result.add(field.stringValue());\n}", "author": "jimczi", "createdAt": "2020-03-13T10:51:29Z", "path": "server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java", "diffHunk": "@@ -313,14 +314,33 @@ private static Fields generateTermVectorsFromDoc(IndexShard indexShard, TermVect\n             else {\n                 seenFields.add(field.name());\n             }\n-            String[] values = doc.getValues(field.name());\n+            String[] values = getValues(doc.getFields(field.name()));\n             documentFields.add(new DocumentField(field.name(), Arrays.asList((Object[]) values)));\n         }\n         return generateTermVectors(indexShard,\n             XContentHelper.convertToMap(parsedDocument.source(), true, request.xContentType()).v2(), documentFields,\n                 request.offsets(), request.perFieldAnalyzer(), seenFields);\n     }\n \n+    /**\n+     * Returns an array of values of the field specified as the method parameter.\n+     * This method returns an empty array when there are no\n+     * matching fields.  It never returns null.\n+     * @param fields The <code>IndexableField</code> to get the values from\n+     * @return a <code>String[]</code> of field values\n+     */\n+    public static String[] getValues(IndexableField[] fields) {\n+        List<String> result = new ArrayList<>();\n+        for (IndexableField field : fields) {\n+            if (field.stringValue() != null) {\n+                result.add(field.stringValue());\n+            } else if (field.binaryValue() != null) { // KeywordFieldType", "originalCommit": "7fd234c03ef48167b7e45914f4e72de8c95631ce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea1a4ef0bebe1c55b2681d55951452e120d33d34", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java b/server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java\nindex a971b12336e..3326b435405 100644\n--- a/server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java\n+++ b/server/src/main/java/org/elasticsearch/index/termvectors/TermVectorsService.java\n\n@@ -332,10 +332,10 @@ public class TermVectorsService  {\n     public static String[] getValues(IndexableField[] fields) {\n         List<String> result = new ArrayList<>();\n         for (IndexableField field : fields) {\n-            if (field.stringValue() != null) {\n-                result.add(field.stringValue());\n-            } else if (field.binaryValue() != null) { // KeywordFieldType\n+            if (field.fieldType() instanceof KeywordFieldMapper.KeywordFieldType) {\n                 result.add(field.binaryValue().utf8ToString());\n+            } else if (field.fieldType() instanceof StringFieldType) {\n+                result.add(field.stringValue());\n             }\n         }\n         return result.toArray(new String[0]);\n"}}, {"oid": "ea1a4ef0bebe1c55b2681d55951452e120d33d34", "url": "https://github.com/elastic/elasticsearch/commit/ea1a4ef0bebe1c55b2681d55951452e120d33d34", "message": "address comments", "committedDate": "2020-03-13T12:56:42Z", "type": "commit"}, {"oid": "ea87219370f56020e5ded04b321c0127ae9e884c", "url": "https://github.com/elastic/elasticsearch/commit/ea87219370f56020e5ded04b321c0127ae9e884c", "message": "Merge remote-tracking branch 'upstream/master' into fix-53494", "committedDate": "2020-03-13T12:56:51Z", "type": "commit"}, {"oid": "ffd1ac91d2eabcbce680cce9799cf31d5fb684a7", "url": "https://github.com/elastic/elasticsearch/commit/ffd1ac91d2eabcbce680cce9799cf31d5fb684a7", "message": "Merge remote-tracking branch 'upstream/master' into fix-53494", "committedDate": "2020-03-13T13:41:48Z", "type": "commit"}, {"oid": "f1b69af926c54af7f5d30fb4d76a7c2014055d35", "url": "https://github.com/elastic/elasticsearch/commit/f1b69af926c54af7f5d30fb4d76a7c2014055d35", "message": "add import", "committedDate": "2020-03-13T13:47:02Z", "type": "commit"}, {"oid": "38d1eeb49ab540a1f0808df734385d94b9a84b58", "url": "https://github.com/elastic/elasticsearch/commit/38d1eeb49ab540a1f0808df734385d94b9a84b58", "message": "fix test", "committedDate": "2020-03-13T14:16:20Z", "type": "commit"}]}