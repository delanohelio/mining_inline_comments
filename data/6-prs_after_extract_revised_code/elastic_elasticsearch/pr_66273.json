{"pr_number": 66273, "pr_title": "[Transform] Handle multi-fields properly when creating destination index.", "pr_createdAt": "2020-12-14T17:15:44Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/66273", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543076831", "bodyText": "Tests show this doesn't work when there are object fields mixed with multi-fields.\nI need to rethink this solution.", "author": "przemekwitek", "createdAt": "2020-12-15T06:20:59Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +134,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");\n+            Map<String, Object> current = fieldMappings;\n+            current = diveInto(current, parts[0]);\n+            for (int j = 1; j < parts.length; ++j) {\n+                current = diveInto(current, \"fields\");", "originalCommit": "e2e38ed7c7fd49a62ac3efa1a88b44186827fa52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2NTIyNg==", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543365226", "bodyText": "Ok, I've fixed it.\nStill, I have the impression that there should be an easier way of reconciling individual mappings into the new index creation request. But that's what I have for now.", "author": "przemekwitek", "createdAt": "2020-12-15T14:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjgzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5dca6cd23e4af96f23cc246ed49b64bf04030e01", "chunk": "diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\nindex 6658c222c67..2fbab240cb9 100644\n--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\n+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\n\n@@ -135,27 +149,27 @@ public final class TransformIndex {\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n     static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+        List<Map.Entry<String, String>> sortedMappingsEntries = new ArrayList<>(mappings.entrySet());\n+        // We sort the entry list to make sure that for each (parent, parent.child) pair, parent entry will be processed before child entry.\n+        sortedMappingsEntries.sort(comparingByKey());\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n+        for (Map.Entry<String, String> entry : sortedMappingsEntries) {\n             String[] parts = entry.getKey().split(\"\\\\.\");\n+            String type = entry.getValue();\n             Map<String, Object> current = fieldMappings;\n             current = diveInto(current, parts[0]);\n             for (int j = 1; j < parts.length; ++j) {\n-                current = diveInto(current, \"fields\");\n+                // Here we decide whether a dot ('.') means inner object or a multi-field.\n+                current = diveInto(current, OBJECT_TYPES.contains(current.get(\"type\")) ? PROPERTIES : FIELDS);\n                 current = diveInto(current, parts[j]);\n             }\n-            current.put(\"type\", entry.getValue());\n+            current.put(\"type\", type);\n         }\n         return fieldMappings;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> diveInto(Map<String, Object> map, String key) {\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, Object> childMap = (Map<String, Object>) map.get(key);\n-        if (childMap == null) {\n-            childMap = new HashMap<>();\n-            map.put(key, childMap);\n-        }\n-        return childMap;\n+        return (Map<String, Object>) map.computeIfAbsent(key, k -> new HashMap<>());\n     }\n }\n"}}, {"oid": "5dca6cd23e4af96f23cc246ed49b64bf04030e01", "url": "https://github.com/elastic/elasticsearch/commit/5dca6cd23e4af96f23cc246ed49b64bf04030e01", "message": "Fix failing unit test\nSimplify \"diveInto\" method by using \"computeIfAbsent\"", "committedDate": "2020-12-15T13:09:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODYwMA==", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r543498600", "bodyText": "nit: I am not a big fan of using regex if there is no reason. Arguably its java's fault. A potential alternative: the tokenize methods in org.elasticsearch.common.Strings", "author": "hendrikmuhs", "createdAt": "2020-12-15T16:33:58Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java", "diffHunk": "@@ -134,10 +148,28 @@ private static Settings createSettings() {\n      * }\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n-    private static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+    static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n+        List<Map.Entry<String, String>> sortedMappingsEntries = new ArrayList<>(mappings.entrySet());\n+        // We sort the entry list to make sure that for each (parent, parent.child) pair, parent entry will be processed before child entry.\n+        sortedMappingsEntries.sort(comparingByKey());\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        mappings.forEach((k, v) -> fieldMappings.put(k, Map.of(\"type\", v)));\n-\n+        for (Map.Entry<String, String> entry : sortedMappingsEntries) {\n+            String[] parts = entry.getKey().split(\"\\\\.\");", "originalCommit": "5dca6cd23e4af96f23cc246ed49b64bf04030e01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMTI4NA==", "url": "https://github.com/elastic/elasticsearch/pull/66273#discussion_r544031284", "bodyText": "Arguably its java's fault.\n\nUnfortunately I couldn't find a non-regex version of split() method.\n\nA potential alternative: the tokenize methods in org.elasticsearch.common.Strings\n\nThanks! I've used Strings.tokenizeToStringArray method.", "author": "przemekwitek", "createdAt": "2020-12-16T06:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "3384109121aa0a6ece9339c66f5fd51c29ac2840", "chunk": "diff --git a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\nindex 2fbab240cb9..6658c222c67 100644\n--- a/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\n+++ b/x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/persistence/TransformIndex.java\n\n@@ -149,27 +135,27 @@ public final class TransformIndex {\n      * @param mappings A Map of the form {\"fieldName\": \"fieldType\"}\n      */\n     static Map<String, Object> createMappingsFromStringMap(Map<String, String> mappings) {\n-        List<Map.Entry<String, String>> sortedMappingsEntries = new ArrayList<>(mappings.entrySet());\n-        // We sort the entry list to make sure that for each (parent, parent.child) pair, parent entry will be processed before child entry.\n-        sortedMappingsEntries.sort(comparingByKey());\n         Map<String, Object> fieldMappings = new HashMap<>();\n-        for (Map.Entry<String, String> entry : sortedMappingsEntries) {\n+        for (Map.Entry<String, String> entry : mappings.entrySet()) {\n             String[] parts = entry.getKey().split(\"\\\\.\");\n-            String type = entry.getValue();\n             Map<String, Object> current = fieldMappings;\n             current = diveInto(current, parts[0]);\n             for (int j = 1; j < parts.length; ++j) {\n-                // Here we decide whether a dot ('.') means inner object or a multi-field.\n-                current = diveInto(current, OBJECT_TYPES.contains(current.get(\"type\")) ? PROPERTIES : FIELDS);\n+                current = diveInto(current, \"fields\");\n                 current = diveInto(current, parts[j]);\n             }\n-            current.put(\"type\", type);\n+            current.put(\"type\", entry.getValue());\n         }\n         return fieldMappings;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> diveInto(Map<String, Object> map, String key) {\n-        return (Map<String, Object>) map.computeIfAbsent(key, k -> new HashMap<>());\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> childMap = (Map<String, Object>) map.get(key);\n+        if (childMap == null) {\n+            childMap = new HashMap<>();\n+            map.put(key, childMap);\n+        }\n+        return childMap;\n     }\n }\n"}}, {"oid": "3384109121aa0a6ece9339c66f5fd51c29ac2840", "url": "https://github.com/elastic/elasticsearch/commit/3384109121aa0a6ece9339c66f5fd51c29ac2840", "message": "Handle multi-fields properly when creating destination index.", "committedDate": "2020-12-16T06:40:13Z", "type": "commit"}, {"oid": "b67ac9f422c62c7367f470046a02169c7f5a7ecf", "url": "https://github.com/elastic/elasticsearch/commit/b67ac9f422c62c7367f470046a02169c7f5a7ecf", "message": "Handle \"object\" and \"nested\" mappings when constructing transform's destination index mappings", "committedDate": "2020-12-16T06:40:13Z", "type": "commit"}, {"oid": "f138d23073160694deb0a98c43b19c0d1cd4891d", "url": "https://github.com/elastic/elasticsearch/commit/f138d23073160694deb0a98c43b19c0d1cd4891d", "message": "Emit explicit { \"type\": \"object\" } entries and fix test", "committedDate": "2020-12-16T06:40:13Z", "type": "commit"}, {"oid": "62495ba1bcfbf22341e0d380fe1289dc3883a710", "url": "https://github.com/elastic/elasticsearch/commit/62495ba1bcfbf22341e0d380fe1289dc3883a710", "message": "Fix failing unit test\nSimplify \"diveInto\" method by using \"computeIfAbsent\"", "committedDate": "2020-12-16T06:40:13Z", "type": "commit"}, {"oid": "141e1fbf493344cb2e165cea446213bf1aadedb7", "url": "https://github.com/elastic/elasticsearch/commit/141e1fbf493344cb2e165cea446213bf1aadedb7", "message": "Apply review comment", "committedDate": "2020-12-16T06:40:13Z", "type": "commit"}, {"oid": "141e1fbf493344cb2e165cea446213bf1aadedb7", "url": "https://github.com/elastic/elasticsearch/commit/141e1fbf493344cb2e165cea446213bf1aadedb7", "message": "Apply review comment", "committedDate": "2020-12-16T06:40:13Z", "type": "forcePushed"}]}