{"pr_number": 50703, "pr_title": "SQL: Optimisation fixes for conjunction merges", "pr_createdAt": "2020-01-07T14:14:37Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50703", "timeline": [{"oid": "f8a73cd8b52838cac727aa4ff78812b51ed3f647", "url": "https://github.com/elastic/elasticsearch/commit/f8a73cd8b52838cac727aa4ff78812b51ed3f647", "message": "SQL: Optimisation fixes for conjunction merges\n\nThis commit fixes the following issues around the way comparisions are\nmerged with ranges in conjunctions:\n* the decision to include the equality of the lower limit is corrected;\n* the selection of the upper limit is corrected to use the upper bound\nof the range;\n* the list of terms in the conjunction is sorted to have the ranges at\nthe bottom; this allows subsequent binary comarisions to find compatible\nranges and potentially be merged away. The end guarantee being that the\noptimisation takes place irrespective of the order of the conjunction\nterms in the statement.\n\nSome comments are also corrected.", "committedDate": "2020-01-07T13:41:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwODE3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/50703#discussion_r363808176", "bodyText": "That's a big miss - were there no tests for this?", "author": "costin", "createdAt": "2020-01-07T15:38:37Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1316,7 +1331,7 @@ private boolean findConjunctiveComparisonInRange(BinaryComparison main, List<Ran\n                                     ranges.remove(i);\n                                     ranges.add(i,\n                                             new Range(other.source(), other.value(),\n-                                                    main.right(), lowerEq ? true : other.includeLower(),\n+                                                    main.right(), lowerEq ? false : main instanceof GreaterThanOrEqual,", "originalCommit": "f8a73cd8b52838cac727aa4ff78812b51ed3f647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDEyNjY5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50703#discussion_r364126699", "bodyText": "It seemed much like a c&p fallout.\nThere wasn't a test, no, so I've simply implemented the test listed as comment in the source (2 < a AND (2 <= a < 3) -> 2 < a < 3 / testCombineBinaryComparisonsAndRangeLower())", "author": "bpintea", "createdAt": "2020-01-08T09:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwODE3Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwODM3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/50703#discussion_r363808379", "bodyText": "Likewise - a whole optimization being skipped...", "author": "costin", "createdAt": "2020-01-07T15:39:01Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1325,19 +1340,19 @@ private boolean findConjunctiveComparisonInRange(BinaryComparison main, List<Ran\n                             }\n                         }\n                     } else if (main instanceof LessThan || main instanceof LessThanOrEqual) {\n-                        if (other.lower().foldable()) {\n-                            Integer comp = BinaryComparison.compare(value, other.lower().fold());\n+                        if (other.upper().foldable()) {", "originalCommit": "f8a73cd8b52838cac727aa4ff78812b51ed3f647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIzMzM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/50703#discussion_r364233375", "bodyText": "Maybe extract this custom Comparator into its own variable inside CombineBinaryComparisons and re-use that, without creating it each time the combine method is called?", "author": "astefan", "createdAt": "2020-01-08T13:36:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1090,7 +1091,21 @@ private Expression combine(And and) {\n \n             boolean changed = false;\n \n-            for (Expression ex : Predicates.splitAnd(and)) {\n+            List<Expression> andExps = Predicates.splitAnd(and);\n+            // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n+            andExps.sort(new Comparator<Expression>() {", "originalCommit": "f8a73cd8b52838cac727aa4ff78812b51ed3f647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDI2ODU4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50703#discussion_r364268583", "bodyText": "Good point, thanks.\nI've however replaced with a (non-capturing) lambda, which should then be optimised by the jvm.", "author": "bpintea", "createdAt": "2020-01-08T14:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDIzMzM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9587bfe8d6d65af9b4768a7cfb05104d8402325a", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex ab1b533faba..ce23010c8bd 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1093,16 +1092,13 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n \n             List<Expression> andExps = Predicates.splitAnd(and);\n             // Ranges need to show up before BinaryComparisons in list, to allow the latter be optimized away into a Range, if possible\n-            andExps.sort(new Comparator<Expression>() {\n-                @Override\n-                public int compare(Expression o1, Expression o2) {\n-                    if (o1 instanceof Range && o2 instanceof Range) {\n-                        return 0; // keep ranges' order\n-                    } else if (o1 instanceof Range || o2 instanceof Range) {\n-                        return o2 instanceof Range ? 1 : -1;\n-                    } else {\n-                        return 0; // keep non-ranges' order\n-                    }\n+            andExps.sort((o1, o2) -> {\n+                if (o1 instanceof Range && o2 instanceof Range) {\n+                    return 0; // keep ranges' order\n+                } else if (o1 instanceof Range || o2 instanceof Range) {\n+                    return o2 instanceof Range ? 1 : -1;\n+                } else {\n+                    return 0; // keep non-ranges' order\n                 }\n             });\n             for (Expression ex : andExps) {\n"}}, {"oid": "9587bfe8d6d65af9b4768a7cfb05104d8402325a", "url": "https://github.com/elastic/elasticsearch/commit/9587bfe8d6d65af9b4768a7cfb05104d8402325a", "message": "adress review observation on anon. comparator\n\nReplace anonymous comparator of split AND Expressions with a lambda.", "committedDate": "2020-01-08T14:42:21Z", "type": "commit"}]}