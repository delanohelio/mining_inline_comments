{"pr_number": 52743, "pr_title": "Delegate toXContent logic from ClusterState to its member classes #48218", "pr_createdAt": "2020-02-25T07:17:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52743", "timeline": [{"oid": "422dadb0d2ebe5f23eaefe73476bbec41e6053f7", "url": "https://github.com/elastic/elasticsearch/commit/422dadb0d2ebe5f23eaefe73476bbec41e6053f7", "message": "Add serialization tests for ClusterState and MetaData toXContent methods", "committedDate": "2020-02-19T17:54:41Z", "type": "commit"}, {"oid": "072e05d370f464ec8582d55c7c26bb8199b58735", "url": "https://github.com/elastic/elasticsearch/commit/072e05d370f464ec8582d55c7c26bb8199b58735", "message": "Copy over ClusterState.toXContent serialization test metadata section to MetaData.toXContent serialization test", "committedDate": "2020-02-19T18:32:42Z", "type": "commit"}, {"oid": "734d5a744b709ccf00d3205b421855f6adbc1ada", "url": "https://github.com/elastic/elasticsearch/commit/734d5a744b709ccf00d3205b421855f6adbc1ada", "message": "Parameterize classes to emit different serialization based on API vs. Gateway context.\n\nNote that as the updates to existing serialization test cases show, there are inconsistencies of serializations under API context.\nWe can pick and choose which serializaton scheme we actually want, and which one should no longer be supported under API context.", "committedDate": "2020-02-25T06:02:38Z", "type": "commit"}, {"oid": "b021eac9a37e425602e9067cd19a08b17377b3c7", "url": "https://github.com/elastic/elasticsearch/commit/b021eac9a37e425602e9067cd19a08b17377b3c7", "message": "Substitue ClusterState.toXContent metadata serialization logic with MetaData.toXContent", "committedDate": "2020-02-25T06:51:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NDg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r386844841", "bodyText": "can you add this as a static field to this class and call it API_PARAMS?", "author": "ywelsch", "createdAt": "2020-03-03T07:46:37Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterState.java", "diffHunk": "@@ -418,104 +414,15 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n \n-        // meta data\n-        if (metrics.contains(Metric.METADATA)) {\n-            builder.startObject(\"metadata\");\n-            builder.field(\"cluster_uuid\", metaData().clusterUUID());\n-\n-            builder.startObject(\"cluster_coordination\");\n-            coordinationMetaData().toXContent(builder, params);\n-            builder.endObject();\n-\n-            builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData().templates().values()) {\n-                IndexTemplateMetaData templateMetaData = cursor.value;\n-                builder.startObject(templateMetaData.name());\n-\n-                builder.field(\"index_patterns\", templateMetaData.patterns());\n-                builder.field(\"order\", templateMetaData.order());\n-\n-                builder.startObject(\"settings\");\n-                Settings settings = templateMetaData.settings();\n-                settings.toXContent(builder, params);\n-                builder.endObject();\n-\n-                builder.startObject(\"mappings\");\n-                for (ObjectObjectCursor<String, CompressedXContent> cursor1 : templateMetaData.mappings()) {\n-                    Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(cursor1.value.uncompressed()), false).v2();\n-                    if (mapping.size() == 1 && mapping.containsKey(cursor1.key)) {\n-                        // the type name is the root value, reduce it\n-                        mapping = (Map<String, Object>) mapping.get(cursor1.key);\n-                    }\n-                    builder.field(cursor1.key);\n-                    builder.map(mapping);\n-                }\n-                builder.endObject();\n \n+        Map<String, String> mapParams = new HashMap<>();", "originalCommit": "b021eac9a37e425602e9067cd19a08b17377b3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5MjI2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r387492269", "bodyText": "Sure will do.", "author": "zacharymorn", "createdAt": "2020-03-04T07:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NDg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxMjIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r395412216", "bodyText": "Done.", "author": "zacharymorn", "createdAt": "2020-03-20T02:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NDg0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\nindex 8810c385697..421805634de 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n\n@@ -415,14 +421,12 @@ public class ClusterState implements ToXContentFragment, Diffable<ClusterState>\n         }\n \n \n-        Map<String, String> mapParams = new HashMap<>();\n-        mapParams.put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_API);\n-        mapParams.put(\"flat_settings\", params.param(\"flat_settings\"));\n-        mapParams.put(\"reduce_mappings\", params.param(\"reduce_mappings\"));\n+        API_PARAMS.put(\"flat_settings\", params.param(\"flat_settings\"));\n+        API_PARAMS.put(\"reduce_mappings\", params.param(\"reduce_mappings\"));\n \n         // meta data\n         if (metrics.contains(Metric.METADATA)) {\n-            metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+            metaData.toXContent(builder, new ToXContent.MapParams(API_PARAMS));\n         }\n \n         // routing table\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTY2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r386845664", "bodyText": "should we just pass on params instead of just extracting flat_settings?", "author": "ywelsch", "createdAt": "2020-03-03T07:48:51Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java", "diffHunk": "@@ -1186,48 +1187,89 @@ public IndexMetaData build() {\n         }\n \n         public static void toXContent(IndexMetaData indexMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n+            MetaData.XContentContext context = MetaData.XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));\n+\n             builder.startObject(indexMetaData.getIndex().getName());\n \n             builder.field(KEY_VERSION, indexMetaData.getVersion());\n             builder.field(KEY_MAPPING_VERSION, indexMetaData.getMappingVersion());\n             builder.field(KEY_SETTINGS_VERSION, indexMetaData.getSettingsVersion());\n             builder.field(KEY_ALIASES_VERSION, indexMetaData.getAliasesVersion());\n             builder.field(KEY_ROUTING_NUM_SHARDS, indexMetaData.getRoutingNumShards());\n+\n             builder.field(KEY_STATE, indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH));\n \n             boolean binary = params.paramAsBoolean(\"binary\", false);\n \n             builder.startObject(KEY_SETTINGS);\n-            indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+            if (context != MetaData.XContentContext.API) {\n+                indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+            }\n+            else {\n+                indexMetaData.getSettings()\n+                    .toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", params.param(\"flat_settings\"))));", "originalCommit": "b021eac9a37e425602e9067cd19a08b17377b3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5MjMyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r387492324", "bodyText": "As before the rest of params was not passed along to IndexMetaData.toXContent, I suspect this may change the serialization and thus introduce a breaking change. I can try and submit another commit with that to see what happen?", "author": "zacharymorn", "createdAt": "2020-03-04T07:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxMjIyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r395412229", "bodyText": "Actually the original ClusterState#toXContent uses the whole params \n  \n    \n      elasticsearch/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n    \n    \n         Line 444\n      in\n      2e617c3\n    \n    \n    \n    \n\n        \n          \n           settings.toXContent(builder, params); \n        \n    \n  \n\n. I've updated it.", "author": "zacharymorn", "createdAt": "2020-03-20T02:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\nindex a91e4b6d507..80e84c3a4f3 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n\n@@ -1204,10 +1204,8 @@ public class IndexMetaData implements Diffable<IndexMetaData>, ToXContentFragmen\n             builder.startObject(KEY_SETTINGS);\n             if (context != MetaData.XContentContext.API) {\n                 indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n-            }\n-            else {\n-                indexMetaData.getSettings()\n-                    .toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", params.param(\"flat_settings\"))));\n+            } else {\n+                indexMetaData.getSettings().toXContent(builder, params);\n             }\n             builder.endObject();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTg5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r386845899", "bodyText": "please put the else on the same line as closing bracket (same for other occurrences in this PR)", "author": "ywelsch", "createdAt": "2020-03-03T07:49:29Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java", "diffHunk": "@@ -1186,48 +1187,89 @@ public IndexMetaData build() {\n         }\n \n         public static void toXContent(IndexMetaData indexMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n+            MetaData.XContentContext context = MetaData.XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));\n+\n             builder.startObject(indexMetaData.getIndex().getName());\n \n             builder.field(KEY_VERSION, indexMetaData.getVersion());\n             builder.field(KEY_MAPPING_VERSION, indexMetaData.getMappingVersion());\n             builder.field(KEY_SETTINGS_VERSION, indexMetaData.getSettingsVersion());\n             builder.field(KEY_ALIASES_VERSION, indexMetaData.getAliasesVersion());\n             builder.field(KEY_ROUTING_NUM_SHARDS, indexMetaData.getRoutingNumShards());\n+\n             builder.field(KEY_STATE, indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH));\n \n             boolean binary = params.paramAsBoolean(\"binary\", false);\n \n             builder.startObject(KEY_SETTINGS);\n-            indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+            if (context != MetaData.XContentContext.API) {\n+                indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n+            }\n+            else {", "originalCommit": "b021eac9a37e425602e9067cd19a08b17377b3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5MjI5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r387492295", "bodyText": "Sure will do. If this is style requirement I can add a rule to checkstyle as well?", "author": "zacharymorn", "createdAt": "2020-03-04T07:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxMjIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r395412234", "bodyText": "I've put the else on the same line for now without adding checkstyle rule.", "author": "zacharymorn", "createdAt": "2020-03-20T02:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0NTg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\nindex a91e4b6d507..80e84c3a4f3 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n\n@@ -1204,10 +1204,8 @@ public class IndexMetaData implements Diffable<IndexMetaData>, ToXContentFragmen\n             builder.startObject(KEY_SETTINGS);\n             if (context != MetaData.XContentContext.API) {\n                 indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", \"true\")));\n-            }\n-            else {\n-                indexMetaData.getSettings()\n-                    .toXContent(builder, new MapParams(Collections.singletonMap(\"flat_settings\", params.param(\"flat_settings\"))));\n+            } else {\n+                indexMetaData.getSettings().toXContent(builder, params);\n             }\n             builder.endObject();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MDYxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r386850613", "bodyText": "I think we should remove that static method (MetaData.Builder.toXContent) which seems to be only used by this test.\nInstead, we should test both API and non-API serialization in this class, and non-API deserialization.", "author": "ywelsch", "createdAt": "2020-03-03T08:01:54Z", "path": "server/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java", "diffHunk": "@@ -246,13 +245,19 @@ public void testSimpleJsonFromAndTo() throws IOException {\n         assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n         assertThat(indexMetaData.getAliases().size(), equalTo(3));\n         assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").filter().string(), equalTo(ALIAS_FILTER1));\n+        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization", "originalCommit": "b021eac9a37e425602e9067cd19a08b17377b3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxMjI0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r395412242", "bodyText": "I've moved the new serialization tests from MetaDataTests to ToAndFromJsonMetaDataTests.\nI've inlined / removed 1 MetaData.Builder#toXContent which is only used by test. There's another one though that takes more parameters and used in production code, so I left that one alone.", "author": "zacharymorn", "createdAt": "2020-03-20T02:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MDYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "0c11613501e979d9202a1f6fa7dda3aca4b69b72", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java b/server/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java\nindex 5d2cbf8af7a..155d2ff316f 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/metadata/ToAndFromJsonMetaDataTests.java\n\n@@ -137,169 +152,506 @@ public class ToAndFromJsonMetaDataTests extends ESTestCase {\n                         .putAlias(newAliasMetaDataBuilder(\"alias-bar3\").routing(\"routing-bar\")))\n                 .build();\n \n-        String metaDataSource = MetaData.Builder.toXContent(metaData);\n-\n-        MetaData parsedMetaData = MetaData.Builder.fromXContent(createParser(JsonXContent.jsonXContent, metaDataSource), false);\n-\n-        IndexMetaData indexMetaData = parsedMetaData.index(\"test1\");\n-        assertThat(indexMetaData.primaryTerm(0), equalTo(1L));\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(3));\n-        assertNull(indexMetaData.mapping());\n-\n-        indexMetaData = parsedMetaData.index(\"test2\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(2));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(3));\n-        assertThat(indexMetaData.primaryTerm(0), equalTo(2L));\n-        assertThat(indexMetaData.primaryTerm(1), equalTo(2L));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(5));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertNull(indexMetaData.mapping());\n-\n-        indexMetaData = parsedMetaData.index(\"test3\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(3));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-\n-        indexMetaData = parsedMetaData.index(\"test4\");\n-        assertThat(indexMetaData.getCreationDate(), equalTo(2L));\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(4));\n-        assertNull(indexMetaData.mapping());\n-\n-        indexMetaData = parsedMetaData.index(\"test5\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(5));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE2));\n-\n-        indexMetaData = parsedMetaData.index(\"test6\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(2L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(6));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertNull(indexMetaData.mapping());\n-\n-        indexMetaData = parsedMetaData.index(\"test7\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(2L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(4));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE2));\n-\n-        indexMetaData = parsedMetaData.index(\"test8\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(5));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-        assertThat(indexMetaData.getAliases().size(), equalTo(2));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        assertThat(indexMetaData.getAliases().get(\"alias2\").alias(), equalTo(\"alias2\"));\n-\n-        indexMetaData = parsedMetaData.index(\"test9\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(2L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(6));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-        assertThat(indexMetaData.getAliases().size(), equalTo(2));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        assertThat(indexMetaData.getAliases().get(\"alias2\").alias(), equalTo(\"alias2\"));\n-\n-        indexMetaData = parsedMetaData.index(\"test10\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(5));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-        assertThat(indexMetaData.getAliases().size(), equalTo(2));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        assertThat(indexMetaData.getAliases().get(\"alias2\").alias(), equalTo(\"alias2\"));\n-\n-        indexMetaData = parsedMetaData.index(\"test11\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(-1L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(5));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-        assertThat(indexMetaData.getAliases().size(), equalTo(3));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias1\").filter().string(), equalTo(ALIAS_FILTER1));\n-        assertThat(indexMetaData.getAliases().get(\"alias2\").alias(), equalTo(\"alias2\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter & writeIndex emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias2\").filter(), nullValue());\n-        // assertThat(indexMetaData.getAliases().get(\"alias2\").writeIndex(),\n-            // equalTo(metaData.index(\"test11\").getAliases().get(\"alias2\").writeIndex()));\n-        assertThat(indexMetaData.getAliases().get(\"alias4\").alias(), equalTo(\"alias4\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias4\").filter().string(), equalTo(ALIAS_FILTER2));\n-\n-        indexMetaData = parsedMetaData.index(\"test12\");\n-        assertThat(indexMetaData.getNumberOfShards(), equalTo(1));\n-        assertThat(indexMetaData.getNumberOfReplicas(), equalTo(2));\n-        assertThat(indexMetaData.getCreationDate(), equalTo(2L));\n-        assertThat(indexMetaData.getSettings().size(), equalTo(6));\n-        assertThat(indexMetaData.getSettings().get(\"setting1\"), equalTo(\"value1\"));\n-        assertThat(indexMetaData.getSettings().get(\"setting2\"), equalTo(\"value2\"));\n-        assertThat(indexMetaData.mapping().source().string(), equalTo(MAPPING_SOURCE1));\n-        assertThat(indexMetaData.getAliases().size(), equalTo(3));\n-        assertThat(indexMetaData.getAliases().get(\"alias1\").alias(), equalTo(\"alias1\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias1\").filter().string(), equalTo(ALIAS_FILTER1));\n-        assertThat(indexMetaData.getAliases().get(\"alias3\").alias(), equalTo(\"alias3\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter & writeIndex emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias3\").filter(), nullValue());\n-        // assertThat(indexMetaData.getAliases().get(\"alias3\").writeIndex(),\n-            // equalTo(metaData.index(\"test12\").getAliases().get(\"alias3\").writeIndex()));\n-        assertThat(indexMetaData.getAliases().get(\"alias4\").alias(), equalTo(\"alias4\"));\n-        // By default, MetaData.Builder.toXContent(metaData) will use ToXContent.EMPTY_PARAMS, which generates the same serialization\n-        // as under API context that may not have alias filter emitted. Hence this assertion is no longer needed\n-        // assertThat(indexMetaData.getAliases().get(\"alias4\").filter().string(), equalTo(ALIAS_FILTER2));\n-\n-        // templates\n-        assertThat(parsedMetaData.templates().get(\"foo\").name(), is(\"foo\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").patterns(), is(Collections.singletonList(\"bar\")));\n-        assertThat(parsedMetaData.templates().get(\"foo\").settings().get(\"index.setting1\"), is(\"value1\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").settings().getByPrefix(\"index.\").get(\"setting2\"), is(\"value2\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().size(), equalTo(3));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar1\").alias(), equalTo(\"alias-bar1\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar2\").alias(), equalTo(\"alias-bar2\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar2\").filter().string(),\n-            equalTo(\"{\\\"term\\\":{\\\"user\\\":\\\"kimchy\\\"}}\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar3\").alias(), equalTo(\"alias-bar3\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar3\").indexRouting(), equalTo(\"routing-bar\"));\n-        assertThat(parsedMetaData.templates().get(\"foo\").aliases().get(\"alias-bar3\").searchRouting(), equalTo(\"routing-bar\"));\n+        XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n+        builder.startObject();\n+        MetaData.Builder.toXContent(metaData, builder, ToXContent.EMPTY_PARAMS);\n+        builder.endObject();\n     }\n \n     private static final String MAPPING_SOURCE1 = \"{\\\"_doc\\\":{\\\"mapping1\\\":{\\\"text1\\\":{\\\"type\\\":\\\"string\\\"}}}}\";\n     private static final String MAPPING_SOURCE2 = \"{\\\"_doc\\\":{\\\"mapping2\\\":{\\\"text2\\\":{\\\"type\\\":\\\"string\\\"}}}}\";\n     private static final String ALIAS_FILTER1 = \"{\\\"field1\\\":\\\"value1\\\"}\";\n     private static final String ALIAS_FILTER2 = \"{\\\"field2\\\":\\\"value2\\\"}\";\n+\n+    public void testToXContentGateway_FlatSettingTrue_ReduceMappingFalse() throws IOException {\n+        Map<String, String> mapParams = new HashMap<>(){{\n+            put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_GATEWAY);\n+            put(\"flat_settings\", \"true\");\n+            put(\"reduce_mappings\", \"false\");\n+        }};\n+\n+        MetaData metaData = buildMetaData();\n+        XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint();\n+        builder.startObject();\n+        metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+        builder.endObject();\n+\n+        assertEquals(\"{\\n\" +\n+            \"  \\\"meta-data\\\" : {\\n\" +\n+            \"    \\\"version\\\" : 0,\\n\" +\n+            \"    \\\"cluster_uuid\\\" : \\\"clusterUUID\\\",\\n\" +\n+            \"    \\\"cluster_uuid_committed\\\" : false,\\n\" +\n+            \"    \\\"cluster_coordination\\\" : {\\n\" +\n+            \"      \\\"term\\\" : 1,\\n\" +\n+            \"      \\\"last_committed_config\\\" : [\\n\" +\n+            \"        \\\"commitedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"last_accepted_config\\\" : [\\n\" +\n+            \"        \\\"acceptedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"voting_config_exclusions\\\" : [\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"node_id\\\" : \\\"exlucdedNodeId\\\",\\n\" +\n+            \"          \\\"node_name\\\" : \\\"excludedNodeName\\\"\\n\" +\n+            \"        }\\n\" +\n+            \"      ]\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"settings\\\" : {\\n\" +\n+            \"      \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"templates\\\" : {\\n\" +\n+            \"      \\\"template\\\" : {\\n\" +\n+            \"        \\\"order\\\" : 0,\\n\" +\n+            \"        \\\"index_patterns\\\" : [\\n\" +\n+            \"          \\\"pattern1\\\",\\n\" +\n+            \"          \\\"pattern2\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : [\\n\" +\n+            \"          {\\n\" +\n+            \"            \\\"key1\\\" : { },\\n\" +\n+            \"            \\\"key2\\\" : { },\\n\" +\n+            \"            \\\"key3\\\" : { }\\n\" +\n+            \"          }\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"aliases\\\" : { }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"index-graveyard\\\" : {\\n\" +\n+            \"      \\\"tombstones\\\" : [ ]\\n\" +\n+            \"    }\\n\" +\n+            \"  }\\n\" +\n+            \"}\", Strings.toString(builder));\n+    }\n+\n+    public void testToXContentAPI_SameTypeName() throws IOException {\n+        Map<String, String> mapParams = new HashMap<>(){{\n+            put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_API);\n+        }};\n+\n+        MetaData metaData = MetaData.builder()\n+            .clusterUUID(\"clusterUUID\")\n+            .coordinationMetaData(CoordinationMetaData.builder()\n+                .build())\n+            .put(IndexMetaData.builder(\"index\")\n+                .state(IndexMetaData.State.OPEN)\n+                .settings(Settings.builder()\n+                    .put(SETTING_VERSION_CREATED, Version.CURRENT.id))\n+                .putMapping(new MappingMetaData(\"type\",\n+                    // the type name is the root value,\n+                    // the original logic in ClusterState.toXContent will reduce\n+                    new HashMap<>(){{\n+                        put(\"type\", new HashMap<String, Object>(){{\n+                            put(\"key\", \"value\");\n+                        }});\n+                    }}))\n+                .numberOfShards(1)\n+                .primaryTerm(0, 1L)\n+                .numberOfReplicas(2))\n+            .build();\n+        XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint();\n+        builder.startObject();\n+        metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+        builder.endObject();\n+\n+        assertEquals(\"{\\n\" +\n+            \"  \\\"metadata\\\" : {\\n\" +\n+            \"    \\\"cluster_uuid\\\" : \\\"clusterUUID\\\",\\n\" +\n+            \"    \\\"cluster_uuid_committed\\\" : false,\\n\" +\n+            \"    \\\"cluster_coordination\\\" : {\\n\" +\n+            \"      \\\"term\\\" : 0,\\n\" +\n+            \"      \\\"last_committed_config\\\" : [ ],\\n\" +\n+            \"      \\\"last_accepted_config\\\" : [ ],\\n\" +\n+            \"      \\\"voting_config_exclusions\\\" : [ ]\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"templates\\\" : { },\\n\" +\n+            \"    \\\"indices\\\" : {\\n\" +\n+            \"      \\\"index\\\" : {\\n\" +\n+            \"        \\\"version\\\" : 2,\\n\" +\n+            \"        \\\"mapping_version\\\" : 1,\\n\" +\n+            \"        \\\"settings_version\\\" : 1,\\n\" +\n+            \"        \\\"aliases_version\\\" : 1,\\n\" +\n+            \"        \\\"routing_num_shards\\\" : 1,\\n\" +\n+            \"        \\\"state\\\" : \\\"open\\\",\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index\\\" : {\\n\" +\n+            \"            \\\"number_of_shards\\\" : \\\"1\\\",\\n\" +\n+            \"            \\\"number_of_replicas\\\" : \\\"2\\\",\\n\" +\n+            \"            \\\"version\\\" : {\\n\" +\n+            \"              \\\"created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"key\\\" : \\\"value\\\"\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : [ ],\\n\" +\n+            \"        \\\"primary_terms\\\" : {\\n\" +\n+            \"          \\\"0\\\" : 1\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"in_sync_allocations\\\" : {\\n\" +\n+            \"          \\\"0\\\" : [ ]\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"rollover_info\\\" : { }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"index-graveyard\\\" : {\\n\" +\n+            \"      \\\"tombstones\\\" : [ ]\\n\" +\n+            \"    }\\n\" +\n+            \"  }\\n\" +\n+            \"}\", Strings.toString(builder));\n+    }\n+\n+    public void testToXContentGateway_FlatSettingFalse_ReduceMappingTrue() throws IOException {\n+        Map<String, String> mapParams = new HashMap<>(){{\n+            put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_GATEWAY);\n+            put(\"flat_settings\", \"false\");\n+            put(\"reduce_mappings\", \"true\");\n+        }};\n+\n+        MetaData metaData = buildMetaData();\n+        XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint();\n+        builder.startObject();\n+        metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+        builder.endObject();\n+\n+        assertEquals(\"{\\n\" +\n+            \"  \\\"meta-data\\\" : {\\n\" +\n+            \"    \\\"version\\\" : 0,\\n\" +\n+            \"    \\\"cluster_uuid\\\" : \\\"clusterUUID\\\",\\n\" +\n+            \"    \\\"cluster_uuid_committed\\\" : false,\\n\" +\n+            \"    \\\"cluster_coordination\\\" : {\\n\" +\n+            \"      \\\"term\\\" : 1,\\n\" +\n+            \"      \\\"last_committed_config\\\" : [\\n\" +\n+            \"        \\\"commitedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"last_accepted_config\\\" : [\\n\" +\n+            \"        \\\"acceptedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"voting_config_exclusions\\\" : [\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"node_id\\\" : \\\"exlucdedNodeId\\\",\\n\" +\n+            \"          \\\"node_name\\\" : \\\"excludedNodeName\\\"\\n\" +\n+            \"        }\\n\" +\n+            \"      ]\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"settings\\\" : {\\n\" +\n+            \"      \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"templates\\\" : {\\n\" +\n+            \"      \\\"template\\\" : {\\n\" +\n+            \"        \\\"order\\\" : 0,\\n\" +\n+            \"        \\\"index_patterns\\\" : [\\n\" +\n+            \"          \\\"pattern1\\\",\\n\" +\n+            \"          \\\"pattern2\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index\\\" : {\\n\" +\n+            \"            \\\"version\\\" : {\\n\" +\n+            \"              \\\"created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"key1\\\" : { },\\n\" +\n+            \"            \\\"key2\\\" : { },\\n\" +\n+            \"            \\\"key3\\\" : { }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : { }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"index-graveyard\\\" : {\\n\" +\n+            \"      \\\"tombstones\\\" : [ ]\\n\" +\n+            \"    }\\n\" +\n+            \"  }\\n\" +\n+            \"}\", Strings.toString(builder));\n+    }\n+\n+    public void testToXContentAPI_FlatSettingTrue_ReduceMappingFalse() throws IOException {\n+        Map<String, String> mapParams = new HashMap<>(){{\n+            put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_API);\n+            put(\"flat_settings\", \"true\");\n+            put(\"reduce_mappings\", \"false\");\n+        }};\n+\n+        final MetaData metaData = buildMetaData();\n+\n+        XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint();\n+        builder.startObject();\n+        metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+        builder.endObject();\n+\n+        assertEquals(\"{\\n\" +\n+            \"  \\\"metadata\\\" : {\\n\" +\n+            \"    \\\"cluster_uuid\\\" : \\\"clusterUUID\\\",\\n\" +\n+            \"    \\\"cluster_uuid_committed\\\" : false,\\n\" +\n+            \"    \\\"cluster_coordination\\\" : {\\n\" +\n+            \"      \\\"term\\\" : 1,\\n\" +\n+            \"      \\\"last_committed_config\\\" : [\\n\" +\n+            \"        \\\"commitedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"last_accepted_config\\\" : [\\n\" +\n+            \"        \\\"acceptedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"voting_config_exclusions\\\" : [\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"node_id\\\" : \\\"exlucdedNodeId\\\",\\n\" +\n+            \"          \\\"node_name\\\" : \\\"excludedNodeName\\\"\\n\" +\n+            \"        }\\n\" +\n+            \"      ]\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"transient_settings\\\" : {\\n\" +\n+            \"      \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"templates\\\" : {\\n\" +\n+            \"      \\\"template\\\" : {\\n\" +\n+            \"        \\\"order\\\" : 0,\\n\" +\n+            \"        \\\"index_patterns\\\" : [\\n\" +\n+            \"          \\\"pattern1\\\",\\n\" +\n+            \"          \\\"pattern2\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"key1\\\" : { },\\n\" +\n+            \"            \\\"key2\\\" : { },\\n\" +\n+            \"            \\\"key3\\\" : { }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : { }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"indices\\\" : {\\n\" +\n+            \"      \\\"index\\\" : {\\n\" +\n+            \"        \\\"version\\\" : 2,\\n\" +\n+            \"        \\\"mapping_version\\\" : 1,\\n\" +\n+            \"        \\\"settings_version\\\" : 1,\\n\" +\n+            \"        \\\"aliases_version\\\" : 1,\\n\" +\n+            \"        \\\"routing_num_shards\\\" : 1,\\n\" +\n+            \"        \\\"state\\\" : \\\"open\\\",\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index.number_of_replicas\\\" : \\\"2\\\",\\n\" +\n+            \"          \\\"index.number_of_shards\\\" : \\\"1\\\",\\n\" +\n+            \"          \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"type1\\\" : {\\n\" +\n+            \"              \\\"key\\\" : \\\"value\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : [\\n\" +\n+            \"          \\\"alias\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"primary_terms\\\" : {\\n\" +\n+            \"          \\\"0\\\" : 1\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"in_sync_allocations\\\" : {\\n\" +\n+            \"          \\\"0\\\" : [\\n\" +\n+            \"            \\\"allocationId\\\"\\n\" +\n+            \"          ]\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"rollover_info\\\" : {\\n\" +\n+            \"          \\\"rolloveAlias\\\" : {\\n\" +\n+            \"            \\\"met_conditions\\\" : { },\\n\" +\n+            \"            \\\"time\\\" : 1\\n\" +\n+            \"          }\\n\" +\n+            \"        }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"index-graveyard\\\" : {\\n\" +\n+            \"      \\\"tombstones\\\" : [ ]\\n\" +\n+            \"    }\\n\" +\n+            \"  }\\n\" +\n+            \"}\", Strings.toString(builder));\n+    }\n+\n+    public void testToXContentAPI_FlatSettingFalse_ReduceMappingTrue() throws IOException {\n+        Map<String, String> mapParams = new HashMap<>(){{\n+            put(MetaData.CONTEXT_MODE_PARAM, CONTEXT_MODE_API);\n+            put(\"flat_settings\", \"false\");\n+            put(\"reduce_mappings\", \"true\");\n+        }};\n+\n+        final MetaData metaData = buildMetaData();\n+\n+        XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint();\n+        builder.startObject();\n+        metaData.toXContent(builder, new ToXContent.MapParams(mapParams));\n+        builder.endObject();\n+\n+        assertEquals(\"{\\n\" +\n+            \"  \\\"metadata\\\" : {\\n\" +\n+            \"    \\\"cluster_uuid\\\" : \\\"clusterUUID\\\",\\n\" +\n+            \"    \\\"cluster_uuid_committed\\\" : false,\\n\" +\n+            \"    \\\"cluster_coordination\\\" : {\\n\" +\n+            \"      \\\"term\\\" : 1,\\n\" +\n+            \"      \\\"last_committed_config\\\" : [\\n\" +\n+            \"        \\\"commitedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"last_accepted_config\\\" : [\\n\" +\n+            \"        \\\"acceptedConfigurationNodeId\\\"\\n\" +\n+            \"      ],\\n\" +\n+            \"      \\\"voting_config_exclusions\\\" : [\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"node_id\\\" : \\\"exlucdedNodeId\\\",\\n\" +\n+            \"          \\\"node_name\\\" : \\\"excludedNodeName\\\"\\n\" +\n+            \"        }\\n\" +\n+            \"      ]\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"transient_settings\\\" : {\\n\" +\n+            \"      \\\"index.version.created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"templates\\\" : {\\n\" +\n+            \"      \\\"template\\\" : {\\n\" +\n+            \"        \\\"order\\\" : 0,\\n\" +\n+            \"        \\\"index_patterns\\\" : [\\n\" +\n+            \"          \\\"pattern1\\\",\\n\" +\n+            \"          \\\"pattern2\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index\\\" : {\\n\" +\n+            \"            \\\"version\\\" : {\\n\" +\n+            \"              \\\"created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"key1\\\" : { },\\n\" +\n+            \"            \\\"key2\\\" : { },\\n\" +\n+            \"            \\\"key3\\\" : { }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : { }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"indices\\\" : {\\n\" +\n+            \"      \\\"index\\\" : {\\n\" +\n+            \"        \\\"version\\\" : 2,\\n\" +\n+            \"        \\\"mapping_version\\\" : 1,\\n\" +\n+            \"        \\\"settings_version\\\" : 1,\\n\" +\n+            \"        \\\"aliases_version\\\" : 1,\\n\" +\n+            \"        \\\"routing_num_shards\\\" : 1,\\n\" +\n+            \"        \\\"state\\\" : \\\"open\\\",\\n\" +\n+            \"        \\\"settings\\\" : {\\n\" +\n+            \"          \\\"index\\\" : {\\n\" +\n+            \"            \\\"number_of_shards\\\" : \\\"1\\\",\\n\" +\n+            \"            \\\"number_of_replicas\\\" : \\\"2\\\",\\n\" +\n+            \"            \\\"version\\\" : {\\n\" +\n+            \"              \\\"created\\\" : \\\"\" + Version.CURRENT.id + \"\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"mappings\\\" : {\\n\" +\n+            \"          \\\"type\\\" : {\\n\" +\n+            \"            \\\"type1\\\" : {\\n\" +\n+            \"              \\\"key\\\" : \\\"value\\\"\\n\" +\n+            \"            }\\n\" +\n+            \"          }\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"aliases\\\" : [\\n\" +\n+            \"          \\\"alias\\\"\\n\" +\n+            \"        ],\\n\" +\n+            \"        \\\"primary_terms\\\" : {\\n\" +\n+            \"          \\\"0\\\" : 1\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"in_sync_allocations\\\" : {\\n\" +\n+            \"          \\\"0\\\" : [\\n\" +\n+            \"            \\\"allocationId\\\"\\n\" +\n+            \"          ]\\n\" +\n+            \"        },\\n\" +\n+            \"        \\\"rollover_info\\\" : {\\n\" +\n+            \"          \\\"rolloveAlias\\\" : {\\n\" +\n+            \"            \\\"met_conditions\\\" : { },\\n\" +\n+            \"            \\\"time\\\" : 1\\n\" +\n+            \"          }\\n\" +\n+            \"        }\\n\" +\n+            \"      }\\n\" +\n+            \"    },\\n\" +\n+            \"    \\\"index-graveyard\\\" : {\\n\" +\n+            \"      \\\"tombstones\\\" : [ ]\\n\" +\n+            \"    }\\n\" +\n+            \"  }\\n\" +\n+            \"}\", Strings.toString(builder));\n+    }\n+\n+\n+    private MetaData buildMetaData() throws IOException {\n+        return MetaData.builder()\n+            .clusterUUID(\"clusterUUID\")\n+            .coordinationMetaData(CoordinationMetaData.builder()\n+                .term(1)\n+                .lastCommittedConfiguration(new CoordinationMetaData.VotingConfiguration(new HashSet<>(){{\n+                    add(\"commitedConfigurationNodeId\");\n+                }}))\n+                .lastAcceptedConfiguration(new CoordinationMetaData.VotingConfiguration(new HashSet<>(){{\n+                    add(\"acceptedConfigurationNodeId\");\n+                }}))\n+                .addVotingConfigExclusion(new CoordinationMetaData.VotingConfigExclusion(\"exlucdedNodeId\", \"excludedNodeName\"))\n+                .build())\n+            .persistentSettings(Settings.builder()\n+                .put(SETTING_VERSION_CREATED, Version.CURRENT.id).build())\n+            .transientSettings(Settings.builder()\n+                .put(SETTING_VERSION_CREATED, Version.CURRENT.id).build())\n+            .put(IndexMetaData.builder(\"index\")\n+                .state(IndexMetaData.State.OPEN)\n+                .settings(Settings.builder()\n+                    .put(SETTING_VERSION_CREATED, Version.CURRENT.id))\n+                .putMapping(new MappingMetaData(\"type\",\n+                    new HashMap<>(){{\n+                        put(\"type1\", new HashMap<String, Object>(){{\n+                            put(\"key\", \"value\");\n+                        }});\n+                    }}))\n+                .putAlias(AliasMetaData.builder(\"alias\")\n+                    .indexRouting(\"indexRouting\")\n+                    .build())\n+                .numberOfShards(1)\n+                .primaryTerm(0, 1L)\n+                .putInSyncAllocationIds(0, new HashSet<>(){{\n+                    add(\"allocationId\");\n+                }})\n+                .numberOfReplicas(2)\n+                .putRolloverInfo(new RolloverInfo(\"rolloveAlias\", new ArrayList<>(), 1L)))\n+            .put(IndexTemplateMetaData.builder(\"template\")\n+                .patterns(List.of(\"pattern1\", \"pattern2\"))\n+                .order(0)\n+                .settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT.id))\n+                .putMapping(\"type\", \"{ \\\"key1\\\": {}, \\\"key2\\\": {}, \\\"key3\\\": {} }\")\n+                .build())\n+            .build();\n+    }\n+\n+    public static class CustomMetaData extends TestCustomMetaData {\n+        public static final String TYPE = \"custom_md\";\n+\n+        CustomMetaData(String data) {\n+            super(data);\n+        }\n+\n+        @Override\n+        public String getWriteableName() {\n+            return TYPE;\n+        }\n+\n+        @Override\n+        public Version getMinimalSupportedVersion() {\n+            return Version.CURRENT;\n+        }\n+\n+        @Override\n+        public EnumSet<MetaData.XContentContext> context() {\n+            return EnumSet.of(MetaData.XContentContext.GATEWAY, MetaData.XContentContext.SNAPSHOT);\n+        }\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MTIwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r386851202", "bodyText": "why did you add deserialization code here?\nIs it because we are testing API deserialization somewhere? If so, I would rather have the tests changed to test non-API deserialization.\nSame comment of other places below.", "author": "ywelsch", "createdAt": "2020-03-03T08:03:21Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java", "diffHunk": "@@ -1318,7 +1360,21 @@ public static IndexMetaData fromXContent(XContentParser parser) throws IOExcepti\n                                 throw new IllegalArgumentException(\"Unexpected token: \" + token);\n                             }\n                         }\n-                    } else if (\"warmers\".equals(currentFieldName)) {\n+                    } else if (KEY_PRIMARY_TERMS.equals(currentFieldName)) {", "originalCommit": "b021eac9a37e425602e9067cd19a08b17377b3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ5NDc2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r387494767", "bodyText": "The primary reason for adding these is, the original ClusterState.toXContent emits array serialization for aliases and object serialization for primary_terms, which are different from what MetaData.toXContent emits, which is object serialization for aliases and array serialization for primary_terms, under API context. The delta can been seen here 072e05d#diff-4385d650a8cef0592db3454ad42e4bf3L1172-R1157\nIn general, as the duplicated code diverges, there are conflicting serializations under API context.\nSo the additional deserialization here is to be able to read back in the different serialization emitted by the new code (namely, array serialization for aliases and object serialization for primary_terms)", "author": "zacharymorn", "createdAt": "2020-03-04T07:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MTIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNzY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396307645", "bodyText": "I think we should avoid being able to read back the API-serialized XContent. There is no requirement to do so, and it introduces leniency in the parsing here, with the possibility of silently hiding bugs where the wrong context is chosen for serialization.", "author": "ywelsch", "createdAt": "2020-03-23T09:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MTIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3OTI0NA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396879244", "bodyText": "I've given this a shot and removed deserialization for both primary_terms and aliases. These ended up breaking a lot of tests as they serialized under default context (API), and deserialized for further checking. I thus removed the breaking tests (as little as I can, but more can be removed as what's left are just setup code) and isolated the removal in this commit  0c11613.\nIf we don't want to remove these many tests for such small changes, the other possible approach is to not emit those different serialization for aliases and primary_terms for ClusterState.toXContent. This obviously would break code relying on it.\nPlease let me know which way you prefer, or if you have other ideas around this.", "author": "zacharymorn", "createdAt": "2020-03-24T03:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg1MTIwMg=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\nindex a91e4b6d507..3589f28ce4b 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n\n@@ -1365,16 +1361,14 @@ public class IndexMetaData implements Diffable<IndexMetaData>, ToXContentFragmen\n                         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                             if (token == XContentParser.Token.FIELD_NAME) {\n                                 currentFieldName = parser.currentName();\n-                            }\n-                            else if (token == XContentParser.Token.VALUE_NUMBER) {\n+                            } else if (token == XContentParser.Token.VALUE_NUMBER) {\n                                 list.add(parser.longValue());\n                             } else {\n                                 throw new IllegalStateException(\"found a non-numeric value under [\" + KEY_PRIMARY_TERMS + \"]\");\n                             }\n                         }\n                         builder.primaryTerms(list.toArray());\n-                    }\n-                    else if (\"warmers\".equals(currentFieldName)) {\n+                    } else if (\"warmers\".equals(currentFieldName)) {\n                         // TODO: do this in 6.0:\n                         // throw new IllegalArgumentException(\"Warmers are not supported anymore - are you upgrading from 1.x?\");\n                         // ignore: warmers have been removed in 5.0 and are\n"}}, {"oid": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "url": "https://github.com/elastic/elasticsearch/commit/958d41a75792ff3cbe443e1c35c5c701cfcd9526", "message": "Address comments", "committedDate": "2020-03-20T02:14:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMjU0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396302549", "bodyText": "This mutates the global variable on every call? Certainly not what we want?", "author": "ywelsch", "createdAt": "2020-03-23T09:11:10Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterState.java", "diffHunk": "@@ -418,104 +420,13 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n \n-        // meta data\n-        if (metrics.contains(Metric.METADATA)) {\n-            builder.startObject(\"metadata\");\n-            builder.field(\"cluster_uuid\", metaData().clusterUUID());\n-\n-            builder.startObject(\"cluster_coordination\");\n-            coordinationMetaData().toXContent(builder, params);\n-            builder.endObject();\n-\n-            builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData().templates().values()) {\n-                IndexTemplateMetaData templateMetaData = cursor.value;\n-                builder.startObject(templateMetaData.name());\n-\n-                builder.field(\"index_patterns\", templateMetaData.patterns());\n-                builder.field(\"order\", templateMetaData.order());\n-\n-                builder.startObject(\"settings\");\n-                Settings settings = templateMetaData.settings();\n-                settings.toXContent(builder, params);\n-                builder.endObject();\n-\n-                builder.startObject(\"mappings\");\n-                for (ObjectObjectCursor<String, CompressedXContent> cursor1 : templateMetaData.mappings()) {\n-                    Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(cursor1.value.uncompressed()), false).v2();\n-                    if (mapping.size() == 1 && mapping.containsKey(cursor1.key)) {\n-                        // the type name is the root value, reduce it\n-                        mapping = (Map<String, Object>) mapping.get(cursor1.key);\n-                    }\n-                    builder.field(cursor1.key);\n-                    builder.map(mapping);\n-                }\n-                builder.endObject();\n-\n-\n-                builder.endObject();\n-            }\n-            builder.endObject();\n-\n-            builder.startObject(\"indices\");\n-            for (IndexMetaData indexMetaData : metaData()) {\n-                builder.startObject(indexMetaData.getIndex().getName());\n-\n-                builder.field(\"state\", indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH));\n-\n-                builder.startObject(\"settings\");\n-                Settings settings = indexMetaData.getSettings();\n-                settings.toXContent(builder, params);\n-                builder.endObject();\n-\n-                builder.startObject(\"mappings\");\n-                MappingMetaData mmd = indexMetaData.mapping();\n-                if (mmd != null) {\n-                    Map<String, Object> mapping = XContentHelper\n-                            .convertToMap(new BytesArray(mmd.source().uncompressed()), false).v2();\n-                    if (mapping.size() == 1 && mapping.containsKey(mmd.type())) {\n-                        // the type name is the root value, reduce it\n-                        mapping = (Map<String, Object>) mapping.get(mmd.type());\n-                    }\n-                    builder.field(mmd.type());\n-                    builder.map(mapping);\n-                }\n-                builder.endObject();\n \n-                builder.startArray(\"aliases\");\n-                for (ObjectCursor<String> cursor : indexMetaData.getAliases().keys()) {\n-                    builder.value(cursor.value);\n-                }\n-                builder.endArray();\n-\n-                builder.startObject(IndexMetaData.KEY_PRIMARY_TERMS);\n-                for (int shard = 0; shard < indexMetaData.getNumberOfShards(); shard++) {\n-                    builder.field(Integer.toString(shard), indexMetaData.primaryTerm(shard));\n-                }\n-                builder.endObject();\n-\n-                builder.startObject(IndexMetaData.KEY_IN_SYNC_ALLOCATIONS);\n-                for (IntObjectCursor<Set<String>> cursor : indexMetaData.getInSyncAllocationIds()) {\n-                    builder.startArray(String.valueOf(cursor.key));\n-                    for (String allocationId : cursor.value) {\n-                        builder.value(allocationId);\n-                    }\n-                    builder.endArray();\n-                }\n-                builder.endObject();\n+        API_PARAMS.put(\"flat_settings\", params.param(\"flat_settings\"));", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3ODc1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396878756", "bodyText": "I've removed API_PARAMS as suggested so this is no longer relevant.", "author": "zacharymorn", "createdAt": "2020-03-24T03:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMjU0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\nindex 421805634de..400b0d373fb 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n\n@@ -420,13 +415,9 @@ public class ClusterState implements ToXContentFragment, Diffable<ClusterState>\n             builder.endObject();\n         }\n \n-\n-        API_PARAMS.put(\"flat_settings\", params.param(\"flat_settings\"));\n-        API_PARAMS.put(\"reduce_mappings\", params.param(\"reduce_mappings\"));\n-\n         // meta data\n         if (metrics.contains(Metric.METADATA)) {\n-            metaData.toXContent(builder, new ToXContent.MapParams(API_PARAMS));\n+            metaData.toXContent(builder, params);\n         }\n \n         // routing table\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNTU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396305590", "bodyText": "Instead of passing down a limited set of parameters here, I wonder if we should pass all of them, but additionally inject the API context.\nGiven that Metadata is already using API context as default, I wonder if we need to do anything here in this class. Perhaps it's sufficient to just pass down the params as is?", "author": "ywelsch", "createdAt": "2020-03-23T09:16:40Z", "path": "server/src/main/java/org/elasticsearch/cluster/ClusterState.java", "diffHunk": "@@ -418,104 +420,13 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n \n-        // meta data\n-        if (metrics.contains(Metric.METADATA)) {\n-            builder.startObject(\"metadata\");\n-            builder.field(\"cluster_uuid\", metaData().clusterUUID());\n-\n-            builder.startObject(\"cluster_coordination\");\n-            coordinationMetaData().toXContent(builder, params);\n-            builder.endObject();\n-\n-            builder.startObject(\"templates\");\n-            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData().templates().values()) {\n-                IndexTemplateMetaData templateMetaData = cursor.value;\n-                builder.startObject(templateMetaData.name());\n-\n-                builder.field(\"index_patterns\", templateMetaData.patterns());\n-                builder.field(\"order\", templateMetaData.order());\n-\n-                builder.startObject(\"settings\");\n-                Settings settings = templateMetaData.settings();\n-                settings.toXContent(builder, params);\n-                builder.endObject();\n-\n-                builder.startObject(\"mappings\");\n-                for (ObjectObjectCursor<String, CompressedXContent> cursor1 : templateMetaData.mappings()) {\n-                    Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(cursor1.value.uncompressed()), false).v2();\n-                    if (mapping.size() == 1 && mapping.containsKey(cursor1.key)) {\n-                        // the type name is the root value, reduce it\n-                        mapping = (Map<String, Object>) mapping.get(cursor1.key);\n-                    }\n-                    builder.field(cursor1.key);\n-                    builder.map(mapping);\n-                }\n-                builder.endObject();\n-\n-\n-                builder.endObject();\n-            }\n-            builder.endObject();\n-\n-            builder.startObject(\"indices\");\n-            for (IndexMetaData indexMetaData : metaData()) {\n-                builder.startObject(indexMetaData.getIndex().getName());\n-\n-                builder.field(\"state\", indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH));\n-\n-                builder.startObject(\"settings\");\n-                Settings settings = indexMetaData.getSettings();\n-                settings.toXContent(builder, params);\n-                builder.endObject();\n-\n-                builder.startObject(\"mappings\");\n-                MappingMetaData mmd = indexMetaData.mapping();\n-                if (mmd != null) {\n-                    Map<String, Object> mapping = XContentHelper\n-                            .convertToMap(new BytesArray(mmd.source().uncompressed()), false).v2();\n-                    if (mapping.size() == 1 && mapping.containsKey(mmd.type())) {\n-                        // the type name is the root value, reduce it\n-                        mapping = (Map<String, Object>) mapping.get(mmd.type());\n-                    }\n-                    builder.field(mmd.type());\n-                    builder.map(mapping);\n-                }\n-                builder.endObject();\n \n-                builder.startArray(\"aliases\");\n-                for (ObjectCursor<String> cursor : indexMetaData.getAliases().keys()) {\n-                    builder.value(cursor.value);\n-                }\n-                builder.endArray();\n-\n-                builder.startObject(IndexMetaData.KEY_PRIMARY_TERMS);\n-                for (int shard = 0; shard < indexMetaData.getNumberOfShards(); shard++) {\n-                    builder.field(Integer.toString(shard), indexMetaData.primaryTerm(shard));\n-                }\n-                builder.endObject();\n-\n-                builder.startObject(IndexMetaData.KEY_IN_SYNC_ALLOCATIONS);\n-                for (IntObjectCursor<Set<String>> cursor : indexMetaData.getInSyncAllocationIds()) {\n-                    builder.startArray(String.valueOf(cursor.key));\n-                    for (String allocationId : cursor.value) {\n-                        builder.value(allocationId);\n-                    }\n-                    builder.endArray();\n-                }\n-                builder.endObject();\n+        API_PARAMS.put(\"flat_settings\", params.param(\"flat_settings\"));\n+        API_PARAMS.put(\"reduce_mappings\", params.param(\"reduce_mappings\"));\n \n-                // index metadata\n-                builder.endObject();\n-            }\n-            builder.endObject();\n-\n-            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {\n-                builder.startObject(cursor.key);\n-                cursor.value.toXContent(builder, params);\n-                builder.endObject();\n-            }\n-\n-            builder.endObject();\n+        // meta data\n+        if (metrics.contains(Metric.METADATA)) {\n+            metaData.toXContent(builder, new ToXContent.MapParams(API_PARAMS));", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3ODczMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396878731", "bodyText": "That's a good point. The delegation refactoring ultimately do away the need for selecting params in this layer. I've removed it.", "author": "zacharymorn", "createdAt": "2020-03-24T03:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNTU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\nindex 421805634de..400b0d373fb 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/ClusterState.java\n\n@@ -420,13 +415,9 @@ public class ClusterState implements ToXContentFragment, Diffable<ClusterState>\n             builder.endObject();\n         }\n \n-\n-        API_PARAMS.put(\"flat_settings\", params.param(\"flat_settings\"));\n-        API_PARAMS.put(\"reduce_mappings\", params.param(\"reduce_mappings\"));\n-\n         // meta data\n         if (metrics.contains(Metric.METADATA)) {\n-            metaData.toXContent(builder, new ToXContent.MapParams(API_PARAMS));\n+            metaData.toXContent(builder, params);\n         }\n \n         // routing table\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwOTI5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396309293", "bodyText": "Use CONTEXT_MODE_API constant here?", "author": "ywelsch", "createdAt": "2020-03-23T09:23:06Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1270,28 +1270,26 @@ public MetaData build() {\n             return aliasAndIndexLookup;\n         }\n \n-        public static String toXContent(MetaData metaData) throws IOException {\n-            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n-            builder.startObject();\n-            toXContent(metaData, builder, ToXContent.EMPTY_PARAMS);\n-            builder.endObject();\n-            return Strings.toString(builder);\n-        }\n-\n         public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n             XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3ODc4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396878787", "bodyText": "Done.", "author": "zacharymorn", "createdAt": "2020-03-24T03:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwOTI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nindex 5c650106deb..dc124fcee90 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n\n@@ -1271,18 +1271,16 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n         }\n \n         public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n-            XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));\n+            XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, CONTEXT_MODE_API));\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"metadata\");\n-            }\n-            else {\n+            } else {\n                 builder.startObject(\"meta-data\");\n                 builder.field(\"version\", metaData.version());\n             }\n \n             builder.field(\"cluster_uuid\", metaData.clusterUUID);\n-            // This is required for some serialization under API context, as some tests in MetaDataTests assert its presenc\n             builder.field(\"cluster_uuid_committed\", metaData.clusterUUIDCommitted);\n \n             builder.startObject(\"cluster_coordination\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODIzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396328231", "bodyText": "I'm not sure I understand this comment? Is it outdated?", "author": "ywelsch", "createdAt": "2020-03-23T09:53:44Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1270,28 +1270,26 @@ public MetaData build() {\n             return aliasAndIndexLookup;\n         }\n \n-        public static String toXContent(MetaData metaData) throws IOException {\n-            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n-            builder.startObject();\n-            toXContent(metaData, builder, ToXContent.EMPTY_PARAMS);\n-            builder.endObject();\n-            return Strings.toString(builder);\n-        }\n-\n         public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n             XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));\n \n-            builder.startObject(\"meta-data\");\n+            if (context == XContentContext.API) {\n+                builder.startObject(\"metadata\");\n+            }\n+            else {\n+                builder.startObject(\"meta-data\");\n+                builder.field(\"version\", metaData.version());\n+            }\n \n-            builder.field(\"version\", metaData.version());\n             builder.field(\"cluster_uuid\", metaData.clusterUUID);\n+            // This is required for some serialization under API context, as some tests in MetaDataTests assert its presenc", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3ODgwMA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396878800", "bodyText": "Yes sorry. This was added in between the commits, as was meant to say that ClusterState.toXContent will now start to emit cluster_uuid_committed in its serialization, as I retried to remove cluster_uuid_committed before to keep ClusterState.toXContent serialization unchanged, but had to put back due to the test asserting it.", "author": "zacharymorn", "createdAt": "2020-03-24T03:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nindex 5c650106deb..dc124fcee90 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n\n@@ -1271,18 +1271,16 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n         }\n \n         public static void toXContent(MetaData metaData, XContentBuilder builder, ToXContent.Params params) throws IOException {\n-            XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, \"API\"));\n+            XContentContext context = XContentContext.valueOf(params.param(CONTEXT_MODE_PARAM, CONTEXT_MODE_API));\n \n             if (context == XContentContext.API) {\n                 builder.startObject(\"metadata\");\n-            }\n-            else {\n+            } else {\n                 builder.startObject(\"meta-data\");\n                 builder.field(\"version\", metaData.version());\n             }\n \n             builder.field(\"cluster_uuid\", metaData.clusterUUID);\n-            // This is required for some serialization under API context, as some tests in MetaDataTests assert its presenc\n             builder.field(\"cluster_uuid_committed\", metaData.clusterUUIDCommitted);\n \n             builder.startObject(\"cluster_coordination\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyOTA1NA==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396329054", "bodyText": "As commented above, let's remove the lenient parsing here.", "author": "ywelsch", "createdAt": "2020-03-23T09:55:00Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java", "diffHunk": "@@ -1347,7 +1345,8 @@ public static MetaData fromXContent(XContentParser parser, boolean preserveUnkno\n                 currentFieldName = parser.currentName();\n             }\n \n-            if (!\"meta-data\".equals(parser.currentName())) {\n+            if (!\"meta-data\".equals(parser.currentName()) &&\n+                !\"metadata\".equals(parser.currentName())) {", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3OTE2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396879162", "bodyText": "Done. This also caused some test cases to be broken and removed as they relied on deserialization of API-serialized XContent 0c11613", "author": "zacharymorn", "createdAt": "2020-03-24T03:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyOTA1NA=="}], "type": "inlineReview", "revised_code": {"commit": "0c11613501e979d9202a1f6fa7dda3aca4b69b72", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\nindex 5c650106deb..8c95cb13aa0 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java\n\n@@ -1345,8 +1343,7 @@ public class MetaData implements Iterable<IndexMetaData>, Diffable<MetaData>, To\n                 currentFieldName = parser.currentName();\n             }\n \n-            if (!\"meta-data\".equals(parser.currentName()) &&\n-                !\"metadata\".equals(parser.currentName())) {\n+            if (!\"meta-data\".equals(parser.currentName())) {\n                 throw new IllegalArgumentException(\"Expected [meta-data] as a field name but got \" + currentFieldName);\n             }\n             if (token != XContentParser.Token.START_OBJECT) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMDQ5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396330491", "bodyText": "move these elses up (lot's of other occurrences in this file)", "author": "ywelsch", "createdAt": "2020-03-23T09:57:17Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java", "diffHunk": "@@ -1352,7 +1404,13 @@ public static IndexMetaData fromXContent(XContentParser parser) throws IOExcepti\n                             }\n                         }\n                         builder.primaryTerms(list.toArray());\n-                    } else {\n+                    }\n+                    else if (KEY_ALIASES.equals(currentFieldName)) {\n+                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n+                            builder.putAlias(AliasMetaData.builder(parser.text()).build());\n+                        }\n+                    }\n+                    else {", "originalCommit": "958d41a75792ff3cbe443e1c35c5c701cfcd9526", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3OTIwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r396879203", "bodyText": "I've removed these changes as they are also for reading back API-serialized XContent. I did correct else placement in other places though.", "author": "zacharymorn", "createdAt": "2020-03-24T03:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMDQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\nindex 80e84c3a4f3..3589f28ce4b 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java\n\n@@ -1404,13 +1402,11 @@ public class IndexMetaData implements Diffable<IndexMetaData>, ToXContentFragmen\n                             }\n                         }\n                         builder.primaryTerms(list.toArray());\n-                    }\n-                    else if (KEY_ALIASES.equals(currentFieldName)) {\n+                    } else if (KEY_ALIASES.equals(currentFieldName)) {\n                         while (parser.nextToken() != XContentParser.Token.END_ARRAY) {\n                             builder.putAlias(AliasMetaData.builder(parser.text()).build());\n                         }\n-                    }\n-                    else {\n+                    } else {\n                         throw new IllegalArgumentException(\"Unexpected field for an array \" + currentFieldName);\n                     }\n                 } else if (token.isValue()) {\n"}}, {"oid": "089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "url": "https://github.com/elastic/elasticsearch/commit/089d7a308bb3d5baa7a87a4a909c2f2e3e6d893c", "message": "Address comments to place else on the same line, and pass down entire params from ClusterState to MetaData", "committedDate": "2020-03-23T23:37:40Z", "type": "commit"}, {"oid": "0c11613501e979d9202a1f6fa7dda3aca4b69b72", "url": "https://github.com/elastic/elasticsearch/commit/0c11613501e979d9202a1f6fa7dda3aca4b69b72", "message": "Remove lenient deserialization parsing for API-serialized XContent, as well as the tests that get broken", "committedDate": "2020-03-24T01:24:08Z", "type": "commit"}, {"oid": "977a4284c57bb0ab2bc4fbc18c62ac66ce0a1150", "url": "https://github.com/elastic/elasticsearch/commit/977a4284c57bb0ab2bc4fbc18c62ac66ce0a1150", "message": "Fix tests", "committedDate": "2020-03-24T07:35:59Z", "type": "commit"}, {"oid": "608d627328d21345d400bab5e4d526c312de8009", "url": "https://github.com/elastic/elasticsearch/commit/608d627328d21345d400bab5e4d526c312de8009", "message": "Merge remote-tracking branch 'elastic/master' into pr/52743", "committedDate": "2020-03-24T08:06:23Z", "type": "commit"}, {"oid": "ae97011a09e7c94412811d1e0cb489cb80c3406c", "url": "https://github.com/elastic/elasticsearch/commit/ae97011a09e7c94412811d1e0cb489cb80c3406c", "message": "fix merge issue", "committedDate": "2020-03-24T08:20:18Z", "type": "commit"}, {"oid": "db900412d7c82902ac756417fd01304b2b77fb93", "url": "https://github.com/elastic/elasticsearch/commit/db900412d7c82902ac756417fd01304b2b77fb93", "message": "fix tests", "committedDate": "2020-03-24T09:01:13Z", "type": "commit"}, {"oid": "76564f98e3bdb2bb883f74e4491ee690e273b45f", "url": "https://github.com/elastic/elasticsearch/commit/76564f98e3bdb2bb883f74e4491ee690e273b45f", "message": "undo more changes", "committedDate": "2020-03-24T09:50:01Z", "type": "commit"}, {"oid": "7a30a36dbda6b2b89658e4d8736a04357bf05fa8", "url": "https://github.com/elastic/elasticsearch/commit/7a30a36dbda6b2b89658e4d8736a04357bf05fa8", "message": "Fix alias filter parsing and test", "committedDate": "2020-03-24T10:57:41Z", "type": "commit"}, {"oid": "e99f60acc4cce806d631671ac7cf6686f3337c5f", "url": "https://github.com/elastic/elasticsearch/commit/e99f60acc4cce806d631671ac7cf6686f3337c5f", "message": "Remove transient settings", "committedDate": "2020-03-24T11:28:45Z", "type": "commit"}, {"oid": "b1eb05a4828607ccd42e85269eaa36e66a3147b9", "url": "https://github.com/elastic/elasticsearch/commit/b1eb05a4828607ccd42e85269eaa36e66a3147b9", "message": "always print indices in API mode", "committedDate": "2020-03-24T11:38:16Z", "type": "commit"}, {"oid": "cc4f3177d94b9f22f07d80a0d17f1cd60426090c", "url": "https://github.com/elastic/elasticsearch/commit/cc4f3177d94b9f22f07d80a0d17f1cd60426090c", "message": "Merge remote-tracking branch 'elastic/master' into pr/52743", "committedDate": "2020-03-24T13:47:48Z", "type": "commit"}, {"oid": "3fe6cea443fd8347465ad5b1691051964cc09e12", "url": "https://github.com/elastic/elasticsearch/commit/3fe6cea443fd8347465ad5b1691051964cc09e12", "message": "checkstyle", "committedDate": "2020-03-24T13:48:50Z", "type": "commit"}, {"oid": "7235ade03b41617408d0a568856e9c2b07b5d24f", "url": "https://github.com/elastic/elasticsearch/commit/7235ade03b41617408d0a568856e9c2b07b5d24f", "message": "checkstyle", "committedDate": "2020-03-24T16:10:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU1OTQyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52743#discussion_r397559427", "bodyText": "Didn't realize we could use this to save the tests, good to know!", "author": "zacharymorn", "createdAt": "2020-03-25T01:31:12Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java", "diffHunk": "@@ -1451,7 +1452,13 @@ public static Settings addHumanReadableSettings(Settings settings) {\n         return builder.build();\n     }\n \n-    private static final ToXContent.Params FORMAT_PARAMS = new MapParams(Collections.singletonMap(\"binary\", \"true\"));\n+    private static final ToXContent.Params FORMAT_PARAMS;", "originalCommit": "977a4284c57bb0ab2bc4fbc18c62ac66ce0a1150", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "af8286d56c0c13b5f82cfa417754148d6fbe435b", "url": "https://github.com/elastic/elasticsearch/commit/af8286d56c0c13b5f82cfa417754148d6fbe435b", "message": "Merge remote-tracking branch 'elastic/master' into pr/52743", "committedDate": "2020-03-25T08:05:53Z", "type": "commit"}, {"oid": "65601162d3de68e84aa2deb144d540053dade591", "url": "https://github.com/elastic/elasticsearch/commit/65601162d3de68e84aa2deb144d540053dade591", "message": "More test fixing", "committedDate": "2020-03-25T09:55:28Z", "type": "commit"}, {"oid": "8c7a30819af844aef9faf82039d9f72a9fdb62a3", "url": "https://github.com/elastic/elasticsearch/commit/8c7a30819af844aef9faf82039d9f72a9fdb62a3", "message": "one more test to fix after merging master", "committedDate": "2020-03-25T10:48:04Z", "type": "commit"}, {"oid": "8567d919a7b1d76a2d5a5fb4ada638f8323f65fa", "url": "https://github.com/elastic/elasticsearch/commit/8567d919a7b1d76a2d5a5fb4ada638f8323f65fa", "message": "more fixes yet", "committedDate": "2020-03-25T12:13:48Z", "type": "commit"}, {"oid": "51b31b496fbb83ca889ebaecb27fbc4a8decdfa7", "url": "https://github.com/elastic/elasticsearch/commit/51b31b496fbb83ca889ebaecb27fbc4a8decdfa7", "message": "another fix", "committedDate": "2020-03-25T12:49:06Z", "type": "commit"}]}