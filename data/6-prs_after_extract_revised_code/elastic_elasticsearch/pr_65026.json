{"pr_number": 65026, "pr_title": "SQL: Add method args to PERCENTILE/PERCENTILE_RANK", "pr_createdAt": "2020-11-12T23:41:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65026", "timeline": [{"oid": "15fff8a17bbcbfa1e5f062d50db5dcad9332cd00", "url": "https://github.com/elastic/elasticsearch/commit/15fff8a17bbcbfa1e5f062d50db5dcad9332cd00", "message": "SQL: Add method args to PERCENTILE/PERCENTILE_RANK\n\n* Adds the capability to have functions with two optional arguments\n* Adds two new optional arguments to `PERCENTILE()` and\n  `PERCENTILE_RANK()` functions, namely the method and\n  method_parameter which can be: 1) `tdigest` and a double `compression`\n  parameter or 2) `hdr` and an integer representing the\n  `number_of_digits` parameter.\n* Integration tests\n* Documentation updates\n\nCloses #63567", "committedDate": "2020-11-12T23:39:17Z", "type": "commit"}, {"oid": "088161a8eedb7a937b5c16ad78da312bf3388726", "url": "https://github.com/elastic/elasticsearch/commit/088161a8eedb7a937b5c16ad78da312bf3388726", "message": "Reverted the FunctionRegistry refactor and comments", "committedDate": "2020-11-13T03:21:30Z", "type": "commit"}, {"oid": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "url": "https://github.com/elastic/elasticsearch/commit/c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-13T03:24:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc1OTk2NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522759964", "bodyText": "Percentiles and PercentilesRanks are coupled yet they have a different style in declaration. Looking at the code I can't remember why that is however the TODO can be important - unless you have a conclusion for it and the impact of keyed, do not remove it.", "author": "costin", "createdAt": "2020-11-13T07:59:39Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentilesAgg.java", "diffHunk": "@@ -16,21 +15,18 @@\n public class PercentilesAgg extends DefaultAggSourceLeafAgg {\n \n     private final List<Double> percents;\n+    private final PercentilesConfig percentilesConfig;\n \n-    public PercentilesAgg(String id, AggSource source, List<Double> percents) {\n+    public PercentilesAgg(String id, AggSource source, List<Double> percents, PercentilesConfig percentilesConfig) {\n         super(id, source);\n         this.percents = percents;\n-    }\n-    \n-    @Override\n-    AggregationBuilder toBuilder() {\n-        // TODO: look at keyed\n-        PercentilesAggregationBuilder builder = (PercentilesAggregationBuilder) super.toBuilder();\n-        return builder.percentiles(percents.stream().mapToDouble(Double::doubleValue).toArray());\n+        this.percentilesConfig = percentilesConfig;\n     }\n \n     @Override\n     Function<String, ValuesSourceAggregationBuilder<?>> builder() {\n-        return AggregationBuilders::percentiles;\n+        return s -> AggregationBuilders.percentiles(s)\n+            .percentiles(percents.stream().mapToDouble(Double::doubleValue).toArray())\n+            .percentilesConfig(percentilesConfig);", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MzQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524393439", "bodyText": "About the TODO: Based on commit history this TODO was last touched last time in this feature branch merge 3 years ago. Keyed refers to keyed here. I am not changing behaviour here, by default keyed: true is used both for Percentiles and PercentileRanks before and after this change. Although the TODO might be important, it is 3 years old and it does not describe how could we resolve it and I don't see why we would switch to keyed: false. I'd remove it.", "author": "palesz", "createdAt": "2020-11-16T16:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc1OTk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentilesAgg.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentilesAgg.java\nindex cd75f94561f..f66dd0eb490 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentilesAgg.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentilesAgg.java\n\n@@ -29,4 +29,4 @@ public class PercentilesAgg extends DefaultAggSourceLeafAgg {\n             .percentiles(percents.stream().mapToDouble(Double::doubleValue).toArray())\n             .percentilesConfig(percentilesConfig);\n     }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NDAzNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522784036", "bodyText": "Unless this method is used in multiple places, I would not promote it to TypeResolution.\nThe name also looks incorrect, isEnum but there's no enum in the args - if I'm guessing the intent correctly, pass an Enum along side a translating function so the object/string mapping is generalized:\n<E extends Enum<E>> isStringInEnum(Expression e, Function<Enum<E>, String> value, Enum<E> e, String operationName, ParamOrdinal paramOrd)\nThis however seems too complicated for a narrow case, just checking a string inside a list of strings is much more common but that should be reflected in the name.", "author": "costin", "createdAt": "2020-11-13T08:22:22Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java", "diffHunk": "@@ -45,6 +46,29 @@ public static TypeResolution isIP(Expression e, String operationName, ParamOrdin\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n+    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NzUzMg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525547532", "bodyText": "Removed from TypeResolutions.", "author": "palesz", "createdAt": "2020-11-17T21:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NDAzNg=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\nindex 3079aba34be..42a5bce7b9f 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n\n@@ -46,29 +45,6 @@ public final class TypeResolutions {\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n-    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {\n-        TypeResolution resolution = isFoldable(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        resolution = isString(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        String value = (String)e.fold();\n-        if (acceptedValues.contains(value) == false) {\n-            return new TypeResolution(format(null, \"{}argument of [{}] must be a string, one of {}, received [{}]\",\n-                paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? \"\" : paramOrd.name().toLowerCase(Locale.ROOT) + \" \",\n-                operationName,\n-                acceptedValues,\n-                value));\n-        }\n-\n-        return TypeResolution.TYPE_RESOLVED;\n-    }\n-\n     public static TypeResolution isExact(Expression e, String message) {\n         if (e instanceof FieldAttribute) {\n             EsField.Exact exact = ((FieldAttribute) e).getExactInfo();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NDY5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522784693", "bodyText": "Yet again an issue with formatting - please fix it.", "author": "costin", "createdAt": "2020-11-13T08:23:04Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java", "diffHunk": "@@ -45,6 +46,29 @@ public static TypeResolution isIP(Expression e, String operationName, ParamOrdin\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n+    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {\n+        TypeResolution resolution = isFoldable(e, operationName, paramOrd);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        resolution = isString(e, operationName, paramOrd);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        String value = (String)e.fold();", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NzU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525547590", "bodyText": "Thanks. Reimported formatting options from buildSrc.", "author": "palesz", "createdAt": "2020-11-17T21:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NDY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\nindex 3079aba34be..42a5bce7b9f 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n\n@@ -46,29 +45,6 @@ public final class TypeResolutions {\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n-    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {\n-        TypeResolution resolution = isFoldable(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        resolution = isString(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        String value = (String)e.fold();\n-        if (acceptedValues.contains(value) == false) {\n-            return new TypeResolution(format(null, \"{}argument of [{}] must be a string, one of {}, received [{}]\",\n-                paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? \"\" : paramOrd.name().toLowerCase(Locale.ROOT) + \" \",\n-                operationName,\n-                acceptedValues,\n-                value));\n-        }\n-\n-        return TypeResolution.TYPE_RESOLVED;\n-    }\n-\n     public static TypeResolution isExact(Expression e, String message) {\n         if (e instanceof FieldAttribute) {\n             EsField.Exact exact = ((FieldAttribute) e).getExactInfo();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NjkxNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522786916", "bodyText": "The initial order is more readable - start with OptionalArgument, second TwoOptionalArguments", "author": "costin", "createdAt": "2020-11-13T08:25:06Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -420,16 +420,23 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     public static <T extends Function> FunctionDefinition def(Class<T> function,\n             FourParametersFunctionBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, distinct, cfg) -> {\n-            boolean hasMinimumThree = OptionalArgument.class.isAssignableFrom(function);\n-            if (hasMinimumThree && (children.size() > 4 || children.size() < 3)) {\n-                throw new QlIllegalArgumentException(\"expects three or four arguments\");\n-            } else if (!hasMinimumThree && children.size() != 4) {\n+            if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 2) {\n+                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n+                }\n+            } else if (OptionalArgument.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 3) {\n+                    throw new QlIllegalArgumentException(\"expects three or four arguments\");\n+                }\n+            } else if (children.size() != 4) {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0NzkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525547939", "bodyText": "\ud83d\udc4d  flipped.", "author": "palesz", "createdAt": "2020-11-17T21:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4NjkxNg=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\nindex 181f707f65a..874cb9e98e5 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\n\n@@ -420,21 +420,21 @@ public class FunctionRegistry {\n     public static <T extends Function> FunctionDefinition def(Class<T> function,\n             FourParametersFunctionBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, distinct, cfg) -> {\n-            if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n-                if (children.size() > 4 || children.size() < 2) {\n-                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n-                }\n-            } else if (OptionalArgument.class.isAssignableFrom(function)) {\n+            if (OptionalArgument.class.isAssignableFrom(function)) {\n                 if (children.size() > 4 || children.size() < 3) {\n                     throw new QlIllegalArgumentException(\"expects three or four arguments\");\n                 }\n+            } else if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 2) {\n+                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n+                }\n             } else if (children.size() != 4) {\n                 throw new QlIllegalArgumentException(\"expects exactly four arguments\");\n             }\n             if (distinct) {\n                 throw new QlIllegalArgumentException(\"does not support DISTINCT yet it was specified\");\n             }\n-            return ctorRef.build(source, children.get(0), children.get(1),\n+            return ctorRef.build(source, children.get(0), children.get(1), \n                 children.size() > 2 ? children.get(2) : null,\n                 children.size() > 3 ? children.get(3) : null);\n         };\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4ODE2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522788167", "bodyText": "Extract the children extraction the ifs above - it's easier to understand what branch did what.", "author": "costin", "createdAt": "2020-11-13T08:26:09Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -420,16 +420,23 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     public static <T extends Function> FunctionDefinition def(Class<T> function,\n             FourParametersFunctionBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, distinct, cfg) -> {\n-            boolean hasMinimumThree = OptionalArgument.class.isAssignableFrom(function);\n-            if (hasMinimumThree && (children.size() > 4 || children.size() < 3)) {\n-                throw new QlIllegalArgumentException(\"expects three or four arguments\");\n-            } else if (!hasMinimumThree && children.size() != 4) {\n+            if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 2) {\n+                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n+                }\n+            } else if (OptionalArgument.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 3) {\n+                    throw new QlIllegalArgumentException(\"expects three or four arguments\");\n+                }\n+            } else if (children.size() != 4) {\n                 throw new QlIllegalArgumentException(\"expects exactly four arguments\");\n             }\n             if (distinct) {\n                 throw new QlIllegalArgumentException(\"does not support DISTINCT yet it was specified\");\n             }\n-            return ctorRef.build(source, children.get(0), children.get(1), children.get(2), children.size() == 4 ? children.get(3) : null);\n+            return ctorRef.build(source, children.get(0), children.get(1),\n+                children.size() > 2 ? children.get(2) : null,", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\nindex 181f707f65a..874cb9e98e5 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java\n\n@@ -420,21 +420,21 @@ public class FunctionRegistry {\n     public static <T extends Function> FunctionDefinition def(Class<T> function,\n             FourParametersFunctionBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, distinct, cfg) -> {\n-            if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n-                if (children.size() > 4 || children.size() < 2) {\n-                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n-                }\n-            } else if (OptionalArgument.class.isAssignableFrom(function)) {\n+            if (OptionalArgument.class.isAssignableFrom(function)) {\n                 if (children.size() > 4 || children.size() < 3) {\n                     throw new QlIllegalArgumentException(\"expects three or four arguments\");\n                 }\n+            } else if (TwoOptionalArguments.class.isAssignableFrom(function)) {\n+                if (children.size() > 4 || children.size() < 2) {\n+                    throw new QlIllegalArgumentException(\"expects minimum two, maximum four arguments\");\n+                }\n             } else if (children.size() != 4) {\n                 throw new QlIllegalArgumentException(\"expects exactly four arguments\");\n             }\n             if (distinct) {\n                 throw new QlIllegalArgumentException(\"does not support DISTINCT yet it was specified\");\n             }\n-            return ctorRef.build(source, children.get(0), children.get(1),\n+            return ctorRef.build(source, children.get(0), children.get(1), \n                 children.size() > 2 ? children.get(2) : null,\n                 children.size() > 3 ? children.get(3) : null);\n         };\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4OTA3MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522789070", "bodyText": "This method is not tied to functions, has a clunky name and bad names - countOf -> return shift?.\nPlease remove it.", "author": "costin", "createdAt": "2020-11-13T08:26:57Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/Functions.java", "diffHunk": "@@ -18,4 +18,12 @@ public static boolean isAggregate(Expression e) {\n     public static boolean isGrouping(Expression e) {\n         return e instanceof GroupingFunction;\n     }\n-}\n\\ No newline at end of file\n+\n+    public static int countOfNonNullOptionalArgs(Object... args) {\n+        int shift = 0;\n+        for (Object a : args) {\n+            shift += a == null ? 0 : 1;\n+        }\n+        return shift;\n+    }", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525551715", "bodyText": "Removed.", "author": "palesz", "createdAt": "2020-11-17T21:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4OTA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/Functions.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/Functions.java\nindex 8fe0e9dae10..6da5f053034 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/Functions.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/Functions.java\n\n@@ -18,12 +18,4 @@ public abstract class Functions {\n     public static boolean isGrouping(Expression e) {\n         return e instanceof GroupingFunction;\n     }\n-\n-    public static int countOfNonNullOptionalArgs(Object... args) {\n-        int shift = 0;\n-        for (Object a : args) {\n-            shift += a == null ? 0 : 1;\n-        }\n-        return shift;\n-    }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5MjI4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522792280", "bodyText": "Instead of an in-line stream creation/filtering/collection inside a super invocation (a no-no), extract this into a static utility method.", "author": "costin", "createdAt": "2020-11-13T08:29:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -16,31 +17,44 @@\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n \n     private final Expression percent;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, Stream.of(percent, (method = defaultMethod(source, method)),\n+            (methodParameter = defaultMethodParameter(methodParameter))).filter(Objects::nonNull).collect(Collectors.toList()));", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTgwMw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525555803", "bodyText": "After making the method and methodParameter a property only, this change is not required.", "author": "palesz", "createdAt": "2020-11-17T22:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5MjI4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex ee1a2567502..71f823781d8 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -16,27 +19,28 @@ import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Objects;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression percent;\n     private final Expression method;\n     private final Expression methodParameter;\n \n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, Stream.of(percent, (method = defaultMethod(source, method)),\n-            (methodParameter = defaultMethodParameter(methodParameter))).filter(Objects::nonNull).collect(Collectors.toList()));\n+        super(source, field, Collections.singletonList(percent));\n         this.percent = percent;\n         this.method = method;\n         this.methodParameter = methodParameter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5MzExOA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522793118", "bodyText": "This should be static check not a dynamic one.", "author": "costin", "createdAt": "2020-11-13T08:30:21Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -16,31 +17,44 @@\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n \n     private final Expression percent;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, Stream.of(percent, (method = defaultMethod(source, method)),\n+            (methodParameter = defaultMethodParameter(methodParameter))).filter(Objects::nonNull).collect(Collectors.toList()));\n         this.percent = percent;\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method, methodParameter);\n     }\n \n     @Override\n     public Percentile replaceChildren(List<Expression> newChildren) {\n-        if (newChildren.size() != 2) {\n-            throw new IllegalArgumentException(\"expected [2] children but received [\" + newChildren.size() + \"]\");\n+        if (children().size() != newChildren.size()) {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525555721", "bodyText": "After I moved the method and methodParameter to properties only, this code change is not required.", "author": "palesz", "createdAt": "2020-11-17T22:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5MzExOA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex ee1a2567502..71f823781d8 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -16,27 +19,28 @@ import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Objects;\n+import java.util.Set;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression percent;\n     private final Expression method;\n     private final Expression methodParameter;\n \n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, Stream.of(percent, (method = defaultMethod(source, method)),\n-            (methodParameter = defaultMethodParameter(methodParameter))).filter(Objects::nonNull).collect(Collectors.toList()));\n+        super(source, field, Collections.singletonList(percent));\n         this.percent = percent;\n         this.method = method;\n         this.methodParameter = methodParameter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NTQ0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522795444", "bodyText": "Why is there a need for isEnum if the methodParam is checked again to be folded and then checked against the enum values itself?\nFurther more the point of type resolution is to not throw exceptions but return error messages.", "author": "costin", "createdAt": "2020-11-13T08:32:31Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxMTcyMw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524411723", "bodyText": "Will simplify this part.", "author": "palesz", "createdAt": "2020-11-16T16:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522797679", "bodyText": "This class needs rework - it's hard to understand its purpose and style. The code both goes multiple checks and does either enum to string or directly on string validation.\nThere should be only one way and if there's a dedicated class, make that customized for the enum it tries to handle.", "author": "costin", "createdAt": "2020-11-13T08:34:43Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTIxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525555211", "bodyText": "Agreed, dissolved this class and tried to simplify the code.", "author": "palesz", "createdAt": "2020-11-17T22:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzkwNA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522797904", "bodyText": "Two methods doing similar checks for null and folding.", "author": "costin", "createdAt": "2020-11-13T08:35:08Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n+                + Arrays.toString(PercentilesMethod.values()));\n+        }\n+        return percentilesMethod;\n+    }\n+\n+    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n+        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return (T) null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    private static Expression nullIfUnspecified(Expression e) {\n+        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n+    }", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMjIyOA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522802228", "bodyText": "arguments -> args", "author": "costin", "createdAt": "2020-11-13T08:43:28Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1008,37 +1008,34 @@ public LogicalPlan apply(LogicalPlan p) {\n \n     static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n \n+        private List<Expression> keyOf(Percentile per) {\n+            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        }\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per field/expression\n-            Map<Expression, Set<Expression>> percentsPerField = new LinkedHashMap<>();\n+            // percentile per (field/expression, method, methodparameters)\n+            Map<List<Expression>, Set<Expression>> percentsPerArgs = new LinkedHashMap<>();\n \n             // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    Expression field = per.field();\n-                    Set<Expression> percentiles = percentsPerField.get(field);\n-\n-                    if (percentiles == null) {\n-                        percentiles = new LinkedHashSet<>();\n-                        percentsPerField.put(field, percentiles);\n-                    }\n-\n-                    percentiles.add(per.percent());\n+                    percentsPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.percent());\n                 }\n             });\n \n-            Map<Expression, Percentiles> percentilesPerField = new LinkedHashMap<>();\n-            // create a Percentile agg for each field (and its associated percents)\n-            percentsPerField.forEach((k, v) -> {\n-                percentilesPerField.put(k, new Percentiles(v.iterator().next().source(), k, new ArrayList<>(v)));\n-            });\n+            // create a Percentile agg for each argument combination\n+            Map<List<Expression>, Percentiles> percentilesPerArgs = new LinkedHashMap<>();\n+            percentsPerArgs.forEach((arguments, percents) -> percentilesPerArgs.put(", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTI5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525569299", "bodyText": "\ud83d\udc4d", "author": "palesz", "createdAt": "2020-11-17T22:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMjIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex d3477e7ad6a..3be5e890505 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1006,36 +1008,68 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n         }\n     }\n \n-    static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n+    private static class PercentileArgumentCombination {\n+        final Expression field;\n+        final PercentilesConfig config;\n+        final Expression method;\n+        final Expression methodParameter;\n+\n+        PercentileArgumentCombination(Percentile per) {\n+            this.field = per.field();\n+            this.method = per.method();\n+            this.methodParameter = per.methodParameter();\n+            this.config = per.percentileConfig();\n+        }\n+\n+        PercentileArgumentCombination(PercentileRank per) {\n+            this.field = per.field();\n+            this.method = per.method();\n+            this.methodParameter = per.methodParameter();\n+            this.config = per.percentileConfig();\n+        }\n \n-        private List<Expression> keyOf(Percentile per) {\n-            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            PercentileArgumentCombination that = (PercentileArgumentCombination) o;\n+\n+            return field.equals(that.field) && Objects.equals(config, that.config);\n         }\n \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(field, config);\n+        }\n+    }\n+\n+    static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per (field/expression, method, methodparameters)\n-            Map<List<Expression>, Set<Expression>> percentsPerArgs = new LinkedHashMap<>();\n+            Map<PercentileArgumentCombination, Set<Expression>> distinctPercentsPerArgs = new LinkedHashMap<>();\n \n-            // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    percentsPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.percent());\n+                    distinctPercentsPerArgs.computeIfAbsent(new PercentileArgumentCombination(per), k -> new LinkedHashSet<>())\n+                        .add(per.percent());\n                 }\n             });\n \n             // create a Percentile agg for each argument combination\n-            Map<List<Expression>, Percentiles> percentilesPerArgs = new LinkedHashMap<>();\n-            percentsPerArgs.forEach((arguments, percents) -> percentilesPerArgs.put(\n-                    arguments,\n+            Map<PercentileArgumentCombination, Percentiles> percentilesPerArgs = new LinkedHashMap<>();\n+            distinctPercentsPerArgs.forEach((args, percents) -> percentilesPerArgs.put(\n+                    args,\n                     new Percentiles(percents.iterator().next().source(),\n-                        arguments.get(0), arguments.get(1), arguments.get(2), new ArrayList<>(percents))));\n+                        args.field, new ArrayList<>(percents), args.method, args.methodParameter)));\n \n             return p.transformExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    Percentiles percentiles = percentilesPerArgs.get(keyOf(per));\n+                    PercentileArgumentCombination a = new PercentileArgumentCombination(per);\n+                    Percentiles percentiles = percentilesPerArgs.get(a);\n                     return new InnerAggregate(per, percentiles);\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522803230", "bodyText": "Readjust the comments.", "author": "costin", "createdAt": "2020-11-13T08:44:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1049,37 +1046,33 @@ public LogicalPlan apply(LogicalPlan p) {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n+        private List<Expression> keyOf(PercentileRank per) {\n+            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        }\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n             // percentile per field/expression\n-            final Map<Expression, Set<Expression>> percentPerField = new LinkedHashMap<>();\n+            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n \n             // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    Expression field = per.field();\n-                    Set<Expression> percentiles = percentPerField.get(field);\n-\n-                    if (percentiles == null) {\n-                        percentiles = new LinkedHashSet<>();\n-                        percentPerField.put(field, percentiles);\n-                    }\n-\n-                    percentiles.add(per.value());\n+                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());\n                 }\n             });\n \n-            Map<Expression, PercentileRanks> ranksPerField = new LinkedHashMap<>();\n-            // create a PercentileRanks agg for each field (and its associated values)\n-            percentPerField.forEach((k, v) -> {\n-                ranksPerField.put(k, new PercentileRanks(v.iterator().next().source(), k, new ArrayList<>(v)));\n-            });\n+            Map<List<Expression>, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n+            valuesPerArgs.forEach((arguments, values) -> ranksPerArgs.put(", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTU5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525569599", "bodyText": "Reorganized the code a bit, after that removed the comments that seemed redundant.", "author": "palesz", "createdAt": "2020-11-17T22:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzIzMA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex d3477e7ad6a..3be5e890505 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1046,33 +1080,29 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n-        private List<Expression> keyOf(PercentileRank per) {\n-            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n-        }\n-\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per field/expression\n-            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n+            final Map<PercentileArgumentCombination, Set<Expression>> distinctValuesPerArgs = new LinkedHashMap<>();\n \n-            // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());\n+                    distinctValuesPerArgs.computeIfAbsent(new PercentileArgumentCombination(per), k -> new LinkedHashSet<>())\n+                        .add(per.value());\n                 }\n             });\n \n-            Map<List<Expression>, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n-            valuesPerArgs.forEach((arguments, values) -> ranksPerArgs.put(\n-                arguments,\n+            // create a PercentileRank agg for each argument combination\n+            Map<PercentileArgumentCombination, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n+            distinctValuesPerArgs.forEach((args, values) -> ranksPerArgs.put(\n+                args,\n                 new PercentileRanks(values.iterator().next().source(),\n-                    arguments.get(0), arguments.get(1), arguments.get(2), new ArrayList<>(values))));\n+                    args.field, new ArrayList<>(values), args.method, args.methodParameter)));\n \n             return p.transformExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    PercentileRanks ranks = ranksPerArgs.get(keyOf(per));\n+                    PercentileRanks ranks = ranksPerArgs.get(new PercentileArgumentCombination(per));\n                     return new InnerAggregate(per, ranks);\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522803337", "bodyText": "arguments -> args", "author": "costin", "createdAt": "2020-11-13T08:44:47Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1049,37 +1046,33 @@ public LogicalPlan apply(LogicalPlan p) {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n+        private List<Expression> keyOf(PercentileRank per) {\n+            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        }\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n             // percentile per field/expression\n-            final Map<Expression, Set<Expression>> percentPerField = new LinkedHashMap<>();\n+            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n \n             // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    Expression field = per.field();\n-                    Set<Expression> percentiles = percentPerField.get(field);\n-\n-                    if (percentiles == null) {\n-                        percentiles = new LinkedHashSet<>();\n-                        percentPerField.put(field, percentiles);\n-                    }\n-\n-                    percentiles.add(per.value());\n+                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());\n                 }\n             });\n \n-            Map<Expression, PercentileRanks> ranksPerField = new LinkedHashMap<>();\n-            // create a PercentileRanks agg for each field (and its associated values)\n-            percentPerField.forEach((k, v) -> {\n-                ranksPerField.put(k, new PercentileRanks(v.iterator().next().source(), k, new ArrayList<>(v)));\n-            });\n+            Map<List<Expression>, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n+            valuesPerArgs.forEach((arguments, values) -> ranksPerArgs.put(\n+                arguments,", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex d3477e7ad6a..3be5e890505 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1046,33 +1080,29 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n-        private List<Expression> keyOf(PercentileRank per) {\n-            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n-        }\n-\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per field/expression\n-            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n+            final Map<PercentileArgumentCombination, Set<Expression>> distinctValuesPerArgs = new LinkedHashMap<>();\n \n-            // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());\n+                    distinctValuesPerArgs.computeIfAbsent(new PercentileArgumentCombination(per), k -> new LinkedHashSet<>())\n+                        .add(per.value());\n                 }\n             });\n \n-            Map<List<Expression>, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n-            valuesPerArgs.forEach((arguments, values) -> ranksPerArgs.put(\n-                arguments,\n+            // create a PercentileRank agg for each argument combination\n+            Map<PercentileArgumentCombination, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n+            distinctValuesPerArgs.forEach((args, values) -> ranksPerArgs.put(\n+                args,\n                 new PercentileRanks(values.iterator().next().source(),\n-                    arguments.get(0), arguments.get(1), arguments.get(2), new ArrayList<>(values))));\n+                    args.field, new ArrayList<>(values), args.method, args.methodParameter)));\n \n             return p.transformExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    PercentileRanks ranks = ranksPerArgs.get(keyOf(per));\n+                    PercentileRanks ranks = ranksPerArgs.get(new PercentileArgumentCombination(per));\n                     return new InnerAggregate(per, ranks);\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522803529", "bodyText": "\ud83d\udc4d", "author": "costin", "createdAt": "2020-11-13T08:45:00Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1049,37 +1046,33 @@ public LogicalPlan apply(LogicalPlan p) {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n+        private List<Expression> keyOf(PercentileRank per) {\n+            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        }\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n             // percentile per field/expression\n-            final Map<Expression, Set<Expression>> percentPerField = new LinkedHashMap<>();\n+            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n \n             // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    Expression field = per.field();\n-                    Set<Expression> percentiles = percentPerField.get(field);\n-\n-                    if (percentiles == null) {\n-                        percentiles = new LinkedHashSet<>();\n-                        percentPerField.put(field, percentiles);\n-                    }\n-\n-                    percentiles.add(per.value());\n+                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex d3477e7ad6a..3be5e890505 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1046,33 +1080,29 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n \n     static class ReplaceAggsWithPercentileRanks extends OptimizerBasicRule {\n \n-        private List<Expression> keyOf(PercentileRank per) {\n-            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n-        }\n-\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per field/expression\n-            final Map<List<Expression>, Set<Expression>> valuesPerArgs = new LinkedHashMap<>();\n+            final Map<PercentileArgumentCombination, Set<Expression>> distinctValuesPerArgs = new LinkedHashMap<>();\n \n-            // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    valuesPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.value());\n+                    distinctValuesPerArgs.computeIfAbsent(new PercentileArgumentCombination(per), k -> new LinkedHashSet<>())\n+                        .add(per.value());\n                 }\n             });\n \n-            Map<List<Expression>, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n-            valuesPerArgs.forEach((arguments, values) -> ranksPerArgs.put(\n-                arguments,\n+            // create a PercentileRank agg for each argument combination\n+            Map<PercentileArgumentCombination, PercentileRanks> ranksPerArgs = new LinkedHashMap<>();\n+            distinctValuesPerArgs.forEach((args, values) -> ranksPerArgs.put(\n+                args,\n                 new PercentileRanks(values.iterator().next().source(),\n-                    arguments.get(0), arguments.get(1), arguments.get(2), new ArrayList<>(values))));\n+                    args.field, new ArrayList<>(values), args.method, args.methodParameter)));\n \n             return p.transformExpressionsUp(e -> {\n                 if (e instanceof PercentileRank) {\n                     PercentileRank per = (PercentileRank) e;\n-                    PercentileRanks ranks = ranksPerArgs.get(keyOf(per));\n+                    PercentileRanks ranks = ranksPerArgs.get(new PercentileArgumentCombination(per));\n                     return new InnerAggregate(per, ranks);\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzcyMg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r522803722", "bodyText": "\ud83d\udc4d", "author": "costin", "createdAt": "2020-11-13T08:45:10Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1008,37 +1008,34 @@ public LogicalPlan apply(LogicalPlan p) {\n \n     static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n \n+        private List<Expression> keyOf(Percentile per) {\n+            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        }\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per field/expression\n-            Map<Expression, Set<Expression>> percentsPerField = new LinkedHashMap<>();\n+            // percentile per (field/expression, method, methodparameters)\n+            Map<List<Expression>, Set<Expression>> percentsPerArgs = new LinkedHashMap<>();\n \n             // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    Expression field = per.field();\n-                    Set<Expression> percentiles = percentsPerField.get(field);\n-\n-                    if (percentiles == null) {\n-                        percentiles = new LinkedHashSet<>();\n-                        percentsPerField.put(field, percentiles);\n-                    }\n-\n-                    percentiles.add(per.percent());\n+                    percentsPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.percent());", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex d3477e7ad6a..3be5e890505 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1006,36 +1008,68 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n         }\n     }\n \n-    static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n+    private static class PercentileArgumentCombination {\n+        final Expression field;\n+        final PercentilesConfig config;\n+        final Expression method;\n+        final Expression methodParameter;\n+\n+        PercentileArgumentCombination(Percentile per) {\n+            this.field = per.field();\n+            this.method = per.method();\n+            this.methodParameter = per.methodParameter();\n+            this.config = per.percentileConfig();\n+        }\n+\n+        PercentileArgumentCombination(PercentileRank per) {\n+            this.field = per.field();\n+            this.method = per.method();\n+            this.methodParameter = per.methodParameter();\n+            this.config = per.percentileConfig();\n+        }\n \n-        private List<Expression> keyOf(Percentile per) {\n-            return Arrays.asList(per.field(), per.method(), per.methodParameter());\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            PercentileArgumentCombination that = (PercentileArgumentCombination) o;\n+\n+            return field.equals(that.field) && Objects.equals(config, that.config);\n         }\n \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(field, config);\n+        }\n+    }\n+\n+    static class ReplaceAggsWithPercentiles extends OptimizerBasicRule {\n+\n         @Override\n         public LogicalPlan apply(LogicalPlan p) {\n-            // percentile per (field/expression, method, methodparameters)\n-            Map<List<Expression>, Set<Expression>> percentsPerArgs = new LinkedHashMap<>();\n+            Map<PercentileArgumentCombination, Set<Expression>> distinctPercentsPerArgs = new LinkedHashMap<>();\n \n-            // count gather the percents for each field\n             p.forEachExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    percentsPerArgs.computeIfAbsent(keyOf(per), k -> new LinkedHashSet<>()).add(per.percent());\n+                    distinctPercentsPerArgs.computeIfAbsent(new PercentileArgumentCombination(per), k -> new LinkedHashSet<>())\n+                        .add(per.percent());\n                 }\n             });\n \n             // create a Percentile agg for each argument combination\n-            Map<List<Expression>, Percentiles> percentilesPerArgs = new LinkedHashMap<>();\n-            percentsPerArgs.forEach((arguments, percents) -> percentilesPerArgs.put(\n-                    arguments,\n+            Map<PercentileArgumentCombination, Percentiles> percentilesPerArgs = new LinkedHashMap<>();\n+            distinctPercentsPerArgs.forEach((args, percents) -> percentilesPerArgs.put(\n+                    args,\n                     new Percentiles(percents.iterator().next().source(),\n-                        arguments.get(0), arguments.get(1), arguments.get(2), new ArrayList<>(percents))));\n+                        args.field, new ArrayList<>(percents), args.method, args.methodParameter)));\n \n             return p.transformExpressionsUp(e -> {\n                 if (e instanceof Percentile) {\n                     Percentile per = (Percentile) e;\n-                    Percentiles percentiles = percentilesPerArgs.get(keyOf(per));\n+                    PercentileArgumentCombination a = new PercentileArgumentCombination(per);\n+                    Percentiles percentiles = percentilesPerArgs.get(a);\n                     return new InnerAggregate(per, percentiles);\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMxNDk0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524314940", "bodyText": "You could place this method in Percentile class and then re-use it in other places as well.", "author": "astefan", "createdAt": "2020-11-16T14:38:28Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NDgxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525554810", "bodyText": "Removed, not needed anymore.", "author": "palesz", "createdAt": "2020-11-17T22:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMxNDk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMyMTEwNw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524321107", "bodyText": "(thinking out loud here) Isn't there a difference between a foldable-to-null expression and a null expression in this context? Meaning, a null parameter for a function that has that parameter optional is different than the expression being there, being foldable and being folded to null.", "author": "astefan", "createdAt": "2020-11-16T14:46:32Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n+                + Arrays.toString(PercentilesMethod.values()));\n+        }\n+        return percentilesMethod;\n+    }\n+\n+    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n+        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return (T) null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    private static Expression nullIfUnspecified(Expression e) {\n+        return e == null || (e.foldable() && e.fold() == null) ? null : e;", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1Mzg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525553889", "bodyText": "There is a difference, but see the tests, I don't want to differentiate between specifying NULL for the methodParameter or not specifying the methodParameter at all. Nonetheless, removed this method with the latest change.", "author": "palesz", "createdAt": "2020-11-17T22:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMyMTEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMyMjU3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524322571", "bodyText": "If this method is really needed, it should belong to Expressions class.", "author": "astefan", "createdAt": "2020-11-16T14:48:25Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n+                + Arrays.toString(PercentilesMethod.values()));\n+        }\n+        return percentilesMethod;\n+    }\n+\n+    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n+        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return (T) null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    private static Expression nullIfUnspecified(Expression e) {", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMyNzMzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524327331", "bodyText": "After this line you could break.", "author": "astefan", "createdAt": "2020-11-16T14:54:42Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NDYxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525554619", "bodyText": "\ud83d\udc4d", "author": "palesz", "createdAt": "2020-11-17T22:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMyNzMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524355252", "bodyText": "I think here you need to not throw an exception, but create a TypeResolution to express the inconsistency.", "author": "astefan", "createdAt": "2020-11-16T15:31:51Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NDY3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525554679", "bodyText": "Removed this one.", "author": "palesz", "createdAt": "2020-11-17T22:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NTI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NTU5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524355594", "bodyText": "Here the same. About TypeResolution instead of Exception.", "author": "astefan", "createdAt": "2020-11-16T15:32:16Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.Literal;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+\n+public abstract class PercentileMethodConfiguration {\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    public static Expression defaultMethod(Source source, Expression method) {\n+        return method == null\n+            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n+            : method;\n+    }\n+\n+    public static Expression defaultMethodParameter(Expression methodParameter) {\n+        return nullIfUnspecified(methodParameter);\n+    }\n+\n+    public static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        if (methodParameter != null) {\n+            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+            switch (percentilesMethod) {\n+                case TDIGEST:\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                case HDR:\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                    break;\n+                default:\n+                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n+            }\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+        return resolution;\n+    }\n+\n+    private static PercentilesMethod asPercentilesMethod(Expression method) {\n+        PercentilesMethod percentilesMethod = null;\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n+                + Arrays.toString(PercentilesMethod.values()));\n+        }\n+        return percentilesMethod;\n+    }\n+\n+    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n+        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NDQ0OA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525554448", "bodyText": "Moved this method elsewhere and converted to IllegalStateException (can only happen if the code does not handle all the possible PercentileMethods).", "author": "palesz", "createdAt": "2020-11-17T22:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NTU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\ndeleted file mode 100644\nindex 97d71852b7e..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileMethodConfiguration.java\n+++ /dev/null\n\n@@ -1,119 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.QlIllegalArgumentException;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.Literal;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isEnum;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n-public abstract class PercentileMethodConfiguration {\n-\n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    public static Expression defaultMethod(Source source, Expression method) {\n-        return method == null\n-            ? new Literal(source, PercentilesMethod.TDIGEST.getParseField().getPreferredName(), DataTypes.KEYWORD)\n-            : method;\n-    }\n-\n-    public static Expression defaultMethodParameter(Expression methodParameter) {\n-        return nullIfUnspecified(methodParameter);\n-    }\n-\n-    public static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        Expression.TypeResolution resolution = isEnum(method, sourceText, methodOrdinal, ACCEPTED_METHODS);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        if (methodParameter != null) {\n-            resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-            switch (percentilesMethod) {\n-                case TDIGEST:\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                case HDR:\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                    break;\n-                default:\n-                    throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-            }\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-        }\n-        return resolution;\n-    }\n-\n-    private static PercentilesMethod asPercentilesMethod(Expression method) {\n-        PercentilesMethod percentilesMethod = null;\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new QlIllegalArgumentException(\"specified method [ \" + methodName + \" ] is not one of the allowed methods \"\n-                + Arrays.toString(PercentilesMethod.values()));\n-        }\n-        return percentilesMethod;\n-    }\n-\n-    public static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        PercentilesMethod percentilesMethod = asPercentilesMethod(method);\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new QlIllegalArgumentException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"]\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return (T) null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    private static Expression nullIfUnspecified(Expression e) {\n-        return e == null || (e.foldable() && e.fold() == null) ? null : e;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NDUyNA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524364524", "bodyText": "The error message is a bit messed up. This is how it looks with actual values in it: third argument of [PERCENTILE(int, 50, null)] must be a string, one of [tdigest, hdr], received [null]. How about third argument of [PERCENTILE(int, 50, null)] must be one of [tdigest, hdr], received [null]? To me it seems more clear and concise.", "author": "astefan", "createdAt": "2020-11-16T15:43:37Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java", "diffHunk": "@@ -45,6 +46,29 @@ public static TypeResolution isIP(Expression e, String operationName, ParamOrdin\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n+    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {\n+        TypeResolution resolution = isFoldable(e, operationName, paramOrd);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        resolution = isString(e, operationName, paramOrd);\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        String value = (String)e.fold();\n+        if (acceptedValues.contains(value) == false) {\n+            return new TypeResolution(format(null, \"{}argument of [{}] must be a string, one of {}, received [{}]\",", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0Nzc3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525547777", "bodyText": "Thanks for the suggestion, updated the error message.", "author": "palesz", "createdAt": "2020-11-17T21:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NDUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\nindex 3079aba34be..42a5bce7b9f 100644\n--- a/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n+++ b/x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/TypeResolutions.java\n\n@@ -46,29 +45,6 @@ public final class TypeResolutions {\n         return isType(e, dt -> dt == IP, operationName, paramOrd, \"ip\");\n     }\n \n-    public static TypeResolution isEnum(Expression e, String operationName, ParamOrdinal paramOrd, Set<String> acceptedValues) {\n-        TypeResolution resolution = isFoldable(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        resolution = isString(e, operationName, paramOrd);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        String value = (String)e.fold();\n-        if (acceptedValues.contains(value) == false) {\n-            return new TypeResolution(format(null, \"{}argument of [{}] must be a string, one of {}, received [{}]\",\n-                paramOrd == null || paramOrd == ParamOrdinal.DEFAULT ? \"\" : paramOrd.name().toLowerCase(Locale.ROOT) + \" \",\n-                operationName,\n-                acceptedValues,\n-                value));\n-        }\n-\n-        return TypeResolution.TYPE_RESOLVED;\n-    }\n-\n     public static TypeResolution isExact(Expression e, String message) {\n         if (e instanceof FieldAttribute) {\n             EsField.Exact exact = ((FieldAttribute) e).getExactInfo();\n"}}, {"oid": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "url": "https://github.com/elastic/elasticsearch/commit/e43ab47e4a73d446f7f1d703d136710924cf0ff9", "message": "Refactor, PR suggestions\n\n* Removed the `method` and `methodParameter` from the `Node.children()\n`s (this way it also stops interacting with `FoldNull` unnecessarily)\n* Added examples for the documentation\n* Link the docs to the `percentiles()` aggregation documentation about\napproximations\n* Added extra testcases\n* Folds everything that results with the same `PercentileConfig` into a\nsingle aggregation.\n* Reverted the whitespace changes", "committedDate": "2020-11-17T23:36:32Z", "type": "commit"}, {"oid": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "url": "https://github.com/elastic/elasticsearch/commit/24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-17T23:36:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwMTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r524401064", "bodyText": "Callout: I have switched the parent class, so the part of Percentile and PercentileRank is the same. Any reason not to?", "author": "palesz", "createdAt": "2020-11-16T16:31:17Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -8,40 +8,52 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.AggregateFunction;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n \n-public class PercentileRank extends AggregateFunction implements EnclosedAgg {\n+public class PercentileRank extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n ", "originalCommit": "c6a39395f8ef683770e7834a1cbbae6470f2e5f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e43ab47e4a73d446f7f1d703d136710924cf0ff9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex 6929f42eb1d..c176925a9dd 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -15,27 +15,22 @@ import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-import static org.elasticsearch.xpack.ql.expression.function.Functions.countOfNonNullOptionalArgs;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethod;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.defaultMethodParameter;\n-import static org.elasticsearch.xpack.sql.expression.function.aggregate.PercentileMethodConfiguration.resolvePercentileConfiguration;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.Percentile.resolvePercentileConfiguration;\n \n-public class PercentileRank extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+public class PercentileRank extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression value;\n     private final Expression method;\n     private final Expression methodParameter;\n \n     public PercentileRank(Source source, Expression field, Expression value, Expression method, Expression methodParameter) {\n-        super(source, field, Stream.of(value, (method = defaultMethod(source, method)),\n-            (methodParameter = defaultMethodParameter(methodParameter))).filter(Objects::nonNull).collect(Collectors.toList()));\n+        super(source, field, Collections.singletonList(value));\n         this.value = value;\n         this.method = method;\n         this.methodParameter = methodParameter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzMzk0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525933945", "bodyText": "seems superfluous.", "author": "bpintea", "createdAt": "2020-11-18T09:25:34Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -72,4 +103,74 @@ public String innerName() {\n         Double value = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(percent), DataTypes.DOUBLE);\n         return Double.toString(value);\n     }\n+\n+    private static final Set<String> ACCEPTED_METHODS =\n+        Arrays.stream(PercentilesMethod.values()).map(pm -> pm.getParseField().getPreferredName()).collect(Collectors.toSet());\n+\n+    static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            if (ACCEPTED_METHODS.contains(methodName) == false) {\n+                return new Expression.TypeResolution(format(\n+                    null,\n+                    \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \",\n+                    sourceText,\n+                    Stream.of(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toList()),\n+                    methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                if (PercentilesMethod.TDIGEST.getParseField().getPreferredName().equals(methodName)) {\n+                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n+                } else if (PercentilesMethod.HDR.getParseField().getPreferredName().equals(methodName)) {\n+                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n+                } else {\n+                    throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+                }\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 71f823781d8..cd496d8c878 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -104,73 +72,5 @@ public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOpti\n         return Double.toString(value);\n     }\n \n-    private static final Set<String> ACCEPTED_METHODS =\n-        Arrays.stream(PercentilesMethod.values()).map(pm -> pm.getParseField().getPreferredName()).collect(Collectors.toSet());\n-\n-    static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            if (ACCEPTED_METHODS.contains(methodName) == false) {\n-                return new Expression.TypeResolution(format(\n-                    null,\n-                    \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \",\n-                    sourceText,\n-                    Stream.of(PercentilesMethod.values()).map(p -> p.getParseField().getPreferredName()).collect(Collectors.toList()),\n-                    methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                if (PercentilesMethod.TDIGEST.getParseField().getPreferredName().equals(methodName)) {\n-                    resolution = isNumeric(methodParameter, sourceText, methodParameterOrdinal);\n-                } else if (PercentilesMethod.HDR.getParseField().getPreferredName().equals(methodName)) {\n-                    resolution = isInteger(methodParameter, sourceText, methodParameterOrdinal);\n-                } else {\n-                    throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-                }\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n \n-        Percentile that = (Percentile) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(getClass(), children(), method, methodParameter);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzNjY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525936661", "bodyText": "superfluous?", "author": "bpintea", "createdAt": "2020-11-18T09:29:37Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentileRanksAgg.java", "diffHunk": "@@ -5,24 +5,30 @@\n  */\n package org.elasticsearch.xpack.sql.querydsl.agg;\n \n+import org.elasticsearch.search.aggregations.AggregationBuilders;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder;\n \n import java.util.List;\n import java.util.function.Function;\n \n-import static org.elasticsearch.search.aggregations.AggregationBuilders.percentileRanks;\n-\n public class PercentileRanksAgg extends DefaultAggSourceLeafAgg {\n \n     private final List<Double> values;\n+    private final PercentilesConfig percentilesConfig;\n+\n+    public static PercentilesConfig DEFAULT_PERCENTILES_CONFIG =\n+        AggregationBuilders.percentileRanks(\"not_important\", new double[1]).percentilesConfig();", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentileRanksAgg.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentileRanksAgg.java\nindex b08efa5e2e5..86d2e2744e9 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentileRanksAgg.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/querydsl/agg/PercentileRanksAgg.java\n\n@@ -17,9 +17,6 @@ public class PercentileRanksAgg extends DefaultAggSourceLeafAgg {\n     private final List<Double> values;\n     private final PercentilesConfig percentilesConfig;\n \n-    public static PercentilesConfig DEFAULT_PERCENTILES_CONFIG =\n-        AggregationBuilders.percentileRanks(\"not_important\", new double[1]).percentilesConfig();\n-\n     public PercentileRanksAgg(String id, AggSource source, List<Double> values, PercentilesConfig percentilesConfig) {\n         super(id, source);\n         this.values = values;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r525939096", "bodyText": "not sure if this had been the target of a previous comment, but I would myself deduplicate the tests that only differ in the name of the function (like this and testPercentileRankNullOrUnspecifiedMethodOrDefaultMethodParameterIsTheSame or testPercentileOptimization and testPercentileRankOptimization) with a simple two steps loop.", "author": "bpintea", "createdAt": "2020-11-18T09:33:18Z", "path": "x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java", "diffHunk": "@@ -2338,4 +2345,138 @@ public void testInInRangeValues() {\n         PhysicalPlan p = testContext.optimizeAndPlan(\"SELECT long FROM test WHERE long IN (1, 2, 3, \" + Long.MAX_VALUE + \", 5, 6, 7)\");\n         assertEquals(EsQueryExec.class, p.getClass());\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> List<T> metricAggsByField(Supplier<PhysicalPlan> physicalPlanSupplier, int fieldCount) {\n+        PhysicalPlan p = physicalPlanSupplier.get();\n+        assertEquals(EsQueryExec.class, p.getClass());\n+        EsQueryExec ee = (EsQueryExec) p;\n+        AggregationBuilder aggregationBuilder = ee.queryContainer().aggs().asAggBuilder();\n+        assertEquals(fieldCount, ee.output().size());\n+        assertEquals(ReferenceAttribute.class, ee.output().get(0).getClass());\n+        assertEquals(fieldCount, ee.queryContainer().fields().size());\n+        assertThat(fieldCount, greaterThanOrEqualTo(ee.queryContainer().aggs().asAggBuilder().getSubAggregations().size()));\n+        Map<String, AggregationBuilder> aggsByName =\n+            aggregationBuilder.getSubAggregations().stream().collect(Collectors.toMap(AggregationBuilder::getName, ab -> ab));\n+        return IntStream.range(0, fieldCount).mapToObj(i -> {\n+            String percentileAggName = ((MetricAggRef) ee.queryContainer().fields().get(i).v1()).name();\n+            return (T) aggsByName.get(percentileAggName);\n+        }).collect(Collectors.toList());\n+    }\n+\n+    public void testPercentileNullOrUnspecifiedMethodOrDefaultMethodParameterIsTheSame() {", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java\nindex b9cede6a9bf..20de6ec0d19 100644\n--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java\n+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/planner/QueryTranslatorTests.java\n\n@@ -2346,9 +2348,8 @@ public class QueryTranslatorTests extends ESTestCase {\n         assertEquals(EsQueryExec.class, p.getClass());\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> List<T> metricAggsByField(Supplier<PhysicalPlan> physicalPlanSupplier, int fieldCount) {\n-        PhysicalPlan p = physicalPlanSupplier.get();\n+    @SuppressWarnings({\"rawtypes\"})\n+    private static List<AbstractPercentilesAggregationBuilder> percentilesAggsByField(PhysicalPlan p, int fieldCount) {\n         assertEquals(EsQueryExec.class, p.getClass());\n         EsQueryExec ee = (EsQueryExec) p;\n         AggregationBuilder aggregationBuilder = ee.queryContainer().aggs().asAggBuilder();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2OTI1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526169259", "bodyText": "Since it returns a PercentilesConfig object why not call the method percentilesConfig() for consistency?", "author": "astefan", "createdAt": "2020-11-18T15:18:45Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentileConfig.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+public interface HasPercentileConfig {\n+\n+    Expression method();\n+\n+    Expression methodParameter();\n+\n+    default PercentilesConfig percentileConfig() {", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3NTE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526475195", "bodyText": "Typo, fixed.", "author": "palesz", "createdAt": "2020-11-18T22:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2OTI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentileConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentileConfig.java\ndeleted file mode 100644\nindex 9b0c2895ee4..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentileConfig.java\n+++ /dev/null\n\n@@ -1,62 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-public interface HasPercentileConfig {\n-\n-    Expression method();\n-\n-    Expression methodParameter();\n-\n-    default PercentilesConfig percentileConfig() {\n-        return asPercentileConfig(method(), methodParameter());\n-    }\n-\n-    private static PercentilesConfig asPercentileConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3MDQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526170457", "bodyText": "The code style is making use of import static and only when there is an ambiguity, use the class name as well.", "author": "astefan", "createdAt": "2020-11-18T15:20:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -5,42 +5,58 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression percent;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, Collections.singletonList(percent));", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 71f823781d8..cd496d8c878 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -5,50 +5,33 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n+public class Percentile extends HasPercentilesConfig {\n \n     private final Expression percent;\n-    private final Expression method;\n-    private final Expression methodParameter;\n \n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, Collections.singletonList(percent));\n+        super(source, field, Collections.singletonList(percent), method, methodParameter);\n         this.percent = percent;\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent, method, methodParameter);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method(), methodParameter());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NDAzNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526174036", "bodyText": "I'm not following.  Why this change?", "author": "astefan", "createdAt": "2020-11-18T15:24:31Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -5,42 +5,58 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression percent;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, Collections.singletonList(percent));\n         this.percent = percent;\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method, methodParameter);\n     }\n \n     @Override\n     public Percentile replaceChildren(List<Expression> newChildren) {\n-        if (newChildren.size() != 2) {\n+        if (children().size() != 2) {", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3NTg1OA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526475858", "bodyText": "\ud83d\udc4d  good catch", "author": "palesz", "createdAt": "2020-11-18T22:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NDAzNg=="}], "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 71f823781d8..cd496d8c878 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -5,50 +5,33 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n+public class Percentile extends HasPercentilesConfig {\n \n     private final Expression percent;\n-    private final Expression method;\n-    private final Expression methodParameter;\n \n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, Collections.singletonList(percent));\n+        super(source, field, Collections.singletonList(percent), method, methodParameter);\n         this.percent = percent;\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent, method, methodParameter);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method(), methodParameter());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE3NzI5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526177292", "bodyText": "Same here about import static vs. using the class name as well.", "author": "astefan", "createdAt": "2020-11-18T15:28:32Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -8,40 +8,45 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.AggregateFunction;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n \n-import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.Percentile.resolvePercentileConfiguration;\n \n-public class PercentileRank extends AggregateFunction implements EnclosedAgg {\n+public class PercentileRank extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression value;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public PercentileRank(Source source, Expression field, Expression value) {\n-        super(source, field, singletonList(value));\n+    public PercentileRank(Source source, Expression field, Expression value, Expression method, Expression methodParameter) {\n+        super(source, field, Collections.singletonList(value));", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex c176925a9dd..edbca8b44f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -8,8 +8,6 @@ package org.elasticsearch.xpack.sql.expression.function.aggregate;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4MTgzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526181835", "bodyText": "Shouldn't the list of new children be checked against a certain size?", "author": "astefan", "createdAt": "2020-11-18T15:34:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -8,40 +8,45 @@\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.AggregateFunction;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n \n-import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n+import static org.elasticsearch.xpack.sql.expression.function.aggregate.Percentile.resolvePercentileConfiguration;\n \n-public class PercentileRank extends AggregateFunction implements EnclosedAgg {\n+public class PercentileRank extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression value;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public PercentileRank(Source source, Expression field, Expression value) {\n-        super(source, field, singletonList(value));\n+    public PercentileRank(Source source, Expression field, Expression value, Expression method, Expression methodParameter) {\n+        super(source, field, Collections.singletonList(value));\n         this.value = value;\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRank> info() {\n-        return NodeInfo.create(this, PercentileRank::new, field(), value);\n+        return NodeInfo.create(this, PercentileRank::new, field(), value, method, methodParameter);\n     }\n \n     @Override\n     public Expression replaceChildren(List<Expression> newChildren) {\n-        if (newChildren.size() != 2) {\n-            throw new IllegalArgumentException(\"expected [2] children but received [\" + newChildren.size() + \"]\");\n+        if (children().size() < 2) {", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MjMxNA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526482314", "bodyText": "\ud83d\udc4d  yes, good catch", "author": "palesz", "createdAt": "2020-11-18T23:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4MTgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex c176925a9dd..edbca8b44f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -8,8 +8,6 @@ package org.elasticsearch.xpack.sql.expression.function.aggregate;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NTQ2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526185469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this == o) return true;\n          \n          \n            \n                    if (o == null || getClass() != o.getClass()) return false;\n          \n          \n            \n                    if (!super.equals(o)) return false;\n          \n          \n            \n                    if (this == o) {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (o == null || getClass() != o.getClass()) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (super.equals(o) == false) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }", "author": "astefan", "createdAt": "2020-11-18T15:38:41Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -64,13 +74,35 @@ public Expression value() {\n     }\n \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DOUBLE;\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n     }\n \n     @Override\n     public String innerName() {\n         Double doubleValue = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(value), DataTypes.DOUBLE);\n         return Double.toString(doubleValue);\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex c176925a9dd..edbca8b44f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -61,48 +53,17 @@ public class PercentileRank extends NumericAggregate implements EnclosedAgg, Two\n             return resolution;\n         }\n \n-        resolution = resolvePercentileConfiguration(sourceText(), method, ParamOrdinal.THIRD, methodParameter, ParamOrdinal.FOURTH);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n         return isNumeric(value, sourceText(), ParamOrdinal.DEFAULT);\n     }\n \n     public Expression value() {\n         return value;\n     }\n-\n-    @Override\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    @Override\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n+    \n \n     @Override\n     public String innerName() {\n         Double doubleValue = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(value), DataTypes.DOUBLE);\n         return Double.toString(doubleValue);\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        PercentileRank that = (PercentileRank) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(getClass(), children(), method, methodParameter);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NTk4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526185987", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.hash(getClass(), children(), method, methodParameter);\n          \n          \n            \n                    return Objects.hash(super.hashCode(), method, methodParameter);", "author": "astefan", "createdAt": "2020-11-18T15:39:18Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -64,13 +74,35 @@ public Expression value() {\n     }\n \n     @Override\n-    public DataType dataType() {\n-        return DataTypes.DOUBLE;\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n     }\n \n     @Override\n     public String innerName() {\n         Double doubleValue = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(value), DataTypes.DOUBLE);\n         return Double.toString(doubleValue);\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        PercentileRank that = (PercentileRank) o;\n+\n+        return Objects.equals(method, that.method)\n+            && Objects.equals(methodParameter, that.methodParameter);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getClass(), children(), method, methodParameter);", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex c176925a9dd..edbca8b44f7 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -61,48 +53,17 @@ public class PercentileRank extends NumericAggregate implements EnclosedAgg, Two\n             return resolution;\n         }\n \n-        resolution = resolvePercentileConfiguration(sourceText(), method, ParamOrdinal.THIRD, methodParameter, ParamOrdinal.FOURTH);\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n         return isNumeric(value, sourceText(), ParamOrdinal.DEFAULT);\n     }\n \n     public Expression value() {\n         return value;\n     }\n-\n-    @Override\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    @Override\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n+    \n \n     @Override\n     public String innerName() {\n         Double doubleValue = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(value), DataTypes.DOUBLE);\n         return Double.toString(doubleValue);\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        PercentileRank that = (PercentileRank) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(getClass(), children(), method, methodParameter);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NjY2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526186669", "bodyText": "Put these two after values initialization (same order as they are in the constructor declaration).", "author": "astefan", "createdAt": "2020-11-18T15:40:03Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -10,30 +10,63 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class PercentileRanks extends CompoundNumericAggregate {\n+public class PercentileRanks extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> values;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, Expression method, Expression methodParameter) {\n         super(source, field, values);\n+        this.method = method;\n+        this.methodParameter = methodParameter;", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex b9cb80f1c95..4ef52b36356 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NzIyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526187229", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this == o) return true;\n          \n          \n            \n                    if (o == null || getClass() != o.getClass()) return false;\n          \n          \n            \n                    if (!super.equals(o)) return false;\n          \n          \n            \n                    if (this == o) {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (o == null || getClass() != o.getClass()) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (super.equals(o) == false) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }", "author": "astefan", "createdAt": "2020-11-18T15:40:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -10,30 +10,63 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class PercentileRanks extends CompoundNumericAggregate {\n+public class PercentileRanks extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> values;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, Expression method, Expression methodParameter) {\n         super(source, field, values);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n         this.values = values;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values, method, methodParameter);\n     }\n \n     @Override\n     public PercentileRanks replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n             throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), method, methodParameter);\n     }\n \n     public List<Expression> values() {\n         return values;\n     }\n+\n+    @Override\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex b9cb80f1c95..4ef52b36356 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NzU2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526187561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Objects.hash(getClass(), children(), method, methodParameter);\n          \n          \n            \n                    return Objects.hash(super.hashCode(), method, methodParameter);", "author": "astefan", "createdAt": "2020-11-18T15:41:08Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -10,30 +10,63 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class PercentileRanks extends CompoundNumericAggregate {\n+public class PercentileRanks extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> values;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, Expression method, Expression methodParameter) {\n         super(source, field, values);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n         this.values = values;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values, method, methodParameter);\n     }\n \n     @Override\n     public PercentileRanks replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n             throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), method, methodParameter);\n     }\n \n     public List<Expression> values() {\n         return values;\n     }\n+\n+    @Override\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        PercentileRanks that = (PercentileRanks) o;\n+\n+        return Objects.equals(method, that.method)\n+            && Objects.equals(methodParameter, that.methodParameter);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getClass(), children(), method, methodParameter);", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex b9cb80f1c95..4ef52b36356 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4NzkxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526187912", "bodyText": "Keep percents initialization before method and methodParameter.", "author": "astefan", "createdAt": "2020-11-18T15:41:34Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java", "diffHunk": "@@ -10,30 +10,62 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class Percentiles extends CompoundNumericAggregate {\n+public class Percentiles extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> percents;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentiles(Source source, Expression field, List<Expression> percents) {\n+    public Percentiles(Source source, Expression field, List<Expression> percents, Expression method, Expression methodParameter) {\n         super(source, field, percents);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n         this.percents = percents;", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\nindex e4aa27d17c1..743e5c26ad1 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4ODUxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526188510", "bodyText": "Same change here as with the other suggestions.", "author": "astefan", "createdAt": "2020-11-18T15:42:15Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java", "diffHunk": "@@ -10,30 +10,62 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class Percentiles extends CompoundNumericAggregate {\n+public class Percentiles extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> percents;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentiles(Source source, Expression field, List<Expression> percents) {\n+    public Percentiles(Source source, Expression field, List<Expression> percents, Expression method, Expression methodParameter) {\n         super(source, field, percents);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n         this.percents = percents;\n     }\n \n     @Override\n     protected NodeInfo<Percentiles> info() {\n-        return NodeInfo.create(this, Percentiles::new, field(), percents);\n+        return NodeInfo.create(this, Percentiles::new, field(), percents, method, methodParameter);\n     }\n \n     @Override\n     public Percentiles replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n-            throw new IllegalArgumentException(\"expected more than one child but received [\" + newChildren.size() + \"]\");\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), method, methodParameter);\n     }\n \n     public List<Expression> percents() {\n         return percents;\n     }\n+\n+    @Override\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\nindex e4aa27d17c1..743e5c26ad1 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE4ODYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526188617", "bodyText": "Same change here as with the other suggestions.", "author": "astefan", "createdAt": "2020-11-18T15:42:22Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java", "diffHunk": "@@ -10,30 +10,62 @@\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n-public class Percentiles extends CompoundNumericAggregate {\n+public class Percentiles extends CompoundNumericAggregate implements HasPercentileConfig {\n \n     private final List<Expression> percents;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentiles(Source source, Expression field, List<Expression> percents) {\n+    public Percentiles(Source source, Expression field, List<Expression> percents, Expression method, Expression methodParameter) {\n         super(source, field, percents);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n         this.percents = percents;\n     }\n \n     @Override\n     protected NodeInfo<Percentiles> info() {\n-        return NodeInfo.create(this, Percentiles::new, field(), percents);\n+        return NodeInfo.create(this, Percentiles::new, field(), percents, method, methodParameter);\n     }\n \n     @Override\n     public Percentiles replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n-            throw new IllegalArgumentException(\"expected more than one child but received [\" + newChildren.size() + \"]\");\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), method, methodParameter);\n     }\n \n     public List<Expression> percents() {\n         return percents;\n     }\n+\n+    @Override\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    @Override\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        Percentiles that = (Percentiles) o;\n+\n+        return Objects.equals(method, that.method)\n+            && Objects.equals(methodParameter, that.methodParameter);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(getClass(), children(), method, methodParameter);", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\nindex e4aa27d17c1..743e5c26ad1 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIwMTg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526201891", "bodyText": "I'm wondering (not strictly related to this private class) if Percentile and PercentileRank could have a common base class that abstract away most of the common code in these two classes...", "author": "astefan", "createdAt": "2020-11-18T15:57:35Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1006,39 +1008,68 @@ public LogicalPlan apply(LogicalPlan p) {\n         }\n     }\n \n+    private static class PercentileArgumentCombination {\n+        final Expression field;\n+        final PercentilesConfig config;\n+        final Expression method;\n+        final Expression methodParameter;\n+\n+        PercentileArgumentCombination(Percentile per) {", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex 3be5e890505..7c0432bbf4c 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1008,39 +1009,17 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n         }\n     }\n \n-    private static class PercentileArgumentCombination {\n-        final Expression field;\n-        final PercentilesConfig config;\n-        final Expression method;\n-        final Expression methodParameter;\n-\n-        PercentileArgumentCombination(Percentile per) {\n-            this.field = per.field();\n-            this.method = per.method();\n-            this.methodParameter = per.methodParameter();\n-            this.config = per.percentileConfig();\n+    private static class PercentileAggKey extends Tuple<Expression, PercentilesConfig> {\n+        PercentileAggKey(HasPercentilesConfig per) {\n+            super(per.field(), per.percentileConfig());\n         }\n-\n-        PercentileArgumentCombination(PercentileRank per) {\n-            this.field = per.field();\n-            this.method = per.method();\n-            this.methodParameter = per.methodParameter();\n-            this.config = per.percentileConfig();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-\n-            PercentileArgumentCombination that = (PercentileArgumentCombination) o;\n-\n-            return field.equals(that.field) && Objects.equals(config, that.config);\n+        \n+        public Expression field() {\n+            return v1();\n         }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(field, config);\n+        \n+        public PercentilesConfig percentilesConfig() {\n+            return v2();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2ODgzOA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526168838", "bodyText": "Keep the static import.", "author": "costin", "createdAt": "2020-11-18T15:18:12Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -5,42 +5,58 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-import static java.util.Collections.singletonList;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n \n     private final Expression percent;\n+    private final Expression method;\n+    private final Expression methodParameter;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, Collections.singletonList(percent));", "originalCommit": "24c0a68a07d34a37e4b1928e1d9197e92aa0770c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 71f823781d8..cd496d8c878 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -5,50 +5,33 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n import org.elasticsearch.xpack.ql.type.DataType;\n import org.elasticsearch.xpack.ql.type.DataTypes;\n import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isInteger;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments, HasPercentileConfig {\n+public class Percentile extends HasPercentilesConfig {\n \n     private final Expression percent;\n-    private final Expression method;\n-    private final Expression methodParameter;\n \n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, Collections.singletonList(percent));\n+        super(source, field, Collections.singletonList(percent), method, methodParameter);\n         this.percent = percent;\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent, method, methodParameter);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method(), methodParameter());\n     }\n \n     @Override\n"}}, {"oid": "80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "url": "https://github.com/elastic/elasticsearch/commit/80b6a1cfdb4045cf6d9617ef928cb7631a8a96f6", "message": "Code cleanup, doc cleanup", "committedDate": "2020-11-18T22:21:17Z", "type": "commit"}, {"oid": "676bf651671ee705313d9aafbc8ce1aefe3ac949", "url": "https://github.com/elastic/elasticsearch/commit/676bf651671ee705313d9aafbc8ce1aefe3ac949", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-18T22:22:07Z", "type": "commit"}, {"oid": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "url": "https://github.com/elastic/elasticsearch/commit/964ed9a5c250e461a1d09c7551dcc77a71aba639", "message": "More cleanups based on PR", "committedDate": "2020-11-18T23:21:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczNzM1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526737355", "bodyText": "Function.identity()", "author": "astefan", "createdAt": "2020-11-19T10:04:48Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczOTg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526739857", "bodyText": "Expressions.ParamOrdinal -> ParamOrdinal and import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;", "author": "astefan", "createdAt": "2020-11-19T10:09:05Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), ", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0MDEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526740101", "bodyText": "import org.elasticsearch.xpack.ql.expression.Expression; and use TypeResolution.", "author": "astefan", "createdAt": "2020-11-19T10:09:26Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0MDQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526740465", "bodyText": ".size() + 1", "author": "astefan", "createdAt": "2020-11-19T10:10:00Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), ", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0MDU5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526740596", "bodyText": "size() + 2", "author": "astefan", "createdAt": "2020-11-19T10:10:11Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1MzE2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526753161", "bodyText": "The phrasing is probably a mix of leftover from a first version and the final one... ...that can we are capable...", "author": "astefan", "createdAt": "2020-11-19T10:29:38Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NjExNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526756116", "bodyText": "I think mehtodParameterOrdinal needs to be the second argument for format? methodName needs to be the first and sourceText the last one?\nSomething like the [future_compression_method_name] method can only be used with the default parameters, please omit the fourth argument of PERCENTILE(x, 50, future..., blabla).", "author": "astefan", "createdAt": "2020-11-19T10:34:19Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526757140", "bodyText": "Again, remove Expression.", "author": "astefan", "createdAt": "2020-11-19T10:35:50Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzY3OA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526757678", "bodyText": "I like this idea. Not sure how frequently they will add new methods, but I think it's a safety net that's worth adding.", "author": "astefan", "createdAt": "2020-11-19T10:36:44Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk0ODQ5MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526948490", "bodyText": "Sadly, I have to remove it. Looking at it more we cannot future proof automagically. The asPercentilesConfig won't be able to translate the enum to a PercentilesConfig class anyways (we will hit the default case that will result in IllegalArgumentException). The best I can do is to add a unit test whether all the methods are handled, but server team might not be happy about that.", "author": "palesz", "createdAt": "2020-11-19T14:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1Nzk2NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526757964", "bodyText": "I think this can be private.", "author": "astefan", "createdAt": "2020-11-19T10:37:09Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1OTMzOA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526759338", "bodyText": "I would define a static final DEFAULT_METHOD (or whatever name we choose) and use that here (and if it's used in other places, there as well) for code-visibility purposes. The constants at the top of the class definition just have a greater visibility than looking throughout the code for how to set the default.", "author": "astefan", "createdAt": "2020-11-19T10:39:24Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return new PercentilesConfig.TDigest();", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDI0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526764242", "bodyText": "If the class is not an interface anymore but the base for Percentile and PercentileRank, its name is not that great anymore. How about PercentileNumericAggregate?\nWe'd have Percentile/PercentileRank -> PercentileNumericAggregate -> NumericAggregate -> AggregateFunction ->...", "author": "astefan", "createdAt": "2020-11-19T10:46:58Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxNTE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526815187", "bodyText": "\ud83d\udc4d  Or just PercentileAggregate. The class should be protected, same as the constructor.", "author": "costin", "createdAt": "2020-11-19T12:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDI0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526764544", "bodyText": "Remove these two empty lines.", "author": "astefan", "createdAt": "2020-11-19T10:47:23Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -72,4 +71,6 @@ public String innerName() {\n         Double value = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(percent), DataTypes.DOUBLE);\n         return Double.toString(value);\n     }\n+\n+", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 03df55859b6..ac603c73dc9 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -61,16 +60,9 @@ public class Percentile extends HasPercentilesConfig {\n         return percent;\n     }\n \n-    @Override\n-    public DataType dataType() {\n-        return DataTypes.DOUBLE;\n-    }\n-\n     @Override\n     public String innerName() {\n         Double value = (Double) SqlDataTypeConverter.convert(Foldables.valueOf(percent), DataTypes.DOUBLE);\n         return Double.toString(value);\n     }\n-\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2Njg4NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526766884", "bodyText": "Why is < 2 here and != 2 for Percentile?\nIf both should have an identic behavior and the above difference is just an overlook when it comes to replaceChildren I think you can move this method to HasPercentilesConfig.", "author": "astefan", "createdAt": "2020-11-19T10:50:56Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -22,26 +19,26 @@\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class PercentileRank extends AggregateFunction implements EnclosedAgg {\n+public class PercentileRank extends HasPercentilesConfig {\n \n     private final Expression value;\n \n-    public PercentileRank(Source source, Expression field, Expression value) {\n-        super(source, field, singletonList(value));\n+    public PercentileRank(Source source, Expression field, Expression value, Expression method, Expression methodParameter) {\n+        super(source, field, singletonList(value), method, methodParameter);\n         this.value = value;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRank> info() {\n-        return NodeInfo.create(this, PercentileRank::new, field(), value);\n+        return NodeInfo.create(this, PercentileRank::new, field(), value, method(), methodParameter());\n     }\n \n     @Override\n     public Expression replaceChildren(List<Expression> newChildren) {\n-        if (newChildren.size() != 2) {\n-            throw new IllegalArgumentException(\"expected [2] children but received [\" + newChildren.size() + \"]\");\n+        if (newChildren.size() < 2) {", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk1MzMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526953312", "bodyText": "I will keep this check in the Percentile and PercentileRank classes. The HasPercentilesConfig class does not have explicit static (rather only dynamic) knowledge about the children count of the child classes. Right now it just happens to be that only Percentile and PercentileRank are the child classes, each with two children.", "author": "palesz", "createdAt": "2020-11-19T14:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2Njg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex ba527b3e4d1..a4a9fc2aee0 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -19,7 +19,7 @@ import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class PercentileRank extends HasPercentilesConfig {\n+public class PercentileRank extends PercentileAggregate {\n \n     private final Expression value;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2ODY3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526768676", "bodyText": "The dataType() method of this class returns DOUBLE but so it does dataType() from NumericAggregate. Can you check if both Percentile and PercentileRank don't need to override dataType()?", "author": "astefan", "createdAt": "2020-11-19T10:53:50Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -21,26 +20,26 @@\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends HasPercentilesConfig {", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 03df55859b6..ac603c73dc9 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -20,7 +19,7 @@ import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends HasPercentilesConfig {\n+public class Percentile extends PercentileAggregate {\n \n     private final Expression percent;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2OTY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526769675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PercentileRanks that = (PercentileRanks) o;\n          \n          \n            \n            \n          \n          \n            \n                    return Objects.equals(percentilesConfig, that.percentilesConfig);\n          \n          \n            \n                    return Objects.equals(percentilesConfig, ((PercentileRanks) o).percentilesConfig);", "author": "astefan", "createdAt": "2020-11-19T10:55:18Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -5,35 +5,66 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n public class PercentileRanks extends CompoundNumericAggregate {\n \n     private final List<Expression> values;\n+    private final PercentilesConfig percentilesConfig;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, PercentilesConfig percentilesConfig) {\n         super(source, field, values);\n         this.values = values;\n+        this.percentilesConfig = percentilesConfig;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values, percentilesConfig);\n     }\n \n     @Override\n     public PercentileRanks replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n             throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), percentilesConfig);\n     }\n \n     public List<Expression> values() {\n         return values;\n     }\n+    \n+    public PercentilesConfig percentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+\n+        PercentileRanks that = (PercentileRanks) o;\n+\n+        return Objects.equals(percentilesConfig, that.percentilesConfig);", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex 39de2dea01c..b9ac2a02552 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -45,6 +45,11 @@ public class PercentileRanks extends CompoundNumericAggregate {\n         return percentilesConfig;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), percentilesConfig);\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3MDA2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526770066", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Percentiles that = (Percentiles) o;\n          \n          \n            \n            \n          \n          \n            \n                    return Objects.equals(percentilesConfig, that.percentilesConfig);\n          \n          \n            \n                    return Objects.equals(percentilesConfig, ((Percentiles) o).percentilesConfig);", "author": "astefan", "createdAt": "2020-11-19T10:55:52Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java", "diffHunk": "@@ -5,35 +5,65 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n public class Percentiles extends CompoundNumericAggregate {\n \n     private final List<Expression> percents;\n+    private final PercentilesConfig percentilesConfig;\n \n-    public Percentiles(Source source, Expression field, List<Expression> percents) {\n+    public Percentiles(Source source, Expression field, List<Expression> percents, PercentilesConfig percentilesConfig) {\n         super(source, field, percents);\n         this.percents = percents;\n+        this.percentilesConfig = percentilesConfig;\n     }\n \n     @Override\n     protected NodeInfo<Percentiles> info() {\n-        return NodeInfo.create(this, Percentiles::new, field(), percents);\n+        return NodeInfo.create(this, Percentiles::new, field(), percents, percentilesConfig);\n     }\n \n     @Override\n     public Percentiles replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n-            throw new IllegalArgumentException(\"expected more than one child but received [\" + newChildren.size() + \"]\");\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new Percentiles(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), percentilesConfig);\n     }\n \n     public List<Expression> percents() {\n         return percents;\n     }\n+    \n+    public PercentilesConfig percentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+\n+        Percentiles that = (Percentiles) o;\n+\n+        return Objects.equals(percentilesConfig, that.percentilesConfig);", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\nindex 9152e20056c..a65066bc30c 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentiles.java\n\n@@ -45,6 +45,11 @@ public class Percentiles extends CompoundNumericAggregate {\n         return percentilesConfig;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), percentilesConfig);\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxNzM3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526817372", "bodyText": "hashcode before equals", "author": "costin", "createdAt": "2020-11-19T12:06:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return new PercentilesConfig.TDigest();\n+        }\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+        PercentilesMethod percentilesMethod = null;\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+                break;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+        }\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+\n+        HasPercentilesConfig that = (HasPercentilesConfig) o;\n+\n+        return Objects.equals(method, that.method)\n+            && Objects.equals(methodParameter, that.methodParameter);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), method, methodParameter);\n+    }", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxODU4MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526818580", "bodyText": "Map.of will create issues when backporting to 7.11", "author": "costin", "createdAt": "2020-11-19T12:07:50Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyOTAyNA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526829024", "bodyText": "There's no value in making this method static - in fact it hurts. The method/params should be taken from the enclosing class simplifying the signature.\nThe NAME_TO_METHOD (has little meaning to say ENUM_RESOLUTION) can contain Function<Enum,TypeResolution> and the declaration can just pick up the arguments from the enclosing context inside the lambda.", "author": "costin", "createdAt": "2020-11-19T12:16:22Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyNjk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527026944", "bodyText": "Inlined the static method.\nAbout NAME_TO_METHOD: Lambda can only pick up the fields method and methodParameter if the NAME_TO_METHOD is not static, otherwise the it has no access to the instance fields. Making it non-static on the other hand feels a bit wasteful.", "author": "palesz", "createdAt": "2020-11-19T16:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyOTAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMTcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526831716", "bodyText": "If super.equals is called, no need to call == or do the getClass() comparison since the super does it already.", "author": "costin", "createdAt": "2020-11-19T12:21:04Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return new PercentilesConfig.TDigest();\n+        }\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+        PercentilesMethod percentilesMethod = null;\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+                break;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+        }\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwMzExMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527003111", "bodyText": "True. Removed. On the same note: Function.equals() seems copy of Node.equals(), I will remove that in a cleanup PR separately.", "author": "palesz", "createdAt": "2020-11-19T16:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMTcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526832278", "bodyText": "I believe this method is the same for Percentile/PercentileRanks so it can be extracted into the parent.", "author": "costin", "createdAt": "2020-11-19T12:22:04Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -21,26 +20,26 @@\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends HasPercentilesConfig {\n \n     private final Expression percent;\n \n-    public Percentile(Source source, Expression field, Expression percent) {\n-        super(source, field, singletonList(percent));\n+    public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n+        super(source, field, singletonList(percent), method, methodParameter);\n         this.percent = percent;\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent);\n+        return NodeInfo.create(this, Percentile::new, field(), percent, method(), methodParameter());\n     }\n \n     @Override\n     public Percentile replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() != 2) {\n             throw new IllegalArgumentException(\"expected [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new Percentile(source(), newChildren.get(0), newChildren.get(1));\n+        return new Percentile(source(), newChildren.get(0), newChildren.get(1), method(), methodParameter());\n     }\n \n     @Override", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwNDM0NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527004344", "bodyText": "See #65026 (comment)", "author": "palesz", "createdAt": "2020-11-19T16:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex 03df55859b6..ac603c73dc9 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -20,7 +19,7 @@ import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends HasPercentilesConfig {\n+public class Percentile extends PercentileAggregate {\n \n     private final Expression percent;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjUxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526832517", "bodyText": "again, hashcode before equals", "author": "costin", "createdAt": "2020-11-19T12:22:26Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -5,35 +5,66 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n public class PercentileRanks extends CompoundNumericAggregate {\n \n     private final List<Expression> values;\n+    private final PercentilesConfig percentilesConfig;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, PercentilesConfig percentilesConfig) {\n         super(source, field, values);\n         this.values = values;\n+        this.percentilesConfig = percentilesConfig;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values, percentilesConfig);\n     }\n \n     @Override\n     public PercentileRanks replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n             throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), percentilesConfig);\n     }\n \n     public List<Expression> values() {\n         return values;\n     }\n+    \n+    public PercentilesConfig percentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+\n+        PercentileRanks that = (PercentileRanks) o;\n+\n+        return Objects.equals(percentilesConfig, that.percentilesConfig);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), percentilesConfig);\n+    }\n+", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex 39de2dea01c..b9ac2a02552 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -45,6 +45,11 @@ public class PercentileRanks extends CompoundNumericAggregate {\n         return percentilesConfig;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), percentilesConfig);\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjg0MA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526832840", "bodyText": "by calling super, the getClass() and == check are redundant.", "author": "costin", "createdAt": "2020-11-19T12:23:00Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -5,35 +5,66 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n public class PercentileRanks extends CompoundNumericAggregate {\n \n     private final List<Expression> values;\n+    private final PercentilesConfig percentilesConfig;\n \n-    public PercentileRanks(Source source, Expression field, List<Expression> values) {\n+    public PercentileRanks(Source source, Expression field, List<Expression> values, PercentilesConfig percentilesConfig) {\n         super(source, field, values);\n         this.values = values;\n+        this.percentilesConfig = percentilesConfig;\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values, percentilesConfig);\n     }\n \n     @Override\n     public PercentileRanks replaceChildren(List<Expression> newChildren) {\n         if (newChildren.size() < 2) {\n             throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n         }\n-        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+        return new PercentileRanks(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()), percentilesConfig);\n     }\n \n     public List<Expression> values() {\n         return values;\n     }\n+    \n+    public PercentilesConfig percentilesConfig() {\n+        return percentilesConfig;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex 39de2dea01c..b9ac2a02552 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -45,6 +45,11 @@ public class PercentileRanks extends CompoundNumericAggregate {\n         return percentilesConfig;\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), percentilesConfig);\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNDI3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526834279", "bodyText": "Percentile is already an agg making PercentileAgg redundant - just call the tuple PercentileKey.\nAlso the methods should be all private/protected where possible.", "author": "costin", "createdAt": "2020-11-19T12:25:28Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1006,39 +1009,46 @@ public LogicalPlan apply(LogicalPlan p) {\n         }\n     }\n \n+    private static class PercentileAggKey extends Tuple<Expression, PercentilesConfig> {\n+        PercentileAggKey(HasPercentilesConfig per) {\n+            super(per.field(), per.percentilesConfig());\n+        }\n+        \n+        public Expression field() {\n+            return v1();\n+        }\n+        \n+        public PercentilesConfig percentilesConfig() {\n+            return v2();\n+        }\n+    }", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\nindex 4b9fccbafe7..bfa6cf598f5 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java\n\n@@ -1009,16 +1008,20 @@ public class Optimizer extends RuleExecutor<LogicalPlan> {\n         }\n     }\n \n-    private static class PercentileAggKey extends Tuple<Expression, PercentilesConfig> {\n-        PercentileAggKey(HasPercentilesConfig per) {\n+    private static class PercentileKey extends Tuple<Expression, PercentilesConfig> {\n+        PercentileKey(Percentile per) {\n+            super(per.field(), per.percentilesConfig());\n+        }\n+\n+        PercentileKey(PercentileRank per) {\n             super(per.field(), per.percentilesConfig());\n         }\n         \n-        public Expression field() {\n+        private Expression field() {\n             return v1();\n         }\n         \n-        public PercentilesConfig percentilesConfig() {\n+        private PercentilesConfig percentilesConfig() {\n             return v2();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNzA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526837079", "bodyText": "return e == null ?  null : SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);", "author": "costin", "createdAt": "2020-11-19T12:30:13Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return new PercentilesConfig.TDigest();\n+        }\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+        PercentilesMethod percentilesMethod = null;\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+                break;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+        }\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n+        if (e == null) {\n+            return null;\n+        }\n+        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNzY2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r526837666", "bodyText": "The name is misleading since nullable means something else. rename to foldNullSafe", "author": "costin", "createdAt": "2020-11-19T12:31:03Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import static java.util.Arrays.stream;\n+import static java.util.stream.Collectors.toMap;\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n+    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n+        pm -> pm.getParseField().getPreferredName(),\n+        pm -> pm\n+    ));\n+\n+    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n+    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n+        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n+        PercentilesMethod.HDR, TypeResolutions::isInteger\n+    );\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n+        Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n+            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        return asPercentilesConfig(method, methodParameter);\n+    }\n+\n+    @FunctionalInterface\n+    interface MethodParameterResolver {\n+        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n+    }\n+\n+    private static Expression.TypeResolution resolvePercentileConfiguration(\n+        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n+        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n+\n+        if (method != null) {\n+            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n+            if (percentilesMethod == null) {\n+                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n+                if (resolver == null) {\n+                    // so in the future if a new method is added, at least the users will be able to use it with \n+                    // the default parameters, but won't be able to configure it until the resolver is added\n+                    return new Expression.TypeResolution(format(null,\n+                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n+                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n+                }\n+                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return Expression.TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return new PercentilesConfig.TDigest();\n+        }\n+        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n+        PercentilesMethod percentilesMethod = null;\n+        for (PercentilesMethod m : PercentilesMethod.values()) {\n+            if (m.getParseField().getPreferredName().equals(methodName)) {\n+                percentilesMethod = m;\n+                break;\n+            }\n+        }\n+        if (percentilesMethod == null) {\n+            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+        }\n+        switch (percentilesMethod) {\n+            case TDIGEST:\n+                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            case HDR:\n+                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            default:\n+                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {", "originalCommit": "964ed9a5c250e461a1d09c7551dcc77a71aba639", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\ndeleted file mode 100644\nindex fc75dd07059..00000000000\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/HasPercentilesConfig.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-\n-package org.elasticsearch.xpack.sql.expression.function.aggregate;\n-\n-import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n-import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n-import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n-import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n-import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n-import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataType;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Arrays.stream;\n-import static java.util.stream.Collectors.toMap;\n-import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-\n-public abstract class HasPercentilesConfig extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n-\n-    // extensive list of all the possible PercentilesMethods (all can be used with default method parameters)\n-    private static final Map<String, PercentilesMethod> NAME_TO_METHOD = stream(PercentilesMethod.values()).collect(toMap(\n-        pm -> pm.getParseField().getPreferredName(),\n-        pm -> pm\n-    ));\n-\n-    // list of all the possible PercentileMethods that can we are capable of parameterizing as of now\n-    private static final Map<PercentilesMethod, MethodParameterResolver> METHOD_TO_RESOLVER = Map.of(\n-        PercentilesMethod.TDIGEST, TypeResolutions::isNumeric,\n-        PercentilesMethod.HDR, TypeResolutions::isInteger\n-    );\n-    \n-    private final Expression method;\n-    private final Expression methodParameter;\n-    \n-    public HasPercentilesConfig(Source source, Expression field, List<Expression> parameters, \n-        Expression method, Expression methodParameter) \n-    {\n-        super(source, field, parameters);\n-        this.method = method;\n-        this.methodParameter = methodParameter;\n-    }\n-\n-    @Override \n-    protected TypeResolution resolveType() {\n-        TypeResolution resolution = super.resolveType();\n-        if (resolution.unresolved()) {\n-            return resolution;\n-        }\n-\n-        return resolvePercentileConfiguration(sourceText(), method, Expressions.ParamOrdinal.fromIndex(parameters().size()+1), \n-            methodParameter, Expressions.ParamOrdinal.fromIndex(parameters().size()+2));\n-    }\n-\n-    public Expression method() {\n-        return method;\n-    }\n-\n-    public Expression methodParameter() {\n-        return methodParameter;\n-    }\n-\n-    public PercentilesConfig percentilesConfig() {\n-        return asPercentilesConfig(method, methodParameter);\n-    }\n-\n-    @FunctionalInterface\n-    interface MethodParameterResolver {\n-        Expression.TypeResolution resolve(Expression methodParameter, String sourceText, Expressions.ParamOrdinal methodParameterOrdinal);\n-    }\n-\n-    private static Expression.TypeResolution resolvePercentileConfiguration(\n-        String sourceText, Expression method, Expressions.ParamOrdinal methodOrdinal,\n-        Expression methodParameter, Expressions.ParamOrdinal methodParameterOrdinal) {\n-\n-        if (method != null) {\n-            Expression.TypeResolution resolution = isFoldable(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-            resolution = TypeResolutions.isString(method, sourceText, methodOrdinal);\n-            if (resolution.unresolved()) {\n-                return resolution;\n-            }\n-\n-            String methodName = (String) method.fold();\n-\n-            PercentilesMethod percentilesMethod = NAME_TO_METHOD.get(methodName);\n-            if (percentilesMethod == null) {\n-                return new Expression.TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n-                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText, NAME_TO_METHOD.keySet(), methodName));\n-            }\n-\n-            // if method is null, the method parameter is not checked\n-            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n-                resolution = isFoldable(methodParameter, sourceText, methodParameterOrdinal);\n-                if (resolution.unresolved()) {\n-                    return resolution;\n-                }\n-\n-                MethodParameterResolver resolver = METHOD_TO_RESOLVER.get(percentilesMethod);\n-                if (resolver == null) {\n-                    // so in the future if a new method is added, at least the users will be able to use it with \n-                    // the default parameters, but won't be able to configure it until the resolver is added\n-                    return new Expression.TypeResolution(format(null,\n-                        \"the [{}] method can only be used with the default method parameters, please omit the {} argument of [{}]\",\n-                        methodParameterOrdinal.name().toLowerCase(Locale.ROOT), sourceText, methodName));\n-                }\n-                resolution = resolver.resolve(methodParameter, sourceText, methodParameterOrdinal);\n-                return resolution;\n-            }\n-        }\n-\n-        return Expression.TypeResolution.TYPE_RESOLVED;\n-    }\n-\n-    private static PercentilesConfig asPercentilesConfig(Expression method, Expression methodParameter) {\n-        if (method == null) {\n-            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n-            return new PercentilesConfig.TDigest();\n-        }\n-        String methodName = foldOptionalNullable(method, DataTypes.KEYWORD);\n-        PercentilesMethod percentilesMethod = null;\n-        for (PercentilesMethod m : PercentilesMethod.values()) {\n-            if (m.getParseField().getPreferredName().equals(methodName)) {\n-                percentilesMethod = m;\n-                break;\n-            }\n-        }\n-        if (percentilesMethod == null) {\n-            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n-        }\n-        switch (percentilesMethod) {\n-            case TDIGEST:\n-                Double compression = foldOptionalNullable(methodParameter, DataTypes.DOUBLE);\n-                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n-            case HDR:\n-                Integer numOfDigits = foldOptionalNullable(methodParameter, DataTypes.INTEGER);\n-                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n-            default:\n-                throw new IllegalStateException(\"Not handled PercentilesMethod [\" + percentilesMethod + \"], type resolution needs fix\");\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T foldOptionalNullable(Expression e, DataType dataType) {\n-        if (e == null) {\n-            return null;\n-        }\n-        return (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-\n-        HasPercentilesConfig that = (HasPercentilesConfig) o;\n-\n-        return Objects.equals(method, that.method)\n-            && Objects.equals(methodParameter, that.methodParameter);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), method, methodParameter);\n-    }\n-\n-}\n"}}, {"oid": "93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "url": "https://github.com/elastic/elasticsearch/commit/93a5f8fd4b584fab82eebbaf751a825b2ac5b6d9", "message": "More cleanups based on PR", "committedDate": "2020-11-19T16:05:15Z", "type": "commit"}, {"oid": "1cf0991d8e06d9199bd3db89c31abaac49953c6e", "url": "https://github.com/elastic/elasticsearch/commit/1cf0991d8e06d9199bd3db89c31abaac49953c6e", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-19T16:05:39Z", "type": "commit"}, {"oid": "f50a43be34c28cd3d0e23c9365076d12922fe33e", "url": "https://github.com/elastic/elasticsearch/commit/f50a43be34c28cd3d0e23c9365076d12922fe33e", "message": "More cleanups based on PR", "committedDate": "2020-11-19T16:33:13Z", "type": "commit"}, {"oid": "8402391d12b951d07a25f1ba04266b4d8a4c7193", "url": "https://github.com/elastic/elasticsearch/commit/8402391d12b951d07a25f1ba04266b4d8a4c7193", "message": "Using LinkedHashMap instead of normal map", "committedDate": "2020-11-19T17:48:27Z", "type": "commit"}, {"oid": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "url": "https://github.com/elastic/elasticsearch/commit/19099ec55b43ca07a14a86a09da6684cc9e6a59e", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-19T17:58:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwMTM5NA==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527701394", "bodyText": "This field as well as resolveType and innerName() are similar across Percentile and PercentileRank - they should be moved to PercentileAggregate, the subclasses acting really as a marker and implementing percent()/value() as an alias to the internal field.", "author": "costin", "createdAt": "2020-11-20T13:48:37Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java", "diffHunk": "@@ -21,26 +19,26 @@\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class Percentile extends NumericAggregate implements EnclosedAgg {\n+public class Percentile extends PercentileAggregate {\n \n     private final Expression percent;", "originalCommit": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\nindex ac603c73dc9..f0a03b480a4 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/Percentile.java\n\n@@ -6,31 +6,20 @@\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.List;\n \n-import static java.util.Collections.singletonList;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n public class Percentile extends PercentileAggregate {\n \n-    private final Expression percent;\n-\n     public Percentile(Source source, Expression field, Expression percent, Expression method, Expression methodParameter) {\n-        super(source, field, singletonList(percent), method, methodParameter);\n-        this.percent = percent;\n+        super(source, field, percent, method, methodParameter);\n     }\n \n     @Override\n     protected NodeInfo<Percentile> info() {\n-        return NodeInfo.create(this, Percentile::new, field(), percent, method(), methodParameter());\n+        return NodeInfo.create(this, Percentile::new, field(), percent(), method(), methodParameter());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwMTYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527701609", "bodyText": "See my comments in Percentile", "author": "costin", "createdAt": "2020-11-20T13:48:54Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java", "diffHunk": "@@ -22,26 +19,26 @@\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n-public class PercentileRank extends AggregateFunction implements EnclosedAgg {\n+public class PercentileRank extends PercentileAggregate {\n \n     private final Expression value;", "originalCommit": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\nindex a4a9fc2aee0..fd6bace83f6 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRank.java\n\n@@ -6,31 +6,20 @@\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n import org.elasticsearch.xpack.ql.expression.Expression;\n-import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n-import org.elasticsearch.xpack.ql.expression.Foldables;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n-import org.elasticsearch.xpack.ql.type.DataTypes;\n-import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.List;\n \n-import static java.util.Collections.singletonList;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n-import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n-\n public class PercentileRank extends PercentileAggregate {\n \n-    private final Expression value;\n-\n     public PercentileRank(Source source, Expression field, Expression value, Expression method, Expression methodParameter) {\n-        super(source, field, singletonList(value), method, methodParameter);\n-        this.value = value;\n+        super(source, field, value, method, methodParameter);\n     }\n \n     @Override\n     protected NodeInfo<PercentileRank> info() {\n-        return NodeInfo.create(this, PercentileRank::new, field(), value, method(), methodParameter());\n+        return NodeInfo.create(this, PercentileRank::new, field(), value(), method(), methodParameter());\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwNzMxNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527707316", "bodyText": "Move this towards the top of the class where the rest of the static fields are being declared", "author": "costin", "createdAt": "2020-11-20T13:58:06Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileAggregate.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.sql.expression.function.aggregate;\n+\n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n+import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.Foldables;\n+import org.elasticsearch.xpack.ql.expression.TypeResolutions;\n+import org.elasticsearch.xpack.ql.expression.function.TwoOptionalArguments;\n+import org.elasticsearch.xpack.ql.expression.function.aggregate.EnclosedAgg;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+\n+abstract class PercentileAggregate extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n+\n+    private static final PercentilesConfig.TDigest DEFAULT_PERCENTILES_CONFIG = new PercentilesConfig.TDigest();\n+\n+    // preferred method name to configurator mapping (type resolution, method parameter -> config)\n+    // contains all the possible PercentilesMethods that we know of and are capable of parameterizing at the moment\n+    private static final Map<String, MethodConfigurator> METHOD_CONFIGURATORS = new LinkedHashMap<>();\n+    static {\n+        Arrays.asList(\n+            new MethodConfigurator(PercentilesMethod.TDIGEST, TypeResolutions::isNumeric, methodParameter -> {\n+                Double compression = foldNullSafe(methodParameter, DataTypes.DOUBLE);\n+                return compression == null ? new PercentilesConfig.TDigest() : new PercentilesConfig.TDigest(compression);\n+            }), \n+            new MethodConfigurator(PercentilesMethod.HDR, TypeResolutions::isInteger, methodParameter -> {\n+                Integer numOfDigits = foldNullSafe(methodParameter, DataTypes.INTEGER);\n+                return numOfDigits == null ? new PercentilesConfig.Hdr() : new PercentilesConfig.Hdr(numOfDigits);\n+            }))\n+            .forEach(c -> METHOD_CONFIGURATORS.put(c.method.getParseField().getPreferredName(), c));\n+    }\n+    \n+    private final Expression method;\n+    private final Expression methodParameter;\n+    \n+    PercentileAggregate(Source source, Expression field, List<Expression> parameters, Expression method, Expression methodParameter) \n+    {\n+        super(source, field, parameters);\n+        this.method = method;\n+        this.methodParameter = methodParameter;\n+    }\n+\n+    @Override \n+    protected TypeResolution resolveType() {\n+        TypeResolution resolution = super.resolveType();\n+        if (resolution.unresolved()) {\n+            return resolution;\n+        }\n+\n+        ParamOrdinal methodOrdinal = ParamOrdinal.fromIndex(parameters().size() + 1);\n+        ParamOrdinal methodParameterOrdinal = ParamOrdinal.fromIndex(parameters().size() + 2);\n+        \n+        if (method != null) {\n+            resolution = isFoldable(method, sourceText(), methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+            resolution = TypeResolutions.isString(method, sourceText(), methodOrdinal);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+\n+            String methodName = (String) method.fold();\n+\n+            MethodConfigurator methodConfigurator = METHOD_CONFIGURATORS.get(methodName);\n+            if (methodConfigurator == null) {\n+                return new TypeResolution(format(null, \"{}argument of [{}] must be one of {}, received [{}]\",\n+                    methodOrdinal.name().toLowerCase(Locale.ROOT) + \" \", sourceText(),\n+                    METHOD_CONFIGURATORS.keySet(), methodName));\n+            }\n+\n+            // if method is null, the method parameter is not checked\n+            if (methodParameter != null && Expressions.isNull(methodParameter) == false) {\n+                resolution = isFoldable(methodParameter, sourceText(), methodParameterOrdinal);\n+                if (resolution.unresolved()) {\n+                    return resolution;\n+                }\n+\n+                resolution = methodConfigurator.resolver.resolve(methodParameter, sourceText(), methodParameterOrdinal);\n+                return resolution;\n+            }\n+        }\n+\n+        return TypeResolution.TYPE_RESOLVED;\n+    }\n+\n+    public Expression method() {\n+        return method;\n+    }\n+\n+    public Expression methodParameter() {\n+        return methodParameter;\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.DOUBLE;\n+    }\n+\n+    public PercentilesConfig percentilesConfig() {\n+        if (method == null) {\n+            // sadly we had to set the default here, the PercentilesConfig does not provide a default\n+            return DEFAULT_PERCENTILES_CONFIG;\n+        }\n+        String methodName = foldNullSafe(method, DataTypes.KEYWORD);\n+        MethodConfigurator methodConfigurator = METHOD_CONFIGURATORS.get(methodName);\n+        if (methodConfigurator == null) {\n+            throw new IllegalStateException(\"Not handled PercentilesMethod [\" + methodName + \"], type resolution needs fix\");\n+        }\n+        return methodConfigurator.parameterToConfig.apply(methodParameter);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T foldNullSafe(Expression e, DataType dataType) {\n+        return e == null ? null : (T) SqlDataTypeConverter.convert(Foldables.valueOf(e), dataType);\n+    }\n+\n+    private static class MethodConfigurator {", "originalCommit": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileAggregate.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileAggregate.java\nindex 449799f517e..40ff0d5ddf5 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileAggregate.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileAggregate.java\n\n@@ -22,14 +22,15 @@ import org.elasticsearch.xpack.sql.type.SqlDataTypeConverter;\n \n import java.util.Arrays;\n import java.util.LinkedHashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Objects;\n import java.util.function.Function;\n \n+import static java.util.Collections.singletonList;\n import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isFoldable;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isNumeric;\n \n abstract class PercentileAggregate extends NumericAggregate implements EnclosedAgg, TwoOptionalArguments {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIwNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527709206", "bodyText": "Considering this file and Percentiles have grew in size and have two properties plus the associated equals/hashCode is worth extracting the functionlity into a common base class that extends CompoundNumericAggregate and just like their function equivalent, the actual implementations only inherit and declare the values/fields as a synonim to the internal expressions list and handle the info and replaceChildren methods.", "author": "costin", "createdAt": "2020-11-20T14:01:09Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java", "diffHunk": "@@ -5,35 +5,64 @@\n  */\n package org.elasticsearch.xpack.sql.expression.function.aggregate;\n \n+import org.elasticsearch.search.aggregations.metrics.PercentilesConfig;\n import org.elasticsearch.xpack.ql.expression.Expression;\n import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n+import java.util.Objects;\n \n public class PercentileRanks extends CompoundNumericAggregate {", "originalCommit": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxNTE1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r529015159", "bodyText": "While implementing this suggested change, found the following:\n    public InnerAggregate(Source source, AggregateFunction inner, CompoundAggregate outer, Expression innerKey) {\n        super(source, outer.field(), outer.arguments());\nWhere the outer.arguments() delegates to children() which already contains the field(), so the InnerAggregate will have two fields in the children list.", "author": "palesz", "createdAt": "2020-11-23T21:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIwNg=="}], "type": "inlineReview", "revised_code": {"commit": "1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "chunk": "diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\nindex b9ac2a02552..1943f342ced 100644\n--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/aggregate/PercentileRanks.java\n\n@@ -11,22 +11,16 @@ import org.elasticsearch.xpack.ql.tree.NodeInfo;\n import org.elasticsearch.xpack.ql.tree.Source;\n \n import java.util.List;\n-import java.util.Objects;\n \n-public class PercentileRanks extends CompoundNumericAggregate {\n-\n-    private final List<Expression> values;\n-    private final PercentilesConfig percentilesConfig;\n+public class PercentileRanks extends PercentileCompoundAggregate {\n \n     public PercentileRanks(Source source, Expression field, List<Expression> values, PercentilesConfig percentilesConfig) {\n-        super(source, field, values);\n-        this.values = values;\n-        this.percentilesConfig = percentilesConfig;\n+        super(source, field, values, percentilesConfig);\n     }\n \n     @Override\n     protected NodeInfo<PercentileRanks> info() {\n-        return NodeInfo.create(this, PercentileRanks::new, field(), values, percentilesConfig);\n+        return NodeInfo.create(this, PercentileRanks::new, field(), values(), percentilesConfig);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcxMDgyNg==", "url": "https://github.com/elastic/elasticsearch/pull/65026#discussion_r527710826", "bodyText": "A small nit - to avoid having two constructors, it would be possible make the base class public so that percentilesConfig can be accessed. Since the rest of the methods are not, it keeps the encapsulation while removing redundancy.", "author": "costin", "createdAt": "2020-11-20T14:03:59Z", "path": "x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/optimizer/Optimizer.java", "diffHunk": "@@ -1006,39 +1008,50 @@ public LogicalPlan apply(LogicalPlan p) {\n         }\n     }\n \n+    private static class PercentileKey extends Tuple<Expression, PercentilesConfig> {\n+        PercentileKey(Percentile per) {", "originalCommit": "19099ec55b43ca07a14a86a09da6684cc9e6a59e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "url": "https://github.com/elastic/elasticsearch/commit/1ed343e2592f5f62c0ae0b854bb84279e55dfaf6", "message": "Further PR comments", "committedDate": "2020-11-23T22:09:13Z", "type": "commit"}, {"oid": "3679378e06ba730af8107a73b043ee6d90b9c687", "url": "https://github.com/elastic/elasticsearch/commit/3679378e06ba730af8107a73b043ee6d90b9c687", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-23T22:09:43Z", "type": "commit"}, {"oid": "024e53bdd4aedb9f7f30609bf5c630a819b17c06", "url": "https://github.com/elastic/elasticsearch/commit/024e53bdd4aedb9f7f30609bf5c630a819b17c06", "message": "QL: Stop duplicating children in InnerAggregate\n\nInstead of the `arguments()` that is the synonym of the `children()`,\nuse the `parameters()` (everything except the field) to avoid\nduplicating the `field` in the `children` collection.", "committedDate": "2020-11-23T23:19:06Z", "type": "commit"}, {"oid": "7e14f9a005f4361027158b78b8028850092d23da", "url": "https://github.com/elastic/elasticsearch/commit/7e14f9a005f4361027158b78b8028850092d23da", "message": "Merge remote-tracking branch 'origin/master' into enhancement/percentile-hdr-support", "committedDate": "2020-11-24T15:37:44Z", "type": "commit"}]}