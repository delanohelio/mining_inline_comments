{"pr_number": 51977, "pr_title": "Remove Redundant Loading of RepositoryData during Restore", "pr_createdAt": "2020-02-06T06:30:00Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51977", "timeline": [{"oid": "c9f0cc2a68b743f373da6d0214d5d435fbdff6a6", "url": "https://github.com/elastic/elasticsearch/commit/c9f0cc2a68b743f373da6d0214d5d435fbdff6a6", "message": "Remove Redundant Loading of RepositoryData during Restore\n\nWe can just put the `IndexId` instead of just the index name into the recovery soruce and\nsave one load of `RepositoryData` on each shard restore that way.", "committedDate": "2020-02-06T06:27:12Z", "type": "commit"}, {"oid": "d0081c55f91f89b8bf815cefe75e3310806eaca3", "url": "https://github.com/elastic/elasticsearch/commit/d0081c55f91f89b8bf815cefe75e3310806eaca3", "message": "nicer", "committedDate": "2020-02-06T06:33:36Z", "type": "commit"}, {"oid": "946ce257f95bc8d6592e0f1924a4c334675ab0fe", "url": "https://github.com/elastic/elasticsearch/commit/946ce257f95bc8d6592e0f1924a4c334675ab0fe", "message": "safer bwc", "committedDate": "2020-02-06T08:13:52Z", "type": "commit"}, {"oid": "14e71fb2a4b85841dd3b6944dc4736830ba56c2c", "url": "https://github.com/elastic/elasticsearch/commit/14e71fb2a4b85841dd3b6944dc4736830ba56c2c", "message": "Merge remote-tracking branch 'elastic/master' into cleaner-restore", "committedDate": "2020-02-06T08:14:06Z", "type": "commit"}, {"oid": "f6a6f7a4a585eba9e75f1a8aaee78cb0131eb67b", "url": "https://github.com/elastic/elasticsearch/commit/f6a6f7a4a585eba9e75f1a8aaee78cb0131eb67b", "message": "shorter", "committedDate": "2020-02-06T08:16:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzNjc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r375936793", "bodyText": "can we avoid sending this field if indexId != null (i.e. in the non-bwc case)", "author": "ywelsch", "createdAt": "2020-02-06T16:21:11Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java", "diffHunk": "@@ -252,6 +278,9 @@ protected void writeAdditionalFields(StreamOutput out) throws IOException {\n             snapshot.writeTo(out);\n             Version.writeVersion(version, out);\n             out.writeString(index);", "originalCommit": "f6a6f7a4a585eba9e75f1a8aaee78cb0131eb67b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTY1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376041651", "bodyText": "Not sure, see the other question, seems to me we need to write the uuid string as optional, maybe not?", "author": "original-brownbear", "createdAt": "2020-02-06T19:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzNjc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9bf7a99c64fa8d2ff60583e049f28764b16de2c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\nindex b10f7750884..5e8d05e876f 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\n\n@@ -277,9 +263,10 @@ public abstract class RecoverySource implements Writeable, ToXContentObject {\n             out.writeString(restoreUUID);\n             snapshot.writeTo(out);\n             Version.writeVersion(version, out);\n-            out.writeString(index);\n             if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n-                out.writeOptionalString(indexId == null ? null : indexId.getId());\n+                index.writeTo(out);\n+            } else {\n+                out.writeString(index.getName());\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzOTQ5NA==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r375939494", "bodyText": "the approach here does not allow us to later switch to just reading directly IndexId from stream after backport to 7.x.\nCan you change things so that you conditionally do in.readString(); or new IndexId(in)", "author": "ywelsch", "createdAt": "2020-02-06T16:25:11Z", "path": "server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java", "diffHunk": "@@ -214,20 +216,44 @@ public String toString() {\n         private final String restoreUUID;\n         private final Snapshot snapshot;\n         private final String index;\n+\n+        @Nullable\n+        private final IndexId indexId;\n         private final Version version;\n \n-        public SnapshotRecoverySource(String restoreUUID, Snapshot snapshot, Version version, String index) {\n+        public SnapshotRecoverySource(String restoreUUID, Snapshot snapshot, Version version, IndexId indexId) {\n             this.restoreUUID = restoreUUID;\n             this.snapshot = Objects.requireNonNull(snapshot);\n             this.version = Objects.requireNonNull(version);\n-            this.index = Objects.requireNonNull(index);\n+            this.indexId = Objects.requireNonNull(indexId);\n+            this.index = indexId.getName();\n         }\n \n         SnapshotRecoverySource(StreamInput in) throws IOException {\n             restoreUUID = in.readString();\n             snapshot = new Snapshot(in);\n             version = Version.readVersion(in);\n             index = in.readString();\n+            if (in.getVersion().onOrAfter(Version.V_8_0_0)) {", "originalCommit": "f6a6f7a4a585eba9e75f1a8aaee78cb0131eb67b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376041012", "bodyText": "Tell me if I'm missing something here. But doesn't this break in the edge case of:\n\nRunning mixed cluster with old version master\nFail over to new version master\nNew version master sends the existing recovery source over the wire because it still has null for the uuid because the old master didn't add that when creating the RecoverySource? (am I missing a spot where this is upgraded/recreated during master fail-over?", "author": "original-brownbear", "createdAt": "2020-02-06T19:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzOTQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4MDA0MA==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376280040", "bodyText": "Maybe we should differentiate the in.readString() / new IndexId(in) serialization part and make the logic only rely on IndexId, both on master and 7.x, and INDEX_UUID_NA_VALUE to resolve the index id later when needed?", "author": "tlrx", "createdAt": "2020-02-07T09:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzOTQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "9bf7a99c64fa8d2ff60583e049f28764b16de2c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\nindex b10f7750884..5e8d05e876f 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/routing/RecoverySource.java\n\n@@ -215,45 +215,35 @@ public abstract class RecoverySource implements Writeable, ToXContentObject {\n     public static class SnapshotRecoverySource extends RecoverySource {\n         private final String restoreUUID;\n         private final Snapshot snapshot;\n-        private final String index;\n-\n-        @Nullable\n-        private final IndexId indexId;\n+        private final IndexId index;\n         private final Version version;\n \n         public SnapshotRecoverySource(String restoreUUID, Snapshot snapshot, Version version, IndexId indexId) {\n             this.restoreUUID = restoreUUID;\n             this.snapshot = Objects.requireNonNull(snapshot);\n             this.version = Objects.requireNonNull(version);\n-            this.indexId = Objects.requireNonNull(indexId);\n-            this.index = indexId.getName();\n+            this.index = Objects.requireNonNull(indexId);\n         }\n \n         SnapshotRecoverySource(StreamInput in) throws IOException {\n             restoreUUID = in.readString();\n             snapshot = new Snapshot(in);\n             version = Version.readVersion(in);\n-            index = in.readString();\n             if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n-                final String indexUUID = in.readOptionalString();\n-                if (indexUUID == null) {\n-                    indexId = null;\n-                } else {\n-                    indexId = new IndexId(index, indexUUID);\n-                }\n+                index = new IndexId(in);\n             } else {\n-                indexId = null;\n+                index = new IndexId(in.readString(), IndexMetaData.INDEX_UUID_NA_VALUE);\n             }\n         }\n \n         /**\n-         * Gets the {@link IndexId} of the recovery source.\n+         * Gets the {@link IndexId} of the recovery source. May contain {@link IndexMetaData#INDEX_UUID_NA_VALUE} as the index uuid if it\n+         * was created by an older version master in a mixed version cluster.\n          *\n-         * @return IndexId or {@code null} if running against old version master that did not add an IndexId to the recovery source\n+         * @return IndexId\n          */\n-        @Nullable\n-        public IndexId indexId() {\n-            return indexId;\n+        public IndexId index() {\n+            return index;\n         }\n \n         public String restoreUUID() {\n"}}, {"oid": "c6110c88e15794b2d1359ed231d757d34e3852aa", "url": "https://github.com/elastic/elasticsearch/commit/c6110c88e15794b2d1359ed231d757d34e3852aa", "message": "Merge remote-tracking branch 'elastic/master' into cleaner-restore", "committedDate": "2020-02-07T09:47:12Z", "type": "commit"}, {"oid": "9bf7a99c64fa8d2ff60583e049f28764b16de2c8", "url": "https://github.com/elastic/elasticsearch/commit/9bf7a99c64fa8d2ff60583e049f28764b16de2c8", "message": "CR: nicer serialization", "committedDate": "2020-02-07T10:47:37Z", "type": "commit"}, {"oid": "274a7e5db0d611051b2b0f57c88f2e2cb9a94716", "url": "https://github.com/elastic/elasticsearch/commit/274a7e5db0d611051b2b0f57c88f2e2cb9a94716", "message": "shorter diff", "committedDate": "2020-02-07T10:57:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM0NjI3MQ==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376346271", "bodyText": "Maybe just final IndexId indexId = restoreSource.index();", "author": "tlrx", "createdAt": "2020-02-07T11:33:58Z", "path": "server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java", "diffHunk": "@@ -473,20 +475,33 @@ private void restore(IndexShard indexShard, Repository repository, SnapshotRecov\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final String indexName = restoreSource.index();\n-            if (!shardId.getIndexName().equals(indexName)) {\n-                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n-            } else {\n+            final IndexId indexIdFromCS = restoreSource.index();", "originalCommit": "274a7e5db0d611051b2b0f57c88f2e2cb9a94716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "11f84fefe579eceed336a3af696dc0e708bbf9a4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nindex 3dd0caacc2e..b84b6aa4c1e 100644\n--- a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n+++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n\n@@ -475,33 +474,24 @@ final class StoreRecovery {\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final IndexId indexIdFromCS = restoreSource.index();\n-            if (shardId.getIndexName().equals(indexIdFromCS.getName())) {\n+            final IndexId indexId = restoreSource.index();\n+            if (shardId.getIndexName().equals(indexId.getName())) {\n                 snapshotShardId = shardId;\n             } else {\n-                snapshotShardId = new ShardId(indexIdFromCS.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n+                snapshotShardId = new ShardId(indexId.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n             }\n-            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it buy index name\n-            final boolean indexUUIDUnavailable = indexIdFromCS.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE);\n-            final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-            repositoryDataListener.whenComplete(repositoryData -> {\n-                final IndexId indexId;\n-                if (indexUUIDUnavailable) {\n-                    indexId = repositoryData.resolveIndexId(indexIdFromCS.getName());\n-                } else {\n-                    assert repositoryData == null: \"Shouldn't have loaded RepositoryData but saw [\" + repositoryData + \"]\";\n-                    indexId = indexIdFromCS;\n-                }\n-                assert indexShard.getEngineOrNull() == null;\n-                repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,\n-                    indexShard.recoveryState(), restoreListener);\n-            }, restoreListener::onFailure);\n-            if (indexUUIDUnavailable) {\n+            final StepListener<IndexId> indexIdListener = new StepListener<>();\n+            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it by index name\n+            if (indexId.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {\n                 // BwC path, running against an old version master that did not add the IndexId to the recovery source\n-                repository.getRepositoryData(repositoryDataListener);\n+                repository.getRepositoryData(ActionListener.map(\n+                    indexIdListener, repositoryData -> repositoryData.resolveIndexId(indexId.getName())));\n             } else {\n-                repositoryDataListener.onResponse(null);\n+                indexIdListener.onResponse(indexId);\n             }\n+            assert indexShard.getEngineOrNull() == null;\n+            indexIdListener.whenComplete(idx -> repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(),\n+                idx, snapshotShardId, indexShard.recoveryState(), restoreListener), restoreListener::onFailure);\n         } catch (Exception e) {\n             restoreListener.onFailure(e);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM0NjQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376346436", "bodyText": "typo buy", "author": "tlrx", "createdAt": "2020-02-07T11:34:29Z", "path": "server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java", "diffHunk": "@@ -473,20 +475,33 @@ private void restore(IndexShard indexShard, Repository repository, SnapshotRecov\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final String indexName = restoreSource.index();\n-            if (!shardId.getIndexName().equals(indexName)) {\n-                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n-            } else {\n+            final IndexId indexIdFromCS = restoreSource.index();\n+            if (shardId.getIndexName().equals(indexIdFromCS.getName())) {\n                 snapshotShardId = shardId;\n+            } else {\n+                snapshotShardId = new ShardId(indexIdFromCS.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n+            }\n+            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it buy index name", "originalCommit": "274a7e5db0d611051b2b0f57c88f2e2cb9a94716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "11f84fefe579eceed336a3af696dc0e708bbf9a4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nindex 3dd0caacc2e..b84b6aa4c1e 100644\n--- a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n+++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n\n@@ -475,33 +474,24 @@ final class StoreRecovery {\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final IndexId indexIdFromCS = restoreSource.index();\n-            if (shardId.getIndexName().equals(indexIdFromCS.getName())) {\n+            final IndexId indexId = restoreSource.index();\n+            if (shardId.getIndexName().equals(indexId.getName())) {\n                 snapshotShardId = shardId;\n             } else {\n-                snapshotShardId = new ShardId(indexIdFromCS.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n+                snapshotShardId = new ShardId(indexId.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n             }\n-            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it buy index name\n-            final boolean indexUUIDUnavailable = indexIdFromCS.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE);\n-            final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-            repositoryDataListener.whenComplete(repositoryData -> {\n-                final IndexId indexId;\n-                if (indexUUIDUnavailable) {\n-                    indexId = repositoryData.resolveIndexId(indexIdFromCS.getName());\n-                } else {\n-                    assert repositoryData == null: \"Shouldn't have loaded RepositoryData but saw [\" + repositoryData + \"]\";\n-                    indexId = indexIdFromCS;\n-                }\n-                assert indexShard.getEngineOrNull() == null;\n-                repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,\n-                    indexShard.recoveryState(), restoreListener);\n-            }, restoreListener::onFailure);\n-            if (indexUUIDUnavailable) {\n+            final StepListener<IndexId> indexIdListener = new StepListener<>();\n+            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it by index name\n+            if (indexId.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {\n                 // BwC path, running against an old version master that did not add the IndexId to the recovery source\n-                repository.getRepositoryData(repositoryDataListener);\n+                repository.getRepositoryData(ActionListener.map(\n+                    indexIdListener, repositoryData -> repositoryData.resolveIndexId(indexId.getName())));\n             } else {\n-                repositoryDataListener.onResponse(null);\n+                indexIdListener.onResponse(indexId);\n             }\n+            assert indexShard.getEngineOrNull() == null;\n+            indexIdListener.whenComplete(idx -> repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(),\n+                idx, snapshotShardId, indexShard.recoveryState(), restoreListener), restoreListener::onFailure);\n         } catch (Exception e) {\n             restoreListener.onFailure(e);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM0NjcyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/51977#discussion_r376346721", "bodyText": "Maybe final boolean resolveIndexId = IndexMetaData.INDEX_UUID_NA_VALUE.equals(indexId.getId());", "author": "tlrx", "createdAt": "2020-02-07T11:35:17Z", "path": "server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java", "diffHunk": "@@ -473,20 +475,33 @@ private void restore(IndexShard indexShard, Repository repository, SnapshotRecov\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final String indexName = restoreSource.index();\n-            if (!shardId.getIndexName().equals(indexName)) {\n-                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n-            } else {\n+            final IndexId indexIdFromCS = restoreSource.index();\n+            if (shardId.getIndexName().equals(indexIdFromCS.getName())) {\n                 snapshotShardId = shardId;\n+            } else {\n+                snapshotShardId = new ShardId(indexIdFromCS.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n+            }\n+            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it buy index name\n+            final boolean indexUUIDUnavailable = indexIdFromCS.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE);", "originalCommit": "274a7e5db0d611051b2b0f57c88f2e2cb9a94716", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "11f84fefe579eceed336a3af696dc0e708bbf9a4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nindex 3dd0caacc2e..b84b6aa4c1e 100644\n--- a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n+++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n\n@@ -475,33 +474,24 @@ final class StoreRecovery {\n             translogState.totalOperationsOnStart(0);\n             indexShard.prepareForIndexRecovery();\n             final ShardId snapshotShardId;\n-            final IndexId indexIdFromCS = restoreSource.index();\n-            if (shardId.getIndexName().equals(indexIdFromCS.getName())) {\n+            final IndexId indexId = restoreSource.index();\n+            if (shardId.getIndexName().equals(indexId.getName())) {\n                 snapshotShardId = shardId;\n             } else {\n-                snapshotShardId = new ShardId(indexIdFromCS.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n+                snapshotShardId = new ShardId(indexId.getName(), IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id());\n             }\n-            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it buy index name\n-            final boolean indexUUIDUnavailable = indexIdFromCS.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE);\n-            final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-            repositoryDataListener.whenComplete(repositoryData -> {\n-                final IndexId indexId;\n-                if (indexUUIDUnavailable) {\n-                    indexId = repositoryData.resolveIndexId(indexIdFromCS.getName());\n-                } else {\n-                    assert repositoryData == null: \"Shouldn't have loaded RepositoryData but saw [\" + repositoryData + \"]\";\n-                    indexId = indexIdFromCS;\n-                }\n-                assert indexShard.getEngineOrNull() == null;\n-                repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(), indexId, snapshotShardId,\n-                    indexShard.recoveryState(), restoreListener);\n-            }, restoreListener::onFailure);\n-            if (indexUUIDUnavailable) {\n+            final StepListener<IndexId> indexIdListener = new StepListener<>();\n+            // If the index UUID was not found in the recovery source we will have to load RepositoryData and resolve it by index name\n+            if (indexId.getId().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {\n                 // BwC path, running against an old version master that did not add the IndexId to the recovery source\n-                repository.getRepositoryData(repositoryDataListener);\n+                repository.getRepositoryData(ActionListener.map(\n+                    indexIdListener, repositoryData -> repositoryData.resolveIndexId(indexId.getName())));\n             } else {\n-                repositoryDataListener.onResponse(null);\n+                indexIdListener.onResponse(indexId);\n             }\n+            assert indexShard.getEngineOrNull() == null;\n+            indexIdListener.whenComplete(idx -> repository.restoreShard(indexShard.store(), restoreSource.snapshot().getSnapshotId(),\n+                idx, snapshotShardId, indexShard.recoveryState(), restoreListener), restoreListener::onFailure);\n         } catch (Exception e) {\n             restoreListener.onFailure(e);\n         }\n"}}, {"oid": "11f84fefe579eceed336a3af696dc0e708bbf9a4", "url": "https://github.com/elastic/elasticsearch/commit/11f84fefe579eceed336a3af696dc0e708bbf9a4", "message": "nicer", "committedDate": "2020-02-07T11:49:51Z", "type": "commit"}]}