{"pr_number": 60994, "pr_title": "Add data tiers (hot, warm, cold, frozen) as custom node roles", "pr_createdAt": "2020-08-11T22:52:28Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60994", "timeline": [{"oid": "27974f13be8a140e8404f4484d3aa837937ce945", "url": "https://github.com/elastic/elasticsearch/commit/27974f13be8a140e8404f4484d3aa837937ce945", "message": "Add data tiers (hot, warm, cold, frozen) as custom node roles\n\nThis commit adds the `data_hot`, `data_warm`, `data_cold`, and `data_frozen` node roles to the\nx-pack plugin. These roles are intended to be the base for the formalization of data tiers in\nElasticsearch.\n\nThese roles all act as data nodes (meaning shards can be allocated to them). Nodes with the existing\n`data` role acts as though they have all of the roles configured (it is a hot, warm, cold, and\nfrozen node).\n\nThis also includes a custom `AllocationDecider` that allows the user to configure the following\nsettings on a cluster level:\n- `cluster.routing.allocation.require._tier`\n- `cluster.routing.allocation.include._tier`\n- `cluster.routing.allocation.exclude._tier`\n\nAnd in index settings:\n- `index.routing.allocation.require._tier`\n- `index.routing.allocation.include._tier`\n- `index.routing.allocation.exclude._tier`\n\nRelates to #60848", "committedDate": "2020-08-11T22:47:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMTYxOA==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469131618", "bodyText": "This doesn't read well to me. Should this be something along the lines of \"due to the way that plugins are initialized/started, the role settings may not be available from a static context/during bootstrapping of plugins\"? Or maybe due to the order in which the plugins are started?", "author": "andreidan", "createdAt": "2020-08-12T09:33:22Z", "path": "server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java", "diffHunk": "@@ -72,8 +73,13 @@ public static boolean isMasterNode(final Settings settings) {\n         return hasRole(settings, DiscoveryNodeRole.MASTER_ROLE);\n     }\n \n+    /**\n+     * Note, due to the way that plugins may not be available when settings are being initialized,", "originalCommit": "27974f13be8a140e8404f4484d3aa837937ce945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5MjI0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469292246", "bodyText": "I'll reword this a bit, thanks for the suggestion", "author": "dakrone", "createdAt": "2020-08-12T14:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMTYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMxNzE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469317157", "bodyText": "Thanks for updating this \ud83d\udc4d", "author": "andreidan", "createdAt": "2020-08-12T14:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMTYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "4373994d3d969271d75601777244d9fb70fef3c0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\nindex f9aae518f81..299989815b7 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\n\n@@ -74,9 +74,9 @@ public class DiscoveryNode implements Writeable, ToXContentFragment {\n     }\n \n     /**\n-     * Note, due to the way that plugins may not be available when settings are being initialized,\n-     * do not use this from a static {@link Setting} default value function, as it may not contain\n-     * all roles at that point.\n+     * Due to the way that plugins may not be available when settings are being initialized,\n+     * not all roles may be available from a static/initializing context such as a {@link Setting}\n+     * default value function. In that case, be warned that this may not include all plugin roles.\n      */\n     public static boolean isDataNode(final Settings settings) {\n         return getRolesFromSettings(settings).stream().anyMatch(DiscoveryNodeRole::canContainData);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0OTk5MA==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469149990", "bodyText": "nit: maybe personal preference but I find if statements without { } error-prone ( I seem to remember apple was bitten by this https://www.imperialviolet.org/2014/02/22/applebug.html )\nThere are a few if statements like this in this class, I'd rather have all of them use curly braces", "author": "andreidan", "createdAt": "2020-08-12T10:05:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDecider.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.cluster.routing.allocation;\n+\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.xpack.core.DataTier;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The {@code DataTierAllocationDecider} is a custom allocation decider that behaves similar to the\n+ * {@link org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider}, however it\n+ * is specific to the {@code _tier} setting for both the cluster and index level.\n+ */\n+public class DataTierAllocationDecider extends AllocationDecider {\n+\n+    public static final String NAME = \"data_tier\";\n+\n+    public static final String CLUSTER_ROUTING_REQUIRE = \"cluster.routing.allocation.require._tier\";\n+    public static final String CLUSTER_ROUTING_INCLUDE = \"cluster.routing.allocation.include._tier\";\n+    public static final String CLUSTER_ROUTING_EXCLUDE = \"cluster.routing.allocation.exclude._tier\";\n+    public static final String INDEX_ROUTING_REQUIRE = \"index.routing.allocation.require._tier\";\n+    public static final String INDEX_ROUTING_INCLUDE = \"index.routing.allocation.include._tier\";\n+    public static final String INDEX_ROUTING_EXCLUDE = \"index.routing.allocation.exclude._tier\";\n+\n+    public static final Setting<String> CLUSTER_ROUTING_REQUIRE_SETTING = Setting.simpleString(CLUSTER_ROUTING_REQUIRE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.NodeScope);\n+    public static final Setting<String> CLUSTER_ROUTING_INCLUDE_SETTING = Setting.simpleString(CLUSTER_ROUTING_INCLUDE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.NodeScope);\n+    public static final Setting<String> CLUSTER_ROUTING_EXCLUDE_SETTING = Setting.simpleString(CLUSTER_ROUTING_EXCLUDE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.NodeScope);\n+    public static final Setting<String> INDEX_ROUTING_REQUIRE_SETTING = Setting.simpleString(INDEX_ROUTING_REQUIRE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.IndexScope);\n+    public static final Setting<String> INDEX_ROUTING_INCLUDE_SETTING = Setting.simpleString(INDEX_ROUTING_INCLUDE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.IndexScope);\n+    public static final Setting<String> INDEX_ROUTING_EXCLUDE_SETTING = Setting.simpleString(INDEX_ROUTING_EXCLUDE,\n+        DataTierAllocationDecider::validateTierSetting, Setting.Property.Dynamic, Setting.Property.IndexScope);\n+\n+    private static void validateTierSetting(String setting) {\n+        if (Strings.hasText(setting)) {\n+            Set<String> invalidTiers = Arrays.stream(setting.split(\",\"))\n+                .filter(tier -> DataTier.validTierName(tier) == false)\n+                .collect(Collectors.toSet());\n+            if (invalidTiers.size() > 0) {\n+                throw new IllegalArgumentException(\"invalid tier names: \" + invalidTiers);\n+            }\n+        }\n+    }\n+\n+    private volatile String clusterRequire = null;\n+    private volatile String clusterInclude = null;\n+    private volatile String clusterExclude = null;\n+\n+    public DataTierAllocationDecider(ClusterSettings clusterSettings) {\n+        clusterSettings.addSettingsUpdateConsumer(CLUSTER_ROUTING_REQUIRE_SETTING, s -> this.clusterRequire = s);\n+        clusterSettings.addSettingsUpdateConsumer(CLUSTER_ROUTING_INCLUDE_SETTING, s -> this.clusterInclude = s);\n+        clusterSettings.addSettingsUpdateConsumer(CLUSTER_ROUTING_EXCLUDE_SETTING, s -> this.clusterExclude = s);\n+    }\n+\n+    @Override\n+    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n+        return shouldFilter(shardRouting, node.node(), allocation);\n+    }\n+\n+    @Override\n+    public Decision canAllocate(IndexMetadata indexMetadata, RoutingNode node, RoutingAllocation allocation) {\n+        return shouldFilter(indexMetadata, node.node(), allocation);\n+    }\n+\n+    @Override\n+    public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n+        return shouldFilter(shardRouting, node.node(), allocation);\n+    }\n+\n+    @Override\n+    public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n+        Decision decision = shouldClusterFilter(node, allocation);\n+        if (decision != null) return decision;", "originalCommit": "27974f13be8a140e8404f4484d3aa837937ce945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI4OTg4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469289887", "bodyText": "Yes I agree, this was copied from FilterAllocationDecider which is why, I'll change these to real if statements", "author": "dakrone", "createdAt": "2020-08-12T14:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0OTk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9a5233d281ff5582dc211dce54e2067a966ea6e3", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDecider.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDecider.java\nindex f1686cae878..3f5cce55ebf 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDecider.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDecider.java\n\n@@ -92,30 +92,42 @@ public class DataTierAllocationDecider extends AllocationDecider {\n     @Override\n     public Decision shouldAutoExpandToNode(IndexMetadata indexMetadata, DiscoveryNode node, RoutingAllocation allocation) {\n         Decision decision = shouldClusterFilter(node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         decision = shouldIndexFilter(indexMetadata, node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         return allocation.decision(Decision.YES, NAME, \"node passes include/exclude/require tier filters\");\n     }\n \n     private Decision shouldFilter(ShardRouting shardRouting, DiscoveryNode node, RoutingAllocation allocation) {\n         Decision decision = shouldClusterFilter(node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         decision = shouldIndexFilter(allocation.metadata().getIndexSafe(shardRouting.index()), node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         return allocation.decision(Decision.YES, NAME, \"node passes include/exclude/require tier filters\");\n     }\n \n     private Decision shouldFilter(IndexMetadata indexMd, DiscoveryNode node, RoutingAllocation allocation) {\n         Decision decision = shouldClusterFilter(node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         decision = shouldIndexFilter(indexMd, node, allocation);\n-        if (decision != null) return decision;\n+        if (decision != null) {\n+            return decision;\n+        }\n \n         return allocation.decision(Decision.YES, NAME, \"node passes include/exclude/require tier filters\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MzA3MA==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469163070", "bodyText": "shall we add a test that has both cluster and index routings? (maybe one where allocation is successful and one where the index routing matches but the cluster one doesn't to test the cluster settings precedence?", "author": "andreidan", "createdAt": "2020-08-12T10:30:44Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.cluster.routing.allocation;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ESAllocationTestCase;\n+import org.elasticsearch.cluster.EmptyClusterInfoService;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodeRole;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.cluster.routing.RecoverySource;\n+import org.elasticsearch.cluster.routing.RoutingNode;\n+import org.elasticsearch.cluster.routing.ShardRouting;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.cluster.routing.allocation.AllocationService;\n+import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\n+import org.elasticsearch.cluster.routing.allocation.allocator.BalancedShardsAllocator;\n+import org.elasticsearch.cluster.routing.allocation.decider.AllocationDeciders;\n+import org.elasticsearch.cluster.routing.allocation.decider.Decision;\n+import org.elasticsearch.cluster.routing.allocation.decider.ReplicaAfterPrimaryActiveAllocationDecider;\n+import org.elasticsearch.cluster.routing.allocation.decider.SameShardAllocationDecider;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.test.gateway.TestGatewayAllocator;\n+import org.elasticsearch.xpack.core.DataTier;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n+\n+    private static final Set<Setting<?>> ALL_SETTINGS;\n+    private static final DiscoveryNode HOT_NODE = newNode(\"node-hot\", Collections.singleton(DataTier.DATA_HOT_NODE_ROLE));\n+    private static final DiscoveryNode WARM_NODE = newNode(\"node-warm\", Collections.singleton(DataTier.DATA_WARM_NODE_ROLE));\n+    private static final DiscoveryNode COLD_NODE = newNode(\"node-cold\", Collections.singleton(DataTier.DATA_COLD_NODE_ROLE));\n+    private static final DiscoveryNode FROZEN_NODE = newNode(\"node-frozen\", Collections.singleton(DataTier.DATA_FROZEN_NODE_ROLE));\n+    private static final DiscoveryNode DATA_NODE = newNode(\"node-data\", Collections.singleton(DiscoveryNodeRole.DATA_ROLE));\n+\n+    private final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ALL_SETTINGS);\n+    private final DataTierAllocationDecider decider = new DataTierAllocationDecider(clusterSettings);\n+    private final AllocationDeciders allocationDeciders = new AllocationDeciders(\n+        Arrays.asList(decider,\n+            new SameShardAllocationDecider(Settings.EMPTY, clusterSettings),\n+            new ReplicaAfterPrimaryActiveAllocationDecider()));\n+    private final AllocationService service = new AllocationService(allocationDeciders,\n+        new TestGatewayAllocator(), new BalancedShardsAllocator(Settings.EMPTY), EmptyClusterInfoService.INSTANCE);\n+\n+    private final ShardRouting shard = ShardRouting.newUnassigned(new ShardId(\"myindex\", \"myindex\", 0), true,\n+        RecoverySource.EmptyStoreRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, \"index created\"));\n+\n+    static {\n+        Set<Setting<?>> allSettings = new HashSet<>(ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_REQUIRE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_INCLUDE_SETTING);\n+        allSettings.add(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE_SETTING);\n+        ALL_SETTINGS = allSettings;\n+    }\n+\n+    public void testClusterRequires() {", "originalCommit": "27974f13be8a140e8404f4484d3aa837937ce945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5ODg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469298846", "bodyText": "Sure! I added this", "author": "dakrone", "createdAt": "2020-08-12T14:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2MzA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "b0b4c08cfc5129d48b79c73d379494381a78d8b3", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\nindex c67da351588..bedbcdeecca 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/cluster/routing/allocation/DataTierAllocationDeciderTests.java\n\n@@ -275,6 +275,55 @@ public class DataTierAllocationDeciderTests extends ESAllocationTestCase {\n         }\n     }\n \n+    public void testClusterAndIndex() {\n+        ClusterState state = prepareState(service.reroute(ClusterState.EMPTY_STATE, \"initial state\"),\n+            Settings.builder()\n+                .put(DataTierAllocationDecider.INDEX_ROUTING_INCLUDE, \"data_warm,data_frozen\")\n+                .build());\n+        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state.getRoutingNodes(), state,\n+            null, 0);\n+        clusterSettings.applySettings(Settings.builder()\n+            .put(DataTierAllocationDecider.CLUSTER_ROUTING_EXCLUDE, \"data_frozen\")\n+            .build());\n+        allocation.debugDecision(true);\n+        Decision d;\n+        RoutingNode node;\n+\n+        for (DiscoveryNode n : Arrays.asList(HOT_NODE, COLD_NODE)) {\n+            node = new RoutingNode(n.getId(), n, shard);\n+            d = decider.canAllocate(shard, node, allocation);\n+            assertThat(node.toString(), d.type(), equalTo(Decision.Type.NO));\n+            assertThat(node.toString(), d.getExplanation(),\n+                containsString(\"node does not match any index setting [index.routing.allocation.include._tier] \" +\n+                    \"tier filters [data_warm,data_frozen]\"));\n+            d = decider.canRemain(shard, node, allocation);\n+            assertThat(node.toString(), d.type(), equalTo(Decision.Type.NO));\n+            assertThat(node.toString(), d.getExplanation(),\n+                containsString(\"node does not match any index setting [index.routing.allocation.include._tier] \" +\n+                    \"tier filters [data_warm,data_frozen]\"));\n+        }\n+\n+        for (DiscoveryNode n : Arrays.asList(FROZEN_NODE, DATA_NODE)) {\n+            node = new RoutingNode(n.getId(), n, shard);\n+            d = decider.canAllocate(shard, node, allocation);\n+            assertThat(node.toString(), d.type(), equalTo(Decision.Type.NO));\n+            assertThat(d.getExplanation(),\n+                containsString(\"node matches any cluster setting [cluster.routing.allocation.exclude._tier] tier filters [data_frozen]\"));\n+            d = decider.canRemain(shard, node, allocation);\n+            assertThat(node.toString(), d.type(), equalTo(Decision.Type.NO));\n+            assertThat(d.getExplanation(),\n+                containsString(\"node matches any cluster setting [cluster.routing.allocation.exclude._tier] tier filters [data_frozen]\"));\n+        }\n+\n+        for (DiscoveryNode n : Arrays.asList(WARM_NODE)) {\n+            node = new RoutingNode(n.getId(), n, shard);\n+            d = decider.canAllocate(shard, node, allocation);\n+            assertThat(n.toString(), d.type(), equalTo(Decision.Type.YES));\n+            d = decider.canRemain(shard, node, allocation);\n+            assertThat(n.toString(), d.type(), equalTo(Decision.Type.YES));\n+        }\n+    }\n+\n     private ClusterState prepareState(ClusterState initialState) {\n         return prepareState(initialState, Settings.EMPTY);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NTgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469165822", "bodyText": "should we mention the hasRole || DataTier.isExplicitDataTier alternative in the doc here?", "author": "andreidan", "createdAt": "2020-08-12T10:36:24Z", "path": "server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java", "diffHunk": "@@ -72,8 +73,13 @@ public static boolean isMasterNode(final Settings settings) {\n         return hasRole(settings, DiscoveryNodeRole.MASTER_ROLE);\n     }\n \n+    /**\n+     * Note, due to the way that plugins may not be available when settings are being initialized,\n+     * do not use this from a static {@link Setting} default value function, as it may not contain\n+     * all roles at that point.", "originalCommit": "27974f13be8a140e8404f4484d3aa837937ce945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTI5MDE1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60994#discussion_r469290155", "bodyText": "DataTier is an x-pack concept, so I didn't want to mention it here", "author": "dakrone", "createdAt": "2020-08-12T14:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE2NTgyMg=="}], "type": "inlineReview", "revised_code": {"commit": "4373994d3d969271d75601777244d9fb70fef3c0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\nindex f9aae518f81..299989815b7 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/node/DiscoveryNode.java\n\n@@ -74,9 +74,9 @@ public class DiscoveryNode implements Writeable, ToXContentFragment {\n     }\n \n     /**\n-     * Note, due to the way that plugins may not be available when settings are being initialized,\n-     * do not use this from a static {@link Setting} default value function, as it may not contain\n-     * all roles at that point.\n+     * Due to the way that plugins may not be available when settings are being initialized,\n+     * not all roles may be available from a static/initializing context such as a {@link Setting}\n+     * default value function. In that case, be warned that this may not include all plugin roles.\n      */\n     public static boolean isDataNode(final Settings settings) {\n         return getRolesFromSettings(settings).stream().anyMatch(DiscoveryNodeRole::canContainData);\n"}}, {"oid": "9a5233d281ff5582dc211dce54e2067a966ea6e3", "url": "https://github.com/elastic/elasticsearch/commit/9a5233d281ff5582dc211dce54e2067a966ea6e3", "message": "Use real \"if\" statements", "committedDate": "2020-08-12T14:13:36Z", "type": "commit"}, {"oid": "4373994d3d969271d75601777244d9fb70fef3c0", "url": "https://github.com/elastic/elasticsearch/commit/4373994d3d969271d75601777244d9fb70fef3c0", "message": "Clarify documentation message", "committedDate": "2020-08-12T14:15:19Z", "type": "commit"}, {"oid": "b0b4c08cfc5129d48b79c73d379494381a78d8b3", "url": "https://github.com/elastic/elasticsearch/commit/b0b4c08cfc5129d48b79c73d379494381a78d8b3", "message": "Add a test using both cluster and index settings", "committedDate": "2020-08-12T14:24:24Z", "type": "commit"}]}