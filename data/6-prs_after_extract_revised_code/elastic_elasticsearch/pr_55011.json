{"pr_number": 55011, "pr_title": "[Transform] implement throttling in indexer", "pr_createdAt": "2020-04-09T13:17:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55011", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r407519609", "bodyText": "Since this is not synchronized, I am not sure if private synchronized void reQueueThrottledSearch() or private synchronized void triggerThrottledSearchNow() actually work :/. The scheduledNextSearch could get set out from under those blocks. Unless we are ONLY worried about reQueueThrottledSearch and triggerThrottledSearchNow conflicting.", "author": "benwtrent", "createdAt": "2020-04-13T14:53:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -410,25 +473,43 @@ private void onSearchResponse(SearchResponse searchResponse) {\n     private void onBulkResponse(BulkResponse response, JobPosition position) {\n         stats.markEndIndexing();\n         try {\n-            ActionListener<SearchResponse> listener = ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n             // TODO probably something more intelligent than every-50 is needed\n             if (stats.getNumPages() > 0 && stats.getNumPages() % 50 == 0) {\n                 doSaveState(IndexerState.INDEXING, position, () -> {\n-                    nextSearch(listener);\n+                    nextSearch();\n                 });\n             } else {\n-                nextSearch(listener);\n+                nextSearch();\n             }\n         } catch (Exception e) {\n             finishWithIndexingFailure(e);\n         }\n     }\n \n-    private void nextSearch(ActionListener<SearchResponse> listener) {\n+    protected void nextSearch() {\n+        if (maximumRequestsPerSecond > 0 && lastDocCount > 0) {\n+            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos,\n+                    getTimeNanos());\n+\n+            if (executionDelay.duration() > 0) {\n+                logger.debug(\"throttling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n+                        lastDocCount);\n+                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);", "originalCommit": "dc0a4bc9ccb8cb58da69def30129226bf1e285c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzODU3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r408138576", "bodyText": "good point. Synchronized for re-throttle and stop is required, because there could be parallel calls to it. nextSearch only runs in the indexer thread, so its never called more than once at the same time.\nThe purpose of triggerThrottledSearchNow is to avoid a long waiting time between calling stop and the actual stop. For this case the idea is to trigger the search immediately. However its still possible that stop is called but the search ends in the wait queue.\nI will revisit it. Maybe its better to cancel the search request instead of re-queuing, e.g. if stop is called, because of cluster trouble.", "author": "hendrikmuhs", "createdAt": "2020-04-14T13:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c55d357dce778f6aa02b20b01109155eb295662", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex bc7b7410621..94eba8d20f1 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -495,6 +495,12 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n                 logger.debug(\"throttling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n                         lastDocCount);\n                 scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);\n+\n+                // corner case: if for whatever reason stop() has been called meanwhile fast forward\n+                if (getState().equals(IndexerState.STOPPING)) {\n+                    triggerThrottledSearchNow();\n+                }\n+\n                 return;\n             }\n         }\n"}}, {"oid": "7c55d357dce778f6aa02b20b01109155eb295662", "url": "https://github.com/elastic/elasticsearch/commit/7c55d357dce778f6aa02b20b01109155eb295662", "message": "fix corner case issue when stop is called while a next search is scheduled", "committedDate": "2020-04-14T15:09:36Z", "type": "forcePushed"}, {"oid": "35a9b748ad78f994697ccbc770208fc19c3844e2", "url": "https://github.com/elastic/elasticsearch/commit/35a9b748ad78f994697ccbc770208fc19c3844e2", "message": "expose wait time so rollup/transform can issue lightweight queries for\nthrottling", "committedDate": "2020-04-21T09:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NTg3NA==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412285874", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Cancels a scheduled search request and issues the search request immediately\n          \n          \n            \n                 * Cancels a scheduled search request", "author": "benwtrent", "createdAt": "2020-04-21T15:27:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately", "originalCommit": "4f922f21e48acf6a3b70b7ed88341aa31796ca91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df0b527d9852ad70288182b93d9edfc33104c191", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex 33cd75e38fe..dccbefe77b9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -208,15 +253,6 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n         }\n     }\n \n-    /**\n-     * Cancels a scheduled search request and issues the search request immediately\n-     */\n-    private synchronized void stopThrottledSearch() {\n-        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {\n-            threadPool.executor(executorName).execute(() -> checkState(getState()));\n-        }\n-    }\n-\n     /**\n      * Sets a new requestsPerSecond and re-schedules the search request if necessary, either\n      * immediately or according to the new requestsPerSecond setting.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzOTU0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412339542", "bodyText": "From what I understand around cancel, the only times it will return false are:\n\nIf the action has already been completed\nIf the action has already been cancelled.\n\nThis means it will return true if the thread is executing.\nthreadPool.executor(executorName).execute(() -> checkState(getState()));\n\nCould happen in the middle of triggerNextSearch. This MIGHT be ok, but the call to checkState(getState()) might transition from STOPPING -> STOPPED while a search is still in flight. I am not sure this is intended behavior.", "author": "benwtrent", "createdAt": "2020-04-21T17:13:17Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -178,6 +208,35 @@ public synchronized boolean maybeTriggerAsyncJob(long now) {\n         }\n     }\n \n+    /**\n+     * Cancels a scheduled search request and issues the search request immediately\n+     */\n+    private synchronized void stopThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "originalCommit": "4f922f21e48acf6a3b70b7ed88341aa31796ca91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df0b527d9852ad70288182b93d9edfc33104c191", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex 33cd75e38fe..dccbefe77b9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -208,15 +253,6 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n         }\n     }\n \n-    /**\n-     * Cancels a scheduled search request and issues the search request immediately\n-     */\n-    private synchronized void stopThrottledSearch() {\n-        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {\n-            threadPool.executor(executorName).execute(() -> checkState(getState()));\n-        }\n-    }\n-\n     /**\n      * Sets a new requestsPerSecond and re-schedules the search request if necessary, either\n      * immediately or according to the new requestsPerSecond setting.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r412341103", "bodyText": "Similar comment to above, a current search could be inflight. This means that if the next delay is 0L, we could have two searches occurring in parallel.\nAs long as this method is NEVER called out of band, I think this might be ok.", "author": "benwtrent", "createdAt": "2020-04-21T17:15:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +562,37 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {", "originalCommit": "4f922f21e48acf6a3b70b7ed88341aa31796ca91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df0b527d9852ad70288182b93d9edfc33104c191", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex 33cd75e38fe..dccbefe77b9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -563,19 +612,16 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n     }\n \n     private synchronized void reQueueThrottledSearch() {\n-        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {\n-            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos,\n-                    getTimeNanos());\n-\n-            if (executionDelay.duration() > 0) {\n-                logger.debug(\"rethrottling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond,\n-                        lastDocCount);\n-                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(executionDelay.getNanos()), executionDelay,\n-                        executorName);\n-                return;\n-            } else {\n-                threadPool.executor(executorName).execute(() -> triggerNextSearch(0L));\n-            }\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                maximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\"rethrottling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond, lastDocCount);\n+            scheduledNextSearch.reschedule(executionDelay);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA1MjkyNw==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414052927", "bodyText": "I realized its developer unfriendly to pass maximumRequestsPerSecond as parameter of the constructor.\nIt seems better to have getMaximumRequestsPerSecond() which can be overridden. I still need the rethrottle method, but without a parameter. To avoid that rethrottle kicks in although it hasn't changed, I would still cache the last value for comparison.", "author": "hendrikmuhs", "createdAt": "2020-04-23T19:08:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -38,18 +42,69 @@\n public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends IndexerJobStats> {\n     private static final Logger logger = LogManager.getLogger(AsyncTwoPhaseIndexer.class.getName());\n \n+    // max time to wait for throttling\n+    private static final TimeValue MAX_THROTTLE_WAIT_TIME =  TimeValue.timeValueHours(1);\n+    // min time to trigger delayed execution\n+    private static final TimeValue MIN_THROTTLE_WAIT_TIME =  TimeValue.timeValueMillis(10);\n+\n+    private final ActionListener<SearchResponse> searchResponseListener =\n+        ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n+\n     private final JobStats stats;\n \n     private final AtomicReference<IndexerState> state;\n     private final AtomicReference<JobPosition> position;\n-    private final Executor executor;\n+    private final ThreadPool threadPool;\n+    private final String executorName;\n+\n+    // throttling\n+    private volatile float maximumRequestsPerSecond;\n+    private volatile long lastSearchStartTimeNanos = 0;\n+    private volatile long lastDocCount = 0;\n+    private volatile ScheduledRunnable scheduledNextSearch;\n+\n+    class ScheduledRunnable {\n+        private final ThreadPool threadPool;\n+        private final String executorName;\n+        private final Runnable command;\n+        private Scheduler.ScheduledCancellable scheduled;\n+\n+        ScheduledRunnable(ThreadPool threadPool, String executorName, TimeValue delay, Runnable command) {\n+            this.threadPool = threadPool;\n+            this.executorName = executorName;\n+\n+            // with wrapping the command in RunOnce we ensure the command isn't executed twice, e.g. if the\n+            // future is already running and cancel returns true\n+            this.command = new RunOnce(command);\n+            this.scheduled = threadPool.schedule(() -> {command.run();}, delay, executorName);\n+        }\n+\n+        public void reschedule(TimeValue delay) {\n+            // note: cancel return true if the runnable is currently executing\n+            if (scheduled.cancel()) {\n+                if (delay.duration() > 0) {\n+                    scheduled = threadPool.schedule(() -> command.run(), delay, executorName);\n+                } else {\n+                    threadPool.executor(executorName).execute(() -> command.run());\n+                }\n+            }\n+        }\n \n-    protected AsyncTwoPhaseIndexer(Executor executor, AtomicReference<IndexerState> initialState,\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n                                    JobPosition initialPosition, JobStats jobStats) {\n-        this.executor = executor;\n+        this(threadPool, executorName, initialState, initialPosition, jobStats, -1);\n+    }\n+\n+    protected AsyncTwoPhaseIndexer(ThreadPool threadPool, String executorName, AtomicReference<IndexerState> initialState,\n+            JobPosition initialPosition, JobStats jobStats, float maximumRequestsPerSecond) {", "originalCommit": "9a247d15d98fa947e37d7391fb1dc3b1f6f49ad8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df0b527d9852ad70288182b93d9edfc33104c191", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex 44940eef3cc..dccbefe77b9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -43,12 +43,14 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n     private static final Logger logger = LogManager.getLogger(AsyncTwoPhaseIndexer.class.getName());\n \n     // max time to wait for throttling\n-    private static final TimeValue MAX_THROTTLE_WAIT_TIME =  TimeValue.timeValueHours(1);\n+    private static final TimeValue MAX_THROTTLE_WAIT_TIME = TimeValue.timeValueHours(1);\n     // min time to trigger delayed execution\n-    private static final TimeValue MIN_THROTTLE_WAIT_TIME =  TimeValue.timeValueMillis(10);\n+    private static final TimeValue MIN_THROTTLE_WAIT_TIME = TimeValue.timeValueMillis(10);\n \n-    private final ActionListener<SearchResponse> searchResponseListener =\n-        ActionListener.wrap(this::onSearchResponse, this::finishWithSearchFailure);\n+    private final ActionListener<SearchResponse> searchResponseListener = ActionListener.wrap(\n+        this::onSearchResponse,\n+        this::finishWithSearchFailure\n+    );\n \n     private final JobStats stats;\n \n"}}, {"oid": "df0b527d9852ad70288182b93d9edfc33104c191", "url": "https://github.com/elastic/elasticsearch/commit/df0b527d9852ad70288182b93d9edfc33104c191", "message": "formatting", "committedDate": "2020-04-24T06:59:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MDQyMA==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414390420", "bodyText": "nit: these two arguments should be camelCase", "author": "droberts195", "createdAt": "2020-04-24T08:24:47Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,", "originalCommit": "d0942bce8274f080ee0fb1c50ca3314ee646be7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\nindex abb113abfc5..ab9ba1d3331 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\n\n@@ -518,11 +505,8 @@ public class AsyncTwoPhaseIndexerTests extends ESTestCase {\n         doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n     }\n \n-    public void doTestFiveRunsRethrottle(\n-        float requests_per_second,\n-        float requests_per_second_rethrottle,\n-        Collection<TimeValue> expectedDelays\n-    ) throws Exception {\n+    public void doTestFiveRunsRethrottle(float requests_per_second, float requests_per_second_rethrottle,\n+                                         Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n \n         final MockThreadPool threadPool = new MockThreadPool(getTestName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MTM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414391354", "bodyText": "This comment initially confused me.  It might be clear to say:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // wait until the indexer reached latch await\n          \n          \n            \n                        // wait until the indexer starts waiting on the latch", "author": "droberts195", "createdAt": "2020-04-24T08:26:13Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java", "diffHunk": "@@ -382,22 +457,135 @@ public void testStop_WhileIndexing() throws Exception {\n             assertBusy(() -> assertTrue(isStopped.get()));\n             assertFalse(isFinished.get());\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n \n     public void testFiveRuns() throws Exception {\n+        doTestFiveRuns(-1, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled100() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(100, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsThrottled1000() throws Exception {\n+        // expect throttling to kick in\n+        doTestFiveRuns(1_000, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 950L));\n+    }\n+\n+    public void testFiveRunsThrottled18000() throws Exception {\n+        // expect throttling to not kick in due to min wait time\n+        doTestFiveRuns(18_000, Collections.emptyList());\n+    }\n+\n+    public void testFiveRunsThrottled1000000() throws Exception {\n+        // request per seconds is set high, so throttling does not kick in\n+        doTestFiveRuns(1_000_000, Collections.emptyList());\n+    }\n+\n+    public void doTestFiveRuns(float requests_per_second, Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n-        final ExecutorService executor = Executors.newFixedThreadPool(1);\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n         try {\n-            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (executor, state, 2);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                null);\n             indexer.start();\n             assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n             assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n             assertBusy(() -> assertTrue(isFinished.get()));\n             indexer.assertCounters();\n+            threadPool.assertCountersAndDelay(expectedDelays);\n         } finally {\n-            executor.shutdownNow();\n+            ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS);\n         }\n     }\n+\n+    public void testFiveRunsRethrottle0_100() throws Exception {\n+        doTestFiveRunsRethrottle(-1, 100, timeValueCollectionFromMilliseconds(9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_0() throws Exception {\n+        doTestFiveRunsRethrottle(100, 0, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L));\n+    }\n+\n+    public void testFiveRunsRethrottle100_1000() throws Exception {\n+        doTestFiveRunsRethrottle(100, 1000, timeValueCollectionFromMilliseconds(9950L, 9950L, 9950L, 950L));\n+    }\n+\n+    public void testFiveRunsRethrottle1000_100() throws Exception {\n+        doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n+    }\n+\n+    public void doTestFiveRunsRethrottle(\n+        float requests_per_second,\n+        float requests_per_second_rethrottle,\n+        Collection<TimeValue> expectedDelays\n+    ) throws Exception {\n+        AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n+\n+        final MockThreadPool threadPool = new MockThreadPool(getTestName());\n+        try {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            MockIndexerFiveRuns indexer = new MockIndexerFiveRuns (threadPool, ThreadPool.Names.GENERIC, state, 2, requests_per_second,\n+                latch);\n+            indexer.start();\n+            assertThat(indexer.getState(), equalTo(IndexerState.STARTED));\n+            assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));\n+            // wait until the indexer reached latch await", "originalCommit": "d0942bce8274f080ee0fb1c50ca3314ee646be7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\nindex abb113abfc5..ab9ba1d3331 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexerTests.java\n\n@@ -518,11 +505,8 @@ public class AsyncTwoPhaseIndexerTests extends ESTestCase {\n         doTestFiveRunsRethrottle(1000, 100, timeValueCollectionFromMilliseconds(950L, 950L, 950L, 9950L));\n     }\n \n-    public void doTestFiveRunsRethrottle(\n-        float requests_per_second,\n-        float requests_per_second_rethrottle,\n-        Collection<TimeValue> expectedDelays\n-    ) throws Exception {\n+    public void doTestFiveRunsRethrottle(float requests_per_second, float requests_per_second_rethrottle,\n+                                         Collection<TimeValue> expectedDelays) throws Exception {\n         AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STOPPED);\n \n         final MockThreadPool threadPool = new MockThreadPool(getTestName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414394686", "bodyText": "This formula implies that requestsPerSecond is really desiredDocsPerSecond.  If that's correct then requestsPerSecond seems like it will cause confusion in the future because I would assume requestsPerSecond referred to the number of searches, each of which could return many documents.\nFor example, if I saw a configuration parameter requests_per_second I might decide to set it to 2 so that I'd get a maximum of 2 search requests per second from this functionality.  But then if one of my searches returns 1000 documents then I get a 500 second wait until the next search.", "author": "droberts195", "createdAt": "2020-04-24T08:31:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java", "diffHunk": "@@ -461,4 +608,43 @@ private boolean checkState(IndexerState currentState) {\n         }\n     }\n \n+    private synchronized void reQueueThrottledSearch() {\n+        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n+\n+        if (scheduledNextSearch != null) {\n+            TimeValue executionDelay = calculateThrottlingDelay(\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount,\n+                lastSearchStartTimeNanos,\n+                getTimeNanos()\n+            );\n+\n+            logger.debug(\n+                \"rethrottling job [{}], wait for {} ({} {})\",\n+                getJobId(),\n+                executionDelay,\n+                currentMaximumRequestsPerSecond,\n+                lastDocCount\n+            );\n+            scheduledNextSearch.reschedule(executionDelay);\n+        }\n+    }\n+\n+    static TimeValue calculateThrottlingDelay(float requestsPerSecond, long docCount, long startTimeNanos, long now) {\n+        if (requestsPerSecond <= 0) {\n+            return TimeValue.ZERO;\n+        }\n+        float timeToWaitNanos = (docCount / requestsPerSecond) * TimeUnit.SECONDS.toNanos(1);", "originalCommit": "d0942bce8274f080ee0fb1c50ca3314ee646be7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxMjQ3OA==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414412478", "bodyText": "I saw a couple of nits but I stopped reviewing when I saw the throttling formula because it seems to highlight a fundamental issue: are we intending to throttle based on search requests per second or documents retrieved per second? What changes are required will depend on the answer to that.\n\nThis design and the reasons for that are discussed in the tracking issue: #54862. In a nutshell: You are right that requests_per_second is misleading. The name has still been chosen, because its a existing concept from reindex. It's wrong there, too.", "author": "hendrikmuhs", "createdAt": "2020-04-24T08:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyODExOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55011#discussion_r414428119", "bodyText": "Ah yes, I missed that requests_per_second is used in this way for reindex already.  In that case consistency with reindex is more important.", "author": "droberts195", "createdAt": "2020-04-24T09:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\nindex c3c3d66367d..9be159c744e 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/indexing/AsyncTwoPhaseIndexer.java\n\n@@ -609,24 +541,16 @@ public abstract class AsyncTwoPhaseIndexer<JobPosition, JobStats extends Indexer\n     }\n \n     private synchronized void reQueueThrottledSearch() {\n-        currentMaximumRequestsPerSecond = getMaximumRequestsPerSecond();\n-\n-        if (scheduledNextSearch != null) {\n-            TimeValue executionDelay = calculateThrottlingDelay(\n-                currentMaximumRequestsPerSecond,\n-                lastDocCount,\n-                lastSearchStartTimeNanos,\n-                getTimeNanos()\n-            );\n-\n-            logger.debug(\n-                \"rethrottling job [{}], wait for {} ({} {})\",\n-                getJobId(),\n-                executionDelay,\n-                currentMaximumRequestsPerSecond,\n-                lastDocCount\n-            );\n-            scheduledNextSearch.reschedule(executionDelay);\n+        if (scheduledNextSearch != null && scheduledNextSearch.cancel()) {\n+            TimeValue executionDelay = calculateThrottlingDelay(maximumRequestsPerSecond, lastDocCount, lastSearchStartTimeNanos, getTimeNanos());\n+\n+            if (executionDelay.duration() > 0) {\n+                logger.debug(\"rethrottling job [{}], wait for {} ({} {})\", getJobId(), executionDelay, maximumRequestsPerSecond, lastDocCount);\n+                scheduledNextSearch = threadPool.schedule(() -> triggerNextSearch(), executionDelay, executorName);\n+                return;\n+            } else {\n+                threadPool.executor(executorName).execute(() -> triggerNextSearch());\n+            }\n         }\n     }\n \n"}}, {"oid": "56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "url": "https://github.com/elastic/elasticsearch/commit/56f5f9dd9daa530a888ec4441122d88e7c43c9aa", "message": "implement throttling in indexer, to be used in transform", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "bec60e33febcbdba94e0b0d4180456eaaace62ff", "url": "https://github.com/elastic/elasticsearch/commit/bec60e33febcbdba94e0b0d4180456eaaace62ff", "message": "checkstyle", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "1e09c5b86856a9ac476214ae907abad36c5fc5f3", "url": "https://github.com/elastic/elasticsearch/commit/1e09c5b86856a9ac476214ae907abad36c5fc5f3", "message": "fix corner case issue when stop is called while a next search is scheduled", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "92293eb42ac9bda85a1d10aab2a4a5acf01d3168", "url": "https://github.com/elastic/elasticsearch/commit/92293eb42ac9bda85a1d10aab2a4a5acf01d3168", "message": "all throttling members should be volatile", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "cef664e895f2264ed50bb73c5471772badb83422", "url": "https://github.com/elastic/elasticsearch/commit/cef664e895f2264ed50bb73c5471772badb83422", "message": "check state more often and do not fire a search request in case of stopping", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "1f6cfeca3572eb8bd9631d42e1f7648bfc35b07e", "url": "https://github.com/elastic/elasticsearch/commit/1f6cfeca3572eb8bd9631d42e1f7648bfc35b07e", "message": "expose wait time so rollup/transform can issue lightweight queries for\nthrottling", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "d2edb4782e7dfa2d09db245dc1eeee40a5ca0f7a", "url": "https://github.com/elastic/elasticsearch/commit/d2edb4782e7dfa2d09db245dc1eeee40a5ca0f7a", "message": "fix test after stopping earlier", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "fc401f7d14bce16d46eedf1002d46565de86cc9b", "url": "https://github.com/elastic/elasticsearch/commit/fc401f7d14bce16d46eedf1002d46565de86cc9b", "message": "improve code comment", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "463a597bcfbf14fff759afecd31aeaf4351c8111", "url": "https://github.com/elastic/elasticsearch/commit/463a597bcfbf14fff759afecd31aeaf4351c8111", "message": "relax test", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "fd865be8d5a257b2523b1e298bb409c93a1ea30a", "url": "https://github.com/elastic/elasticsearch/commit/fd865be8d5a257b2523b1e298bb409c93a1ea30a", "message": "use checkState to stop job", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "ef4f27fcff8ab7c9cbd9b282e553e7f57b643616", "url": "https://github.com/elastic/elasticsearch/commit/ef4f27fcff8ab7c9cbd9b282e553e7f57b643616", "message": "use runOnce to workaround potential duplicate listener calls when re-throttling", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "54f4874b73131096aad2a3335464605ab7ae9446", "url": "https://github.com/elastic/elasticsearch/commit/54f4874b73131096aad2a3335464605ab7ae9446", "message": "checkstyle", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "2c1e6835ff3bf7811940de852d1683acdde62caf", "url": "https://github.com/elastic/elasticsearch/commit/2c1e6835ff3bf7811940de852d1683acdde62caf", "message": "formatting", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "70cd6fc0fdd76953133f76176b8136704b0a93b2", "url": "https://github.com/elastic/elasticsearch/commit/70cd6fc0fdd76953133f76176b8136704b0a93b2", "message": "get maximumRequestsPerSecond via a getter instead of requiring a constructor\nargument", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "7bb62e5ffd0ebcf7495b65b0e884497fd4aa19a1", "url": "https://github.com/elastic/elasticsearch/commit/7bb62e5ffd0ebcf7495b65b0e884497fd4aa19a1", "message": "address review comments", "committedDate": "2020-04-28T18:43:33Z", "type": "commit"}, {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b", "url": "https://github.com/elastic/elasticsearch/commit/20125a3f3a6ae46edc0434645462920f7e35308b", "message": "renames requests_per_second to docs_per_second", "committedDate": "2020-04-28T19:19:22Z", "type": "commit"}, {"oid": "20125a3f3a6ae46edc0434645462920f7e35308b", "url": "https://github.com/elastic/elasticsearch/commit/20125a3f3a6ae46edc0434645462920f7e35308b", "message": "renames requests_per_second to docs_per_second", "committedDate": "2020-04-28T19:19:22Z", "type": "forcePushed"}]}