{"pr_number": 52986, "pr_title": "Make ServiceProvider lookup asynchronous", "pr_createdAt": "2020-03-01T01:48:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52986", "timeline": [{"oid": "266792188f375864492a9e6bf6254e8ed694e0cb", "url": "https://github.com/elastic/elasticsearch/commit/266792188f375864492a9e6bf6254e8ed694e0cb", "message": "Make ServiceProvider lookup asynchronous\n\nThis prepares for reading the real Service Provider data from the saml\nindex.\n\nWe intend to support a large number of ServiceProviders within a\nsingle cluster, so it is not reasible to keep them all cached in\nmemory. Since the read from the underyling index will be asynchronous,\nall methods that make use of a service provider also need to be\nasychronous.", "committedDate": "2020-03-01T01:45:41Z", "type": "commit"}, {"oid": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "url": "https://github.com/elastic/elasticsearch/commit/d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "message": "Revert whitespace change", "committedDate": "2020-03-01T04:24:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwMjU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r386802546", "bodyText": "TODO: This return value (boolean) is obsolete. It was there from IntelliJ's refactoring and I forgot to fix it.", "author": "tvernum", "createdAt": "2020-03-03T05:11:54Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -73,76 +74,108 @@ public SamlAuthnRequestValidator(SamlFactory samlFactory, SamlIdentityProvider i\n     }\n \n     public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+\n+        final ParsedQueryString parsedQueryString;\n+        try {\n+            parsedQueryString = parseQueryString(queryString);\n+        } catch (ElasticsearchSecurityException e) {\n+            logger.debug(\"Failed to parse query string for SAML AuthnRequest\", e);\n+            listener.onFailure(e);\n+            return;\n+        }\n+\n         try {\n-            final Map<String, String> parameters = new HashMap<>();\n-            RestUtils.decodeQueryString(queryString, 0, parameters);\n-            if (parameters.isEmpty()) {\n-                logAndRespond(\"Invalid Authentication Request query string (zero parameters)\", listener);\n-                return;\n-            }\n-            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n-            final String samlRequest = parameters.get(\"SAMLRequest\");\n-            final String relayState = parameters.get(\"RelayState\");\n-            final String sigAlg = parameters.get(\"SigAlg\");\n-            final String signature = parameters.get(\"Signature\");\n-            if (null == samlRequest) {\n-                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n-                    listener);\n-                return;\n-            }\n             // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n             // verify if we know of this SP and get its credentials for signature verification\n-            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            final Element root = parseSamlMessage(inflate(decodeBase64(parsedQueryString.samlRequest)));\n             if (samlFactory.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n                 logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", samlFactory.text(root, 128)), listener);\n                 return;\n             }\n             final AuthnRequest authnRequest = samlFactory.buildXmlObject(root, AuthnRequest.class);\n-            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n-            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n-            if (sp.shouldSignAuthnRequests()) {\n-                if (Strings.hasText(signature)) {\n-                    if (Strings.hasText(sigAlg) == false) {\n-                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n-                            queryString), listener);\n-                        return;\n+            getSpFromIssuer(authnRequest.getIssuer(), ActionListener.wrap(\n+                sp -> {\n+                    try {\n+                        validateAuthnRequest(authnRequest, sp, parsedQueryString, listener);\n+                    } catch (ElasticsearchSecurityException e) {\n+                        logger.debug(\"Could not validate AuthnRequest\", e);\n+                        listener.onFailure(e);\n+                    } catch (Exception e) {\n+                        logAndRespond(\"Could not validate AuthnRequest\", e, listener);\n                     }\n-                    final X509Credential spSigningCredential = sp.getSpSigningCredential();\n-                    if (spSigningCredential == null) {\n-                        logAndRespond(\n-                            \"Unable to validate signature of authentication request, \" +\n-                                \"Service Provider hasn't registered signing credentials\",\n-                            listener);\n-                        return;\n-                    }\n-                    if (validateSignature(samlRequest, sigAlg, signature, spSigningCredential, relayState) == false) {\n-                        logAndRespond(\n-                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n-                            queryString, samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n-                        return;\n-                    }\n-                } else if (Strings.hasText(sigAlg)) {\n-                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n-                        queryString), listener);\n-                    return;\n-                } else {\n-                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n-                    return;\n-                }\n-            }\n-            validateAuthnRequest(authnRequest, sp);\n-            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n-            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n-                authnRequest.isForceAuthn(), authnState);\n-            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n-                queryString, response));\n-            listener.onResponse(response);\n+                },\n+                listener::onFailure\n+            ));\n         } catch (ElasticsearchSecurityException e) {\n-            logger.debug(\"Could not process and validate AuthnRequest\", e);\n+            logger.debug(\"Could not process AuthnRequest\", e);\n             listener.onFailure(e);\n         } catch (Exception e) {\n-            logAndRespond(\"Could not process and validate AuthnRequest\", e, listener);\n+            logAndRespond(\"Could not process AuthnRequest\", e, listener);\n+        }\n+    }\n+\n+    private ParsedQueryString parseQueryString(String queryString) throws ElasticsearchSecurityException {\n+\n+        final Map<String, String> parameters = new HashMap<>();\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        if (parameters.isEmpty()) {\n+            throw new ElasticsearchSecurityException(\"Invalid Authentication Request query string (zero parameters)\");\n+        }\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        if (null == samlRequest) {\n+            throw new ElasticsearchSecurityException(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString);\n         }\n+        return new ParsedQueryString(\n+            queryString,\n+            samlRequest,\n+            parameters.get(\"RelayState\"),\n+            parameters.get(\"SigAlg\"),\n+            parameters.get(\"Signature\"));\n+    }\n+\n+    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwOTAyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387309027", "bodyText": "ack", "author": "jkakavas", "createdAt": "2020-03-03T21:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwMjU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dd45983a5113267e48e26333098241fa8b0cf57c", "chunk": "diff --git a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\nindex 2430140941c..43acd790e58 100644\n--- a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\n+++ b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\n\n@@ -134,7 +134,7 @@ public class SamlAuthnRequestValidator {\n             parameters.get(\"Signature\"));\n     }\n \n-    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n+    private void validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n                                          ActionListener<SamlValidateAuthnRequestResponse> listener) {\n         // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n         if (sp.shouldSignAuthnRequests()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNjA3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387306074", "bodyText": "nit: I think we don't benefit much from splitting this to two methods. Totally personal preference, fine eitherway with me", "author": "jkakavas", "createdAt": "2020-03-03T21:32:40Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java", "diffHunk": "@@ -35,25 +35,35 @@\n public class TransportSamlInitiateSingleSignOnAction\n     extends HandledTransportAction<SamlInitiateSingleSignOnRequest, SamlInitiateSingleSignOnResponse> {\n \n+    private final Logger logger = LogManager.getLogger();\n+\n     private final SecurityContext securityContext;\n     private final Environment env;\n-    private final Logger logger = LogManager.getLogger(TransportSamlInitiateSingleSignOnAction.class);\n+    private final SamlFactory samlFactory;\n \n     @Inject\n-    public TransportSamlInitiateSingleSignOnAction(TransportService transportService,\n-                                                   SecurityContext securityContext, ActionFilters actionFilters, Environment environment) {\n+    public TransportSamlInitiateSingleSignOnAction(TransportService transportService, ActionFilters actionFilters,\n+                                                   SecurityContext securityContext, Environment environment, SamlFactory samlFactory) {\n         super(SamlInitiateSingleSignOnAction.NAME, transportService, actionFilters, SamlInitiateSingleSignOnRequest::new);\n         this.securityContext = securityContext;\n         this.env = environment;\n+        this.samlFactory = samlFactory;\n     }\n \n     @Override\n     protected void doExecute(Task task, SamlInitiateSingleSignOnRequest request,\n                              ActionListener<SamlInitiateSingleSignOnResponse> listener) {\n-        final SamlFactory samlFactory = new SamlFactory();\n+        // TODO : Inject this IDP from the plugin\n         final SamlIdentityProvider idp = new CloudIdp(env, env.settings());\n+        idp.getRegisteredServiceProvider(request.getSpEntityId(), ActionListener.wrap(\n+            sp -> doExecute(request, idp, sp, listener),\n+            listener::onFailure\n+        ));\n+    }\n+\n+    private void doExecute(SamlInitiateSingleSignOnRequest request, SamlIdentityProvider idp, SamlServiceProvider sp,", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd45983a5113267e48e26333098241fa8b0cf57c", "chunk": "diff --git a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java\nindex 0d9981223c8..a325a6466a2 100644\n--- a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java\n+++ b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/action/TransportSamlInitiateSingleSignOnAction.java\n\n@@ -56,38 +56,36 @@ public class TransportSamlInitiateSingleSignOnAction\n         // TODO : Inject this IDP from the plugin\n         final SamlIdentityProvider idp = new CloudIdp(env, env.settings());\n         idp.getRegisteredServiceProvider(request.getSpEntityId(), ActionListener.wrap(\n-            sp -> doExecute(request, idp, sp, listener),\n+            sp -> {\n+                try {\n+                    if (null == sp) {\n+                        final String message = \"Service Provider with Entity ID [\" + request.getSpEntityId()\n+                            + \"] is not registered with this Identity Provider\";\n+                        logger.debug(message);\n+                        listener.onFailure(new IllegalArgumentException(message));\n+                        return;\n+                    }\n+                    final SecondaryAuthentication secondaryAuthentication = SecondaryAuthentication.readFromContext(securityContext);\n+                    if (secondaryAuthentication == null) {\n+                        listener.onFailure(new IllegalStateException(\"Request is missing secondary authentication\"));\n+                        return;\n+                    }\n+                    final UserServiceAuthentication user = buildUserFromAuthentication(secondaryAuthentication.getAuthentication(), sp);\n+                    final SuccessfulAuthenticationResponseMessageBuilder builder = new SuccessfulAuthenticationResponseMessageBuilder(\n+                        samlFactory, Clock.systemUTC(), idp);\n+                    final Response response = builder.build(user, null);\n+                    listener.onResponse(new SamlInitiateSingleSignOnResponse(\n+                        user.getServiceProvider().getAssertionConsumerService().toString(),\n+                        samlFactory.getXmlContent(response),\n+                        user.getServiceProvider().getEntityId()));\n+                } catch (IOException e) {\n+                    listener.onFailure(new IllegalArgumentException(e.getMessage()));\n+                }\n+            },\n             listener::onFailure\n         ));\n     }\n \n-    private void doExecute(SamlInitiateSingleSignOnRequest request, SamlIdentityProvider idp, SamlServiceProvider sp,\n-                           ActionListener<SamlInitiateSingleSignOnResponse> listener) {\n-        try {\n-            if (null == sp) {\n-                final String message =\n-                    \"Service Provider with Entity ID [\" + request.getSpEntityId() + \"] is not registered with this Identity Provider\";\n-                logger.debug(message);\n-                listener.onFailure(new IllegalArgumentException(message));\n-                return;\n-            }\n-            final SecondaryAuthentication secondaryAuthentication = SecondaryAuthentication.readFromContext(securityContext);\n-            if (secondaryAuthentication == null) {\n-                listener.onFailure(new IllegalStateException(\"Request is missing secondary authentication\"));\n-                return;\n-            }\n-            final UserServiceAuthentication user = buildUserFromAuthentication(secondaryAuthentication.getAuthentication(), sp);\n-            final SuccessfulAuthenticationResponseMessageBuilder builder = new SuccessfulAuthenticationResponseMessageBuilder(samlFactory,\n-                Clock.systemUTC(), idp);\n-            final Response response = builder.build(user, null);\n-            listener.onResponse(new SamlInitiateSingleSignOnResponse(user.getServiceProvider().getAssertionConsumerService().toString(),\n-                samlFactory.getXmlContent(response),\n-                user.getServiceProvider().getEntityId()));\n-        } catch (IOException e) {\n-            listener.onFailure(new IllegalArgumentException(e.getMessage()));\n-        }\n-    }\n-\n     private UserServiceAuthentication buildUserFromAuthentication(Authentication authentication, SamlServiceProvider sp) {\n         final User authenticatedUser = authentication.getUser();\n         final Set<String> groups = new HashSet<>(Arrays.asList(authenticatedUser.roles()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMTk4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387311985", "bodyText": "Again - I see the pattern here.. - I dislike the fact that we have multiple methods with the same name doing similar stuff. Arguments can be made that signature verification is part of the validation of the AuthnRequest so I'm fine with how you moved that around but could we simple replace this with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    validateAuthnRequest(authnRequest, sp);\n          \n          \n            \n                    checkDestination(authnRequest);\n          \n          \n            \n                    checkAcs(authnRequest, sp);\n          \n      \n    \n    \n  \n\n? I see no reason keeping the second validateAuthnRequest now", "author": "jkakavas", "createdAt": "2020-03-03T21:44:30Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java", "diffHunk": "@@ -73,76 +74,108 @@ public SamlAuthnRequestValidator(SamlFactory samlFactory, SamlIdentityProvider i\n     }\n \n     public void processQueryString(String queryString, ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+\n+        final ParsedQueryString parsedQueryString;\n+        try {\n+            parsedQueryString = parseQueryString(queryString);\n+        } catch (ElasticsearchSecurityException e) {\n+            logger.debug(\"Failed to parse query string for SAML AuthnRequest\", e);\n+            listener.onFailure(e);\n+            return;\n+        }\n+\n         try {\n-            final Map<String, String> parameters = new HashMap<>();\n-            RestUtils.decodeQueryString(queryString, 0, parameters);\n-            if (parameters.isEmpty()) {\n-                logAndRespond(\"Invalid Authentication Request query string (zero parameters)\", listener);\n-                return;\n-            }\n-            logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n-            final String samlRequest = parameters.get(\"SAMLRequest\");\n-            final String relayState = parameters.get(\"RelayState\");\n-            final String sigAlg = parameters.get(\"SigAlg\");\n-            final String signature = parameters.get(\"Signature\");\n-            if (null == samlRequest) {\n-                logAndRespond(new ParameterizedMessage(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString),\n-                    listener);\n-                return;\n-            }\n             // We consciously parse the AuthnRequest before we validate its signature as we need to get the Issuer, in order to\n             // verify if we know of this SP and get its credentials for signature verification\n-            final Element root = parseSamlMessage(inflate(decodeBase64(samlRequest)));\n+            final Element root = parseSamlMessage(inflate(decodeBase64(parsedQueryString.samlRequest)));\n             if (samlFactory.elementNameMatches(root, \"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\") == false) {\n                 logAndRespond(new ParameterizedMessage(\"SAML message [{}] is not an AuthnRequest\", samlFactory.text(root, 128)), listener);\n                 return;\n             }\n             final AuthnRequest authnRequest = samlFactory.buildXmlObject(root, AuthnRequest.class);\n-            final SamlServiceProvider sp = getSpFromIssuer(authnRequest.getIssuer());\n-            // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n-            if (sp.shouldSignAuthnRequests()) {\n-                if (Strings.hasText(signature)) {\n-                    if (Strings.hasText(sigAlg) == false) {\n-                        logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n-                            queryString), listener);\n-                        return;\n+            getSpFromIssuer(authnRequest.getIssuer(), ActionListener.wrap(\n+                sp -> {\n+                    try {\n+                        validateAuthnRequest(authnRequest, sp, parsedQueryString, listener);\n+                    } catch (ElasticsearchSecurityException e) {\n+                        logger.debug(\"Could not validate AuthnRequest\", e);\n+                        listener.onFailure(e);\n+                    } catch (Exception e) {\n+                        logAndRespond(\"Could not validate AuthnRequest\", e, listener);\n                     }\n-                    final X509Credential spSigningCredential = sp.getSpSigningCredential();\n-                    if (spSigningCredential == null) {\n-                        logAndRespond(\n-                            \"Unable to validate signature of authentication request, \" +\n-                                \"Service Provider hasn't registered signing credentials\",\n-                            listener);\n-                        return;\n-                    }\n-                    if (validateSignature(samlRequest, sigAlg, signature, spSigningCredential, relayState) == false) {\n-                        logAndRespond(\n-                            new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n-                            queryString, samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n-                        return;\n-                    }\n-                } else if (Strings.hasText(sigAlg)) {\n-                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n-                        queryString), listener);\n-                    return;\n-                } else {\n-                    logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n-                    return;\n-                }\n-            }\n-            validateAuthnRequest(authnRequest, sp);\n-            Map<String, Object> authnState = buildAuthnState(authnRequest, sp);\n-            final SamlValidateAuthnRequestResponse response = new SamlValidateAuthnRequestResponse(sp.getEntityId(),\n-                authnRequest.isForceAuthn(), authnState);\n-            logger.trace(new ParameterizedMessage(\"Validated AuthnResponse from queryString [{}] and extracted [{}]\",\n-                queryString, response));\n-            listener.onResponse(response);\n+                },\n+                listener::onFailure\n+            ));\n         } catch (ElasticsearchSecurityException e) {\n-            logger.debug(\"Could not process and validate AuthnRequest\", e);\n+            logger.debug(\"Could not process AuthnRequest\", e);\n             listener.onFailure(e);\n         } catch (Exception e) {\n-            logAndRespond(\"Could not process and validate AuthnRequest\", e, listener);\n+            logAndRespond(\"Could not process AuthnRequest\", e, listener);\n+        }\n+    }\n+\n+    private ParsedQueryString parseQueryString(String queryString) throws ElasticsearchSecurityException {\n+\n+        final Map<String, String> parameters = new HashMap<>();\n+        RestUtils.decodeQueryString(queryString, 0, parameters);\n+        if (parameters.isEmpty()) {\n+            throw new ElasticsearchSecurityException(\"Invalid Authentication Request query string (zero parameters)\");\n+        }\n+        logger.trace(new ParameterizedMessage(\"Parsed the following parameters from the query string: {}\", parameters));\n+        final String samlRequest = parameters.get(\"SAMLRequest\");\n+        if (null == samlRequest) {\n+            throw new ElasticsearchSecurityException(\"Query string [{}] does not contain a SAMLRequest parameter\", queryString);\n         }\n+        return new ParsedQueryString(\n+            queryString,\n+            samlRequest,\n+            parameters.get(\"RelayState\"),\n+            parameters.get(\"SigAlg\"),\n+            parameters.get(\"Signature\"));\n+    }\n+\n+    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n+                                         ActionListener<SamlValidateAuthnRequestResponse> listener) {\n+        // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n+        if (sp.shouldSignAuthnRequests()) {\n+            if (Strings.hasText(parsedQueryString.signature)) {\n+                if (Strings.hasText(parsedQueryString.sigAlg) == false) {\n+                    logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a Signature but SigAlg parameter is missing\",\n+                        parsedQueryString.queryString), listener);\n+                    return true;\n+                }\n+                final X509Credential spSigningCredential = sp.getSpSigningCredential();\n+                if (spSigningCredential == null) {\n+                    logAndRespond(\n+                        \"Unable to validate signature of authentication request, \" +\n+                            \"Service Provider hasn't registered signing credentials\",\n+                        listener);\n+                    return true;\n+                }\n+                if (validateSignature(parsedQueryString, spSigningCredential) == false) {\n+                    logAndRespond(\n+                        new ParameterizedMessage(\"Unable to validate signature of authentication request [{}] using credentials [{}]\",\n+                            parsedQueryString.queryString,\n+                            samlFactory.describeCredentials(Collections.singletonList(spSigningCredential))), listener);\n+                    return true;\n+                }\n+            } else if (Strings.hasText(parsedQueryString.sigAlg)) {\n+                logAndRespond(new ParameterizedMessage(\"Query string [{}] contains a SigAlg parameter but Signature is missing\",\n+                    parsedQueryString.queryString), listener);\n+                return true;\n+            } else {\n+                logAndRespond(\"The Service Provider must sign authentication requests but no signature was found\", listener);\n+                return true;\n+            }\n+        }\n+        validateAuthnRequest(authnRequest, sp);", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd45983a5113267e48e26333098241fa8b0cf57c", "chunk": "diff --git a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\nindex 2430140941c..43acd790e58 100644\n--- a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\n+++ b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/authn/SamlAuthnRequestValidator.java\n\n@@ -134,7 +134,7 @@ public class SamlAuthnRequestValidator {\n             parameters.get(\"Signature\"));\n     }\n \n-    private boolean validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n+    private void validateAuthnRequest(AuthnRequest authnRequest, SamlServiceProvider sp, ParsedQueryString parsedQueryString,\n                                          ActionListener<SamlValidateAuthnRequestResponse> listener) {\n         // If the Service Provider should not sign requests, do not try to handle signatures even if they are added to the request\n         if (sp.shouldSignAuthnRequests()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52986#discussion_r387314702", "bodyText": "nit: entityId, EntityID, EntityId all work better than entity-id :)", "author": "jkakavas", "createdAt": "2020-03-03T21:49:57Z", "path": "x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java", "diffHunk": "@@ -93,9 +94,15 @@ public URL getSingleLogoutEndpoint(String binding) {\n         return sloEndpoints.get(binding);\n     }\n \n+    /**\n+     * Asynchronously lookup the specified {@link SamlServiceProvider} by entity-id.", "originalCommit": "d612836a0b0a8496bdd2e2b6a8a7b7e186cf6267", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd45983a5113267e48e26333098241fa8b0cf57c", "chunk": "diff --git a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java\nindex 862246742e1..32720cbba14 100644\n--- a/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java\n+++ b/x-pack/plugin/identity-provider/src/main/java/org/elasticsearch/xpack/idp/saml/idp/CloudIdp.java\n\n@@ -95,7 +95,7 @@ public class CloudIdp implements SamlIdentityProvider {\n     }\n \n     /**\n-     * Asynchronously lookup the specified {@link SamlServiceProvider} by entity-id.\n+     * Asynchronously lookup the specified {@link SamlServiceProvider} by EntityID.\n      * @param listener Responds with the requested Service Provider object, or {@code null} if no such SP exists.\n      *                 {@link ActionListener#onFailure} is only used for fatal errors (e.g. being unable to access\n      *                 the backing store (elasticsearch index) that hold the SP data).\n"}}, {"oid": "8026224c5a1a69931ed6076322e81f150b996699", "url": "https://github.com/elastic/elasticsearch/commit/8026224c5a1a69931ed6076322e81f150b996699", "message": "Merge branch 'feature-internal-idp' into idp/sp-async-lookup", "committedDate": "2020-03-05T03:49:17Z", "type": "commit"}, {"oid": "dd45983a5113267e48e26333098241fa8b0cf57c", "url": "https://github.com/elastic/elasticsearch/commit/dd45983a5113267e48e26333098241fa8b0cf57c", "message": "Inline some methods", "committedDate": "2020-03-05T04:14:25Z", "type": "commit"}]}