{"pr_number": 63032, "pr_title": "EQL: Fix NPE from incorrect use of ids search", "pr_createdAt": "2020-09-29T17:29:17Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63032", "timeline": [{"oid": "548851a789429a4eba0d5689ac33a00f19775695", "url": "https://github.com/elastic/elasticsearch/commit/548851a789429a4eba0d5689ac33a00f19775695", "message": "EQL: Fix NPE from incorrect use of ids search\n\nThis fixes a bug introduced when moving from mget to ids query. While\nmget returns all the ids given, id query is a search query and thus by\ndefault returns only 10 documents.\nThe fix correctly sets the expected size so all the information is\nreturned inside the response.\n\nFix #63030", "committedDate": "2020-09-29T17:21:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM1NDU0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63032#discussion_r497354543", "bodyText": "Why is this + 1 ?", "author": "matriv", "createdAt": "2020-09-30T09:01:50Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -94,7 +95,10 @@ public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<Lis\n             .fetchSource(FetchSourceContext.FETCH_SOURCE)\n             .trackTotalHits(false)\n             .trackScores(false)\n-            .query(idsQuery);\n+            .query(idsQuery)\n+            // the default size is 10 so be sure to change it\n+            // this is different from mget\n+            .size(referenceToPosition.size() + 1);", "originalCommit": "548851a789429a4eba0d5689ac33a00f19775695", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d740e1b18e9f055bcec01612c6bff70404a8f996", "chunk": "diff --git a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java\nindex fe70b6c3b41..f715e02c2c1 100644\n--- a/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java\n+++ b/x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java\n\n@@ -68,40 +68,35 @@ public class BasicQueryClient implements QueryClient {\n         client.search(search, listener);\n     }\n \n+    protected void search(MultiSearchRequest search, ActionListener<MultiSearchResponse> listener) {\n+        client.multiSearch(search, listener);\n+    }\n+\n     @Override\n     public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n-        IdsQueryBuilder idsQuery = idsQuery();\n-\n         int innerListSize = 0;\n-        Set<String> indices = new HashSet<>();\n \n-        // associate each reference with its own hit\n+        Map<String, IdsQueryBuilder> queries = new HashMap<>();\n+\n+        // associate each reference with its positions inside the matrix\n         final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n         int counter = 0;\n \n         for (List<HitReference> list : refs) {\n             innerListSize = list.size();\n             for (HitReference ref : list) {\n-                idsQuery.addIds(ref.id());\n-                indices.add(ref.index());\n-                // remember the reference position\n+                // keep ids per index\n+                IdsQueryBuilder query = queries.computeIfAbsent(ref.index(), v -> idsQuery());\n+                query.addIds(ref.id());\n+                // save the ref position inside the matrix\n                 List<Integer> positions = referenceToPosition.computeIfAbsent(ref, v -> new ArrayList<>(1));\n                 positions.add(counter++);\n             }\n         }\n \n-        SearchSourceBuilder builder = SearchSourceBuilder.searchSource()\n-            // make sure to fetch the whole source\n-            .fetchSource(FetchSourceContext.FETCH_SOURCE)\n-            .trackTotalHits(false)\n-            .trackScores(false)\n-            .query(idsQuery)\n-            // the default size is 10 so be sure to change it\n-            // this is different from mget\n-            .size(referenceToPosition.size() + 1);\n-\n         final int listSize = innerListSize;\n         final int topListSize = counter / listSize;\n+\n         // pre-allocate the response matrix\n         @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n         List<SearchHit>[] hits = new List[topListSize];\n"}}, {"oid": "d740e1b18e9f055bcec01612c6bff70404a8f996", "url": "https://github.com/elastic/elasticsearch/commit/d740e1b18e9f055bcec01612c6bff70404a8f996", "message": "Use multi-search to avoid document clashes", "committedDate": "2020-09-30T10:37:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMjA5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/63032#discussion_r497412096", "bodyText": "@jimczi @dnhatn fyi, this is the current code I've used for updating pit when dealing with multiSearch.", "author": "costin", "createdAt": "2020-09-30T10:40:57Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/PITAwareQueryClient.java", "diffHunk": "@@ -42,46 +48,83 @@ public PITAwareQueryClient(EqlSession eqlSession) {\n     protected void search(SearchRequest search, ActionListener<SearchResponse> listener) {\n         // no pitId, ask for one\n         if (pitId == null) {\n-            openPIT(wrap(r -> {\n-                pitId = r;\n-                searchWithPIT(search, listener);\n-            }, listener::onFailure));\n-        }\n-        else {\n+            openPIT(listener, () -> searchWithPIT(search, listener));\n+        } else {\n             searchWithPIT(search, listener);\n         }\n     }\n \n     private void searchWithPIT(SearchRequest search, ActionListener<SearchResponse> listener) {\n         // don't increase the keep alive\n         search.source().pointInTimeBuilder(new PointInTimeBuilder(pitId));\n+        // get the pid on each response\n+        super.search(search, pitListener(SearchResponse::pointInTimeId, listener));\n+    }\n+\n+    @Override\n+    protected void search(MultiSearchRequest search, ActionListener<MultiSearchResponse> listener) {\n+        // no pitId, ask for one\n+        if (pitId == null) {\n+            openPIT(listener, () -> searchWithPIT(search, listener));\n+        } else {\n+            searchWithPIT(search, listener);\n+        }\n+    }\n+\n+    private void searchWithPIT(MultiSearchRequest search, ActionListener<MultiSearchResponse> listener) {\n+        // don't increase the keep alive\n+        for (SearchRequest request : search.requests()) {\n+            request.source().pointInTimeBuilder(new PointInTimeBuilder(pitId));\n+        }\n+\n         // get the pid on each request\n-        super.search(search, wrap(r -> {\n-                pitId = r.pointInTimeId();\n+        super.search(search, pitListener(r -> {\n+            // get pid\n+            for (MultiSearchResponse.Item item : r.getResponses()) {\n+                // pick the first non-failing response\n+                if (item.isFailure() == false) {\n+                    return item.getResponse().pointInTimeId();\n+                }\n+            }\n+            // no results or successful responses, preserve the current pid\n+            return pitId;", "originalCommit": "d740e1b18e9f055bcec01612c6bff70404a8f996", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI4MzgzNA==", "url": "https://github.com/elastic/elasticsearch/pull/63032#discussion_r498283834", "bodyText": "You also need to filter by index too since the query will hit all the indices inside the PIT so you might have duplicates ? So two filter clauses are needed, one for the ids and one to match the right index.", "author": "jimczi", "createdAt": "2020-10-01T14:22:39Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/execution/search/BasicQueryClient.java", "diffHunk": "@@ -67,37 +68,35 @@ protected void search(SearchRequest search, ActionListener<SearchResponse> liste\n         client.search(search, listener);\n     }\n \n+    protected void search(MultiSearchRequest search, ActionListener<MultiSearchResponse> listener) {\n+        client.multiSearch(search, listener);\n+    }\n+\n     @Override\n     public void fetchHits(Iterable<List<HitReference>> refs, ActionListener<List<List<SearchHit>>> listener) {\n-        IdsQueryBuilder idsQuery = idsQuery();\n-\n         int innerListSize = 0;\n-        Set<String> indices = new HashSet<>();\n \n-        // associate each reference with its own\n+        Map<String, IdsQueryBuilder> queries = new HashMap<>();\n+\n+        // associate each reference with its positions inside the matrix\n         final Map<HitReference, List<Integer>> referenceToPosition = new HashMap<>();\n         int counter = 0;\n \n         for (List<HitReference> list : refs) {\n             innerListSize = list.size();\n             for (HitReference ref : list) {\n-                idsQuery.addIds(ref.id());\n-                indices.add(ref.index());\n-                // remember the reference position\n+                // keep ids per index\n+                IdsQueryBuilder query = queries.computeIfAbsent(ref.index(), v -> idsQuery());", "originalCommit": "d740e1b18e9f055bcec01612c6bff70404a8f996", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}