{"pr_number": 53037, "pr_title": "Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry", "pr_createdAt": "2020-03-02T23:03:39Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/53037", "timeline": [{"oid": "bedfcbab45caf43106ca6a9e3eceb1e0d2c6ba99", "url": "https://github.com/elastic/elasticsearch/commit/bedfcbab45caf43106ca6a9e3eceb1e0d2c6ba99", "message": "Wire-up geotile_grid and geohash_grid to ValuesSourceRegistry\n\nThis commit updates the geo*_grid aggregations to depend\non registering itself in the ValuesSourceRegistry\n\nrelates to the values-source refactoring meta issue #42949.", "committedDate": "2020-03-02T23:02:08Z", "type": "commit"}, {"oid": "1cd8c89550e879ee1facc71d219cc8abf348ac92", "url": "https://github.com/elastic/elasticsearch/commit/1cd8c89550e879ee1facc71d219cc8abf348ac92", "message": "Merge remote-tracking branch 'elastic/feature/extensible-values-source' into evs-geogrid", "committedDate": "2020-03-02T23:09:59Z", "type": "commit"}, {"oid": "c503fe8e93755153c1570357514270a4df7591da", "url": "https://github.com/elastic/elasticsearch/commit/c503fe8e93755153c1570357514270a4df7591da", "message": "add supportedFieldType testing", "committedDate": "2020-03-02T23:15:02Z", "type": "commit"}, {"oid": "4b35aa191f9224b6d7d9b3b9c26d000ef9518d27", "url": "https://github.com/elastic/elasticsearch/commit/4b35aa191f9224b6d7d9b3b9c26d000ef9518d27", "message": "Merge remote-tracking branch 'elastic/feature/extensible-values-source' into evs-geogrid", "committedDate": "2020-03-03T18:42:21Z", "type": "commit"}, {"oid": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239", "url": "https://github.com/elastic/elasticsearch/commit/7c2f63bfa507a5b89a2dcffa8298b875d69c6239", "message": "update supplier to use generic ValuesSource", "committedDate": "2020-03-03T18:54:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NzM0OA==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387687348", "bodyText": "I didn't know you could type cast a lambda, that's a really elegant solution.   I kind of want to go back and change some of the others to use this pattern.", "author": "not-napoleon", "createdAt": "2020-03-04T14:07:03Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n-        return new GeoHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize,\n+\n+        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, cellIdSource, requiredSize, shardSize,\n             searchContext, parent, pipelineAggregators, metaData);\n     }\n+\n+    static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n+        valuesSourceRegistry.register(GeoHashGridAggregationBuilder.NAME, CoreValuesSourceType.GEOPOINT,\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, requiredSize, shardSize, aggregationContext, parent,", "originalCommit": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3MzgxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388473815", "bodyText": "I didn't either, but Intellij recommended it and then auto-wrote it for me!", "author": "talevy", "createdAt": "2020-03-05T18:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY4NzM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "c94e9b770997ef54f4febf984d5684a8048382a0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\nindex 559b4aff4a0..a834c6caa3e 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\n\n@@ -92,17 +92,17 @@ public class GeoHashGridAggregatorFactory extends ValuesSourceAggregatorFactory\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n-        CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n-\n-        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, cellIdSource, requiredSize, shardSize,\n-            searchContext, parent, pipelineAggregators, metaData);\n+        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, valuesSource, precision, geoBoundingBox,\n+            requiredSize, shardSize, searchContext, parent, pipelineAggregators, metaData);\n     }\n \n     static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n         valuesSourceRegistry.register(GeoHashGridAggregationBuilder.NAME, CoreValuesSourceType.GEOPOINT,\n-            (GeoGridAggregatorSupplier) (name, factories, valuesSource, requiredSize, shardSize, aggregationContext, parent,\n-                                         pipelineAggregators, metaData) -> new GeoHashGridAggregator(name, factories,\n-                (CellIdSource) valuesSource, requiredSize, shardSize, aggregationContext,\n-                parent, pipelineAggregators, metaData));\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, pipelineAggregators, metaData) -> {\n+            CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n+            return new GeoHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize, aggregationContext,\n+                    parent, pipelineAggregators, metaData);\n+            });\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5Mjc5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387692796", "bodyText": "I think we need to move creating the CellIdSource into the supplier.  This line is casting to a GeoPoint, but we don't know that we always have a GeoPoint here, because we can't know at compile time what Values Sources have been registered for this aggregation.  My guideline has been that we should only care about ValuesSource subclasses at the supplier layer or the aggregator itself, not the factory or the builder.", "author": "not-napoleon", "createdAt": "2020-03-04T14:16:20Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java", "diffHunk": "@@ -79,15 +83,26 @@ protected Aggregator doCreateInternal(final ValuesSource valuesSource,\n                                             boolean collectsFromSingleBucket,\n                                             List<PipelineAggregator> pipelineAggregators,\n                                             Map<String, Object> metaData) throws IOException {\n-        if (valuesSource instanceof ValuesSource.GeoPoint  == false) {\n-            throw new AggregationExecutionException(\"ValuesSource type \" + valuesSource.toString() + \"is not supported for aggregation \" +\n-                this.name());\n+        AggregatorSupplier aggregatorSupplier = queryShardContext.getValuesSourceRegistry()\n+            .getAggregator(config.valueSourceType(), GeoHashGridAggregationBuilder.NAME);\n+        if (aggregatorSupplier instanceof GeoGridAggregatorSupplier == false) {\n+            throw new AggregationExecutionException(\"Registry miss-match - expected \"\n+                + GeoGridAggregatorSupplier.class.getName() + \", found [\" + aggregatorSupplier.getClass().toString() + \"]\");\n         }\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n         CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);", "originalCommit": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3Mzk5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388473992", "bodyText": "++ will do", "author": "talevy", "createdAt": "2020-03-05T18:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5Mjc5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c94e9b770997ef54f4febf984d5684a8048382a0", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\nindex 559b4aff4a0..a834c6caa3e 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregatorFactory.java\n\n@@ -92,17 +92,17 @@ public class GeoHashGridAggregatorFactory extends ValuesSourceAggregatorFactory\n         if (collectsFromSingleBucket == false) {\n             return asMultiBucketAggregator(this, searchContext, parent);\n         }\n-        CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n-\n-        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, cellIdSource, requiredSize, shardSize,\n-            searchContext, parent, pipelineAggregators, metaData);\n+        return ((GeoGridAggregatorSupplier) aggregatorSupplier).build(name, factories, valuesSource, precision, geoBoundingBox,\n+            requiredSize, shardSize, searchContext, parent, pipelineAggregators, metaData);\n     }\n \n     static void registerAggregators(ValuesSourceRegistry valuesSourceRegistry) {\n         valuesSourceRegistry.register(GeoHashGridAggregationBuilder.NAME, CoreValuesSourceType.GEOPOINT,\n-            (GeoGridAggregatorSupplier) (name, factories, valuesSource, requiredSize, shardSize, aggregationContext, parent,\n-                                         pipelineAggregators, metaData) -> new GeoHashGridAggregator(name, factories,\n-                (CellIdSource) valuesSource, requiredSize, shardSize, aggregationContext,\n-                parent, pipelineAggregators, metaData));\n+            (GeoGridAggregatorSupplier) (name, factories, valuesSource, precision, geoBoundingBox, requiredSize, shardSize,\n+                                         aggregationContext, parent, pipelineAggregators, metaData) -> {\n+            CellIdSource cellIdSource = new CellIdSource((ValuesSource.GeoPoint) valuesSource, precision, geoBoundingBox, Geohash::longEncode);\n+            return new GeoHashGridAggregator(name, factories, cellIdSource, requiredSize, shardSize, aggregationContext,\n+                    parent, pipelineAggregators, metaData);\n+            });\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r387706982", "bodyText": "My preference is to PR these tests separately against master first, so we can validate that the type support hasn't changed in the registry branch.", "author": "not-napoleon", "createdAt": "2020-03-04T14:37:46Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java", "diffHunk": "@@ -240,4 +243,14 @@ private void testCase(Query query, int precision, GeoBoundingBox geoBoundingBox,\n         indexReader.close();\n         directory.close();\n     }\n+\n+    @Override\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return createBuilder(\"foo\").field(fieldName);\n+    }\n+\n+    @Override\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {", "originalCommit": "7c2f63bfa507a5b89a2dcffa8298b875d69c6239", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3NDk1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388474953", "bodyText": "will do this in a separate PR", "author": "talevy", "createdAt": "2020-03-05T18:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3ODk0NA==", "url": "https://github.com/elastic/elasticsearch/pull/53037#discussion_r388478944", "bodyText": "opened #53180", "author": "talevy", "createdAt": "2020-03-05T18:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNjk4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c94e9b770997ef54f4febf984d5684a8048382a0", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java\nindex 448c557fee5..2059f465c37 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoGridAggregatorTestCase.java\n\n@@ -243,14 +240,4 @@ public abstract class GeoGridAggregatorTestCase<T extends InternalGeoGridBucket>\n         indexReader.close();\n         directory.close();\n     }\n-\n-    @Override\n-    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return createBuilder(\"foo\").field(fieldName);\n-    }\n-\n-    @Override\n-    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n-        return List.of(CoreValuesSourceType.GEOPOINT);\n-    }\n }\n"}}, {"oid": "c94e9b770997ef54f4febf984d5684a8048382a0", "url": "https://github.com/elastic/elasticsearch/commit/c94e9b770997ef54f4febf984d5684a8048382a0", "message": "respond to review", "committedDate": "2020-03-05T18:25:56Z", "type": "commit"}, {"oid": "7f09b34b1b3d7f53aecab4fae46619afaf58bbf0", "url": "https://github.com/elastic/elasticsearch/commit/7f09b34b1b3d7f53aecab4fae46619afaf58bbf0", "message": "fix checkstyle", "committedDate": "2020-03-06T00:00:11Z", "type": "commit"}, {"oid": "22379a4c42e5b9804133ba3fd0c0f332131f4fe3", "url": "https://github.com/elastic/elasticsearch/commit/22379a4c42e5b9804133ba3fd0c0f332131f4fe3", "message": "Merge remote-tracking branch 'elastic/feature/extensible-values-source' into evs-geogrid", "committedDate": "2020-03-06T21:04:13Z", "type": "commit"}]}