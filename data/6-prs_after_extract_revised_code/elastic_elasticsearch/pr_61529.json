{"pr_number": 61529, "pr_title": "Calculate precise cardinality upper bounds", "pr_createdAt": "2020-08-25T14:23:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61529", "timeline": [{"oid": "4aff47334be0a3ca6b20a5cf7d3e6e782763c4e2", "url": "https://github.com/elastic/elasticsearch/commit/4aff47334be0a3ca6b20a5cf7d3e6e782763c4e2", "message": "Calculate precise cardinality upper bounds\n\nThis reworks `CardinalityUpperBound` to support precise estimates while\nmaintaining most of the public API. This will allow us to make more\ninformed choices about the data structures that we use in aggregations.\nNone of those interesting choices come as part of this change, but they\nare more possible with it.", "committedDate": "2020-08-25T14:04:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDE1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61529#discussion_r476490156", "bodyText": "When I first wrote this I had map take two parameters - one for if the value was unknown and one for if it was known. And that turned out to be pretty inconvenient. In the cases we have \"very big\" might as well be unknown. So pegging unknown as \"the biggest int\" seems to work well here.", "author": "nik9000", "createdAt": "2020-08-25T14:24:40Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java", "diffHunk": "@@ -47,35 +54,32 @@ public CardinalityUpperBound multiply(int bucketCount) {\n      * aggregations like {@link FilterAggregator} or a {@link RangeAggregator}\n      * configured to collect only a single range.\n      */\n-    ONE {\n-        @Override\n-        public CardinalityUpperBound multiply(int bucketCount) {\n-            switch (bucketCount) {\n-                case 0:\n-                    return NONE;\n-                case 1:\n-                    return ONE;\n-                default:\n-                    return MANY;\n-            }\n-        }\n-    },\n+    public static final CardinalityUpperBound ONE = new KnownCardinalityUpperBound(1);\n \n     /**\n      * {@link Aggregator}s with this cardinality may be collected many times.\n      * Most sub-aggregators of {@link BucketsAggregator}s will have\n      * this cardinality.\n      */\n-    MANY {\n+    public static final CardinalityUpperBound MANY = new CardinalityUpperBound() {\n         @Override\n         public CardinalityUpperBound multiply(int bucketCount) {\n             if (bucketCount == 0) {\n                 return NONE;\n             }\n             return MANY;\n         }\n+\n+        @Override\n+        public <R> R map(IntFunction<R> mapper) {\n+            return mapper.apply(Integer.MAX_VALUE);", "originalCommit": "4aff47334be0a3ca6b20a5cf7d3e6e782763c4e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "f92454963658ccb6729e7a21a96ec589e58f4e10", "url": "https://github.com/elastic/elasticsearch/commit/f92454963658ccb6729e7a21a96ec589e58f4e10", "message": "Doc", "committedDate": "2020-08-25T14:27:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5NjEwMg==", "url": "https://github.com/elastic/elasticsearch/pull/61529#discussion_r476496102", "bodyText": "I think I could just have a method to return an int here, but in all non-test cases we'll want to do something like:\nLongKeyedBucketOrds impl(Cardinality cardinality) {\n  return cardinality.map(estimate -> {\n    if (estimate < 2) return new FromSingle();\n    if (estimate < Integer.MAX_VALUE) return new FromInts();\n    return new FromMany();\n  });\n}\n\nSo map feels fairly natural. Also, it will stop compiling if we ever decide that we need to encode more stuff in the estimate.", "author": "nik9000", "createdAt": "2020-08-25T14:32:15Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java", "diffHunk": "@@ -84,4 +88,46 @@ public CardinalityUpperBound multiply(int bucketCount) {\n      *   will collect per owning ordinal\n      */\n     public abstract CardinalityUpperBound multiply(int bucketCount);\n+\n+    /**\n+     * Map the cardinality to a value. If the upper bound of the cardinality\n+     * is unknown the call the first argument to produce the value, otherwise\n+     * call the second argument with the estimated upper bound.\n+     */\n+    public abstract <R> R map(IntFunction<R> mapper);", "originalCommit": "4aff47334be0a3ca6b20a5cf7d3e6e782763c4e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42bbd99d11dd62f48263d0418656802d554011fb", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\nindex c48e2adea62..9adba8dc90b 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\n\n@@ -90,9 +90,9 @@ public abstract class CardinalityUpperBound {\n     public abstract CardinalityUpperBound multiply(int bucketCount);\n \n     /**\n-     * Map the cardinality to a value. If the upper bound of the cardinality\n-     * is unknown the call the first argument to produce the value, otherwise\n-     * call the second argument with the estimated upper bound.\n+     * Map the cardinality to a value. The argument to the {@code mapper}\n+     * is the estimated cardinality, or {@code Integer.MAX_VALUE} if the\n+     * cardinality is unknown.\n      */\n     public abstract <R> R map(IntFunction<R> mapper);\n \n"}}, {"oid": "42bbd99d11dd62f48263d0418656802d554011fb", "url": "https://github.com/elastic/elasticsearch/commit/42bbd99d11dd62f48263d0418656802d554011fb", "message": "Fixup test", "committedDate": "2020-08-25T14:59:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTg5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/61529#discussion_r477471895", "bodyText": "this looks  wrong to me.  In the minimum, known can have an estimate of 2, and 2 * Short.MAX_VALUE is only 2^16, isn't it?  I know CI passed it, possible it just got lucky on picking numbers.  But if this passes most of the time, I think something is wrong.", "author": "not-napoleon", "createdAt": "2020-08-26T17:34:24Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/CardinalityUpperBoundTests.java", "diffHunk": "@@ -22,20 +22,46 @@\n import org.elasticsearch.test.ESTestCase;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n \n public class CardinalityUpperBoundTests extends ESTestCase {\n     public void testNoneMultiply() {\n-        assertThat(CardinalityUpperBound.NONE.multiply(randomInt()), equalTo(CardinalityUpperBound.NONE));\n+        assertThat(CardinalityUpperBound.NONE.multiply(randomInt()), sameInstance(CardinalityUpperBound.NONE));\n+    }\n+\n+    public void testNoneMap() {\n+        assertThat(CardinalityUpperBound.NONE.map(i -> i), equalTo(0));\n     }\n \n     public void testOneMultiply() {\n-        assertThat(CardinalityUpperBound.ONE.multiply(0), equalTo(CardinalityUpperBound.NONE));\n-        assertThat(CardinalityUpperBound.ONE.multiply(1), equalTo(CardinalityUpperBound.ONE));\n-        assertThat(CardinalityUpperBound.ONE.multiply(between(2, Integer.MAX_VALUE)), equalTo(CardinalityUpperBound.MANY));\n+        assertThat(CardinalityUpperBound.ONE.multiply(0), sameInstance(CardinalityUpperBound.NONE));\n+        assertThat(CardinalityUpperBound.ONE.multiply(1), sameInstance(CardinalityUpperBound.ONE));\n+        assertThat(CardinalityUpperBound.ONE.multiply(Integer.MAX_VALUE), sameInstance(CardinalityUpperBound.MANY));\n+    }\n+\n+    public void testOneMap() {\n+        assertThat(CardinalityUpperBound.ONE.map(i -> i), equalTo(1));\n+    }\n+\n+    public void testLargerKnownValues() {\n+        int estimate = between(2, Short.MAX_VALUE);\n+        CardinalityUpperBound known = CardinalityUpperBound.ONE.multiply(estimate);\n+        assertThat(known.map(i -> i), equalTo(estimate));\n+\n+        assertThat(known.multiply(0), sameInstance(CardinalityUpperBound.NONE));\n+        assertThat(known.multiply(1), sameInstance(known));\n+        assertThat(known.multiply(between(Short.MAX_VALUE, Integer.MAX_VALUE)), sameInstance(CardinalityUpperBound.MANY));", "originalCommit": "42bbd99d11dd62f48263d0418656802d554011fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MTYzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61529#discussion_r477491636", "bodyText": "Yeah, we got lucky. Looks like you have to iterate a lot to get unlucky, but my math was wrong.", "author": "nik9000", "createdAt": "2020-08-26T18:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTg5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c7cf58ba7a94efc00df29bd118b20f559d8f10a", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/CardinalityUpperBoundTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/CardinalityUpperBoundTests.java\nindex f425c8500a0..8d03521ecbb 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/CardinalityUpperBoundTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/CardinalityUpperBoundTests.java\n\n@@ -50,7 +50,8 @@ public class CardinalityUpperBoundTests extends ESTestCase {\n \n         assertThat(known.multiply(0), sameInstance(CardinalityUpperBound.NONE));\n         assertThat(known.multiply(1), sameInstance(known));\n-        assertThat(known.multiply(between(Short.MAX_VALUE, Integer.MAX_VALUE)), sameInstance(CardinalityUpperBound.MANY));\n+        int minOverflow = (int) Math.ceil((double) Integer.MAX_VALUE / estimate);\n+        assertThat(known.multiply(between(minOverflow, Integer.MAX_VALUE)), sameInstance(CardinalityUpperBound.MANY));\n \n         int multiplier = between(2, Short.MAX_VALUE - 1);\n         assertThat(known.multiply(multiplier).map(i -> i), equalTo(estimate * multiplier));\n"}}, {"oid": "4c7cf58ba7a94efc00df29bd118b20f559d8f10a", "url": "https://github.com/elastic/elasticsearch/commit/4c7cf58ba7a94efc00df29bd118b20f559d8f10a", "message": "Fix math", "committedDate": "2020-08-26T18:10:02Z", "type": "commit"}, {"oid": "6cc3c05f2b49d06014d003afef80dae607413eb7", "url": "https://github.com/elastic/elasticsearch/commit/6cc3c05f2b49d06014d003afef80dae607413eb7", "message": "Merge branch 'master' into support_precise_upper_bounds", "committedDate": "2020-08-26T18:59:36Z", "type": "commit"}]}