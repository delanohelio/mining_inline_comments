{"pr_number": 55467, "pr_title": "Rely on the computeIfAbsent logic to prevent duplicated compilation of scripts", "pr_createdAt": "2020-04-20T14:59:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55467", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r420314607", "bodyText": "The call to checkCompilationLimit() is no longer locked on the ScriptCache, we'll have to make this call safe.", "author": "stu-elastic", "createdAt": "2020-05-05T18:20:36Z", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();", "originalCommit": "ae24c668a68496080b9990b978503590b79d9aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NTQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r422195439", "bodyText": "Yeah noticed that too that's why I added commit b55e8e3", "author": "mjmbischoff", "createdAt": "2020-05-08T15:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw=="}], "type": "inlineReview", "revised_code": {"commit": "6b253d00005ddc5ef14e5b5b76174431b4c7db11", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5e..c1fd795b5432 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n\n@@ -98,41 +98,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }\n"}}, {"oid": "0dd254137c228138d9b3af4ffdd2f5acc7217d92", "url": "https://github.com/elastic/elasticsearch/commit/0dd254137c228138d9b3af4ffdd2f5acc7217d92", "message": "Instead of serializing compilation using a plain lock / mutex combined with a double check, rely on the computeIfAbsent logic to prevent duplicated compilation of scripts.", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "65a09c3d8a954dddeb109cc7ca588e5833deb01f", "url": "https://github.com/elastic/elasticsearch/commit/65a09c3d8a954dddeb109cc7ca588e5833deb01f", "message": "Updating checkCompilationLimit to be thread-safe", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "message": "Fixing checkstyle violations.", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "message": "Fixing checkstyle violations.", "committedDate": "2020-05-08T16:02:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r439065901", "bodyText": "Let's clean this up a bit by moving the try/catch from inside the lambda out to this level and avoid checking for RuntimeException.\ngit diff\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5..5d59a91b207 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n@@ -98,41 +97,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }", "author": "stu-elastic", "createdAt": "2020-06-11T20:55:33Z", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "originalCommit": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNzM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440017375", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.", "author": "mjmbischoff", "createdAt": "2020-06-15T08:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIzMDc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440230763", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.\n\nTotally reasonable, just made sense to go a bit further for this one.", "author": "stu-elastic", "createdAt": "2020-06-15T14:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "6b253d00005ddc5ef14e5b5b76174431b4c7db11", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5e..c1fd795b5432 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n\n@@ -98,41 +98,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }\n"}}, {"oid": "6b253d00005ddc5ef14e5b5b76174431b4c7db11", "url": "https://github.com/elastic/elasticsearch/commit/6b253d00005ddc5ef14e5b5b76174431b4c7db11", "message": "Processing review comments", "committedDate": "2020-06-15T08:38:00Z", "type": "commit"}, {"oid": "bc3f1d83369749be20780b8e0b07343151c7769f", "url": "https://github.com/elastic/elasticsearch/commit/bc3f1d83369749be20780b8e0b07343151c7769f", "message": "Merge remote-tracking branch 'origin/master' into script-compilation", "committedDate": "2020-06-15T09:16:19Z", "type": "commit"}, {"oid": "52925938e6fd9624011c26ac4e57f32240ac1403", "url": "https://github.com/elastic/elasticsearch/commit/52925938e6fd9624011c26ac4e57f32240ac1403", "message": "Fixing unused import triggering checkstyle.", "committedDate": "2020-06-15T10:00:34Z", "type": "commit"}]}