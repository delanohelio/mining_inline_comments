{"pr_number": 56533, "pr_title": "Improve cardinality measure used to build aggs", "pr_createdAt": "2020-05-11T17:30:30Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56533", "timeline": [{"oid": "2a46c3267e5f94a54d50ca73143c42f6d96ad100", "url": "https://github.com/elastic/elasticsearch/commit/2a46c3267e5f94a54d50ca73143c42f6d96ad100", "message": "Improve cardinality measure used to build aggs\n\nThis makes a `parentCardinality` available to every `Aggregator`'s ctor\nso it can make intelligent choices about how it collects bucket values.\nThis replaces `collectsFromSingleBucket` and is similar to it but:\n1. It supports `NONE`, `ONE`, and `MANY` values and is generally\n   extensible if we decide we can use more precise counts.\n2. It is more accurate. `collectsFromSingleBucket` assumed that all\n   sub-aggregations live under multi-bucket aggregations. This is\n   normally true but `parentCardinality` is properly carried forward\n   for single bucket aggregations like `filter` and for multi-bucket\n   aggregations configured in single-bucket for like `range` with a\n   single range.\n\nWhile I was touching every aggregation I renamed `doCreateInternal` to\n`createMapped` because that seemed like a much better name and it was\nright there, next to the change I was already making.\n\nRelates to #56487", "committedDate": "2020-05-11T17:27:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MDUwMw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r423360503", "bodyText": "A better name for this might be CardinalityEstimate or CardinalityUpperBound.", "author": "nik9000", "createdAt": "2020-05-11T22:40:09Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations;\n+\n+import org.elasticsearch.search.aggregations.bucket.BucketsAggregator;\n+import org.elasticsearch.search.aggregations.metrics.MetricsAggregator;\n+\n+/**\n+ * Rough measure of how many buckets this {@link Aggregator} will collect\n+ * used to pick data structures used during collection. Just \"none\", \"one\",\n+ * and \"many\".\n+ * <p>\n+ * Unlike {@link AggregationBuilder.BucketCardinality} this is influenced\n+ * by the number of buckets that the parent aggregation collect.\n+ */\n+public enum TotalBucketCardinality {", "originalCommit": "2a46c3267e5f94a54d50ca73143c42f6d96ad100", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MTA3MA==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r423361070", "bodyText": "I think removing \"bucket\" from the name would prevent some confusion. And it'd force it into something as simple as an upper bound on the owningBucketOrd passed to the collect method.", "author": "nik9000", "createdAt": "2020-05-11T22:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MDUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MzcwNw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r423363707", "bodyText": "That isn't what it is now, but it could be!", "author": "nik9000", "createdAt": "2020-05-11T22:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MDUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NTc0OA==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r423385748", "bodyText": "Thinking about it again, there are really two cardinalities to measure and they are both useful.\n\nThe Aggregator's cardinality. This is the thing I keep calling parentCardinatlity in the PR. It is an upper bound for the value of owningBucketOrd that will be passed to collect.\nThe Aggregator's bucket's cardinality. This is the thing I was calling bucketCardinality in the PR. Confusingly, it is only a thing in BucketsAggregations.\n\nAlso confusingly, there are a couple of relationships between these things:\n\nAn Aggregator can calculate its bucket's cardinality - sometimes exactly like range and sometimes not like terms.\nAn Aggregator's bucket's cardinality is the cardinality of is sub-aggregations.\n\nThis PR, as it stands now, mixes those two things up and gives them funny names. I'd like to rework it.\nTo be clear: this is useful because knowing an Aggregator's cardinality with some precision would let us pick smarter aggregation implementations. This PR only gives three levels of precision: NONE, ONE, and MANY. But we can do better in a follow up when we're sure how we're going to use it. Right now it is useful to have the distinction between NONE and ONE and MANY. Or, rather, it would be useful if I got the names straight. Right now I'm fairly sure it is wrong.", "author": "nik9000", "createdAt": "2020-05-11T23:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM2MDUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "2b1ebd2ff1a1f5685757841cdc2f8a2683f450a9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\nsimilarity index 55%\nrename from server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java\nrename to server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\nindex 0a35ee9f963..46f9edd945d 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\n\n@@ -20,38 +20,36 @@\n package org.elasticsearch.search.aggregations;\n \n import org.elasticsearch.search.aggregations.bucket.BucketsAggregator;\n-import org.elasticsearch.search.aggregations.metrics.MetricsAggregator;\n+import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregator;\n+import org.elasticsearch.search.aggregations.bucket.range.RangeAggregator;\n \n /**\n- * Rough measure of how many buckets this {@link Aggregator} will collect\n- * used to pick data structures used during collection. Just \"none\", \"one\",\n- * and \"many\".\n- * <p>\n- * Unlike {@link AggregationBuilder.BucketCardinality} this is influenced\n- * by the number of buckets that the parent aggregation collect.\n+ * Upper bound of how many {@code owningBucketOrds} that an {@link Aggregator}\n+ * will have to collect into. Just \"none\", \"one\", and \"many\".\n  */\n-public enum TotalBucketCardinality {\n+public enum CardinalityUpperBound {\n     /**\n-     * {@link Aggregator}s with this cardinality won't collect any buckets.\n-     * This could be because they are {@link MetricsAggregator}s which don't\n-     * support buckets at all. Or they could be {@link BucketsAggregator}\n-     * that are configured in such a way that they collect any buckets. \n+     * {@link Aggregator}s with this cardinality won't collect any data at\n+     * all. For the most part this happens when an aggregation is inside of a\n+     * {@link BucketsAggregator} that is pointing to an unmapped field. \n      */\n     NONE {\n         @Override\n-        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+        public CardinalityUpperBound forKnownBucketAggregator(int bucketCount) {\n             return NONE;\n         }\n     },\n \n     /**\n-     * {@link Aggregator}s with this cardinality will collect only a single\n-     * bucket. This will only be true for top level {@linkplain Aggregator}s\n-     * and for descendants of aggregation\n+     * {@link Aggregator}s with this cardinality will collect be collected\n+     * once or zero times. This will only be true for top level {@linkplain Aggregator}s\n+     * and for sub-aggregator's who's ancestors are all single-bucket\n+     * aggregations like {@link FilterAggregator} or a {@link RangeAggregator}\n+     * configured to collect only a single range.\n      */\n     ONE {\n         @Override\n-        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+        public CardinalityUpperBound forKnownBucketAggregator(int bucketCount) {\n             switch (bucketCount) {\n                 case 0:\n                     return NONE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc2MTU5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r423761597", "bodyText": "This should return NONE if passed 0.", "author": "nik9000", "createdAt": "2020-05-12T14:06:13Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.aggregations;\n+\n+import org.elasticsearch.search.aggregations.bucket.BucketsAggregator;\n+import org.elasticsearch.search.aggregations.metrics.MetricsAggregator;\n+\n+/**\n+ * Rough measure of how many buckets this {@link Aggregator} will collect\n+ * used to pick data structures used during collection. Just \"none\", \"one\",\n+ * and \"many\".\n+ * <p>\n+ * Unlike {@link AggregationBuilder.BucketCardinality} this is influenced\n+ * by the number of buckets that the parent aggregation collect.\n+ */\n+public enum TotalBucketCardinality {\n+    /**\n+     * {@link Aggregator}s with this cardinality won't collect any buckets.\n+     * This could be because they are {@link MetricsAggregator}s which don't\n+     * support buckets at all. Or they could be {@link BucketsAggregator}\n+     * that are configured in such a way that they collect any buckets. \n+     */\n+    NONE {\n+        @Override\n+        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+            return NONE;\n+        }\n+    },\n+\n+    /**\n+     * {@link Aggregator}s with this cardinality will collect only a single\n+     * bucket. This will only be true for top level {@linkplain Aggregator}s\n+     * and for descendants of aggregation\n+     */\n+    ONE {\n+        @Override\n+        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+            switch (bucketCount) {\n+                case 0:\n+                    return NONE;\n+                case 1:\n+                    return ONE;\n+                default:\n+                    return MANY;\n+            }\n+        }\n+    },\n+    /**\n+     * {@link Aggregator}s with this cardinality will collect many buckets.\n+     * Most {@link BucketsAggregator}s will have this cardinality.\n+     */\n+    MANY {\n+        @Override\n+        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+            return MANY;", "originalCommit": "2a46c3267e5f94a54d50ca73143c42f6d96ad100", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2b1ebd2ff1a1f5685757841cdc2f8a2683f450a9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\nsimilarity index 55%\nrename from server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java\nrename to server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\nindex 0a35ee9f963..46f9edd945d 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/TotalBucketCardinality.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/CardinalityUpperBound.java\n\n@@ -20,38 +20,36 @@\n package org.elasticsearch.search.aggregations;\n \n import org.elasticsearch.search.aggregations.bucket.BucketsAggregator;\n-import org.elasticsearch.search.aggregations.metrics.MetricsAggregator;\n+import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregator;\n+import org.elasticsearch.search.aggregations.bucket.range.RangeAggregator;\n \n /**\n- * Rough measure of how many buckets this {@link Aggregator} will collect\n- * used to pick data structures used during collection. Just \"none\", \"one\",\n- * and \"many\".\n- * <p>\n- * Unlike {@link AggregationBuilder.BucketCardinality} this is influenced\n- * by the number of buckets that the parent aggregation collect.\n+ * Upper bound of how many {@code owningBucketOrds} that an {@link Aggregator}\n+ * will have to collect into. Just \"none\", \"one\", and \"many\".\n  */\n-public enum TotalBucketCardinality {\n+public enum CardinalityUpperBound {\n     /**\n-     * {@link Aggregator}s with this cardinality won't collect any buckets.\n-     * This could be because they are {@link MetricsAggregator}s which don't\n-     * support buckets at all. Or they could be {@link BucketsAggregator}\n-     * that are configured in such a way that they collect any buckets. \n+     * {@link Aggregator}s with this cardinality won't collect any data at\n+     * all. For the most part this happens when an aggregation is inside of a\n+     * {@link BucketsAggregator} that is pointing to an unmapped field. \n      */\n     NONE {\n         @Override\n-        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+        public CardinalityUpperBound forKnownBucketAggregator(int bucketCount) {\n             return NONE;\n         }\n     },\n \n     /**\n-     * {@link Aggregator}s with this cardinality will collect only a single\n-     * bucket. This will only be true for top level {@linkplain Aggregator}s\n-     * and for descendants of aggregation\n+     * {@link Aggregator}s with this cardinality will collect be collected\n+     * once or zero times. This will only be true for top level {@linkplain Aggregator}s\n+     * and for sub-aggregator's who's ancestors are all single-bucket\n+     * aggregations like {@link FilterAggregator} or a {@link RangeAggregator}\n+     * configured to collect only a single range.\n      */\n     ONE {\n         @Override\n-        public TotalBucketCardinality forKnownBucketAggregator(int bucketCount) {\n+        public CardinalityUpperBound forKnownBucketAggregator(int bucketCount) {\n             switch (bucketCount) {\n                 case 0:\n                     return NONE;\n"}}, {"oid": "8e75f414fbdadb2621ec218f9a144d8039f8756e", "url": "https://github.com/elastic/elasticsearch/commit/8e75f414fbdadb2621ec218f9a144d8039f8756e", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-05-13T18:40:52Z", "type": "commit"}, {"oid": "2b1ebd2ff1a1f5685757841cdc2f8a2683f450a9", "url": "https://github.com/elastic/elasticsearch/commit/2b1ebd2ff1a1f5685757841cdc2f8a2683f450a9", "message": "Rework", "committedDate": "2020-05-13T19:20:12Z", "type": "commit"}, {"oid": "ddfe6ef9ed2dd840081b30b659a6d45a6275f7da", "url": "https://github.com/elastic/elasticsearch/commit/ddfe6ef9ed2dd840081b30b659a6d45a6275f7da", "message": "Rename multiply", "committedDate": "2020-05-13T19:32:23Z", "type": "commit"}, {"oid": "022e31c92d9b77fe4d7911aa4bd59f4f5c4f31a6", "url": "https://github.com/elastic/elasticsearch/commit/022e31c92d9b77fe4d7911aa4bd59f4f5c4f31a6", "message": "Rename test", "committedDate": "2020-05-13T19:39:56Z", "type": "commit"}, {"oid": "31375fbac72bf651a54ab8fb49eafa9f722671ac", "url": "https://github.com/elastic/elasticsearch/commit/31375fbac72bf651a54ab8fb49eafa9f722671ac", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-05-13T20:14:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5Nzk0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r424697942", "bodyText": "This isn't accurate.  If the user specified a script, we might not have a mapped field at this point.  Or for that matter, if we couldn't map a field but the user provided a missing value.  It would be accurate to say we are creating the aggregator for a non-empty values source.\nIn fact, a large point of the values source abstraction is to not have to know at this point if we have a mapped field or not.", "author": "not-napoleon", "createdAt": "2020-05-13T20:02:27Z", "path": "modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java", "diffHunk": "@@ -58,17 +59,27 @@ public Aggregator createInternal(SearchContext searchContext,\n         if (valuesSources.isEmpty()) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(valuesSources, searchContext, parent, collectsFromSingleBucket, metadata);\n+        return doCreateInternal(valuesSources, searchContext, parent, cardinality, metadata);\n     }\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a field that isn't mapped.\n+     */\n     protected abstract Aggregator createUnmapped(SearchContext searchContext,\n                                                     Aggregator parent,\n                                                     Map<String, Object> metadata) throws IOException;\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a mapped field.", "originalCommit": "ddfe6ef9ed2dd840081b30b659a6d45a6275f7da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNzg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r424707857", "bodyText": "Bah. I meant to revert that too after our conversation yesterday.", "author": "nik9000", "createdAt": "2020-05-13T20:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5Nzk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ae792250ad9cd8642509c839d01f39f2d1d564e2", "chunk": "diff --git a/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\nindex e497615276c..fe88907b923 100644\n--- a/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\n+++ b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\n\n@@ -63,14 +63,16 @@ public abstract class ArrayValuesSourceAggregatorFactory\n     }\n \n     /**\n-     * Create the {@linkplain Aggregator} for a field that isn't mapped.\n+     * Create the {@linkplain Aggregator} when none of the configured\n+     * fields can be resolved to a {@link ValuesSource}.\n      */\n     protected abstract Aggregator createUnmapped(SearchContext searchContext,\n                                                     Aggregator parent,\n                                                     Map<String, Object> metadata) throws IOException;\n \n     /**\n-     * Create the {@linkplain Aggregator} for a mapped field.\n+     * Create the {@linkplain Aggregator} when any of the configured\n+     * fields can be resolved to a {@link ValuesSource}.\n      * \n      * @param cardinality Upper bound of the number of {@code owningBucketOrd}s\n      *                    that the {@link Aggregator} created by this method\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5ODQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r424698474", "bodyText": "As noted on doCreateInternal, it's more accurate to say this is used when we have no values.", "author": "not-napoleon", "createdAt": "2020-05-13T20:03:29Z", "path": "modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java", "diffHunk": "@@ -58,17 +59,27 @@ public Aggregator createInternal(SearchContext searchContext,\n         if (valuesSources.isEmpty()) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(valuesSources, searchContext, parent, collectsFromSingleBucket, metadata);\n+        return doCreateInternal(valuesSources, searchContext, parent, cardinality, metadata);\n     }\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a field that isn't mapped.", "originalCommit": "ddfe6ef9ed2dd840081b30b659a6d45a6275f7da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwODI3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r424708277", "bodyText": "++", "author": "nik9000", "createdAt": "2020-05-13T20:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5ODQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "ae792250ad9cd8642509c839d01f39f2d1d564e2", "chunk": "diff --git a/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\nindex e497615276c..fe88907b923 100644\n--- a/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\n+++ b/modules/aggs-matrix-stats/src/main/java/org/elasticsearch/search/aggregations/support/ArrayValuesSourceAggregatorFactory.java\n\n@@ -63,14 +63,16 @@ public abstract class ArrayValuesSourceAggregatorFactory\n     }\n \n     /**\n-     * Create the {@linkplain Aggregator} for a field that isn't mapped.\n+     * Create the {@linkplain Aggregator} when none of the configured\n+     * fields can be resolved to a {@link ValuesSource}.\n      */\n     protected abstract Aggregator createUnmapped(SearchContext searchContext,\n                                                     Aggregator parent,\n                                                     Map<String, Object> metadata) throws IOException;\n \n     /**\n-     * Create the {@linkplain Aggregator} for a mapped field.\n+     * Create the {@linkplain Aggregator} when any of the configured\n+     * fields can be resolved to a {@link ValuesSource}.\n      * \n      * @param cardinality Upper bound of the number of {@code owningBucketOrd}s\n      *                    that the {@link Aggregator} created by this method\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwMjMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r424702326", "bodyText": "+1 for dropping this comment.  3 lines to say nothing the type declaration didn't.", "author": "not-napoleon", "createdAt": "2020-05-13T20:10:41Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java", "diffHunk": "@@ -226,28 +226,20 @@ public void doValidate() {\n \n     protected abstract Aggregator createInternal(SearchContext searchContext,\n                                                     Aggregator parent,\n-                                                    boolean collectsFromSingleBucket,\n+                                                    CardinalityUpperBound cardinality,\n                                                     Map<String, Object> metadata) throws IOException;\n \n     /**\n-     * Creates the aggregator\n+     * Creates the aggregator.\n      *\n-     *\n-     * @param searchContext\n-     *            The search context", "originalCommit": "ddfe6ef9ed2dd840081b30b659a6d45a6275f7da", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c0d69f461a8ccc5669041cf07d35a7cf8362ef9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java\nindex bf735afde9b..b648e8083e0 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactory.java\n\n@@ -246,20 +81,6 @@ public abstract class AggregatorFactory {\n         return parent;\n     }\n \n-    /**\n-     * Utility method. Given an {@link AggregatorFactory} that creates\n-     * {@link Aggregator}s that only know how to collect bucket {@code 0}, this\n-     * returns an aggregator that can collect any bucket.\n-     * @deprecated implement the aggregator to handle many owning buckets\n-     */\n-    @Deprecated\n-    protected static Aggregator asMultiBucketAggregator(final AggregatorFactory factory, final SearchContext searchContext,\n-            final Aggregator parent) throws IOException {\n-        final Aggregator first = factory.create(searchContext, parent, CardinalityUpperBound.ONE);\n-        final BigArrays bigArrays = searchContext.bigArrays();\n-        return new MultiBucketAggregatorWrapper(bigArrays, searchContext, parent, factory, first);\n-    }\n-\n     /**\n      * Returns the aggregation subtype for nodes usage stats.\n      * <p>\n"}}, {"oid": "6d4d742336857ea6051157417c0855e669bdf6b1", "url": "https://github.com/elastic/elasticsearch/commit/6d4d742336857ea6051157417c0855e669bdf6b1", "message": "license header", "committedDate": "2020-05-13T20:17:44Z", "type": "commit"}, {"oid": "ae792250ad9cd8642509c839d01f39f2d1d564e2", "url": "https://github.com/elastic/elasticsearch/commit/ae792250ad9cd8642509c839d01f39f2d1d564e2", "message": "Different comment", "committedDate": "2020-05-13T20:29:32Z", "type": "commit"}, {"oid": "7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "url": "https://github.com/elastic/elasticsearch/commit/7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-05-18T20:02:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMDI3NA==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r436120274", "bodyText": "nit: I know it was like this when you found it, but since you're touching this anyway, maybe add a message to the exception?", "author": "not-napoleon", "createdAt": "2020-06-05T19:25:31Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/global/GlobalAggregatorFactory.java", "diffHunk": "@@ -42,13 +43,13 @@ public GlobalAggregatorFactory(String name,\n     @Override\n     public Aggregator createInternal(SearchContext searchContext,\n                                         Aggregator parent,\n-                                        boolean collectsFromSingleBucket,\n+                                        CardinalityUpperBound cardinality,\n                                         Map<String, Object> metadata) throws IOException {\n         if (parent != null) {\n             throw new AggregationExecutionException(\"Aggregation [\" + parent.name() + \"] cannot have a global \" + \"sub-aggregation [\" + name\n                     + \"]. Global aggregations can only be defined as top level aggregations\");\n         }\n-        if (collectsFromSingleBucket == false) {\n+        if (cardinality != CardinalityUpperBound.ONE) {", "originalCommit": "7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3968927208a5a5585ae6fec637048e392a5dc9c2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/global/GlobalAggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/global/GlobalAggregatorFactory.java\nindex e6afc01929b..39c732deee8 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/global/GlobalAggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/global/GlobalAggregatorFactory.java\n\n@@ -50,7 +50,7 @@ public class GlobalAggregatorFactory extends AggregatorFactory {\n                     + \"]. Global aggregations can only be defined as top level aggregations\");\n         }\n         if (cardinality != CardinalityUpperBound.ONE) {\n-            throw new IllegalStateException();\n+            throw new AggregationExecutionException(\"Aggregation [\" + name() + \"] must have cardinality 1 but was [\" + cardinality + \"]\");\n         }\n         return new GlobalAggregator(name, factories, searchContext, metadata);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNjIxNg==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r436126216", "bodyText": "Why is this always ONE?", "author": "not-napoleon", "createdAt": "2020-06-05T19:39:54Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificantLongTermsAggregator.java", "diffHunk": "@@ -47,7 +48,7 @@ public SignificantLongTermsAggregator(String name, AggregatorFactories factories\n             IncludeExclude.LongFilter includeExclude, Map<String, Object> metadata) throws IOException {\n \n         super(name, factories, valuesSource, format, null, bucketCountThresholds, context, parent,\n-                SubAggCollectionMode.BREADTH_FIRST, false, includeExclude, false, metadata);\n+                SubAggCollectionMode.BREADTH_FIRST, false, includeExclude, CardinalityUpperBound.ONE, metadata);", "originalCommit": "7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5OTMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r439599337", "bodyText": "This has since been removed. It was ONE because that agg was wrapped in asMultiBucketAggregator.", "author": "nik9000", "createdAt": "2020-06-12T19:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNjIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "8ae89c41acd5ad38d91e3b2280f79e84e1fe003b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificantLongTermsAggregator.java b/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificantLongTermsAggregator.java\ndeleted file mode 100644\nindex 656f98aec7d..00000000000\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/SignificantLongTermsAggregator.java\n+++ /dev/null\n\n@@ -1,137 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.elasticsearch.search.aggregations.bucket.terms;\n-\n-import org.apache.lucene.index.IndexReader;\n-import org.apache.lucene.index.LeafReaderContext;\n-import org.elasticsearch.common.lease.Releasables;\n-import org.elasticsearch.search.DocValueFormat;\n-import org.elasticsearch.search.aggregations.Aggregator;\n-import org.elasticsearch.search.aggregations.AggregatorFactories;\n-import org.elasticsearch.search.aggregations.CardinalityUpperBound;\n-import org.elasticsearch.search.aggregations.InternalAggregation;\n-import org.elasticsearch.search.aggregations.LeafBucketCollector;\n-import org.elasticsearch.search.aggregations.LeafBucketCollectorBase;\n-import org.elasticsearch.search.aggregations.bucket.terms.LongKeyedBucketOrds.BucketOrdsEnum;\n-import org.elasticsearch.search.aggregations.bucket.terms.heuristic.SignificanceHeuristic;\n-import org.elasticsearch.search.aggregations.support.ValuesSource;\n-import org.elasticsearch.search.internal.ContextIndexSearcher;\n-import org.elasticsearch.search.internal.SearchContext;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.Map;\n-\n-import static java.util.Collections.emptyList;\n-\n-public class SignificantLongTermsAggregator extends LongTermsAggregator {\n-\n-    public SignificantLongTermsAggregator(String name, AggregatorFactories factories, ValuesSource.Numeric valuesSource,\n-            DocValueFormat format, BucketCountThresholds bucketCountThresholds, SearchContext context, Aggregator parent,\n-            SignificanceHeuristic significanceHeuristic, SignificantTermsAggregatorFactory termsAggFactory,\n-            IncludeExclude.LongFilter includeExclude, Map<String, Object> metadata) throws IOException {\n-\n-        super(name, factories, valuesSource, format, null, bucketCountThresholds, context, parent,\n-                SubAggCollectionMode.BREADTH_FIRST, false, includeExclude, CardinalityUpperBound.ONE, metadata);\n-        this.significanceHeuristic = significanceHeuristic;\n-        this.termsAggFactory = termsAggFactory;\n-    }\n-\n-    protected long numCollectedDocs;\n-    private final SignificantTermsAggregatorFactory termsAggFactory;\n-    private final SignificanceHeuristic significanceHeuristic;\n-\n-    @Override\n-    public LeafBucketCollector getLeafCollector(LeafReaderContext ctx,\n-            final LeafBucketCollector sub) throws IOException {\n-        return new LeafBucketCollectorBase(super.getLeafCollector(ctx, sub), null) {\n-            @Override\n-            public void collect(int doc, long bucket) throws IOException {\n-                super.collect(doc, bucket);\n-                numCollectedDocs++;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public InternalAggregation[] buildAggregations(long[] owningBucketOrds) throws IOException {\n-        assert owningBucketOrds.length == 1 && owningBucketOrds[0] == 0;\n-\n-        long bucketsInOrd = bucketOrds.bucketsInOrd(0);\n-        final int size = (int) Math.min(bucketsInOrd, bucketCountThresholds.getShardSize());\n-\n-        long supersetSize = termsAggFactory.getSupersetNumDocs();\n-        long subsetSize = numCollectedDocs;\n-\n-        BucketSignificancePriorityQueue<SignificantLongTerms.Bucket> ordered = new BucketSignificancePriorityQueue<>(size);\n-        SignificantLongTerms.Bucket spare = null;\n-        BucketOrdsEnum ordsEnum = bucketOrds.ordsEnum(0);\n-        while (ordsEnum.next()) {\n-            final int docCount = bucketDocCount(ordsEnum.ord());\n-            if (docCount < bucketCountThresholds.getShardMinDocCount()) {\n-                continue;\n-            }\n-            if (spare == null) {\n-                spare = new SignificantLongTerms.Bucket(0, 0, 0, 0, 0, null, format, 0);\n-            }\n-            spare.term = ordsEnum.value();\n-            spare.subsetDf = docCount;\n-            spare.subsetSize = subsetSize;\n-            spare.supersetDf = termsAggFactory.getBackgroundFrequency(spare.term);\n-            spare.supersetSize = supersetSize;\n-            // During shard-local down-selection we use subset/superset stats that are for this shard only\n-            // Back at the central reducer these properties will be updated with global stats\n-            spare.updateScore(significanceHeuristic);\n-\n-            spare.bucketOrd = ordsEnum.ord();\n-            spare = ordered.insertWithOverflow(spare);\n-            if (spare == null) {\n-                consumeBucketsAndMaybeBreak(1);\n-            }\n-        }\n-\n-        SignificantLongTerms.Bucket[] list = new SignificantLongTerms.Bucket[ordered.size()];\n-        for (int i = ordered.size() - 1; i >= 0; i--) {\n-            list[i] = ordered.pop();\n-        }\n-\n-        buildSubAggsForBuckets(list, bucket -> bucket.bucketOrd, (bucket, aggs) -> bucket.aggregations = aggs); \n-\n-        return new InternalAggregation[] {\n-            new SignificantLongTerms(name, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(),\n-                metadata(), format, subsetSize, supersetSize, significanceHeuristic, Arrays.asList(list))\n-        };\n-    }\n-\n-    @Override\n-    public SignificantLongTerms buildEmptyAggregation() {\n-        // We need to account for the significance of a miss in our global stats - provide corpus size as context\n-        ContextIndexSearcher searcher = context.searcher();\n-        IndexReader topReader = searcher.getIndexReader();\n-        int supersetSize = topReader.numDocs();\n-        return new SignificantLongTerms(name, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(),\n-                metadata(), format, 0, supersetSize, significanceHeuristic, emptyList());\n-    }\n-\n-    @Override\n-    public void doClose() {\n-        Releasables.close(bucketOrds, termsAggFactory);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyODM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r436128398", "bodyText": "I liked your comment for this method on MultiValuesSourceAggregationBuilder better.", "author": "not-napoleon", "createdAt": "2020-06-05T19:45:22Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java", "diffHunk": "@@ -40,23 +41,35 @@ public ValuesSourceAggregatorFactory(String name, ValuesSourceConfig config, Que\n     }\n \n     @Override\n-    public Aggregator createInternal(SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket,\n+    public Aggregator createInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality,\n                                      Map<String, Object> metadata) throws IOException {\n         ValuesSource vs = config.toValuesSource();\n         if (vs == null) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(vs, searchContext, parent, collectsFromSingleBucket, metadata);\n+        return doCreateInternal(vs, searchContext, parent, cardinality, metadata);\n     }\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a field that couldn't be resolved\n+     * to a {@link ValuesSource}.", "originalCommit": "7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae89c41acd5ad38d91e3b2280f79e84e1fe003b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\nindex 9f2dd15a90a..52c71caabbe 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\n\n@@ -43,11 +43,10 @@ public abstract class ValuesSourceAggregatorFactory extends AggregatorFactory {\n     @Override\n     public Aggregator createInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality,\n                                      Map<String, Object> metadata) throws IOException {\n-        ValuesSource vs = config.toValuesSource();\n-        if (vs == null) {\n+        if (config.hasValues() == false) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(vs, searchContext, parent, cardinality, metadata);\n+        return doCreateInternal(searchContext, parent, cardinality, metadata);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyODg4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56533#discussion_r436128882", "bodyText": "Nit - there doesn't have to be a field here.  Could be a script, for example.  I prefer to say a values source that has values to return, which is still clunky but English.", "author": "not-napoleon", "createdAt": "2020-06-05T19:46:30Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java", "diffHunk": "@@ -40,23 +41,35 @@ public ValuesSourceAggregatorFactory(String name, ValuesSourceConfig config, Que\n     }\n \n     @Override\n-    public Aggregator createInternal(SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket,\n+    public Aggregator createInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality,\n                                      Map<String, Object> metadata) throws IOException {\n         ValuesSource vs = config.toValuesSource();\n         if (vs == null) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(vs, searchContext, parent, collectsFromSingleBucket, metadata);\n+        return doCreateInternal(vs, searchContext, parent, cardinality, metadata);\n     }\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a field that couldn't be resolved\n+     * to a {@link ValuesSource}.\n+     */\n     protected abstract Aggregator createUnmapped(SearchContext searchContext,\n                                                  Aggregator parent,\n                                                  Map<String, Object> metadata) throws IOException;\n \n+    /**\n+     * Create the {@linkplain Aggregator} for a field that was resolved to a", "originalCommit": "7fd02bd2fb442d7ed96a5042ba5819dcb540cee7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8ae89c41acd5ad38d91e3b2280f79e84e1fe003b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\nindex 9f2dd15a90a..52c71caabbe 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregatorFactory.java\n\n@@ -43,11 +43,10 @@ public abstract class ValuesSourceAggregatorFactory extends AggregatorFactory {\n     @Override\n     public Aggregator createInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality,\n                                      Map<String, Object> metadata) throws IOException {\n-        ValuesSource vs = config.toValuesSource();\n-        if (vs == null) {\n+        if (config.hasValues() == false) {\n             return createUnmapped(searchContext, parent, metadata);\n         }\n-        return doCreateInternal(vs, searchContext, parent, cardinality, metadata);\n+        return doCreateInternal(searchContext, parent, cardinality, metadata);\n     }\n \n     /**\n"}}, {"oid": "8ae89c41acd5ad38d91e3b2280f79e84e1fe003b", "url": "https://github.com/elastic/elasticsearch/commit/8ae89c41acd5ad38d91e3b2280f79e84e1fe003b", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-06-12T19:13:29Z", "type": "commit"}, {"oid": "3968927208a5a5585ae6fec637048e392a5dc9c2", "url": "https://github.com/elastic/elasticsearch/commit/3968927208a5a5585ae6fec637048e392a5dc9c2", "message": "itr", "committedDate": "2020-06-12T19:18:30Z", "type": "commit"}, {"oid": "6cfcc2c1c0d277604f7443aff625abd860fd1db2", "url": "https://github.com/elastic/elasticsearch/commit/6cfcc2c1c0d277604f7443aff625abd860fd1db2", "message": "oops", "committedDate": "2020-06-12T19:41:11Z", "type": "commit"}, {"oid": "9e9eb9eb235d55802893d1d1cc2d3321f035eb76", "url": "https://github.com/elastic/elasticsearch/commit/9e9eb9eb235d55802893d1d1cc2d3321f035eb76", "message": "Fixup", "committedDate": "2020-06-12T20:26:38Z", "type": "commit"}, {"oid": "1c0d69f461a8ccc5669041cf07d35a7cf8362ef9", "url": "https://github.com/elastic/elasticsearch/commit/1c0d69f461a8ccc5669041cf07d35a7cf8362ef9", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-07-01T21:57:39Z", "type": "commit"}, {"oid": "171381dbb4ca56a159df1ba9303159afcfb9be05", "url": "https://github.com/elastic/elasticsearch/commit/171381dbb4ca56a159df1ba9303159afcfb9be05", "message": "Merge branch 'master' into collects_from_single_buckets", "committedDate": "2020-07-06T14:09:44Z", "type": "commit"}, {"oid": "4f22b431c995c627e32f7cf580089ddf8a36e9b7", "url": "https://github.com/elastic/elasticsearch/commit/4f22b431c995c627e32f7cf580089ddf8a36e9b7", "message": "Fixup", "committedDate": "2020-07-06T15:31:04Z", "type": "commit"}, {"oid": "e9c23498c387ac2767b506eb4a6e6949ba59b631", "url": "https://github.com/elastic/elasticsearch/commit/e9c23498c387ac2767b506eb4a6e6949ba59b631", "message": "Parent?", "committedDate": "2020-07-06T16:17:29Z", "type": "commit"}, {"oid": "f2eb87b8178ac1c6c574a816e57041872a3704f4", "url": "https://github.com/elastic/elasticsearch/commit/f2eb87b8178ac1c6c574a816e57041872a3704f4", "message": "Explain", "committedDate": "2020-07-06T19:27:44Z", "type": "commit"}]}