{"pr_number": 64762, "pr_title": "Fix a NPE bug caused by code keep executing after listener returns", "pr_createdAt": "2020-11-09T08:17:59Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/64762", "timeline": [{"oid": "bd6d262bfed38e5e6a3ebc65eb47dbe996e5a8af", "url": "https://github.com/elastic/elasticsearch/commit/bd6d262bfed38e5e6a3ebc65eb47dbe996e5a8af", "message": "Another isntance of the classic bug of not returning after listener.onFailure", "committedDate": "2020-11-09T08:13:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzMzU0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523433545", "bodyText": "++ to not having a non-void method that is also passed an ActionListener. Maybe wrap Exception with an Optional<> ? Nothing much changes but I think it captures the fact that the Tuple.v2() might contain an exception  better?", "author": "jkakavas", "createdAt": "2020-11-14T15:55:36Z", "path": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java", "diffHunk": "@@ -101,23 +107,23 @@ private void authenticateAndCreateToken(GrantType grantType, CreateTokenRequest\n         }\n     }\n \n-    private AuthenticationToken extractAuthenticationToken(GrantType grantType, CreateTokenRequest request,\n-            ActionListener<CreateTokenResponse> listener) {\n+    private Tuple<AuthenticationToken, Exception> extractAuthenticationToken(GrantType grantType, CreateTokenRequest request) {", "originalCommit": "bd6d262bfed38e5e6a3ebc65eb47dbe996e5a8af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxMzE5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523913191", "bodyText": "Updated to wrap the exception in an Optional.", "author": "ywangd", "createdAt": "2020-11-16T05:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzMzU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "94b0f99a41ca19d3cd6af7b8c5ffbd76fc6c770f", "chunk": "diff --git a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java\nindex 89da45a15ec..97aabdf258e 100644\n--- a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java\n+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenAction.java\n\n@@ -107,7 +108,7 @@ public final class TransportCreateTokenAction extends HandledTransportAction<Cre\n         }\n     }\n \n-    private Tuple<AuthenticationToken, Exception> extractAuthenticationToken(GrantType grantType, CreateTokenRequest request) {\n+    private Tuple<AuthenticationToken, Optional<Exception>> extractAuthenticationToken(GrantType grantType, CreateTokenRequest request) {\n         AuthenticationToken authToken = null;\n         if (grantType == GrantType.PASSWORD) {\n             authToken = new UsernamePasswordToken(request.getUsername(), request.getPassword());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzMzkxMA==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523433910", "bodyText": "Maybe a random short string here instead of hardcoding the string that this was reported with?", "author": "jkakavas", "createdAt": "2020-11-14T15:59:38Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java", "diffHunk": "@@ -267,4 +269,25 @@ public void testKerberosGrantTypeCreatesWithRefreshToken() throws Exception {\n             assertNotNull(sourceMap.get(\"refresh_token\"));\n         }\n     }\n+\n+    public void testKerberosGrantTypeWillFailOnBase64DecodeError() throws Exception {\n+        final TokenService tokenService = new TokenService(SETTINGS, Clock.systemUTC(), client, license, securityContext,\n+            securityIndex, securityIndex, clusterService);\n+        Authentication authentication = new Authentication(new User(\"joe\"), new Authentication.RealmRef(\"realm\", \"type\", \"node\"), null);\n+        authentication.writeToContext(threadPool.getThreadContext());\n+\n+        final TransportCreateTokenAction action = new TransportCreateTokenAction(threadPool,\n+            mock(TransportService.class), new ActionFilters(Collections.emptySet()), tokenService,\n+            authenticationService, securityContext);\n+        final CreateTokenRequest createTokenRequest = new CreateTokenRequest();\n+        createTokenRequest.setGrantType(\"_kerberos\");\n+        createTokenRequest.setKerberosTicket(new SecureString(\"(:I\".toCharArray()));", "originalCommit": "bd6d262bfed38e5e6a3ebc65eb47dbe996e5a8af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxMzQzNA==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523913434", "bodyText": "It's a bit tricky to have a great randomness for an invalid base64 string. I took a simple approach to just random from all printable invalid base64 characters.", "author": "ywangd", "createdAt": "2020-11-16T05:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzMzkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "94b0f99a41ca19d3cd6af7b8c5ffbd76fc6c770f", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\nindex 69097efa445..b1ad86f99c8 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\n\n@@ -281,13 +283,26 @@ public class TransportCreateTokenActionTests extends ESTestCase {\n             authenticationService, securityContext);\n         final CreateTokenRequest createTokenRequest = new CreateTokenRequest();\n         createTokenRequest.setGrantType(\"_kerberos\");\n-        createTokenRequest.setKerberosTicket(new SecureString(\"(:I\".toCharArray()));\n+        final char[] invalidBase64Chars = \"!\\\"#$%&\\\\'()*,./:;<>?@[]^_`{|}~\\t\\n\\r\".toCharArray();\n+        final String kerberosTicketValue = Strings.arrayToDelimitedString(\n+            randomArray(1, 10, Character[]::new,\n+                () -> invalidBase64Chars[randomIntBetween(0, invalidBase64Chars.length - 1)]), \"\");\n+        createTokenRequest.setKerberosTicket(new SecureString(kerberosTicketValue.toCharArray()));\n \n         PlainActionFuture<CreateTokenResponse> tokenResponseFuture = new PlainActionFuture<>();\n-        action.doExecute(null, createTokenRequest, tokenResponseFuture);\n+        action.doExecute(null, createTokenRequest, assertListenerIsOnlyCalledOnce(tokenResponseFuture));\n         UnsupportedOperationException e = expectThrows(UnsupportedOperationException.class, () -> tokenResponseFuture.actionGet());\n         assertThat(e.getMessage(), containsString(\"could not decode base64 kerberos ticket\"));\n         // The code flow should stop after above failure and never reach authenticationService\n         Mockito.verifyZeroInteractions(authenticationService);\n     }\n+\n+    private static <T> ActionListener<T> assertListenerIsOnlyCalledOnce(ActionListener<T> delegate) {\n+        final AtomicInteger callCount = new AtomicInteger(0);\n+        return ActionListener.runBefore(delegate, () -> {\n+            if (callCount.incrementAndGet() != 1) {\n+                fail(\"Listener was called twice\");\n+            }\n+        });\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzNDE3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523434175", "bodyText": "We could wrap this in an `assertListenerIsOnlyCalledOnce", "author": "jkakavas", "createdAt": "2020-11-14T16:02:17Z", "path": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java", "diffHunk": "@@ -267,4 +269,25 @@ public void testKerberosGrantTypeCreatesWithRefreshToken() throws Exception {\n             assertNotNull(sourceMap.get(\"refresh_token\"));\n         }\n     }\n+\n+    public void testKerberosGrantTypeWillFailOnBase64DecodeError() throws Exception {\n+        final TokenService tokenService = new TokenService(SETTINGS, Clock.systemUTC(), client, license, securityContext,\n+            securityIndex, securityIndex, clusterService);\n+        Authentication authentication = new Authentication(new User(\"joe\"), new Authentication.RealmRef(\"realm\", \"type\", \"node\"), null);\n+        authentication.writeToContext(threadPool.getThreadContext());\n+\n+        final TransportCreateTokenAction action = new TransportCreateTokenAction(threadPool,\n+            mock(TransportService.class), new ActionFilters(Collections.emptySet()), tokenService,\n+            authenticationService, securityContext);\n+        final CreateTokenRequest createTokenRequest = new CreateTokenRequest();\n+        createTokenRequest.setGrantType(\"_kerberos\");\n+        createTokenRequest.setKerberosTicket(new SecureString(\"(:I\".toCharArray()));\n+\n+        PlainActionFuture<CreateTokenResponse> tokenResponseFuture = new PlainActionFuture<>();", "originalCommit": "bd6d262bfed38e5e6a3ebc65eb47dbe996e5a8af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxMzUyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/64762#discussion_r523913529", "bodyText": "Thanks. This is a nice addition to the assertions.", "author": "ywangd", "createdAt": "2020-11-16T05:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzNDE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "94b0f99a41ca19d3cd6af7b8c5ffbd76fc6c770f", "chunk": "diff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\nindex 69097efa445..b1ad86f99c8 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/token/TransportCreateTokenActionTests.java\n\n@@ -281,13 +283,26 @@ public class TransportCreateTokenActionTests extends ESTestCase {\n             authenticationService, securityContext);\n         final CreateTokenRequest createTokenRequest = new CreateTokenRequest();\n         createTokenRequest.setGrantType(\"_kerberos\");\n-        createTokenRequest.setKerberosTicket(new SecureString(\"(:I\".toCharArray()));\n+        final char[] invalidBase64Chars = \"!\\\"#$%&\\\\'()*,./:;<>?@[]^_`{|}~\\t\\n\\r\".toCharArray();\n+        final String kerberosTicketValue = Strings.arrayToDelimitedString(\n+            randomArray(1, 10, Character[]::new,\n+                () -> invalidBase64Chars[randomIntBetween(0, invalidBase64Chars.length - 1)]), \"\");\n+        createTokenRequest.setKerberosTicket(new SecureString(kerberosTicketValue.toCharArray()));\n \n         PlainActionFuture<CreateTokenResponse> tokenResponseFuture = new PlainActionFuture<>();\n-        action.doExecute(null, createTokenRequest, tokenResponseFuture);\n+        action.doExecute(null, createTokenRequest, assertListenerIsOnlyCalledOnce(tokenResponseFuture));\n         UnsupportedOperationException e = expectThrows(UnsupportedOperationException.class, () -> tokenResponseFuture.actionGet());\n         assertThat(e.getMessage(), containsString(\"could not decode base64 kerberos ticket\"));\n         // The code flow should stop after above failure and never reach authenticationService\n         Mockito.verifyZeroInteractions(authenticationService);\n     }\n+\n+    private static <T> ActionListener<T> assertListenerIsOnlyCalledOnce(ActionListener<T> delegate) {\n+        final AtomicInteger callCount = new AtomicInteger(0);\n+        return ActionListener.runBefore(delegate, () -> {\n+            if (callCount.incrementAndGet() != 1) {\n+                fail(\"Listener was called twice\");\n+            }\n+        });\n+    }\n }\n"}}, {"oid": "94b0f99a41ca19d3cd6af7b8c5ffbd76fc6c770f", "url": "https://github.com/elastic/elasticsearch/commit/94b0f99a41ca19d3cd6af7b8c5ffbd76fc6c770f", "message": "Address feedback", "committedDate": "2020-11-16T05:57:04Z", "type": "commit"}, {"oid": "b5ef1ec2d3107e1358868033f41a2e58efc50387", "url": "https://github.com/elastic/elasticsearch/commit/b5ef1ec2d3107e1358868033f41a2e58efc50387", "message": "Merge branch 'master' into es-64692-should-return-after-listener-onfailure", "committedDate": "2020-11-16T06:09:21Z", "type": "commit"}]}