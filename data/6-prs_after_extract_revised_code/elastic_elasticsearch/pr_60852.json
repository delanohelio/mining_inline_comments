{"pr_number": 60852, "pr_title": "Remove a bunch of type boilerplate from Aggs", "pr_createdAt": "2020-08-06T21:32:48Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60852", "timeline": [{"oid": "39af94f862fd154a28185de46b4f93e6f3f266c9", "url": "https://github.com/elastic/elasticsearch/commit/39af94f862fd154a28185de46b4f93e6f3f266c9", "message": "merge our two 'dummy' interfaces", "committedDate": "2020-08-06T17:38:39Z", "type": "commit"}, {"oid": "bc5d8046692fc2f63d9f2ecca392fd115841d926", "url": "https://github.com/elastic/elasticsearch/commit/bc5d8046692fc2f63d9f2ecca392fd115841d926", "message": "remove a bunch of type boilerplate", "committedDate": "2020-08-06T21:24:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r466709995", "bodyText": "I think the key might belong in the Factory, at least while we still have them.", "author": "nik9000", "createdAt": "2020-08-06T22:02:07Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoTileGridAggregationBuilder.java", "diffHunk": "@@ -19,24 +19,29 @@\n \n package org.elasticsearch.search.aggregations.bucket.geogrid;\n \n-import java.io.IOException;\n-import java.util.Map;\n-\n import org.elasticsearch.common.geo.GeoBoundingBox;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.xcontent.ObjectParser;\n import org.elasticsearch.index.query.QueryShardContext;\n import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorFactories;\n import org.elasticsearch.search.aggregations.AggregatorFactory;\n+import org.elasticsearch.search.aggregations.metrics.GeoGridAggregatorSupplier;\n import org.elasticsearch.search.aggregations.support.ValuesSourceAggregatorFactory;\n import org.elasticsearch.search.aggregations.support.ValuesSourceConfig;\n import org.elasticsearch.search.aggregations.support.ValuesSourceRegistry;\n \n+import java.io.IOException;\n+import java.util.Map;\n+\n public class GeoTileGridAggregationBuilder extends GeoGridAggregationBuilder {\n     public static final String NAME = \"geotile_grid\";\n     public static final int DEFAULT_PRECISION = 7;\n     private static final int DEFAULT_MAX_NUM_CELLS = 10000;\n+    public static final ValuesSourceRegistry.RegistryKey<GeoGridAggregatorSupplier> REGISTRY_KEY = new ValuesSourceRegistry.RegistryKey<>(", "originalCommit": "bc5d8046692fc2f63d9f2ecca392fd115841d926", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0MjUyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468142521", "bodyText": "Actually, I was thinking about moving all of registration into the builder...", "author": "not-napoleon", "createdAt": "2020-08-10T19:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxODU1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468718551", "bodyText": "I ended up needing access to the registry key in ValuesSourceAggregationBuilder, and had to add an override function to get at it from there.  Given that, I think keeping the key on the builder makes more sense.", "author": "not-napoleon", "createdAt": "2020-08-11T16:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMTY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468721665", "bodyText": "\ud83d\udc4d", "author": "nik9000", "createdAt": "2020-08-11T16:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwOTk5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMDQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r466710474", "bodyText": "Do you think we need the marker interface? Like, maybe the <T> below can just be T?", "author": "nik9000", "createdAt": "2020-08-06T22:03:30Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java", "diffHunk": "@@ -31,18 +31,34 @@\n import java.util.Objects;\n \n /**\n- * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link AggregatorSupplier}s.  DO NOT directly\n+ * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link ComponentSupplier}s.  DO NOT directly\n  * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n  * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n  *\n  */\n public class ValuesSourceRegistry {\n \n-    public interface CompositeSupplier {\n+    /**\n+     * {@link ComponentSupplier} serves as a marker for what the {@link ValuesSourceRegistry} holds to construct aggregator instances.\n+     * The aggregators for each aggregation should all share a signature, and that signature should be used to create an ComponentSupplier\n+     * for that aggregation.  Alternatively, if an existing supplier has a matching signature, please re-use that.\n+     *\n+     * In many cases, this can be a simple wrapper over the aggregator constructor.  If that is sufficient, please just use a reference to\n+     * the constructor.  Implementing a supplier (typically as a lambda) should only be necessary when factors besides the\n+     * {@link ValuesSourceType} are necessary for selecting the correct aggregator implementation.  This happens in terms for example where\n+     * we make decisions based on the availability of global ordinals.\n+     *\n+     * The suppliers are responsible for any casting of {@link ValuesSource} that needs to happen.  They must accept a base\n+     * {@link ValuesSource} * instance.  The suppliers may perform additional logic to configure the aggregator as needed, such as in\n+     * {@link org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorFactory} deciding the execution mode.\n+     *\n+     * There is ongoing work to  normalize aggregator constructor signatures, and thus reduce the number of ComponentSupplier interfaces.\n+     */\n+    public interface ComponentSupplier {", "originalCommit": "bc5d8046692fc2f63d9f2ecca392fd115841d926", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da2a203edf75ead2e14c2975d0f9a02b8aa9f0ed", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java\nindex 39c91062b92..135208db6aa 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceRegistry.java\n\n@@ -31,34 +31,14 @@ import java.util.Map;\n import java.util.Objects;\n \n /**\n- * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to {@link ComponentSupplier}s.  DO NOT directly\n- * instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in the case\n- * of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n+ * {@link ValuesSourceRegistry} holds the mapping from {@link ValuesSourceType}s to functions for building aggregation components.  DO NOT\n+ * directly instantiate this class, instead get an already-configured copy from {@link QueryShardContext#getValuesSourceRegistry()}, or (in\n+ * the case of some test scenarios only) directly from {@link SearchModule#getValuesSourceRegistry()}\n  *\n  */\n public class ValuesSourceRegistry {\n \n-    /**\n-     * {@link ComponentSupplier} serves as a marker for what the {@link ValuesSourceRegistry} holds to construct aggregator instances.\n-     * The aggregators for each aggregation should all share a signature, and that signature should be used to create an ComponentSupplier\n-     * for that aggregation.  Alternatively, if an existing supplier has a matching signature, please re-use that.\n-     *\n-     * In many cases, this can be a simple wrapper over the aggregator constructor.  If that is sufficient, please just use a reference to\n-     * the constructor.  Implementing a supplier (typically as a lambda) should only be necessary when factors besides the\n-     * {@link ValuesSourceType} are necessary for selecting the correct aggregator implementation.  This happens in terms for example where\n-     * we make decisions based on the availability of global ordinals.\n-     *\n-     * The suppliers are responsible for any casting of {@link ValuesSource} that needs to happen.  They must accept a base\n-     * {@link ValuesSource} * instance.  The suppliers may perform additional logic to configure the aggregator as needed, such as in\n-     * {@link org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorFactory} deciding the execution mode.\n-     *\n-     * There is ongoing work to  normalize aggregator constructor signatures, and thus reduce the number of ComponentSupplier interfaces.\n-     */\n-    public interface ComponentSupplier {\n-        // this interface intentionally left blank\n-    }\n-\n-    public static final class RegistryKey<T extends ComponentSupplier> {\n+    public static final class RegistryKey<T> {\n         private final String name;\n         private final Class<T> supplierType;\n \n"}}, {"oid": "a7d77719c0ffdb902c6694804d5cd4d551cc6e29", "url": "https://github.com/elastic/elasticsearch/commit/a7d77719c0ffdb902c6694804d5cd4d551cc6e29", "message": "Fix usage tracking", "committedDate": "2020-08-11T14:04:24Z", "type": "commit"}, {"oid": "da2a203edf75ead2e14c2975d0f9a02b8aa9f0ed", "url": "https://github.com/elastic/elasticsearch/commit/da2a203edf75ead2e14c2975d0f9a02b8aa9f0ed", "message": "Remove dummy interface", "committedDate": "2020-08-11T14:15:08Z", "type": "commit"}, {"oid": "6aea16019dcd68a925fbbbe08eec263df3a37b41", "url": "https://github.com/elastic/elasticsearch/commit/6aea16019dcd68a925fbbbe08eec263df3a37b41", "message": "Merge composite and aggs registry", "committedDate": "2020-08-11T15:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyMDQxNw==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468720417", "bodyText": "Probably worth a comment about why this is ok.", "author": "nik9000", "createdAt": "2020-08-11T16:45:30Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java", "diffHunk": "@@ -79,6 +80,11 @@ public String getType() {\n         return NAME;\n     }\n \n+    @Override\n+    protected ValuesSourceRegistry.RegistryKey<?> getRegistryKey() {\n+        throw new UnsupportedOperationException();", "originalCommit": "a7d77719c0ffdb902c6694804d5cd4d551cc6e29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c4f73310b16adebed39aaae2f1d0a5c7fb8c28a4", "chunk": "diff --git a/client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java b/client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java\nindex b13e9978b23..15c86039595 100644\n--- a/client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java\n+++ b/client/rest-high-level/src/main/java/org/elasticsearch/client/analytics/StringStatsAggregationBuilder.java\n\n@@ -82,6 +82,7 @@ public class StringStatsAggregationBuilder extends ValuesSourceAggregationBuilde\n \n     @Override\n     protected ValuesSourceRegistry.RegistryKey<?> getRegistryKey() {\n+        // This would be called from the same thing that calls innerBuild, which also throws.  So it's \"safe\" to throw here.\n         throw new UnsupportedOperationException();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyNTU3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468725576", "bodyText": "I wonder if the factory should be registering the usage. Or if the builder should resolve the registry entry first and pass it down to the factory inside innerBuild.....", "author": "nik9000", "createdAt": "2020-08-11T16:53:49Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSourceAggregationBuilder.java", "diffHunk": "@@ -337,15 +337,21 @@ public ZoneId timeZone() {\n     protected final ValuesSourceAggregatorFactory doBuild(QueryShardContext queryShardContext, AggregatorFactory parent,\n                                                           Builder subFactoriesBuilder) throws IOException {\n         ValuesSourceConfig config = resolveConfig(queryShardContext);\n-        if (queryShardContext.getValuesSourceRegistry().isRegistered(getType())) {\n-            // Only test if the values source type is valid if the aggregation uses the registry\n-            AggregatorSupplier supplier = queryShardContext.getValuesSourceRegistry().getAggregator(config, getType());\n+        if (queryShardContext.getValuesSourceRegistry().isRegistered(getRegistryKey())) {\n+            /*\n+            if the aggregation uses the values source registry, test if the resolved values source type is compatible with this aggregation.\n+            This call will throw if the mapping isn't registered, which is what we want.  Note that we need to throw from here because\n+            AbstractAggregationBuilder#build, which called this, will attempt to register the agg usage next, and if the usage is invalid\n+            that will fail with a weird error.\n+             */\n+            queryShardContext.getValuesSourceRegistry().getAggregator(getRegistryKey(), config);", "originalCommit": "6aea16019dcd68a925fbbbe08eec263df3a37b41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NTE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/60852#discussion_r468785140", "bodyText": "Honestly, I'm not really sure why we don't build the aggregator directly here.  We have all the shard specific information at this point, and we've already parsed everything.  But it would be a huge change to do that, and I'm not ready to take it on today (or any time soon).  But longer term, I think it would make sense for the builder to just create an aggregator directly and not muck about with the factory layer.  In that spirit, I don't want to push more responsibility into the factory.\nAlso, this is a 1000+ line delta, I don't want to touch anything I don't strictly have to.", "author": "not-napoleon", "createdAt": "2020-08-11T18:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyNTU3Ng=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c4f73310b16adebed39aaae2f1d0a5c7fb8c28a4", "url": "https://github.com/elastic/elasticsearch/commit/c4f73310b16adebed39aaae2f1d0a5c7fb8c28a4", "message": "response to PR feedback", "committedDate": "2020-08-11T20:08:02Z", "type": "commit"}, {"oid": "17bab0ff0f3ab903b95c87ed2f4780d4caf52d25", "url": "https://github.com/elastic/elasticsearch/commit/17bab0ff0f3ab903b95c87ed2f4780d4caf52d25", "message": "Merge branch 'master' into vs-regsitry-type-magic", "committedDate": "2020-08-11T21:03:45Z", "type": "commit"}]}