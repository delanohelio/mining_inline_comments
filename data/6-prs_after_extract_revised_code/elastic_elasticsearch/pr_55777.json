{"pr_number": 55777, "pr_title": "More Efficient Blobstore Metdata IO", "pr_createdAt": "2020-04-26T21:23:03Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55777", "timeline": [{"oid": "bc0018544493400ac485cf36afcdf5e9dcaa68df", "url": "https://github.com/elastic/elasticsearch/commit/bc0018544493400ac485cf36afcdf5e9dcaa68df", "message": "More Efficient Blobstore Metdata Writing\n\nNo need to copy all these bytes multiple times, especially not when\nwriting a multiple MB global cluster state snapshot through this method.", "committedDate": "2020-04-26T21:19:16Z", "type": "commit"}, {"oid": "fa533c293580f5e61ce34957580e2abeabc165ed", "url": "https://github.com/elastic/elasticsearch/commit/fa533c293580f5e61ce34957580e2abeabc165ed", "message": "better read as well", "committedDate": "2020-04-26T22:01:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQxMTUxNA==", "url": "https://github.com/elastic/elasticsearch/pull/55777#discussion_r415411514", "bodyText": "ByteBuffersDataInput throws if passed an empty list of buffers so we need this special case handling to throw consistent exceptions when the checksum fails because a blob was truncated to empty for some reason.", "author": "original-brownbear", "createdAt": "2020-04-26T22:05:14Z", "path": "server/src/main/java/org/elasticsearch/repositories/blobstore/ChecksumBlobStoreFormat.java", "diffHunk": "@@ -127,8 +130,10 @@ public String blobName(String name) {\n     public T readBlob(BlobContainer blobContainer, String blobName) throws IOException {\n         final BytesReference bytes = Streams.readFully(blobContainer.readBlob(blobName));\n         final String resourceDesc = \"ChecksumBlobStoreFormat.readBlob(blob=\\\"\" + blobName + \"\\\")\";\n-        try (ByteArrayIndexInput indexInput =\n-                 new ByteArrayIndexInput(resourceDesc, BytesReference.toBytes(bytes))) {\n+        try {\n+            final IndexInput indexInput = bytes.length() > 0 ? new ByteBuffersIndexInput(\n+                    new ByteBuffersDataInput(Arrays.asList(BytesReference.toByteBuffers(bytes))), resourceDesc)\n+                    : new ByteArrayIndexInput(resourceDesc, BytesRef.EMPTY_BYTES);", "originalCommit": "fa533c293580f5e61ce34957580e2abeabc165ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}