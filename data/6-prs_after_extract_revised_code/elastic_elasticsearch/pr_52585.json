{"pr_number": 52585, "pr_title": "ILM: add searchable snapshot action", "pr_createdAt": "2020-02-20T17:46:10Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52585", "timeline": [{"oid": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "url": "https://github.com/elastic/elasticsearch/commit/25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "message": "ILM: add searchable snapshot action", "committedDate": "2020-02-20T17:42:16Z", "type": "commit"}, {"oid": "3c32490f4582fa9e7539e89994c3bc26074e72c5", "url": "https://github.com/elastic/elasticsearch/commit/3c32490f4582fa9e7539e89994c3bc26074e72c5", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-02-21T14:38:22Z", "type": "commit"}, {"oid": "7dbc46e72be3abf9b9683595e39725a2af72f802", "url": "https://github.com/elastic/elasticsearch/commit/7dbc46e72be3abf9b9683595e39725a2af72f802", "message": "Add license header", "committedDate": "2020-02-21T14:50:01Z", "type": "commit"}, {"oid": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "url": "https://github.com/elastic/elasticsearch/commit/9881c44a001bfbc7dad787d97b6d8d329eca3916", "message": "Document why we don\u2019t restore the lifecycle setting", "committedDate": "2020-02-21T15:10:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNDU0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382224540", "bodyText": "I'd suggest maybe cleanup-searchable-snapshot in case we ever have a different snapshot task :)", "author": "dakrone", "createdAt": "2020-02-20T19:55:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the snapshot name present in the lifecycle execution state, hosted in the configured repository.\n+ */\n+public class CleanupSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM1NzI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383357283", "bodyText": "I think leaving it as \"cleanup-snapshot\" makes sense as the step is agnostic of searchable snapshots. It issues a \"delete snapshot\" request for a particular repository and snapshot name (and in our use case we're using it to clean up the regular repository, not the searchable one)", "author": "andreidan", "createdAt": "2020-02-24T16:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNDU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\nindex 743c666c82a..66656eb8c79 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n\n@@ -13,6 +13,7 @@ import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n import org.elasticsearch.snapshots.SnapshotMissingException;\n \n import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382299788", "bodyText": "Should we also catch RepositoryMissingException and re-throw a more helpful message? What do you think?", "author": "dakrone", "createdAt": "2020-02-20T22:42:21Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the snapshot name present in the lifecycle execution state, hosted in the configured repository.\n+ */\n+public class CleanupSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\")\n+            );\n+            return;\n+        }\n+        DeleteSnapshotRequest deleteSnapshotRequest = new DeleteSnapshotRequest(snapshotRepository, snapshotName);\n+        getClient().admin().cluster().deleteSnapshot(deleteSnapshotRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n+                listener.onResponse(true);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                if (e instanceof SnapshotMissingException) {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MzA4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382673080", "bodyText": "Sure", "author": "andreidan", "createdAt": "2020-02-21T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\nindex 743c666c82a..66656eb8c79 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n\n@@ -13,6 +13,7 @@ import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n import org.elasticsearch.snapshots.SnapshotMissingException;\n \n import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382301326", "bodyText": "These need to be Objects.requireNonNull, currently it just returns true or false but doesn't throw an exception.", "author": "dakrone", "createdAt": "2020-02-20T22:46:06Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends AsyncActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey, client);\n+        Objects.nonNull(indexPrefix);\n+        Objects.nonNull(settingsKeys);", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3Mzc1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382673752", "bodyText": "Good catch (I hadn't even acknowledged the existence of an API that just does obj != null - TIL :) )", "author": "andreidan", "createdAt": "2020-02-21T16:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMTMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\nindex 0ae254f2b6f..618ba5ec6ab 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n\n@@ -30,8 +30,8 @@ public class CopySettingsStep extends AsyncActionStep {\n \n     public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n         super(key, nextStepKey, client);\n-        Objects.nonNull(indexPrefix);\n-        Objects.nonNull(settingsKeys);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n         this.indexPrefix = indexPrefix;\n         this.settingsKeys = settingsKeys;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMjI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382302266", "bodyText": "Currently we do this as an AsyncActionStep, but should we rather do this as a ClusterStateActionStep to avoid having to actually issue the request and wait for it? I believe it would be a bit better then, and it would also allow us to copy settings that may not be settable (if we need that functionality in the future)", "author": "dakrone", "createdAt": "2020-02-20T22:48:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends AsyncActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey, client);\n+        Objects.nonNull(indexPrefix);\n+        Objects.nonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentState, ClusterStateObserver observer, Listener listener) {\n+        String indexName = indexPrefix + indexMetaData.getIndex().getName();\n+\n+        Settings.Builder settings = Settings.builder();\n+        for (String key : settingsKeys) {\n+            String value = indexMetaData.getSettings().get(key);\n+            settings.put(key, value);\n+        }\n+\n+        UpdateSettingsRequest updateSettingsRequest = new UpdateSettingsRequest(indexName)", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382674742", "bodyText": "Oh interesting. I agree it'd be a better avenue", "author": "andreidan", "createdAt": "2020-02-21T16:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwMjI2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\nindex 0ae254f2b6f..618ba5ec6ab 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n\n@@ -30,8 +30,8 @@ public class CopySettingsStep extends AsyncActionStep {\n \n     public CopySettingsStep(StepKey key, StepKey nextStepKey, Client client, String indexPrefix, String... settingsKeys) {\n         super(key, nextStepKey, client);\n-        Objects.nonNull(indexPrefix);\n-        Objects.nonNull(settingsKeys);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n         this.indexPrefix = indexPrefix;\n         this.settingsKeys = settingsKeys;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382307808", "bodyText": "Why are we generating the snapshot name twice here?", "author": "dakrone", "createdAt": "2020-02-20T23:02:53Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(TakeSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotName = generateSnapshotName(generateSnapshotName(\"<{now/M}-\" + index.getName() + \"-\" + policy + \">\"));", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODIzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308237", "bodyText": "Also, do we think {now/M} is enough granularity? We could probably go with /d to be a bit more granular?", "author": "dakrone", "createdAt": "2020-02-20T23:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODcxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308716", "bodyText": "Also, this should use the same validation that SnapshotLifecyclePolicy.validate() does for validating things (for example, no # in the name). We should factor that validation out into a method and use it here.", "author": "dakrone", "createdAt": "2020-02-20T23:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\nindex 062d4f39777..ac6947679e6 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n\n@@ -7,11 +7,14 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.UUIDs;\n import org.elasticsearch.index.Index;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODkxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382308915", "bodyText": "We can make SnapshotLifecyclePolicy.generateSnapshotName static and use that instead I think?", "author": "dakrone", "createdAt": "2020-02-20T23:06:14Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(TakeSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotName = generateSnapshotName(generateSnapshotName(\"<{now/M}-\" + index.getName() + \"-\" + policy + \">\"));\n+        newCustomData.setSnapshotName(snapshotName);\n+\n+        IndexMetaData.Builder indexMetadataBuilder = IndexMetaData.builder(indexMetaData);\n+        indexMetadataBuilder.putCustom(ILM_CUSTOM_METADATA_KEY, newCustomData.build().asMap());\n+        newClusterStateBuilder.metaData(MetaData.builder(clusterState.getMetaData()).put(indexMetadataBuilder));\n+        return newClusterStateBuilder.build();\n+    }\n+\n+    /**\n+     * Since snapshots need to be uniquely named, this method will resolve any date math used in\n+     * the provided name, as well as appending a unique identifier so expressions that may overlap\n+     * still result in unique snapshot names.\n+     */\n+    public static String generateSnapshotName(String name) {\n+        return generateSnapshotName(name, new ResolverContext());\n+    }\n+\n+    public static String generateSnapshotName(String name, IndexNameExpressionResolver.Context context) {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNDM3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383414376", "bodyText": "I moved that snapshot generation method here (this is that essentially) as the line of dependency we have is SLM depends on ILM and I didn't want to make it circular.", "author": "andreidan", "createdAt": "2020-02-24T17:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\nindex 062d4f39777..ac6947679e6 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n\n@@ -7,11 +7,14 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.UUIDs;\n import org.elasticsearch.index.Index;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382309302", "bodyText": "Javadocs?", "author": "dakrone", "createdAt": "2020-02-20T23:07:13Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {", "originalCommit": "25cea2b5a66b66dd4caba5f29b8f1341490c4e7c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7075752601ee686fb756f412a1d5352152b80b5c", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\nindex 25d5e5c341f..4e7b01e46f6 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n\n@@ -15,34 +15,55 @@ import org.elasticsearch.common.xcontent.ToXContentObject;\n \n import java.util.Objects;\n \n+/**\n+ * This step changes its {@link #getNextStepKey()} depending on the result of an {@link AsyncWaitStep}.\n+ * <p>\n+ * The next step key will point towards the \"wait action fulfilled\" step when the condition of the async action is met, and towards the\n+ * \"wait action unfulfilled\" step when the client instructs they'd like to stop waiting for the condition using the\n+ * {@link BranchingStepListener#onStopWaitingForCondition(ToXContentObject)}.\n+ * <p>\n+ * If the async action that's branching the execution results in a failure, the {@link #getNextStepKey()} is not set (as ILM would move\n+ * into the {@link ErrorStep} step).\n+ */\n public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n     public static final String NAME = \"async-branch\";\n \n-    private StepKey nextStepKeyOnActionFailure;\n-    private StepKey nextStepKeyOnActionSuccess;\n-    private TriConsumer<Client, IndexMetaData, Listener> asyncWaitAction;\n+    private StepKey nextStepKeyUnfulfilledWaitAction;\n+    private StepKey nextStepKeyFulfilledWaitAction;\n+    private TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction;\n     private SetOnce<Boolean> onCompleteConditionMet;\n \n-    public OnAsyncWaitBranchingStep(StepKey key, StepKey nextStepKeyOnActionFailure, StepKey nextStepKeyOnActionSuccess,\n-                                    Client client, TriConsumer<Client, IndexMetaData, Listener> asyncWaitAction) {\n+    /**\n+     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n+     *\n+     * @param key                                the step's key\n+     * @param nextStepKeyUnfulfilledWaitAction the key of the step to run if the client decides to stop waiting for the condition to be\n+     *                                           via {@link BranchingStepListener#onStopWaitingForCondition(ToXContentObject)}\n+     * @param nextStepKeyFulfilledWaitAction   the key of the step to run if the {@link #asyncWaitAction} condition is met\n+     * @param asyncWaitAction                    the action to execute, would usually be similar to an instance of {@link AsyncWaitStep}\n+     *                                           but the user has the option to decide to stop waiting for the condition to be fulfilled\n+     */\n+    public OnAsyncWaitBranchingStep(StepKey key, StepKey nextStepKeyUnfulfilledWaitAction, StepKey nextStepKeyFulfilledWaitAction,\n+                                    Client client, TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction) {\n         // super.nextStepKey is set to null since it is not used by this step\n         super(key, null, client);\n-        this.nextStepKeyOnActionFailure = nextStepKeyOnActionFailure;\n-        this.nextStepKeyOnActionSuccess = nextStepKeyOnActionSuccess;\n+        this.nextStepKeyUnfulfilledWaitAction = nextStepKeyUnfulfilledWaitAction;\n+        this.nextStepKeyFulfilledWaitAction = nextStepKeyFulfilledWaitAction;\n         this.asyncWaitAction = asyncWaitAction;\n         this.onCompleteConditionMet = new SetOnce<>();\n     }\n \n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n     @Override\n     public void evaluateCondition(IndexMetaData indexMetaData, Listener listener, TimeValue masterTimeout) {\n-        asyncWaitAction.apply(getClient(), indexMetaData, new Listener() {\n+        asyncWaitAction.apply(getClient(), indexMetaData, new BranchingStepListener() {\n             @Override\n             public void onResponse(boolean conditionMet, ToXContentObject informationContext) {\n-                if (conditionMet) {\n-                    onCompleteConditionMet.set(true);\n-                } else {\n-                    onCompleteConditionMet.set(false);\n-                }\n+                onCompleteConditionMet.set(true);\n                 listener.onResponse(conditionMet, informationContext);\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzOTk3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382639978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"restore-snapshot\";\n          \n          \n            \n                public static final String NAME = \"restore-searchable-snapshot\";", "author": "dakrone", "createdAt": "2020-02-21T15:21:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class RestoreSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"restore-snapshot\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\nindex 898d279d226..5fd4ac295fb 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\n\n@@ -7,10 +7,8 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n-import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTQ2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382645466", "bodyText": "Should we do some special processing for an exception due to a snapshot or restore already being in progress?", "author": "dakrone", "createdAt": "2020-02-21T15:30:54Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class RestoreSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"restore-snapshot\";\n+\n+    private final String snapshotRepository;\n+    private final String restoredIndexPrefix;\n+\n+    public RestoreSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        RestoreSnapshotRequest restoreSnapshotRequest = new RestoreSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        restoreSnapshotRequest.waitForCompletion(false);\n+        restoreSnapshotRequest.indices(indexName);\n+        restoreSnapshotRequest.renamePattern(indexName);\n+        restoreSnapshotRequest.renameReplacement(restoredIndexPrefix + indexName);\n+        // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+        // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and, depending on what\n+        // ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in the ILM policy.\n+        // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+        restoreSnapshotRequest.ignoreIndexSettings(LifecycleSettings.LIFECYCLE_NAME);\n+        restoreSnapshotRequest.includeAliases(false);\n+\n+        getClient().admin().cluster().restoreSnapshot(restoreSnapshotRequest, new ActionListener<>() {\n+            @Override\n+            public void onResponse(RestoreSnapshotResponse response) {\n+                listener.onResponse(true);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NTUzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382675537", "bodyText": "I thought we'd retry using our usual retry mechanism. Might be good to report we encountered this better though", "author": "andreidan", "createdAt": "2020-02-21T16:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\nindex 898d279d226..5fd4ac295fb 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/RestoreSnapshotStep.java\n\n@@ -7,10 +7,8 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotRequest;\n-import org.elasticsearch.action.admin.cluster.snapshots.restore.RestoreSnapshotResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTcyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382645725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String NAME = \"searchable_snapshot\";\n          \n          \n            \n                public static final String NAME = \"searchable-snapshot\";", "author": "dakrone", "createdAt": "2020-02-21T15:31:19Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4ODM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401088360", "bodyText": "I think this one may have been lost in some of the other reviews, but I still think it should be changed (to searchable-snapshot)", "author": "dakrone", "createdAt": "2020-03-31T17:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NTcyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex 7caf2f62fda..e9a47e776a0 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -11,6 +11,7 @@ import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRe\n import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382647252", "bodyText": "We might want to discuss what we want the prefix to be, I'm not sure about \"ilm-restored-\" in case we ever have a different (non-searchable) ILM action to restore a snapshot, what do you think?", "author": "dakrone", "createdAt": "2020-02-21T15:33:50Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382677266", "bodyText": "Hm, I'm not sure I understand what you mean. The intention was to keep it \"searchable snapshot\" independent, which it is now. Do you have something specific in mind? (and this is also configurable in the RestoreSnapshotStep, in case we reuse it with regulard snapshot restores)", "author": "andreidan", "createdAt": "2020-02-21T16:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NDA4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382684089", "bodyText": "What about restored-? I think that fits a little more with our shrink- prefix", "author": "dakrone", "createdAt": "2020-02-21T16:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex 7caf2f62fda..e9a47e776a0 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -11,6 +11,7 @@ import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRe\n import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTM5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382649395", "bodyText": "Can you add javadocs to this method?", "author": "dakrone", "createdAt": "2020-02-21T15:37:40Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0], (String) a[1]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SEARCHABLE_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+    private final String searchableRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository, String searchableRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        if (Strings.hasText(searchableRepository) == false) {\n+            throw new IllegalArgumentException(\"the searchable repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+        this.searchableRepository = searchableRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString(), in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey takeSnapshotKey = new StepKey(phase, NAME, TakeSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey restoreFromSearchableRepoKey = new StepKey(phase, NAME, RestoreSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForGreenIndexHealthStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, takeSnapshotKey, client, snapshotRepository);\n+        TakeSnapshotStep takeSnapshotStep = new TakeSnapshotStep(takeSnapshotKey, waitForSnapshotInProgressKey, client, snapshotRepository);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey, snapshotRepository);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, restoreFromSearchableRepoKey, client, getCheckSnapshotStatusAsyncAction(snapshotRepository));\n+        RestoreSnapshotStep restoreSnapshotStep = new RestoreSnapshotStep(restoreFromSearchableRepoKey, waitForGreenRestoredIndexKey,\n+            client, searchableRepository, RESTORED_INDEX_PREFIX);\n+        WaitForGreenIndexHealthStep waitForGreenIndexHealthStep = new WaitForGreenIndexHealthStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey.getName());\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, client,\n+            RESTORED_INDEX_PREFIX, LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, takeSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, restoreSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    private TriConsumer<Client, IndexMetaData, AsyncWaitStep.Listener> getCheckSnapshotStatusAsyncAction(String snapshotRepository) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTkyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382649929", "bodyText": "And maybe this can be static? We could pass in the names of things, might make it easier to test?", "author": "dakrone", "createdAt": "2020-02-21T15:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0OTM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex 7caf2f62fda..e9a47e776a0 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -11,6 +11,7 @@ import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRe\n import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MDUyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382650523", "bodyText": "Can you capture the snapshotState in this message also?", "author": "dakrone", "createdAt": "2020-02-21T15:39:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.snapshots.SnapshotException;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable_snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n+    public static final ParseField SEARCHABLE_REPOSITORY = new ParseField(\"searchable_repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"ilm-restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0], (String) a[1]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SEARCHABLE_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+    private final String searchableRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository, String searchableRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        if (Strings.hasText(searchableRepository) == false) {\n+            throw new IllegalArgumentException(\"the searchable repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+        this.searchableRepository = searchableRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString(), in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey takeSnapshotKey = new StepKey(phase, NAME, TakeSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey restoreFromSearchableRepoKey = new StepKey(phase, NAME, RestoreSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForGreenIndexHealthStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, takeSnapshotKey, client, snapshotRepository);\n+        TakeSnapshotStep takeSnapshotStep = new TakeSnapshotStep(takeSnapshotKey, waitForSnapshotInProgressKey, client, snapshotRepository);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey, snapshotRepository);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, restoreFromSearchableRepoKey, client, getCheckSnapshotStatusAsyncAction(snapshotRepository));\n+        RestoreSnapshotStep restoreSnapshotStep = new RestoreSnapshotStep(restoreFromSearchableRepoKey, waitForGreenRestoredIndexKey,\n+            client, searchableRepository, RESTORED_INDEX_PREFIX);\n+        WaitForGreenIndexHealthStep waitForGreenIndexHealthStep = new WaitForGreenIndexHealthStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey.getName());\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, client,\n+            RESTORED_INDEX_PREFIX, LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, takeSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, restoreSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    private TriConsumer<Client, IndexMetaData, AsyncWaitStep.Listener> getCheckSnapshotStatusAsyncAction(String snapshotRepository) {\n+        return (client, indexMetaData, listener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            if (Strings.hasText(snapshotName) == false) {\n+                listener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index \" +\n+                    \"[\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(snapshotRepository, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        listener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        listener.onFailure(new SnapshotException(snapshotStatus.getSnapshot(),\n+                            \"unable to create snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" +\n+                                policyName + \"] execution\"));", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex 7caf2f62fda..e9a47e776a0 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -11,6 +11,7 @@ import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRe\n import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NTk1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382655951", "bodyText": "I think we could probably switch this to just \"swap-aliases\"", "author": "dakrone", "createdAt": "2020-02-21T15:48:25Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 828d04abef4..d64305492a9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -24,7 +24,7 @@ import java.util.Locale;\n  */\n public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n     public static final String NAME = \"swap-aliases-to-restored\";\n-    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n \n     private final String restoredIndexPrefix;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382657305", "bodyText": "There's a comment above this about inheriting everything except for the writeIndex, but this looks like we're inheriting the write index setting?", "author": "dakrone", "createdAt": "2020-02-21T15:50:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjM5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383322390", "bodyText": "Ah, yes, I'm planning to refactor this into one component and reuse it in ShrinkSetAliasStep. It's not clear to me why we wouldn't want to inherit the write index (as we're deleting the original index in this one update). Do you know why we're skipping it in the shrink case?", "author": "andreidan", "createdAt": "2020-02-24T15:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxMDgyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r383410823", "bodyText": "I don't think it's for a purposeful reason (at least I can't remember it being intentional)", "author": "dakrone", "createdAt": "2020-02-24T17:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NzMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 828d04abef4..d64305492a9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -24,7 +24,7 @@ import java.util.Locale;\n  */\n public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n     public static final String NAME = \"swap-aliases-to-restored\";\n-    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n \n     private final String restoredIndexPrefix;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODI3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658275", "bodyText": "If you want, in the future, you can use ActionListener.wrap(resp -> listener.onResponse(true), listener::onFailure) I believe, rather than a new anonymous class", "author": "dakrone", "createdAt": "2020-02-21T15:52:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));\n+        });\n+\n+        getClient().admin().indices().aliases(aliasesRequest, new ActionListener<>() {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 828d04abef4..d64305492a9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -24,7 +24,7 @@ import java.util.Locale;\n  */\n public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n     public static final String NAME = \"swap-aliases-to-restored\";\n-    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n \n     private final String restoredIndexPrefix;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658484", "bodyText": "We should check that the request was actually acknowledged and throw an exception if it wasn't so that it can be retried", "author": "dakrone", "createdAt": "2020-02-21T15:52:51Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Following a restore from snapshot operation this swaps all the aliases from the source index to the restored index and delete the\n+ * source index.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases-to-restored\";\n+    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String restoredIndexName = restoredIndexPrefix + originalIndex;\n+        IndexMetaData restoredIndexMetaData = currentClusterState.metaData().index(restoredIndexName);\n+\n+        if (restoredIndexMetaData == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"restored index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", restoredIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        // TODO extract and reuse - also see {@link org.elasticsearch.xpack.core.ilm.ShrinkSetAliasStep}\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(getMasterTimeout(currentClusterState))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(originalIndex))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(restoredIndexName).alias(originalIndex));\n+        indexMetaData.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(restoredIndexName).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(aliasMetaDataToAdd.writeIndex()));\n+        });\n+\n+        getClient().admin().indices().aliases(aliasesRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse response) {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 828d04abef4..d64305492a9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -24,7 +24,7 @@ import java.util.Locale;\n  */\n public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n     public static final String NAME = \"swap-aliases-to-restored\";\n-    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n \n     private final String restoredIndexPrefix;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1ODg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382658846", "bodyText": "I think a better name might be CreateSnapshotStep", "author": "dakrone", "createdAt": "2020-02-21T15:53:28Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nsimilarity index 58%\nrename from x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\nrename to x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nindex 5930ebf243b..5182c698f61 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\n\n@@ -7,21 +7,21 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n-import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.snapshots.SnapshotException;\n \n import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n \n-public class TakeSnapshotStep extends AsyncActionStep {\n-    public static final String NAME = \"take-snapshot\";\n+public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"create-snapshot\";\n \n     private final String snapshotRepository;\n \n-    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+    public CreateSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n         super(key, nextStepKey, client);\n         this.snapshotRepository = snapshotRepository;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1OTUzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382659535", "bodyText": "I don't think we should expose this (meaning to hardcode it as false like you have), these are specific snapshots used only for searchable snapshots", "author": "dakrone", "createdAt": "2020-02-21T15:54:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"take-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        // TODO should we expose this?\n+        request.includeGlobalState(false);", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nsimilarity index 58%\nrename from x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\nrename to x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nindex 5930ebf243b..5182c698f61 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\n\n@@ -7,21 +7,21 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n-import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.snapshots.SnapshotException;\n \n import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n \n-public class TakeSnapshotStep extends AsyncActionStep {\n-    public static final String NAME = \"take-snapshot\";\n+public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"create-snapshot\";\n \n     private final String snapshotRepository;\n \n-    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+    public CreateSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n         super(key, nextStepKey, client);\n         this.snapshotRepository = snapshotRepository;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDY0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382660645", "bodyText": "We should probably check the status() of the response, it's possible it could be a failure in which case I think we could retry again immediately?", "author": "dakrone", "createdAt": "2020-02-21T15:56:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+public class TakeSnapshotStep extends AsyncActionStep {\n+    public static final String NAME = \"take-snapshot\";\n+\n+    private final String snapshotRepository;\n+\n+    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+        super(key, nextStepKey, client);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        // TODO should we expose this?\n+        request.includeGlobalState(false);\n+        getClient().admin().cluster().createSnapshot(request, new ActionListener<>() {\n+            @Override\n+            public void onResponse(CreateSnapshotResponse createSnapshotResponse) {\n+                listener.onResponse(true);", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "271fb540ae23cea9f781dba7c4b4a793814457d4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nsimilarity index 58%\nrename from x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\nrename to x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nindex 5930ebf243b..5182c698f61 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TakeSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\n\n@@ -7,21 +7,21 @@ package org.elasticsearch.xpack.core.ilm;\n \n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n-import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotResponse;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.ClusterStateObserver;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.snapshots.SnapshotException;\n \n import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n \n-public class TakeSnapshotStep extends AsyncActionStep {\n-    public static final String NAME = \"take-snapshot\";\n+public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"create-snapshot\";\n \n     private final String snapshotRepository;\n \n-    public TakeSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n+    public CreateSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String snapshotRepository) {\n         super(key, nextStepKey, client);\n         this.snapshotRepository = snapshotRepository;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTYwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382661608", "bodyText": "I think we could refactor the users of this class to use WaitForIndexColorStep and then we wouldn't need to add this class", "author": "dakrone", "createdAt": "2020-02-21T15:57:53Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForGreenIndexHealthStep.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.health.ClusterIndexHealth;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Optionally derives the index name using the provided prefix (if any) and waits for the status of the index to be GREEN.\n+ */\n+public class WaitForGreenIndexHealthStep extends ClusterStateWaitStep {", "originalCommit": "9881c44a001bfbc7dad787d97b6d8d329eca3916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzY3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r382677673", "bodyText": "Totally, thanks for the tip. I didn't know of its existence", "author": "andreidan", "createdAt": "2020-02-21T16:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForGreenIndexHealthStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForGreenIndexHealthStep.java\ndeleted file mode 100644\nindex 838dc586129..00000000000\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForGreenIndexHealthStep.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-package org.elasticsearch.xpack.core.ilm;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.health.ClusterHealthStatus;\n-import org.elasticsearch.cluster.health.ClusterIndexHealth;\n-import org.elasticsearch.cluster.metadata.IndexMetaData;\n-import org.elasticsearch.cluster.routing.IndexRoutingTable;\n-import org.elasticsearch.common.Nullable;\n-import org.elasticsearch.common.ParseField;\n-import org.elasticsearch.common.xcontent.ToXContentObject;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.index.Index;\n-\n-import java.io.IOException;\n-import java.util.Locale;\n-import java.util.Objects;\n-\n-/**\n- * Optionally derives the index name using the provided prefix (if any) and waits for the status of the index to be GREEN.\n- */\n-public class WaitForGreenIndexHealthStep extends ClusterStateWaitStep {\n-\n-    public static final String NAME = \"wait-for-green-health\";\n-    private static final Logger logger = LogManager.getLogger(WaitForGreenIndexHealthStep.class);\n-\n-    private final String indexNamePrefix;\n-\n-    WaitForGreenIndexHealthStep(StepKey key, StepKey nextStepKey, @Nullable String indexNamePrefix) {\n-        super(key, nextStepKey);\n-        this.indexNamePrefix = indexNamePrefix;\n-    }\n-\n-    @Override\n-    public boolean isRetryable() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Result isConditionMet(Index index, ClusterState clusterState) {\n-        String indexName = indexNamePrefix != null ? indexNamePrefix + index.getName() : index.getName();\n-        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n-\n-        if (indexMetaData == null) {\n-            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n-                getKey().getAction(), indexName);\n-            // Index must have been since deleted\n-            logger.debug(errorMessage);\n-            return new Result(false, new Info(errorMessage));\n-        }\n-\n-        IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(indexMetaData.getIndex());\n-        if (indexRoutingTable == null) {\n-            return new Result(false, new Info(\"routing table not available for index [\" + indexName + \"]\"));\n-        }\n-\n-        ClusterIndexHealth indexHealth = new ClusterIndexHealth(indexMetaData, indexRoutingTable);\n-        if (indexHealth.getStatus() == ClusterHealthStatus.GREEN) {\n-            return new Result(true, null);\n-        } else {\n-            return new Result(false, new Info(\"status for index [\" + indexName + \"] is [\" + indexHealth.getStatus() + \"]\"));\n-        }\n-    }\n-\n-    static final class Info implements ToXContentObject {\n-\n-        private final String message;\n-\n-        static final ParseField MESSAGE = new ParseField(\"message\");\n-\n-        Info(String message) {\n-            this.message = message;\n-        }\n-\n-        @Override\n-        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n-            builder.startObject();\n-            builder.field(MESSAGE.getPreferredName(), message);\n-            builder.endObject();\n-            return builder;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (o == null || getClass() != o.getClass()) {\n-                return false;\n-            }\n-            Info info = (Info) o;\n-            return Objects.equals(message, info.message);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(message);\n-        }\n-    }\n-}\n"}}, {"oid": "a601dbf0383d7405411deafa412e8535035fc524", "url": "https://github.com/elastic/elasticsearch/commit/a601dbf0383d7405411deafa412e8535035fc524", "message": "Checkstyle", "committedDate": "2020-02-21T16:03:45Z", "type": "commit"}, {"oid": "f0a9da15368e3556022123d97a21060613734249", "url": "https://github.com/elastic/elasticsearch/commit/f0a9da15368e3556022123d97a21060613734249", "message": "Remove unused import", "committedDate": "2020-02-21T16:14:35Z", "type": "commit"}, {"oid": "dfec7c9344f703f83358c9f0e28f6cace9121a36", "url": "https://github.com/elastic/elasticsearch/commit/dfec7c9344f703f83358c9f0e28f6cace9121a36", "message": "Use WaitForIndexColorStep", "committedDate": "2020-02-24T16:04:03Z", "type": "commit"}, {"oid": "a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "url": "https://github.com/elastic/elasticsearch/commit/a6bc720e4b8b023a83bd765c1933f2e932a1d6d0", "message": "Use requireNonNull", "committedDate": "2020-02-24T16:04:13Z", "type": "commit"}, {"oid": "271fb540ae23cea9f781dba7c4b4a793814457d4", "url": "https://github.com/elastic/elasticsearch/commit/271fb540ae23cea9f781dba7c4b4a793814457d4", "message": "Refactorings and cleanups\n\n- renamed TakeSnapshotStep to CreateSnapshotStep\n- made the Create and RestoreSnapshotStep retry-able using the\nAsyncRetryDuringSnapshotActionStep infrastructure\n- CreateSnapshotStep checks the response status for internal server\nerror and fails the step in this case so we retry before we go to the\nnext steps that\u2019ll discover the snapshot was not created successfully\n- CleanupSnapshotStep reports missing repository in a more detailed way\n- CopySettingsStep copies the settings using the cluster state directly\n- GenerateSnapshotNameStep validates the snapshot name", "committedDate": "2020-02-25T17:48:06Z", "type": "commit"}, {"oid": "f6f7d29ff05d9e6ddb873f773a674f4ed2430a23", "url": "https://github.com/elastic/elasticsearch/commit/f6f7d29ff05d9e6ddb873f773a674f4ed2430a23", "message": "Make performAction final in AsyncRetryDuringSnapshotActionStep", "committedDate": "2020-02-25T17:48:06Z", "type": "commit"}, {"oid": "7075752601ee686fb756f412a1d5352152b80b5c", "url": "https://github.com/elastic/elasticsearch/commit/7075752601ee686fb756f412a1d5352152b80b5c", "message": "Add docs and redesign OnAsyncWaitBranchingStep\n\nThis redesign is meant to allow the client to specify that\nit wants to stop waiting and move to the \u201ccondition unfulfilled\u201d\nside of the branch.", "committedDate": "2020-02-26T17:23:53Z", "type": "commit"}, {"oid": "501dbaf02af9ddb40fc50c842ef423e9ceb04c2b", "url": "https://github.com/elastic/elasticsearch/commit/501dbaf02af9ddb40fc50c842ef423e9ceb04c2b", "message": "Rename BranchingStepListener onStopWaitingForCondition", "committedDate": "2020-02-27T20:25:26Z", "type": "commit"}, {"oid": "12229022b4ccbd970f54e177f07c9f775550059b", "url": "https://github.com/elastic/elasticsearch/commit/12229022b4ccbd970f54e177f07c9f775550059b", "message": "Extract and reuse the alias swap request", "committedDate": "2020-02-28T16:28:37Z", "type": "commit"}, {"oid": "faa2834adfa9b83de8925580fbf512f0b0f42ef8", "url": "https://github.com/elastic/elasticsearch/commit/faa2834adfa9b83de8925580fbf512f0b0f42ef8", "message": "Rename restoredIndexPrefix to targetIndexPrefix", "committedDate": "2020-03-02T10:19:00Z", "type": "commit"}, {"oid": "21d67cbf95514abd05f485d167bc07bdebe9005c", "url": "https://github.com/elastic/elasticsearch/commit/21d67cbf95514abd05f485d167bc07bdebe9005c", "message": "Fix tests", "committedDate": "2020-03-02T11:40:04Z", "type": "commit"}, {"oid": "7e0d5f7cecbcc377d9f3f60f55f4e1fcced43f09", "url": "https://github.com/elastic/elasticsearch/commit/7e0d5f7cecbcc377d9f3f60f55f4e1fcced43f09", "message": "Unused imports", "committedDate": "2020-03-02T11:52:16Z", "type": "commit"}, {"oid": "eafe3dea75c1f7304053a91ad54dcd12461f9b8e", "url": "https://github.com/elastic/elasticsearch/commit/eafe3dea75c1f7304053a91ad54dcd12461f9b8e", "message": "Handle null next step key", "committedDate": "2020-03-02T14:36:45Z", "type": "commit"}, {"oid": "bc91ae30a834878653b4dae73fa739bb97691621", "url": "https://github.com/elastic/elasticsearch/commit/bc91ae30a834878653b4dae73fa739bb97691621", "message": "Try with resources in test", "committedDate": "2020-03-02T15:47:30Z", "type": "commit"}, {"oid": "8520c7b11e48b9e5a5334906ebd5205ef19aaa83", "url": "https://github.com/elastic/elasticsearch/commit/8520c7b11e48b9e5a5334906ebd5205ef19aaa83", "message": "Rename originalIndex to sourceIndexName", "committedDate": "2020-03-02T16:10:27Z", "type": "commit"}, {"oid": "97356491a44242f0aed51c121bb7de87e8a492eb", "url": "https://github.com/elastic/elasticsearch/commit/97356491a44242f0aed51c121bb7de87e8a492eb", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-02T16:18:52Z", "type": "commit"}, {"oid": "d20cf52179651b72f7d23a7cc0572751bd46ce89", "url": "https://github.com/elastic/elasticsearch/commit/d20cf52179651b72f7d23a7cc0572751bd46ce89", "message": "More tests", "committedDate": "2020-03-02T17:58:55Z", "type": "commit"}, {"oid": "8a46d05f061479ddd3985e1696cae3ee47f646af", "url": "https://github.com/elastic/elasticsearch/commit/8a46d05f061479ddd3985e1696cae3ee47f646af", "message": "Add more steps tests", "committedDate": "2020-03-03T17:32:28Z", "type": "commit"}, {"oid": "12c1f5f9f174ee1f2f6969951e95d13f50f7f621", "url": "https://github.com/elastic/elasticsearch/commit/12c1f5f9f174ee1f2f6969951e95d13f50f7f621", "message": "Make method static", "committedDate": "2020-03-03T17:32:45Z", "type": "commit"}, {"oid": "3870388cf75a4f69469730dbc7ef86e633e2c9a5", "url": "https://github.com/elastic/elasticsearch/commit/3870388cf75a4f69469730dbc7ef86e633e2c9a5", "message": "Don\u2019t fail if the response isAck flag is false\n\nWe\u2019re deleting the original index as part of the alias swap so a\nretry of this step after the cluster state change has been committed\nwill fail", "committedDate": "2020-03-03T17:41:35Z", "type": "commit"}, {"oid": "d28557cde757850d0d1ccb26a2a9f28be20c5325", "url": "https://github.com/elastic/elasticsearch/commit/d28557cde757850d0d1ccb26a2a9f28be20c5325", "message": "Searchable action tests and more step tests", "committedDate": "2020-03-04T18:26:45Z", "type": "commit"}, {"oid": "357987be860954f2a61f8f77978bdc48f1a2c24e", "url": "https://github.com/elastic/elasticsearch/commit/357987be860954f2a61f8f77978bdc48f1a2c24e", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-04T18:27:42Z", "type": "commit"}, {"oid": "6960187cd4ad71d6dcf07c43b04fdfdd5790e41f", "url": "https://github.com/elastic/elasticsearch/commit/6960187cd4ad71d6dcf07c43b04fdfdd5790e41f", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-05T09:24:31Z", "type": "commit"}, {"oid": "9af943fab59b667e1a4c5d665b8bfb56ac0c0067", "url": "https://github.com/elastic/elasticsearch/commit/9af943fab59b667e1a4c5d665b8bfb56ac0c0067", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-06T15:09:18Z", "type": "commit"}, {"oid": "858e6a120a3ea037fef75049f7d3ffdcc6ab1b95", "url": "https://github.com/elastic/elasticsearch/commit/858e6a120a3ea037fef75049f7d3ffdcc6ab1b95", "message": "Store the snapshot name in the ILM execution state", "committedDate": "2020-03-06T15:09:31Z", "type": "commit"}, {"oid": "6edfcd09ea2c3b03fb90c6a60219e2163d5c9cab", "url": "https://github.com/elastic/elasticsearch/commit/6edfcd09ea2c3b03fb90c6a60219e2163d5c9cab", "message": "Remove import", "committedDate": "2020-03-06T15:32:18Z", "type": "commit"}, {"oid": "e4791b0176f446ea330ed9dd5f50e6c4ea4148dc", "url": "https://github.com/elastic/elasticsearch/commit/e4791b0176f446ea330ed9dd5f50e6c4ea4148dc", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-06T16:27:35Z", "type": "commit"}, {"oid": "63194eaca2a2028048408c4d73a5b3dff664b8b3", "url": "https://github.com/elastic/elasticsearch/commit/63194eaca2a2028048408c4d73a5b3dff664b8b3", "message": "Copy the repository and snapshot name", "committedDate": "2020-03-10T10:31:59Z", "type": "commit"}, {"oid": "a92463ffffc5370feb75b2ab2f887ca393347117", "url": "https://github.com/elastic/elasticsearch/commit/a92463ffffc5370feb75b2ab2f887ca393347117", "message": "Expose repo and snapshot name in the ILM explain response", "committedDate": "2020-03-10T10:32:39Z", "type": "commit"}, {"oid": "0f65ed7c891b97aa21678f788d7e0a89cc2c5fc1", "url": "https://github.com/elastic/elasticsearch/commit/0f65ed7c891b97aa21678f788d7e0a89cc2c5fc1", "message": "Explain lifecycle repo and snapshot in transport", "committedDate": "2020-03-10T10:44:30Z", "type": "commit"}, {"oid": "6e779b6d9b32279c76d1ebaf90bccd5d3f8d0f26", "url": "https://github.com/elastic/elasticsearch/commit/6e779b6d9b32279c76d1ebaf90bccd5d3f8d0f26", "message": "Delete action has an optional parameter delege_generated_snapshot\n\nThe parameter defaults to true but the users can configure the delete\naction to keep the snapshot they generated in the cold phase", "committedDate": "2020-03-10T11:11:22Z", "type": "commit"}, {"oid": "841f6bc6c4b050f72c0ec44421ea0bc3788803d9", "url": "https://github.com/elastic/elasticsearch/commit/841f6bc6c4b050f72c0ec44421ea0bc3788803d9", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-10T13:42:29Z", "type": "commit"}, {"oid": "da361b53ce1454a0b6116e49046d4ccf4a36af69", "url": "https://github.com/elastic/elasticsearch/commit/da361b53ce1454a0b6116e49046d4ccf4a36af69", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-11T11:51:20Z", "type": "commit"}, {"oid": "5eb524e7cb9ca567187922c2dc1bbfef5adeb87b", "url": "https://github.com/elastic/elasticsearch/commit/5eb524e7cb9ca567187922c2dc1bbfef5adeb87b", "message": "Drop the searchable repository action param", "committedDate": "2020-03-11T12:37:31Z", "type": "commit"}, {"oid": "8e8ff991dfc67ddccc8030bafe0ea8f91eeab32f", "url": "https://github.com/elastic/elasticsearch/commit/8e8ff991dfc67ddccc8030bafe0ea8f91eeab32f", "message": "Drop sys.out.println", "committedDate": "2020-03-11T14:10:30Z", "type": "commit"}, {"oid": "119c4394305056312146cbb16b2e6b5fcd49068d", "url": "https://github.com/elastic/elasticsearch/commit/119c4394305056312146cbb16b2e6b5fcd49068d", "message": "Fix docs tests", "committedDate": "2020-03-11T14:39:54Z", "type": "commit"}, {"oid": "064b4e7a27c361941fb6e0029f601debd863d61c", "url": "https://github.com/elastic/elasticsearch/commit/064b4e7a27c361941fb6e0029f601debd863d61c", "message": "BWC for DeleteAction delete generated snap flag", "committedDate": "2020-03-11T18:03:06Z", "type": "commit"}, {"oid": "1cb648098d2e7ea76987b90223d35b0bdb8225d0", "url": "https://github.com/elastic/elasticsearch/commit/1cb648098d2e7ea76987b90223d35b0bdb8225d0", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-11T19:11:57Z", "type": "commit"}, {"oid": "3a750e06c1aa2fc58851a30c4a9cf162526f11cd", "url": "https://github.com/elastic/elasticsearch/commit/3a750e06c1aa2fc58851a30c4a9cf162526f11cd", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-12T10:50:55Z", "type": "commit"}, {"oid": "0a797533739490be2395ecd6b15d3a9a87abb8f7", "url": "https://github.com/elastic/elasticsearch/commit/0a797533739490be2395ecd6b15d3a9a87abb8f7", "message": "Update settings version when copying settings", "committedDate": "2020-03-12T16:59:35Z", "type": "commit"}, {"oid": "013d4dfb800771d1c71af7920895b10095b8db54", "url": "https://github.com/elastic/elasticsearch/commit/013d4dfb800771d1c71af7920895b10095b8db54", "message": "Add test that deletes the snapshot", "committedDate": "2020-03-12T16:59:35Z", "type": "commit"}, {"oid": "aa098d27c2ecf655143dc5acf2362c369a9a51fb", "url": "https://github.com/elastic/elasticsearch/commit/aa098d27c2ecf655143dc5acf2362c369a9a51fb", "message": "Document step", "committedDate": "2020-03-12T16:59:36Z", "type": "commit"}, {"oid": "520d6bb95d77468b5303496a1336c4421ed7d86c", "url": "https://github.com/elastic/elasticsearch/commit/520d6bb95d77468b5303496a1336c4421ed7d86c", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-12T17:18:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MzkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393353939", "bodyText": "Suuuper minor:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                          ClusterStateObserver observer, Listener listener) {\n          \n          \n            \n                                                ClusterStateObserver observer, Listener listener) {", "author": "dakrone", "createdAt": "2020-03-16T22:54:49Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java", "diffHunk": "@@ -33,7 +33,7 @@ public AsyncRetryDuringSnapshotActionStep(StepKey key, StepKey nextStepKey, Clie\n     }\n \n     @Override\n-    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,\n+    public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,\n                               ClusterStateObserver observer, Listener listener) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "32e3371870bfe0a8ff2517f338f62792225d64fb", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java\nindex 24392d7e5ff..fc2b3e6e338 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/AsyncRetryDuringSnapshotActionStep.java\n\n@@ -34,7 +34,7 @@ public abstract class AsyncRetryDuringSnapshotActionStep extends AsyncActionStep\n \n     @Override\n     public final void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState,\n-                              ClusterStateObserver observer, Listener listener) {\n+                                    ClusterStateObserver observer, Listener listener) {\n         // Wrap the original listener to handle exceptions caused by ongoing snapshots\n         SnapshotExceptionListener snapshotExceptionListener = new SnapshotExceptionListener(indexMetaData.getIndex(), listener, observer);\n         performDuringNoSnapshot(indexMetaData, currentClusterState, snapshotExceptionListener);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1NDI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393354278", "bodyText": "Can you add a comment for future viewers for why this is not retryable? I already can't remember why it's not retryable :X", "author": "dakrone", "createdAt": "2020-03-16T22:55:47Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the repository and snapshot name present in the lifecycle execution state.\n+ */\n+public class CleanupSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return false;", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyNjcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397326729", "bodyText": "I was thinking since we're retrying using the AsyncRetryDuringSnapshotActionStep we might not want to make the steps retryable as well, but on second thought I think we should (as we would indeed want to retry on rest api call failures for eg). I'll swap this to true.", "author": "andreidan", "createdAt": "2020-03-24T17:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1NDI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "ac9e9c3c18c8c39aab98b2ca79bb4d9e71168c28", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\nindex ea1521deacb..9ead34f5c21 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n\n@@ -29,7 +29,7 @@ public class CleanupSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n \n     @Override\n     public boolean isRetryable() {\n-        return false;\n+        return true;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MDUwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393360505", "bodyText": "Another really minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(settingsKeys == null || settingsKeys.length == 0) {\n          \n          \n            \n                    if (settingsKeys == null || settingsKeys.length == 0) {", "author": "dakrone", "createdAt": "2020-03-16T23:07:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends ClusterStateActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private static final Logger logger = LogManager.getLogger(CopySettingsStep.class);\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String[] getSettingsKeys() {\n+        return settingsKeys;\n+    }\n+\n+    public String getIndexPrefix() {\n+        return indexPrefix;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        String sourceIndexName = index.getName();\n+        IndexMetaData sourceIndexMetadata = clusterState.metaData().index(sourceIndexName);\n+        String targetIndexName = indexPrefix + sourceIndexName;\n+        IndexMetaData targetIndexMetadata = clusterState.metaData().index(targetIndexName);\n+\n+        if (sourceIndexMetadata == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), sourceIndexName);\n+            return clusterState;\n+        }\n+\n+        if (targetIndexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"index [%s] is being referenced by ILM action [%s] on step [%s] but \" +\n+                \"it doesn't exist\", targetIndexName, getKey().getAction(), getKey().getName());\n+            logger.debug(errorMessage);\n+            throw new IllegalStateException(errorMessage);\n+        }\n+\n+        if(settingsKeys == null || settingsKeys.length == 0) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "374e50d9c557ce31c51ba998382db2ad7ebc6027", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\nindex 879ae81314a..cfbe1a6cc06 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n\n@@ -72,7 +72,7 @@ public class CopySettingsStep extends ClusterStateActionStep {\n             throw new IllegalStateException(errorMessage);\n         }\n \n-        if(settingsKeys == null || settingsKeys.length == 0) {\n+        if (settingsKeys == null || settingsKeys.length == 0) {\n             return clusterState;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTI5Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393361292", "bodyText": "I believe this needs to configure the request to only snapshot this particular index, currently this is snapshotting all indices in the cluster", "author": "dakrone", "createdAt": "2020-03-16T23:10:32Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.snapshots.SnapshotException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Creates a snapshot of the managed index into the configured repository and snapshot name. The repository and snapshot names are expected\n+ * to be present in the lifecycle execution state (usually generated and stored by a different ILM step)\n+ */\n+public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"create-snapshot\";\n+\n+    public CreateSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        final LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        final String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+        CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n+        // expensive operations (ie. clusterStateProcessed)\n+        request.waitForCompletion(false);\n+        request.includeGlobalState(false);\n+        request.masterNodeTimeout(getMasterTimeout(currentClusterState));\n+        getClient().admin().cluster().createSnapshot(request,", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyODU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397328595", "bodyText": "Great catch @dakrone, thank you", "author": "andreidan", "createdAt": "2020-03-24T17:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\nindex a3e9f0d8f53..7be8fc7cc5f 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStep.java\n\n@@ -53,6 +53,7 @@ public class CreateSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n             return;\n         }\n         CreateSnapshotRequest request = new CreateSnapshotRequest(snapshotRepository, snapshotName);\n+        request.indices(indexName);\n         // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't perform\n         // expensive operations (ie. clusterStateProcessed)\n         request.waitForCompletion(false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTgyOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393361828", "bodyText": "I think this name would be clearer if it were \"delete_searchable_snapshot\", right now I don't want administrators to thing this means all snapshots containing this index would be deleted. What do you think?", "author": "dakrone", "createdAt": "2020-03-16T23:12:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java", "diffHunk": "@@ -5,38 +5,63 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.elasticsearch.Version;\n import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Objects;\n \n /**\n  * A {@link LifecycleAction} which deletes the index.\n  */\n public class DeleteAction implements LifecycleAction {\n     public static final String NAME = \"delete\";\n \n-    private static final ObjectParser<DeleteAction, Void> PARSER = new ObjectParser<>(NAME, DeleteAction::new);\n+    public static final ParseField DELETE_GENERATED_SNAPSHOT_FIELD = new ParseField(\"delete_generated_snapshot\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397330889", "bodyText": "I agree. I didn't use this name before because it was sort of tied to the searchable repository, but that's not an issue anymore.", "author": "andreidan", "createdAt": "2020-03-24T17:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MTgyOA=="}], "type": "inlineReview", "revised_code": {"commit": "0f6f3719e35e43de3e214d3a3c0de86fec9834fe", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java\nindex fc7531602a3..9f0a06e013f 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java\n\n@@ -26,41 +26,41 @@ import java.util.Objects;\n public class DeleteAction implements LifecycleAction {\n     public static final String NAME = \"delete\";\n \n-    public static final ParseField DELETE_GENERATED_SNAPSHOT_FIELD = new ParseField(\"delete_generated_snapshot\");\n+    public static final ParseField DELETE_SEARCHABLE_SNAPSHOT_FIELD = new ParseField(\"delete_searchable_snapshot\");\n \n     private static final ConstructingObjectParser<DeleteAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n         a -> new DeleteAction(a[0] == null ? true : (boolean) a[0]));\n \n     static {\n-        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_GENERATED_SNAPSHOT_FIELD);\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_SEARCHABLE_SNAPSHOT_FIELD);\n     }\n \n     public static DeleteAction parse(XContentParser parser) {\n         return PARSER.apply(parser, null);\n     }\n \n-    private final boolean deleteGeneratedSnapshot;\n+    private final boolean deleteSearchableSnapshot;\n \n     public DeleteAction() {\n         this(true);\n     }\n \n-    public DeleteAction(boolean deleteGeneratedSnapshot) {\n-        this.deleteGeneratedSnapshot = deleteGeneratedSnapshot;\n+    public DeleteAction(boolean deleteSearchableSnapshot) {\n+        this.deleteSearchableSnapshot = deleteSearchableSnapshot;\n     }\n \n     public DeleteAction(StreamInput in) throws IOException {\n         if (in.getVersion().onOrAfter(Version.V_8_0_0)) {\n-            this.deleteGeneratedSnapshot = in.readBoolean();\n+            this.deleteSearchableSnapshot = in.readBoolean();\n         } else {\n-            this.deleteGeneratedSnapshot = true;\n+            this.deleteSearchableSnapshot = true;\n         }\n     }\n \n     @Override\n     public void writeTo(StreamOutput out) throws IOException {\n         if (out.getVersion().onOrAfter(Version.V_8_0_0)) {\n-            out.writeBoolean(deleteGeneratedSnapshot);\n+            out.writeBoolean(deleteSearchableSnapshot);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2MzAyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r393363023", "bodyText": "This should probably be at warn level", "author": "dakrone", "createdAt": "2020-03-16T23:16:09Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata along with the provided snapshot repository.\n+ */\n+public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n+\n+    public static final String NAME = \"generate-snapshot-name\";\n+\n+    private static final Logger logger = LogManager.getLogger(CreateSnapshotStep.class);\n+\n+    private static final IndexNameExpressionResolver.DateMathExpressionResolver DATE_MATH_RESOLVER =\n+        new IndexNameExpressionResolver.DateMathExpressionResolver();\n+\n+    private final String snapshotRepository;\n+\n+    public GenerateSnapshotNameStep(StepKey key, StepKey nextStepKey, String snapshotRepository) {\n+        super(key, nextStepKey);\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public String getSnapshotRepository() {\n+        return snapshotRepository;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        if (indexMetaData == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), index.getName());\n+            return clusterState;\n+        }\n+\n+        ClusterState.Builder newClusterStateBuilder = ClusterState.builder(clusterState);\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        assert lifecycleState.getSnapshotName() == null : \"index \" + index.getName() + \" should not have a snapshot generated by \" +\n+            \"the ilm policy but has \" + lifecycleState.getSnapshotName();\n+        LifecycleExecutionState.Builder newCustomData = LifecycleExecutionState.builder(lifecycleState);\n+        String policy = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        String snapshotNamePrefix = (\"<{now/d}-\" + index.getName() + \"-\" + policy + \">\").toLowerCase(Locale.ROOT);\n+        String snapshotName = generateSnapshotName(snapshotNamePrefix);\n+        ActionRequestValidationException validationException = validateGeneratedSnapshotName(snapshotNamePrefix, snapshotName);\n+        if (validationException != null) {\n+            logger.debug(\"unable to generate a snapshot name as part of policy [{}] for index [{}] due to [{}]\",", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06bf054c65fb19193f6fba1e77ec76e2211fe2f7", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\nindex d0b0a9df7e8..7bc0b95cdc6 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n\n@@ -69,7 +69,7 @@ public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n         String snapshotName = generateSnapshotName(snapshotNamePrefix);\n         ActionRequestValidationException validationException = validateGeneratedSnapshotName(snapshotNamePrefix, snapshotName);\n         if (validationException != null) {\n-            logger.debug(\"unable to generate a snapshot name as part of policy [{}] for index [{}] due to [{}]\",\n+            logger.warn(\"unable to generate a snapshot name as part of policy [{}] for index [{}] due to [{}]\",\n                 policy, index.getName(), validationException.getMessage());\n             throw validationException;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNTA1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394015058", "bodyText": "Should we at least warn/log if the response were not acknowledged? I am thinking since this is retryable we should no-op for an existing index that contains the mounted settings, and throw an error for unacknowledged responses so we retry in ~10 minutes.", "author": "dakrone", "createdAt": "2020-03-17T22:49:03Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class MountSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"mount-snapshot\";\n+\n+    private final String restoredIndexPrefix;\n+\n+    public MountSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getRestoredIndexPrefix() {\n+        return restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+\n+        final MountSearchableSnapshotRequest mountSearchableSnapshotRequest =\n+            new MountSearchableSnapshotRequest(restoredIndexPrefix + indexName,\n+                snapshotRepository, snapshotName, indexName, Settings.builder()\n+                .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+                .build(),\n+                // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+                // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and,\n+                // depending on what ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in\n+                // the ILM policy.\n+                // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+                new String[]{LifecycleSettings.LIFECYCLE_NAME},\n+                // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't\n+                // perform expensive operations (ie. clusterStateProcessed)\n+                false);\n+        getClient().execute(MountSearchableSnapshotAction.INSTANCE, mountSearchableSnapshotRequest,\n+            ActionListener.wrap(response -> listener.onResponse(true), listener::onFailure));", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9d37f78069d40d85d80cca566f150420d12b1fd1", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\nindex fafcf8bd345..f87ebff61f9 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\n\n@@ -5,6 +5,9 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.ClusterState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNjQ5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394016499", "bodyText": "I believe this should be snapshot_repository since we use underscores for our JSON parsing", "author": "dakrone", "createdAt": "2020-03-17T22:53:11Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNzc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394017749", "bodyText": "I might be paranoid here, but can you add some logging to this method (and onResponse) at trace or debug level so we have some feedback in the event we need to debug this?", "author": "dakrone", "createdAt": "2020-03-17T22:56:44Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+/**\n+ * This step changes its {@link #getNextStepKey()} depending on the result of an {@link AsyncWaitStep}.\n+ * <p>\n+ * The next step key will point towards the \"wait action fulfilled\" step when the condition of the async action is met, and towards the\n+ * \"wait action unfulfilled\" step when the client instructs they'd like to stop waiting for the condition using the\n+ * {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}.\n+ * <p>\n+ * If the async action that's branching the execution results in a failure, the {@link #getNextStepKey()} is not set (as ILM would move\n+ * into the {@link ErrorStep} step).\n+ */\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n+    public static final String NAME = \"async-branch\";\n+\n+    private StepKey nextStepKeyUnfulfilledWaitAction;\n+    private StepKey nextStepKeyFulfilledWaitAction;\n+    private TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction;\n+    private SetOnce<Boolean> onCompleteConditionMet;\n+\n+    /**\n+     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n+     *\n+     * @param key                                the step's key\n+     * @param nextStepKeyUnfulfilledWaitAction the key of the step to run if the client decides to stop waiting for the condition to be\n+     *                                           via {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}\n+     * @param nextStepKeyFulfilledWaitAction   the key of the step to run if the {@link #asyncWaitAction} condition is met\n+     * @param asyncWaitAction                    the action to execute, would usually be similar to an instance of {@link AsyncWaitStep}\n+     *                                           but the user has the option to decide to stop waiting for the condition to be fulfilled\n+     */\n+    public OnAsyncWaitBranchingStep(StepKey key, StepKey nextStepKeyUnfulfilledWaitAction, StepKey nextStepKeyFulfilledWaitAction,\n+                                    Client client, TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction) {\n+        // super.nextStepKey is set to null since it is not used by this step\n+        super(key, null, client);\n+        this.nextStepKeyUnfulfilledWaitAction = nextStepKeyUnfulfilledWaitAction;\n+        this.nextStepKeyFulfilledWaitAction = nextStepKeyFulfilledWaitAction;\n+        this.asyncWaitAction = asyncWaitAction;\n+        this.onCompleteConditionMet = new SetOnce<>();\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void evaluateCondition(IndexMetaData indexMetaData, Listener listener, TimeValue masterTimeout) {\n+        asyncWaitAction.apply(getClient(), indexMetaData, new BranchingStepListener() {\n+            @Override\n+            public void onResponse(boolean conditionMet, ToXContentObject informationContext) {\n+                onCompleteConditionMet.set(true);\n+                listener.onResponse(conditionMet, informationContext);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                listener.onFailure(e);\n+            }\n+\n+            @Override\n+            public void onStopWaitingAndMoveToNextKey(ToXContentObject informationContext) {\n+                onCompleteConditionMet.set(false);\n+                // to the \"outside\" world the condition was met (as the user decided so) and we're ready to move to the next step.\n+                // {@link #getNextStepKey} will now point towards {@link #nextStepKeyUnfulfilledWaitAction)\n+                listener.onResponse(true, informationContext);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c3d785e495cf2fa2c2ad2b4958c8e2f1954970e3", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\nindex 5a0e03554d4..2ae4b4e7d81 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n\n@@ -6,6 +6,8 @@\n \n package org.elasticsearch.xpack.core.ilm;\n \n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n import org.apache.lucene.util.SetOnce;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxOTIzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394019230", "bodyText": "Can you add a comment about the use of nextStepKey here? I had to look at the code a couple of times to see why it should be null in some cases (now I understand, but a comment would be useful)", "author": "dakrone", "createdAt": "2020-03-17T23:00:47Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxOTg4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394019883", "bodyText": "The grammar is a little weird:\nsnapshot [foo] for index [bar] as part of policy [baz] is cannot complete as it is in state [FAILED]\n\nThe \"is cannot complete\" needs the \"is\" taken out I think", "author": "dakrone", "createdAt": "2020-03-17T23:02:52Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyMDM2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394020362", "bodyText": "This should include INCOMPATIBLE and PARTIAL, otherwise we'd spin forever in those cases", "author": "dakrone", "createdAt": "2020-03-17T23:04:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyMDU4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r394020584", "bodyText": "This should explicitly check for IN_PROGRESS, it might be easier to flip the if statement to only check for SUCCESS or IN_PROGRESS and do the onStopWaitingAndMoveToNextKey if there is any other state", "author": "dakrone", "createdAt": "2020-03-17T23:04:56Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));\n+                    } else {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1Nzg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395357872", "bodyText": "This isn't a WaitForIndexColorStep.Info class, I think this needs to be changed to just Info", "author": "dakrone", "createdAt": "2020-03-19T22:37:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotStatus;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.health.ClusterHealthStatus;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.ABORTED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.FAILED;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.MISSING;\n+import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n+\n+/**\n+ * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n+ * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n+ * newly created searchable snapshot backed index.\n+ */\n+public class SearchableSnapshotAction implements LifecycleAction {\n+    public static final String NAME = \"searchable-snapshot\";\n+\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+\n+    public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n+\n+    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new SearchableSnapshotAction((String) a[0]));\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n+    }\n+\n+    public static SearchableSnapshotAction parse(XContentParser parser) {\n+        return PARSER.apply(parser, null);\n+    }\n+\n+    private final String snapshotRepository;\n+\n+    public SearchableSnapshotAction(String snapshotRepository) {\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n+        }\n+        this.snapshotRepository = snapshotRepository;\n+    }\n+\n+    public SearchableSnapshotAction(StreamInput in) throws IOException {\n+        this(in.readString());\n+    }\n+\n+    @Override\n+    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {\n+        StepKey waitForNoFollowerStepKey = new StepKey(phase, NAME, WaitForNoFollowersStep.NAME);\n+        StepKey generateSnapshotNameKey = new StepKey(phase, NAME, GenerateSnapshotNameStep.NAME);\n+        StepKey cleanSnapshotKey = new StepKey(phase, NAME, CleanupSnapshotStep.NAME);\n+        StepKey createSnapshotKey = new StepKey(phase, NAME, CreateSnapshotStep.NAME);\n+        StepKey waitForSnapshotInProgressKey = new StepKey(phase, NAME, WaitForSnapshotInProgressStep.NAME);\n+        StepKey verifySnapshotStatusBranchingKey = new StepKey(phase, NAME, OnAsyncWaitBranchingStep.NAME);\n+        StepKey mountSnapshotKey = new StepKey(phase, NAME, MountSnapshotStep.NAME);\n+        StepKey waitForGreenRestoredIndexKey = new StepKey(phase, NAME, WaitForIndexColorStep.NAME);\n+        StepKey copyMetadataKey = new StepKey(phase, NAME, CopyExecutionStateStep.NAME);\n+        StepKey copyLifecyclePolicySettingKey = new StepKey(phase, NAME, CopySettingsStep.NAME);\n+        StepKey swapAliasesKey = new StepKey(phase, NAME, SwapAliasesAndDeleteSourceIndexStep.NAME);\n+\n+        WaitForNoFollowersStep waitForNoFollowersStep = new WaitForNoFollowersStep(waitForNoFollowerStepKey, generateSnapshotNameKey,\n+            client);\n+        GenerateSnapshotNameStep generateSnapshotNameStep = new GenerateSnapshotNameStep(generateSnapshotNameKey, cleanSnapshotKey,\n+            snapshotRepository);\n+        CleanupSnapshotStep cleanupSnapshotStep = new CleanupSnapshotStep(cleanSnapshotKey, createSnapshotKey, client);\n+        CreateSnapshotStep createSnapshotStep = new CreateSnapshotStep(createSnapshotKey, waitForSnapshotInProgressKey, client);\n+        WaitForSnapshotInProgressStep waitForSnapshotInProgressStep = new WaitForSnapshotInProgressStep(waitForSnapshotInProgressKey,\n+            verifySnapshotStatusBranchingKey);\n+        OnAsyncWaitBranchingStep onAsyncWaitBranchingStep = new OnAsyncWaitBranchingStep(verifySnapshotStatusBranchingKey,\n+            cleanSnapshotKey, mountSnapshotKey, client, getCheckSnapshotStatusAsyncAction());\n+        MountSnapshotStep mountSnapshotStep = new MountSnapshotStep(mountSnapshotKey, waitForGreenRestoredIndexKey,\n+            client, RESTORED_INDEX_PREFIX);\n+        WaitForIndexColorStep waitForGreenIndexHealthStep = new WaitForIndexColorStep(waitForGreenRestoredIndexKey,\n+            copyMetadataKey, ClusterHealthStatus.GREEN, RESTORED_INDEX_PREFIX);\n+        CopyExecutionStateStep copyMetadataStep = new CopyExecutionStateStep(copyMetadataKey, copyLifecyclePolicySettingKey,\n+            RESTORED_INDEX_PREFIX, nextStepKey != null ? nextStepKey.getName() : \"null\");\n+        CopySettingsStep copySettingsStep = new CopySettingsStep(copyLifecyclePolicySettingKey, swapAliasesKey, RESTORED_INDEX_PREFIX,\n+            LifecycleSettings.LIFECYCLE_NAME);\n+        // sending this step to null as the restored index (which will after this step essentially be the source index) was sent to the next\n+        // key after we restored the lifecycle execution state\n+        SwapAliasesAndDeleteSourceIndexStep swapAliasesAndDeleteSourceIndexStep = new SwapAliasesAndDeleteSourceIndexStep(swapAliasesKey,\n+            null, client, RESTORED_INDEX_PREFIX);\n+\n+        return Arrays.asList(waitForNoFollowersStep, generateSnapshotNameStep, cleanupSnapshotStep, createSnapshotStep,\n+            waitForSnapshotInProgressStep, onAsyncWaitBranchingStep, mountSnapshotStep, waitForGreenIndexHealthStep,\n+            copyMetadataStep, copySettingsStep, swapAliasesAndDeleteSourceIndexStep);\n+    }\n+\n+    /**\n+     * Creates a consumer to evaluate the ILM generated snapshot status in the provided snapshotRepository in an async way, akin to an\n+     * equivalent {@link AsyncWaitStep} implementation.\n+     */\n+    static TriConsumer<Client, IndexMetaData, BranchingStepListener> getCheckSnapshotStatusAsyncAction() {\n+        return (client, indexMetaData, branchingStepListener) -> {\n+\n+            LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+\n+            String snapshotName = executionState.getSnapshotName();\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            final String indexName = indexMetaData.getIndex().getName();\n+            final String repositoryName = executionState.getSnapshotRepository();\n+            if (Strings.hasText(repositoryName) == false) {\n+                branchingStepListener.onFailure(\n+                    new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName +\n+                        \"]\"));\n+                return;\n+            }\n+            if (Strings.hasText(snapshotName) == false) {\n+                branchingStepListener.onFailure(new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName +\n+                    \"] and index [\" + indexName + \"]\"));\n+                return;\n+            }\n+            SnapshotsStatusRequest snapshotsStatusRequest = new SnapshotsStatusRequest(repositoryName, new String[]{snapshotName});\n+            client.admin().cluster().snapshotsStatus(snapshotsStatusRequest, new ActionListener<>() {\n+                @Override\n+                public void onResponse(SnapshotsStatusResponse snapshotsStatusResponse) {\n+                    List<SnapshotStatus> statuses = snapshotsStatusResponse.getSnapshots();\n+                    assert statuses.size() == 1 : \"we only requested the status info for one snapshot\";\n+                    SnapshotStatus snapshotStatus = statuses.get(0);\n+                    SnapshotsInProgress.State snapshotState = snapshotStatus.getState();\n+                    if (snapshotState.equals(SUCCESS)) {\n+                        branchingStepListener.onResponse(true, null);\n+                    } else if (snapshotState.equals(ABORTED) || snapshotState.equals(FAILED) || snapshotState.equals(MISSING)) {\n+                        branchingStepListener.onStopWaitingAndMoveToNextKey(new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"cannot complete as it is in state [\" + snapshotState + \"]\"));\n+                    } else {\n+                        branchingStepListener.onResponse(false, new Info(\n+                            \"snapshot [\" + snapshotName + \"] for index [ \" + indexName + \"] as part of policy [\" + policyName + \"] is \" +\n+                                \"in state [\" + snapshotState + \"]. waiting for SUCCESS\"));\n+                    }\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    branchingStepListener.onFailure(e);\n+                }\n+\n+                final class Info implements ToXContentObject {\n+\n+                    final ParseField MESSAGE_FIELD = new ParseField(\"message\");\n+\n+                    private final String message;\n+\n+                    Info(String message) {\n+                        this.message = message;\n+                    }\n+\n+                    String getMessage() {\n+                        return message;\n+                    }\n+\n+                    @Override\n+                    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+                        builder.startObject();\n+                        builder.field(MESSAGE_FIELD.getPreferredName(), message);\n+                        builder.endObject();\n+                        return builder;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (o == null) {\n+                            return false;\n+                        }\n+                        if (getClass() != o.getClass()) {\n+                            return false;\n+                        }\n+                        WaitForIndexColorStep.Info info = (WaitForIndexColorStep.Info) o;", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\nindex a232d83d23c..f1ac44e8d48 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotAction.java\n\n@@ -43,7 +43,7 @@ import static org.elasticsearch.cluster.SnapshotsInProgress.State.SUCCESS;\n public class SearchableSnapshotAction implements LifecycleAction {\n     public static final String NAME = \"searchable-snapshot\";\n \n-    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot-repository\");\n+    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n \n     public static final String RESTORED_INDEX_PREFIX = \"restored-\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1OTE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395359195", "bodyText": "I think this should probably check the response and at least log/warn about an unacknowledged request?", "author": "dakrone", "createdAt": "2020-03-19T22:41:08Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * This step swaps all the aliases from the source index to the restored index and deletes the source index. This is useful in scenarios\n+ * following a restore from snapshot operation where the restored index will take the place of the source index in the ILM lifecycle.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases\";\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n+\n+    private final String targetIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String targetIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.targetIndexPrefix = targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getTargetIndexPrefix() {\n+        return targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String targetIndexName = targetIndexPrefix + originalIndex;\n+        IndexMetaData targetIndexMetadata = currentClusterState.metaData().index(targetIndexName);\n+\n+        if (targetIndexMetadata == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"target index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", targetIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        deleteSourceIndexAndTransferAliases(getClient(), indexMetaData, getMasterTimeout(currentClusterState), targetIndexName, listener);\n+    }\n+\n+    /**\n+     * Executes an {@link IndicesAliasesRequest} to copy over all the aliases from the source to the target index, and remove the source\n+     * index.\n+     * <p>\n+     * The is_write_index will *not* be set on the target index as this operation is currently executed on read-only indices.\n+     */\n+    static void deleteSourceIndexAndTransferAliases(Client client, IndexMetaData sourceIndex, TimeValue masterTimeoutValue,\n+                                                    String targetIndex, Listener listener) {\n+        String sourceIndexName = sourceIndex.getIndex().getName();\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(masterTimeoutValue)\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(sourceIndexName))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(targetIndex).alias(sourceIndexName));\n+        // copy over other aliases from source index\n+        sourceIndex.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(targetIndex).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(null));\n+        });\n+\n+        client.admin().indices().aliases(aliasesRequest,\n+            ActionListener.wrap(openIndexResponse -> {\n+                listener.onResponse(true);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2b467cfa615748b08763476902eacf034a79fe5d", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 23694c3a474..6c9e690d539 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -88,7 +88,10 @@ public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n         });\n \n         client.admin().indices().aliases(aliasesRequest,\n-            ActionListener.wrap(openIndexResponse -> {\n+            ActionListener.wrap(response -> {\n+                if (response.isAcknowledged() == false) {\n+                    logger.warn(\"aliases swap from [{}] to [{}] response was not acknowledged\", sourceIndexName, targetIndex);\n+                }\n                 listener.onResponse(true);\n             }, listener::onFailure));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1OTM2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395359361", "bodyText": "This openIndexResponse should probably be aliasResponse since it's not opening an index", "author": "dakrone", "createdAt": "2020-03-19T22:41:33Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.alias.IndicesAliasesRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.ClusterStateObserver;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.unit.TimeValue;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * This step swaps all the aliases from the source index to the restored index and deletes the source index. This is useful in scenarios\n+ * following a restore from snapshot operation where the restored index will take the place of the source index in the ILM lifecycle.\n+ */\n+public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n+    public static final String NAME = \"swap-aliases\";\n+    private static final Logger logger = LogManager.getLogger(SwapAliasesAndDeleteSourceIndexStep.class);\n+\n+    private final String targetIndexPrefix;\n+\n+    public SwapAliasesAndDeleteSourceIndexStep(StepKey key, StepKey nextStepKey, Client client, String targetIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.targetIndexPrefix = targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getTargetIndexPrefix() {\n+        return targetIndexPrefix;\n+    }\n+\n+    @Override\n+    public void performAction(IndexMetaData indexMetaData, ClusterState currentClusterState, ClusterStateObserver observer,\n+                              Listener listener) {\n+        String originalIndex = indexMetaData.getIndex().getName();\n+        final String targetIndexName = targetIndexPrefix + originalIndex;\n+        IndexMetaData targetIndexMetadata = currentClusterState.metaData().index(targetIndexName);\n+\n+        if (targetIndexMetadata == null) {\n+            String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+            String errorMessage = String.format(Locale.ROOT, \"target index [%s] doesn't exist. stopping execution of lifecycle [%s] for\" +\n+                \" index [%s]\", targetIndexName, policyName, originalIndex);\n+            logger.debug(errorMessage);\n+            listener.onFailure(new IllegalStateException(errorMessage));\n+            return;\n+        }\n+\n+        deleteSourceIndexAndTransferAliases(getClient(), indexMetaData, getMasterTimeout(currentClusterState), targetIndexName, listener);\n+    }\n+\n+    /**\n+     * Executes an {@link IndicesAliasesRequest} to copy over all the aliases from the source to the target index, and remove the source\n+     * index.\n+     * <p>\n+     * The is_write_index will *not* be set on the target index as this operation is currently executed on read-only indices.\n+     */\n+    static void deleteSourceIndexAndTransferAliases(Client client, IndexMetaData sourceIndex, TimeValue masterTimeoutValue,\n+                                                    String targetIndex, Listener listener) {\n+        String sourceIndexName = sourceIndex.getIndex().getName();\n+        IndicesAliasesRequest aliasesRequest = new IndicesAliasesRequest()\n+            .masterNodeTimeout(masterTimeoutValue)\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.removeIndex().index(sourceIndexName))\n+            .addAliasAction(IndicesAliasesRequest.AliasActions.add().index(targetIndex).alias(sourceIndexName));\n+        // copy over other aliases from source index\n+        sourceIndex.getAliases().values().spliterator().forEachRemaining(aliasMetaDataObjectCursor -> {\n+            AliasMetaData aliasMetaDataToAdd = aliasMetaDataObjectCursor.value;\n+            // inherit all alias properties except `is_write_index`\n+            aliasesRequest.addAliasAction(IndicesAliasesRequest.AliasActions.add()\n+                .index(targetIndex).alias(aliasMetaDataToAdd.alias())\n+                .indexRouting(aliasMetaDataToAdd.indexRouting())\n+                .searchRouting(aliasMetaDataToAdd.searchRouting())\n+                .filter(aliasMetaDataToAdd.filter() == null ? null : aliasMetaDataToAdd.filter().string())\n+                .writeIndex(null));\n+        });\n+\n+        client.admin().indices().aliases(aliasesRequest,\n+            ActionListener.wrap(openIndexResponse -> {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2b467cfa615748b08763476902eacf034a79fe5d", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\nindex 23694c3a474..6c9e690d539 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/SwapAliasesAndDeleteSourceIndexStep.java\n\n@@ -88,7 +88,10 @@ public class SwapAliasesAndDeleteSourceIndexStep extends AsyncActionStep {\n         });\n \n         client.admin().indices().aliases(aliasesRequest,\n-            ActionListener.wrap(openIndexResponse -> {\n+            ActionListener.wrap(response -> {\n+                if (response.isAcknowledged() == false) {\n+                    logger.warn(\"aliases swap from [{}] to [{}] response was not acknowledged\", sourceIndexName, targetIndex);\n+                }\n                 listener.onResponse(true);\n             }, listener::onFailure));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MDAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395360013", "bodyText": "It was unclear where we wanted this to live, but I'm pretty sure that all the conversations I've heard have mentioned it being in the warm phase, @DaveCTurner was there ever a consensus on where it should go, warm/cold, or just cold?", "author": "dakrone", "createdAt": "2020-03-19T22:43:16Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/TimeseriesLifecycleType.java", "diffHunk": "@@ -41,7 +41,7 @@\n     static final List<String> ORDERED_VALID_WARM_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, ReadOnlyAction.NAME,\n         AllocateAction.NAME, ShrinkAction.NAME, ForceMergeAction.NAME);\n     static final List<String> ORDERED_VALID_COLD_ACTIONS = Arrays.asList(SetPriorityAction.NAME, UnfollowAction.NAME, AllocateAction.NAME,\n-        FreezeAction.NAME);\n+        FreezeAction.NAME, SearchableSnapshotAction.NAME);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MTM2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395361365", "bodyText": "I'm not sure, but can clusterState.custom(SnapshotsInProgress.TYPE) return null if there have never been any snapshots? Perhaps we should add a null check?", "author": "dakrone", "createdAt": "2020-03-19T22:47:26Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f506ee67070eac1bfd7dc6d381ef27caf879d13", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\nindex 4d0ddffbedf..73fb23d5aa5 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\n\n@@ -72,6 +72,11 @@ public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n             return new Result(false, new Info(errorMessage));\n         }\n         final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        // we got here before the cluster state was updated with the (or any) snapshot being started, so we'll wait\n+        if (snapshotsInProgress == null) {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n+        }\n         List<SnapshotInfo> repositorySnapshots = SnapshotsService.currentSnapshots(snapshotsInProgress, snapshotRepository);\n         List<SnapshotInfo> configuredSnapshotInProgress =\n             repositorySnapshots.stream().filter(si -> si.snapshotId().getName().equals(snapshotName)).collect(Collectors.toList());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2MTg4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395361880", "bodyText": "I'm starting to think we should add a GenericILMInfo class that is just a message field so we don't end up having to duplicate this class over and over in each step (not necessarily in this PR)", "author": "dakrone", "createdAt": "2020-03-19T22:48:41Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        List<SnapshotInfo> repositorySnapshots = SnapshotsService.currentSnapshots(snapshotsInProgress, snapshotRepository);\n+        List<SnapshotInfo> configuredSnapshotInProgress =\n+            repositorySnapshots.stream().filter(si -> si.snapshotId().getName().equals(snapshotName)).collect(Collectors.toList());\n+\n+        if (configuredSnapshotInProgress.isEmpty()) {\n+            return new Result(true, null);\n+        } else {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n+        }\n+    }\n+\n+    static final class Info implements ToXContentObject {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f506ee67070eac1bfd7dc6d381ef27caf879d13", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\nindex 4d0ddffbedf..73fb23d5aa5 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\n\n@@ -72,6 +72,11 @@ public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n             return new Result(false, new Info(errorMessage));\n         }\n         final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        // we got here before the cluster state was updated with the (or any) snapshot being started, so we'll wait\n+        if (snapshotsInProgress == null) {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n+        }\n         List<SnapshotInfo> repositorySnapshots = SnapshotsService.currentSnapshots(snapshotsInProgress, snapshotRepository);\n         List<SnapshotInfo> configuredSnapshotInProgress =\n             repositorySnapshots.stream().filter(si -> si.snapshotId().getName().equals(snapshotName)).collect(Collectors.toList());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODUwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395908505", "bodyText": "Super minor nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \" is no snapshot to deleter\");\n          \n          \n            \n                                    \" is no snapshot to delete\");", "author": "dakrone", "createdAt": "2020-03-20T22:00:02Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapshotStep> {\n+\n+    @Override\n+    public CleanupSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CleanupSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CleanupSnapshotStep copyInstance(CleanupSnapshotStep instance) {\n+        return new CleanupSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CleanupSnapshotStep mutateInstance(CleanupSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CleanupSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionDoesntFailIfSnapshotInfoIsMissing() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n+                        \" is no snapshot to deleter\");", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b68b61c1cc6a969d9092f093c8aa543645baf7d9", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\nindex cb81f803977..0763adf1bce 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\n\n@@ -79,7 +79,7 @@ public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapsh\n                 @Override\n                 public void onFailure(Exception e) {\n                     fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n-                        \" is no snapshot to deleter\");\n+                        \" is no snapshot to delete\");\n                 }\n             });\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwODk5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395908997", "bodyText": "Could probably add assertTrue(complete) here", "author": "dakrone", "createdAt": "2020-03-20T22:01:46Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapshotStep> {\n+\n+    @Override\n+    public CleanupSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CleanupSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CleanupSnapshotStep copyInstance(CleanupSnapshotStep instance) {\n+        return new CleanupSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CleanupSnapshotStep mutateInstance(CleanupSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CleanupSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionDoesntFailIfSnapshotInfoIsMissing() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n+                        \" is no snapshot to deleter\");\n+                }\n+            });\n+        }\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            Map<String, String> ilmCustom = Map.of(\"snapshot_repository\", \"repository_name\");\n+            indexMetadataBuilder.putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom);\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CleanupSnapshotStep cleanupSnapshotStep = createRandomInstance();\n+            cleanupSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    assertThat(complete, is(true));\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    fail(\"expecting the step to report success if the snapshot name is missing from the ILM execution state as there is \" +\n+                        \"no snapshot to delete\");\n+                }\n+            });\n+        }\n+    }\n+\n+    public void testPerformAction() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+        String snapshotName = indexName + \"-\" + policyName;\n+        Map<String, String> ilmCustom = Map.of(\"snapshot_name\", snapshotName);\n+\n+        IndexMetaData.Builder indexMetadataBuilder =\n+            IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                .putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom)\n+                .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+        IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+        ClusterState clusterState =\n+            ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+        try (NoOpClient client = getDeleteSnapshotRequestAssertingClient(snapshotName)) {\n+            CleanupSnapshotStep step = new CleanupSnapshotStep(randomStepKey(), randomStepKey(), client);\n+            step.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                }", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b68b61c1cc6a969d9092f093c8aa543645baf7d9", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\nindex cb81f803977..0763adf1bce 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStepTests.java\n\n@@ -79,7 +79,7 @@ public class CleanupSnapshotStepTests extends AbstractStepTestCase<CleanupSnapsh\n                 @Override\n                 public void onFailure(Exception e) {\n                     fail(\"expecting the step to report success if repository information is missing from the ILM execution state as there\" +\n-                        \" is no snapshot to deleter\");\n+                        \" is no snapshot to delete\");\n                 }\n             });\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTMwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395909308", "bodyText": "Can add assertTrue(complete) here as well (and a fail clause in the onFailure below)", "author": "dakrone", "createdAt": "2020-03-20T22:02:50Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.create.CreateSnapshotRequest;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.AbstractStepMasterTimeoutTestCase.emptyClusterState;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CreateSnapshotStepTests extends AbstractStepTestCase<CreateSnapshotStep> {\n+\n+    @Override\n+    public CreateSnapshotStep createRandomInstance() {\n+        StepKey stepKey = randomStepKey();\n+        StepKey nextStepKey = randomStepKey();\n+        return new CreateSnapshotStep(stepKey, nextStepKey, client);\n+    }\n+\n+    @Override\n+    protected CreateSnapshotStep copyInstance(CreateSnapshotStep instance) {\n+        return new CreateSnapshotStep(instance.getKey(), instance.getNextStepKey(), instance.getClient());\n+    }\n+\n+    @Override\n+    public CreateSnapshotStep mutateInstance(CreateSnapshotStep instance) {\n+        StepKey key = instance.getKey();\n+        StepKey nextKey = instance.getNextStepKey();\n+        switch (between(0, 1)) {\n+            case 0:\n+                key = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            case 1:\n+                nextKey = new StepKey(key.getPhase(), key.getAction(), key.getName() + randomAlphaOfLength(5));\n+                break;\n+            default:\n+                throw new AssertionError(\"Illegal randomisation branch\");\n+        }\n+        return new CreateSnapshotStep(key, nextKey, instance.getClient());\n+    }\n+\n+    public void testPerformActionFailure() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            Map<String, String> ilmCustom = new HashMap<>();\n+            String repository = \"repository\";\n+            ilmCustom.put(\"snapshot_repository\", repository);\n+            indexMetadataBuilder.putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom);\n+\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CreateSnapshotStep createSnapshotStep = createRandomInstance();\n+            createSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    fail(\"expecting a failure as the index doesn't have any snapshot name in its ILM execution state\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(IllegalStateException.class));\n+                    assertThat(e.getMessage(),\n+                        is(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+                }\n+            });\n+        }\n+\n+        {\n+            IndexMetaData.Builder indexMetadataBuilder =\n+                IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                    .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+            IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+            ClusterState clusterState =\n+                ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+            CreateSnapshotStep createSnapshotStep = createRandomInstance();\n+            createSnapshotStep.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {\n+                    fail(\"expecting a failure as the index doesn't have any snapshot name in its ILM execution state\");\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    assertThat(e, instanceOf(IllegalStateException.class));\n+                    assertThat(e.getMessage(),\n+                        is(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+                }\n+            });\n+        }\n+    }\n+\n+    public void testPerformAction() {\n+        String indexName = randomAlphaOfLength(10);\n+        String policyName = \"test-ilm-policy\";\n+        Map<String, String> ilmCustom = new HashMap<>();\n+        String snapshotName = indexName + \"-\" + policyName;\n+        ilmCustom.put(\"snapshot_name\", snapshotName);\n+        String repository = \"repository\";\n+        ilmCustom.put(\"snapshot_repository\", repository);\n+\n+        IndexMetaData.Builder indexMetadataBuilder =\n+            IndexMetaData.builder(indexName).settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, policyName))\n+                .putCustom(LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY, ilmCustom)\n+                .numberOfShards(randomIntBetween(1, 5)).numberOfReplicas(randomIntBetween(0, 5));\n+        IndexMetaData indexMetaData = indexMetadataBuilder.build();\n+\n+        ClusterState clusterState =\n+            ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n+\n+        try (NoOpClient client = getCreateSnapshotRequestAssertingClient(repository, snapshotName)) {\n+            CreateSnapshotStep step = new CreateSnapshotStep(randomStepKey(), randomStepKey(), client);\n+            step.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n+                @Override\n+                public void onResponse(boolean complete) {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java\nindex 00114d71079..f39cf6189d9 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/CreateSnapshotStepTests.java\n\n@@ -134,7 +134,7 @@ public class CreateSnapshotStepTests extends AbstractStepTestCase<CreateSnapshot\n         ClusterState clusterState =\n             ClusterState.builder(emptyClusterState()).metaData(MetaData.builder().put(indexMetaData, true).build()).build();\n \n-        try (NoOpClient client = getCreateSnapshotRequestAssertingClient(repository, snapshotName)) {\n+        try (NoOpClient client = getCreateSnapshotRequestAssertingClient(repository, snapshotName, indexName)) {\n             CreateSnapshotStep step = new CreateSnapshotStep(randomStepKey(), randomStepKey(), client);\n             step.performAction(indexMetaData, clusterState, null, new AsyncActionStep.Listener() {\n                 @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395910145", "bodyText": "We could probably put these somewhere else to start splitting this apart similar to #53488 (up to you of course)", "author": "dakrone", "createdAt": "2020-03-20T22:05:43Z", "path": "x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java", "diffHunk": "@@ -1545,6 +1548,145 @@ public void testHaltAtEndOfPhase() throws Exception {\n         assertBusy(() -> assertFalse(\"expected \" + index + \" to be deleted by ILM\", indexExists(index)));\n     }\n \n+    public void testSearchableSnapshotAction() throws Exception {", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNjAzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r397336031", "bodyText": "Yes, totally, I am about to start doing that on master (and will backport here with the appropriate conflict fixes) as I think the scope of this PR is already quite large and some infrastructure needs to be extracted from TimeSeriesLifecycleActionsIT to be reused across the various new test classes.", "author": "andreidan", "createdAt": "2020-03-24T17:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMDE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "chunk": "diff --git a/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\nindex 5d161137040..2c55ba916c8 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n\n@@ -1571,7 +1576,7 @@ public class TimeSeriesLifecycleActionsIT extends ESRestTestCase {\n         assertBusy(() -> assertThat(explainIndex(restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)), 30, TimeUnit.SECONDS);\n     }\n \n-    public void testDeleteActionDeletesGeneratedSnapshot() throws Exception {\n+    public void testDeleteActionDeletesSearchableSnapshot() throws Exception {\n         String snapshotRepo = createSnapshotRepo();\n \n         // create policy with cold and delete phases\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxMTA5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r395911090", "bodyText": "Isn't this index going to be deleted by the policy (time value of 0 to delete), so we should probably just check that the index is missing and then make sure the snapshot still exists?", "author": "dakrone", "createdAt": "2020-03-20T22:09:04Z", "path": "x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java", "diffHunk": "@@ -1545,6 +1548,145 @@ public void testHaltAtEndOfPhase() throws Exception {\n         assertBusy(() -> assertFalse(\"expected \" + index + \" to be deleted by ILM\", indexExists(index)));\n     }\n \n+    public void testSearchableSnapshotAction() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+        createNewSingletonPolicy(\"cold\", new SearchableSnapshotAction(snapshotRepo));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                return indexExists(restoredIndexName);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+\n+        assertBusy(() -> assertThat(explainIndex(restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)), 30, TimeUnit.SECONDS);\n+    }\n+\n+    public void testDeleteActionDeletesGeneratedSnapshot() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+\n+        // create policy with cold and delete phases\n+        Map<String, LifecycleAction> coldActions =\n+            Map.of(SearchableSnapshotAction.NAME, new SearchableSnapshotAction(snapshotRepo));\n+        Map<String, Phase> phases = new HashMap<>();\n+        phases.put(\"cold\", new Phase(\"cold\", TimeValue.ZERO, coldActions));\n+        phases.put(\"delete\", new Phase(\"delete\", TimeValue.ZERO, singletonMap(DeleteAction.NAME, new DeleteAction(true))));\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, phases);\n+        // PUT policy\n+        XContentBuilder builder = jsonBuilder();\n+        lifecyclePolicy.toXContent(builder, null);\n+        final StringEntity entity = new StringEntity(\n+            \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+        Request createPolicyRequest = new Request(\"PUT\", \"_ilm/policy/\" + policy);\n+        createPolicyRequest.setEntity(entity);\n+        assertOK(client().performRequest(createPolicyRequest));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        String[] snapshotName = new String[1];\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                Map<String, Object> explainIndex = explainIndex(restoredIndexName);\n+                String action = (String) explainIndex.get(\"action\");\n+                snapshotName[0] = (String) explainIndex.get(\"snapshot_name\");\n+                return DeleteAction.NAME.equals(action);\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 60, TimeUnit.SECONDS));\n+\n+        assertTrue(\"the snapshot we generate in the cold phase should be deleted by the delete phase\", waitUntil(() -> {\n+            try {\n+                Request getSnapshotsRequest = new Request(\"GET\", \"_snapshot/\" + snapshotRepo + \"/\" + snapshotName[0]);\n+                Response getSnapshotsResponse = client().performRequest(getSnapshotsRequest);\n+                return EntityUtils.toString(getSnapshotsResponse.getEntity()).contains(\"snapshot_missing_exception\");\n+            } catch (IOException e) {\n+                return false;\n+            }\n+        }, 30, TimeUnit.SECONDS));\n+    }\n+\n+    public void testDeleteActionDoesntDeleteGeneratedSnapshot() throws Exception {\n+        String snapshotRepo = createSnapshotRepo();\n+\n+        // create policy with cold and delete phases\n+        Map<String, LifecycleAction> coldActions =\n+            Map.of(SearchableSnapshotAction.NAME, new SearchableSnapshotAction(snapshotRepo));\n+        Map<String, Phase> phases = new HashMap<>();\n+        phases.put(\"cold\", new Phase(\"cold\", TimeValue.ZERO, coldActions));\n+        phases.put(\"delete\", new Phase(\"delete\", TimeValue.ZERO, singletonMap(DeleteAction.NAME, new DeleteAction(false))));\n+        LifecyclePolicy lifecyclePolicy = new LifecyclePolicy(policy, phases);\n+        // PUT policy\n+        XContentBuilder builder = jsonBuilder();\n+        lifecyclePolicy.toXContent(builder, null);\n+        final StringEntity entity = new StringEntity(\n+            \"{ \\\"policy\\\":\" + Strings.toString(builder) + \"}\", ContentType.APPLICATION_JSON);\n+        Request createPolicyRequest = new Request(\"PUT\", \"_ilm/policy/\" + policy);\n+        createPolicyRequest.setEntity(entity);\n+        assertOK(client().performRequest(createPolicyRequest));\n+\n+        createIndexWithSettings(index,\n+            Settings.builder()\n+                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)\n+                .put(LifecycleSettings.LIFECYCLE_NAME, policy),\n+            randomBoolean());\n+\n+        String restoredIndexName = SearchableSnapshotAction.RESTORED_INDEX_PREFIX + this.index;\n+        String[] snapshotName = new String[1];\n+        assertTrue(waitUntil(() -> {\n+            try {\n+                Map<String, Object> explainIndex = explainIndex(restoredIndexName);\n+                String action = (String) explainIndex.get(\"action\");\n+                snapshotName[0] = (String) explainIndex.get(\"snapshot_name\");\n+                return DeleteAction.NAME.equals(action);", "originalCommit": "520d6bb95d77468b5303496a1336c4421ed7d86c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "chunk": "diff --git a/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\nindex 5d161137040..2c55ba916c8 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/test/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n\n@@ -1571,7 +1576,7 @@ public class TimeSeriesLifecycleActionsIT extends ESRestTestCase {\n         assertBusy(() -> assertThat(explainIndex(restoredIndexName).get(\"step\"), is(PhaseCompleteStep.NAME)), 30, TimeUnit.SECONDS);\n     }\n \n-    public void testDeleteActionDeletesGeneratedSnapshot() throws Exception {\n+    public void testDeleteActionDeletesSearchableSnapshot() throws Exception {\n         String snapshotRepo = createSnapshotRepo();\n \n         // create policy with cold and delete phases\n"}}, {"oid": "5e4cf55259fb38419ccfd09de8babbf734d485d9", "url": "https://github.com/elastic/elasticsearch/commit/5e4cf55259fb38419ccfd09de8babbf734d485d9", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-24T14:09:07Z", "type": "commit"}, {"oid": "32e3371870bfe0a8ff2517f338f62792225d64fb", "url": "https://github.com/elastic/elasticsearch/commit/32e3371870bfe0a8ff2517f338f62792225d64fb", "message": "Format code\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-24T17:16:13Z", "type": "commit"}, {"oid": "ac9e9c3c18c8c39aab98b2ca79bb4d9e71168c28", "url": "https://github.com/elastic/elasticsearch/commit/ac9e9c3c18c8c39aab98b2ca79bb4d9e71168c28", "message": "Make CleanupSnapshotStep retryable", "committedDate": "2020-03-24T17:19:20Z", "type": "commit"}, {"oid": "b68b61c1cc6a969d9092f093c8aa543645baf7d9", "url": "https://github.com/elastic/elasticsearch/commit/b68b61c1cc6a969d9092f093c8aa543645baf7d9", "message": "Fix typo\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-24T17:28:38Z", "type": "commit"}, {"oid": "374e50d9c557ce31c51ba998382db2ad7ebc6027", "url": "https://github.com/elastic/elasticsearch/commit/374e50d9c557ce31c51ba998382db2ad7ebc6027", "message": "Format code\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-25T11:21:54Z", "type": "commit"}, {"oid": "4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "url": "https://github.com/elastic/elasticsearch/commit/4f25ce948ef0b3208e268f9ab6b1552a5781afc4", "message": "CreateSnapshotStep request specifies index name", "committedDate": "2020-03-25T11:22:36Z", "type": "commit"}, {"oid": "0f6f3719e35e43de3e214d3a3c0de86fec9834fe", "url": "https://github.com/elastic/elasticsearch/commit/0f6f3719e35e43de3e214d3a3c0de86fec9834fe", "message": "Rename delete action field to delete_searchable_snapshot", "committedDate": "2020-03-25T12:11:44Z", "type": "commit"}, {"oid": "15d39edb48c381e38287d5e6760bc71f9e9db6d9", "url": "https://github.com/elastic/elasticsearch/commit/15d39edb48c381e38287d5e6760bc71f9e9db6d9", "message": "Rename SSA repo field to snapshot_repository (underscore)", "committedDate": "2020-03-25T12:12:15Z", "type": "commit"}, {"oid": "e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "url": "https://github.com/elastic/elasticsearch/commit/e76ff6c8c6df3921f9c2f01d7a1a68dcbbe5ede3", "message": "Fix delete action test assertions", "committedDate": "2020-03-25T12:12:32Z", "type": "commit"}, {"oid": "ff7623fb9188f6fd1542194a1c5beef70bd74df5", "url": "https://github.com/elastic/elasticsearch/commit/ff7623fb9188f6fd1542194a1c5beef70bd74df5", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-25T12:38:10Z", "type": "commit"}, {"oid": "3c56f7373603b542a73e8400b77dbe0a9a4f55f7", "url": "https://github.com/elastic/elasticsearch/commit/3c56f7373603b542a73e8400b77dbe0a9a4f55f7", "message": "Fix doc tests", "committedDate": "2020-03-25T15:36:12Z", "type": "commit"}, {"oid": "06bf054c65fb19193f6fba1e77ec76e2211fe2f7", "url": "https://github.com/elastic/elasticsearch/commit/06bf054c65fb19193f6fba1e77ec76e2211fe2f7", "message": "Change debug level to warn", "committedDate": "2020-03-25T15:36:25Z", "type": "commit"}, {"oid": "c3d785e495cf2fa2c2ad2b4958c8e2f1954970e3", "url": "https://github.com/elastic/elasticsearch/commit/c3d785e495cf2fa2c2ad2b4958c8e2f1954970e3", "message": "Log when we stop waiting for the branch condition", "committedDate": "2020-03-25T15:36:41Z", "type": "commit"}, {"oid": "9d37f78069d40d85d80cca566f150420d12b1fd1", "url": "https://github.com/elastic/elasticsearch/commit/9d37f78069d40d85d80cca566f150420d12b1fd1", "message": "MountSnapshotStep is retries when response is not acked", "committedDate": "2020-03-25T15:37:16Z", "type": "commit"}, {"oid": "985477e2ef48121864bf5e5d840d8134f101d3f9", "url": "https://github.com/elastic/elasticsearch/commit/985477e2ef48121864bf5e5d840d8134f101d3f9", "message": "Doc null handling", "committedDate": "2020-03-25T15:45:04Z", "type": "commit"}, {"oid": "2e4bd2bc1b4a78db0b2009e5e8d14b467667adf6", "url": "https://github.com/elastic/elasticsearch/commit/2e4bd2bc1b4a78db0b2009e5e8d14b467667adf6", "message": "Update info message to be good english", "committedDate": "2020-03-25T15:46:01Z", "type": "commit"}, {"oid": "cd73bd6e97678ead8e4fc814ec86ce6ccbdadd05", "url": "https://github.com/elastic/elasticsearch/commit/cd73bd6e97678ead8e4fc814ec86ce6ccbdadd05", "message": "Use the correct Info class Luke", "committedDate": "2020-03-25T15:48:14Z", "type": "commit"}, {"oid": "0ca1db0ebb4701cade33f9f3fd552887355c5fc4", "url": "https://github.com/elastic/elasticsearch/commit/0ca1db0ebb4701cade33f9f3fd552887355c5fc4", "message": "Cleanup if/else branches that check the snapshot state", "committedDate": "2020-03-25T15:50:31Z", "type": "commit"}, {"oid": "2b467cfa615748b08763476902eacf034a79fe5d", "url": "https://github.com/elastic/elasticsearch/commit/2b467cfa615748b08763476902eacf034a79fe5d", "message": "Log that the swap aliases response was not acked", "committedDate": "2020-03-25T15:57:36Z", "type": "commit"}, {"oid": "5f506ee67070eac1bfd7dc6d381ef27caf879d13", "url": "https://github.com/elastic/elasticsearch/commit/5f506ee67070eac1bfd7dc6d381ef27caf879d13", "message": "SnapshotInProgress null check", "committedDate": "2020-03-25T16:01:47Z", "type": "commit"}, {"oid": "80c9a451b6a6c56bafc3404fc02376941546cf4d", "url": "https://github.com/elastic/elasticsearch/commit/80c9a451b6a6c56bafc3404fc02376941546cf4d", "message": "Fix test", "committedDate": "2020-03-25T21:20:35Z", "type": "commit"}, {"oid": "8ed70c88271aa0c3ebd2707875f9fb9d8e8972e8", "url": "https://github.com/elastic/elasticsearch/commit/8ed70c88271aa0c3ebd2707875f9fb9d8e8972e8", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-26T09:52:26Z", "type": "commit"}, {"oid": "c38e081f076bd2fd1ba618fdea52278206b0ed74", "url": "https://github.com/elastic/elasticsearch/commit/c38e081f076bd2fd1ba618fdea52278206b0ed74", "message": "Delete phase min_age after 5 seconds", "committedDate": "2020-03-26T11:46:02Z", "type": "commit"}, {"oid": "c032d3aee7b2c5852745adb0849573628b0b8b7c", "url": "https://github.com/elastic/elasticsearch/commit/c032d3aee7b2c5852745adb0849573628b0b8b7c", "message": "Checkstyle", "committedDate": "2020-03-26T12:19:34Z", "type": "commit"}, {"oid": "7107b1a0a51aad5cb26ac476120a8acf7e829f27", "url": "https://github.com/elastic/elasticsearch/commit/7107b1a0a51aad5cb26ac476120a8acf7e829f27", "message": "Use underscore in action name too", "committedDate": "2020-03-26T14:53:03Z", "type": "commit"}, {"oid": "5bc6df22a6d9790164185bffcd4be43ca15f20b1", "url": "https://github.com/elastic/elasticsearch/commit/5bc6df22a6d9790164185bffcd4be43ca15f20b1", "message": "Get the generated snapshot name from the original index in test\n\nThis speeds up the test a bit and also avoids a race condition where the\nexplain API will not get a response as the ILM is busy executing cluster\naction steps for the restored index.", "committedDate": "2020-03-27T12:16:19Z", "type": "commit"}, {"oid": "5b7f599156c2eef415cf00a529f359a328c9b62a", "url": "https://github.com/elastic/elasticsearch/commit/5b7f599156c2eef415cf00a529f359a328c9b62a", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:32:09Z", "type": "commit"}, {"oid": "7f1940d48e19cb0abef12d59f06f4932754a422c", "url": "https://github.com/elastic/elasticsearch/commit/7f1940d48e19cb0abef12d59f06f4932754a422c", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:47:26Z", "type": "commit"}, {"oid": "879e7d601828d03e36337363701f1bc9ae4aafab", "url": "https://github.com/elastic/elasticsearch/commit/879e7d601828d03e36337363701f1bc9ae4aafab", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-27T12:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1Mjg3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399352879", "bodyText": "Should we check the acknowledgedResponse here and retry (throw an error) if the request wasn't acknowledged? I think we should", "author": "dakrone", "createdAt": "2020-03-27T15:35:12Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.repositories.RepositoryMissingException;\n+import org.elasticsearch.snapshots.SnapshotMissingException;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Deletes the snapshot designated by the repository and snapshot name present in the lifecycle execution state.\n+ */\n+public class CleanupSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"cleanup-snapshot\";\n+\n+    public CleanupSnapshotStep(StepKey key, StepKey nextStepKey, Client client) {\n+        super(key, nextStepKey, client);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+        final String repositoryName = lifecycleState.getSnapshotRepository();\n+        // if the snapshot information is missing from the ILM execution state there is nothing to delete so we move on\n+        if (Strings.hasText(repositoryName) == false) {\n+            listener.onResponse(true);\n+            return;\n+        }\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onResponse(true);\n+            return;\n+        }\n+        DeleteSnapshotRequest deleteSnapshotRequest = new DeleteSnapshotRequest(repositoryName, snapshotName);\n+        getClient().admin().cluster().deleteSnapshot(deleteSnapshotRequest, new ActionListener<>() {\n+\n+            @Override\n+            public void onResponse(AcknowledgedResponse acknowledgedResponse) {\n+                listener.onResponse(true);", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9bbb9dfd0575cb880a5d30a4dd0eb08867a823fb", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\nindex 9ead34f5c21..8b31771e3da 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CleanupSnapshotStep.java\n\n@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.admin.cluster.snapshots.delete.DeleteSnapshotRequest;\n import org.elasticsearch.action.support.master.AcknowledgedResponse;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxNTYzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399415632", "bodyText": "Super minor, but we can probably stick this before the targetIndexMetadata == null check to avoid an error where no settings are copied?", "author": "dakrone", "createdAt": "2020-03-27T17:08:51Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+/**\n+ * Copy the provided settings from the source to the target index.\n+ * <p>\n+ * The target index is derived from the source index using the provided prefix.\n+ * This is useful for actions like shrink or searchable snapshot that create a new index and migrate the ILM execution from the source\n+ * to the target index.\n+ */\n+public class CopySettingsStep extends ClusterStateActionStep {\n+    public static final String NAME = \"copy-settings\";\n+\n+    private static final Logger logger = LogManager.getLogger(CopySettingsStep.class);\n+\n+    private final String[] settingsKeys;\n+    private final String indexPrefix;\n+\n+    public CopySettingsStep(StepKey key, StepKey nextStepKey, String indexPrefix, String... settingsKeys) {\n+        super(key, nextStepKey);\n+        Objects.requireNonNull(indexPrefix);\n+        Objects.requireNonNull(settingsKeys);\n+        this.indexPrefix = indexPrefix;\n+        this.settingsKeys = settingsKeys;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String[] getSettingsKeys() {\n+        return settingsKeys;\n+    }\n+\n+    public String getIndexPrefix() {\n+        return indexPrefix;\n+    }\n+\n+    @Override\n+    public ClusterState performAction(Index index, ClusterState clusterState) {\n+        String sourceIndexName = index.getName();\n+        IndexMetaData sourceIndexMetadata = clusterState.metaData().index(sourceIndexName);\n+        String targetIndexName = indexPrefix + sourceIndexName;\n+        IndexMetaData targetIndexMetadata = clusterState.metaData().index(targetIndexName);\n+\n+        if (sourceIndexMetadata == null) {\n+            // Index must have been since deleted, ignore it\n+            logger.debug(\"[{}] lifecycle action for index [{}] executed but index no longer exists\", getKey().getAction(), sourceIndexName);\n+            return clusterState;\n+        }\n+\n+        if (targetIndexMetadata == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"index [%s] is being referenced by ILM action [%s] on step [%s] but \" +\n+                \"it doesn't exist\", targetIndexName, getKey().getAction(), getKey().getName());\n+            logger.debug(errorMessage);\n+            throw new IllegalStateException(errorMessage);\n+        }\n+\n+        if (settingsKeys == null || settingsKeys.length == 0) {\n+            return clusterState;\n+        }", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2c61f0063170ca84ffe1db811a49fa00fd7be9fc", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\nindex cfbe1a6cc06..5e32e8cc149 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/CopySettingsStep.java\n\n@@ -65,6 +65,10 @@ public class CopySettingsStep extends ClusterStateActionStep {\n             return clusterState;\n         }\n \n+        if (settingsKeys == null || settingsKeys.length == 0) {\n+            return clusterState;\n+        }\n+\n         if (targetIndexMetadata == null) {\n             String errorMessage = String.format(Locale.ROOT, \"index [%s] is being referenced by ILM action [%s] on step [%s] but \" +\n                 \"it doesn't exist\", targetIndexName, getKey().getAction(), getKey().getName());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxNzIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399417239", "bodyText": "It might be worth having a separate discussion (I can't remember if we discussed it) with David & Co about whether we want the default for this to be true or false (can be had after this PR)", "author": "dakrone", "createdAt": "2020-03-27T17:11:37Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/DeleteAction.java", "diffHunk": "@@ -5,38 +5,63 @@\n  */\n package org.elasticsearch.xpack.core.ilm;\n \n+import org.elasticsearch.Version;\n import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.ParseField;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n-import org.elasticsearch.common.xcontent.ObjectParser;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n import org.elasticsearch.common.xcontent.XContentParser;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Objects;\n \n /**\n  * A {@link LifecycleAction} which deletes the index.\n  */\n public class DeleteAction implements LifecycleAction {\n     public static final String NAME = \"delete\";\n \n-    private static final ObjectParser<DeleteAction, Void> PARSER = new ObjectParser<>(NAME, DeleteAction::new);\n+    public static final ParseField DELETE_SEARCHABLE_SNAPSHOT_FIELD = new ParseField(\"delete_searchable_snapshot\");\n+\n+    private static final ConstructingObjectParser<DeleteAction, Void> PARSER = new ConstructingObjectParser<>(NAME,\n+        a -> new DeleteAction(a[0] == null ? true : (boolean) a[0]));\n+\n+    static {\n+        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), DELETE_SEARCHABLE_SNAPSHOT_FIELD);\n+    }\n \n     public static DeleteAction parse(XContentParser parser) {\n         return PARSER.apply(parser, null);\n     }\n \n+    private final boolean deleteSearchableSnapshot;\n+\n     public DeleteAction() {\n+        this(true);", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxODEzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399418139", "bodyText": "Super minor, but can you put an example name in the docs here like \"for example, the snapshot will be named '2020-01-02-myindex-mypolicy-randomuuid'\"?", "author": "dakrone", "createdAt": "2020-03-27T17:13:10Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.index.Index;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.ILM_CUSTOM_METADATA_KEY;\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Generates a snapshot name for the given index and records it in the index metadata along with the provided snapshot repository.", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "864f4c320c4933b1a0320586cb68c7cc762aa1b4", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\nindex 7bc0b95cdc6..a4d7924e047 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/GenerateSnapshotNameStep.java\n\n@@ -28,6 +28,9 @@ import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndex\n \n /**\n  * Generates a snapshot name for the given index and records it in the index metadata along with the provided snapshot repository.\n+ * <p>\n+ * The generated snapshot name will be in the format {day-indexName-policyName-randomUUID}\n+ * eg.: 2020.03.30-myindex-mypolicy-cmuce-qfvmn_dstqw-ivmjc1etsa\n  */\n public class GenerateSnapshotNameStep extends ClusterStateActionStep {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMDc1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399420759", "bodyText": "Super minor change:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new ElasticsearchException(\"mount snapshot response failed to complete\");\n          \n          \n            \n                                throw new ElasticsearchException(\"mount snapshot response failed to complete, got response \" + response.status());", "author": "dakrone", "createdAt": "2020-03-27T17:17:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.IndexSettings;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotAction;\n+import org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n+\n+import java.util.Objects;\n+\n+import static org.elasticsearch.xpack.core.ilm.LifecycleExecutionState.fromIndexMetadata;\n+\n+/**\n+ * Restores the snapshot created for the designated index via the ILM policy to an index named using the provided prefix appended to the\n+ * designated index name.\n+ */\n+public class MountSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n+    public static final String NAME = \"mount-snapshot\";\n+\n+    private static final Logger logger = LogManager.getLogger(MountSnapshotStep.class);\n+\n+    private final String restoredIndexPrefix;\n+\n+    public MountSnapshotStep(StepKey key, StepKey nextStepKey, Client client, String restoredIndexPrefix) {\n+        super(key, nextStepKey, client);\n+        this.restoredIndexPrefix = restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    public String getRestoredIndexPrefix() {\n+        return restoredIndexPrefix;\n+    }\n+\n+    @Override\n+    void performDuringNoSnapshot(IndexMetaData indexMetaData, ClusterState currentClusterState, Listener listener) {\n+        final String indexName = indexMetaData.getIndex().getName();\n+\n+        LifecycleExecutionState lifecycleState = fromIndexMetadata(indexMetaData);\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        final String snapshotRepository = lifecycleState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            listener.onFailure(new IllegalStateException(\"snapshot repository is not present for policy [\" + policyName + \"] and index [\" +\n+                indexName + \"]\"));\n+            return;\n+        }\n+\n+        final String snapshotName = lifecycleState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            listener.onFailure(\n+                new IllegalStateException(\"snapshot name was not generated for policy [\" + policyName + \"] and index [\" + indexName + \"]\"));\n+            return;\n+        }\n+\n+        String mountedIndexName = restoredIndexPrefix + indexName;\n+        if(currentClusterState.metaData().index(mountedIndexName) != null) {\n+            logger.debug(\"mounted index [{}] for policy [{}] and index [{}] already exists. will not attempt to mount the index again\",\n+                mountedIndexName, policyName, indexName);\n+            listener.onResponse(true);\n+            return;\n+        }\n+\n+        final MountSearchableSnapshotRequest mountSearchableSnapshotRequest = new MountSearchableSnapshotRequest(mountedIndexName,\n+            snapshotRepository, snapshotName, indexName, Settings.builder()\n+            .put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), Boolean.FALSE.toString())\n+            .build(),\n+            // we captured the index metadata when we took the snapshot. the index likely had the ILM execution state in the metadata.\n+            // if we were to restore the lifecycle.name setting, the restored index would be captured by the ILM runner and,\n+            // depending on what ILM execution state was captured at snapshot time, make it's way forward from _that_ step forward in\n+            // the ILM policy.\n+            // we'll re-set this setting on the restored index at a later step once we restored a deterministic execution state\n+            new String[]{LifecycleSettings.LIFECYCLE_NAME},\n+            // we'll not wait for the snapshot to complete in this step as the async steps are executed from threads that shouldn't\n+            // perform expensive operations (ie. clusterStateProcessed)\n+            false);\n+        getClient().execute(MountSearchableSnapshotAction.INSTANCE, mountSearchableSnapshotRequest,\n+            ActionListener.wrap(response -> {\n+                if (response.status() != RestStatus.OK) {\n+                    logger.debug(\"mount snapshot response failed to complete\");\n+                    throw new ElasticsearchException(\"mount snapshot response failed to complete\");", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "64a903d5bd9234e1f985c15ec0b1389738d1ab9e", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\nindex f87ebff61f9..5b11293f392 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/MountSnapshotStep.java\n\n@@ -94,7 +94,7 @@ public class MountSnapshotStep extends AsyncRetryDuringSnapshotActionStep {\n             ActionListener.wrap(response -> {\n                 if (response.status() != RestStatus.OK) {\n                     logger.debug(\"mount snapshot response failed to complete\");\n-                    throw new ElasticsearchException(\"mount snapshot response failed to complete\");\n+                    throw new ElasticsearchException(\"mount snapshot response failed to complete, got response \" + response.status());\n                 }\n                 listener.onResponse(true);\n             }, listener::onFailure));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMTMyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399421326", "bodyText": "I think this might be linking to the wrong thing, maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n          \n          \n            \n                 * {@link OnAsyncWaitBranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.", "author": "dakrone", "createdAt": "2020-03-27T17:18:34Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+\n+import java.util.Objects;\n+\n+/**\n+ * This step changes its {@link #getNextStepKey()} depending on the result of an {@link AsyncWaitStep}.\n+ * <p>\n+ * The next step key will point towards the \"wait action fulfilled\" step when the condition of the async action is met, and towards the\n+ * \"wait action unfulfilled\" step when the client instructs they'd like to stop waiting for the condition using the\n+ * {@link BranchingStepListener#onStopWaitingAndMoveToNextKey(ToXContentObject)}.\n+ * <p>\n+ * If the async action that's branching the execution results in a failure, the {@link #getNextStepKey()} is not set (as ILM would move\n+ * into the {@link ErrorStep} step).\n+ */\n+public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n+    public static final String NAME = \"async-branch\";\n+\n+    private static final Logger logger = LogManager.getLogger(OnAsyncWaitBranchingStep.class);\n+\n+    private StepKey nextStepKeyUnfulfilledWaitAction;\n+    private StepKey nextStepKeyFulfilledWaitAction;\n+    private TriConsumer<Client, IndexMetaData, BranchingStepListener> asyncWaitAction;\n+    private SetOnce<Boolean> onCompleteConditionMet;\n+\n+    /**\n+     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e4ede4c8d37e4f57615bc22a432d6dc9c206bc9", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\nindex 2ae4b4e7d81..0adf99894a7 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/OnAsyncWaitBranchingStep.java\n\n@@ -38,7 +38,7 @@ public class OnAsyncWaitBranchingStep extends AsyncWaitStep {\n     private SetOnce<Boolean> onCompleteConditionMet;\n \n     /**\n-     * {@link BranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n+     * {@link OnAsyncWaitBranchingStep} is a step whose next step is based on the {@link #asyncWaitAction} condition being met or not.\n      *\n      * @param key                                the step's key\n      * @param nextStepKeyUnfulfilledWaitAction the key of the step to run if the client decides to stop waiting for the condition to be\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNjU0NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r399426544", "bodyText": "I actually think we need to return true here, it's possible that the snapshot was taken and completed (prior to the step being updated), and then the cluster was restarted, so the SnapshotsInProgress is null and won't ever exist because the snapshot was successful, best to err on the side of moving forward and doing a check than be wedged I think", "author": "dakrone", "createdAt": "2020-03-27T17:27:15Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.SnapshotsInProgress;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.Index;\n+import org.elasticsearch.snapshots.SnapshotInfo;\n+import org.elasticsearch.snapshots.SnapshotsService;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n+ * contain an entry for the snapshot we've triggered)\n+ */\n+public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n+\n+    public static final String NAME = \"wait-for-snapshot\";\n+    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n+\n+    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n+        super(key, nextStepKey);\n+    }\n+\n+    @Override\n+    public boolean isRetryable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Result isConditionMet(Index index, ClusterState clusterState) {\n+        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n+        String indexName = index.getName();\n+\n+        if (indexMetaData == null) {\n+            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n+                getKey().getAction(), indexName);\n+            // Index must have been since deleted\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+\n+        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n+        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n+        final String snapshotRepository = executionState.getSnapshotRepository();\n+        if (Strings.hasText(snapshotRepository) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final String snapshotName = executionState.getSnapshotName();\n+        if (Strings.hasText(snapshotName) == false) {\n+            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n+                policyName, indexName);\n+            logger.debug(errorMessage);\n+            return new Result(false, new Info(errorMessage));\n+        }\n+        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n+        // we got here before the cluster state was updated with the (or any) snapshot being started, so we'll wait\n+        if (snapshotsInProgress == null) {\n+            return new Result(false, new Info(String.format(Locale.ROOT,\n+                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));", "originalCommit": "879e7d601828d03e36337363701f1bc9ae4aafab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA1MzYxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401053611", "bodyText": "Deleted the WaitForSnapshotInProgressStep altogether as we'll design a step that waits for a generation change in the repo metadata in a subsequent PR.", "author": "andreidan", "createdAt": "2020-03-31T16:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNjU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "ac574b218493a9436f398882224b35da55bf89fd", "chunk": "diff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\ndeleted file mode 100644\nindex 73fb23d5aa5..00000000000\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ilm/WaitForSnapshotInProgressStep.java\n+++ /dev/null\n\n@@ -1,127 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License;\n- * you may not use this file except in compliance with the Elastic License.\n- */\n-package org.elasticsearch.xpack.core.ilm;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.cluster.ClusterState;\n-import org.elasticsearch.cluster.SnapshotsInProgress;\n-import org.elasticsearch.cluster.metadata.IndexMetaData;\n-import org.elasticsearch.common.ParseField;\n-import org.elasticsearch.common.Strings;\n-import org.elasticsearch.common.xcontent.ToXContentObject;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n-import org.elasticsearch.index.Index;\n-import org.elasticsearch.snapshots.SnapshotInfo;\n-import org.elasticsearch.snapshots.SnapshotsService;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.stream.Collectors;\n-\n-/**\n- * After we triggered a snapshot we'll wait until the snapshot is not executing anymore (ie. the SnapshotInProgress meta data doesn't\n- * contain an entry for the snapshot we've triggered)\n- */\n-public class WaitForSnapshotInProgressStep extends ClusterStateWaitStep {\n-\n-    public static final String NAME = \"wait-for-snapshot\";\n-    private static final Logger logger = LogManager.getLogger(WaitForSnapshotInProgressStep.class);\n-\n-    WaitForSnapshotInProgressStep(StepKey key, StepKey nextStepKey) {\n-        super(key, nextStepKey);\n-    }\n-\n-    @Override\n-    public boolean isRetryable() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Result isConditionMet(Index index, ClusterState clusterState) {\n-        IndexMetaData indexMetaData = clusterState.metaData().index(index);\n-        String indexName = index.getName();\n-\n-        if (indexMetaData == null) {\n-            String errorMessage = String.format(Locale.ROOT, \"[%s] lifecycle action for index [%s] executed but index no longer exists\",\n-                getKey().getAction(), indexName);\n-            // Index must have been since deleted\n-            logger.debug(errorMessage);\n-            return new Result(false, new Info(errorMessage));\n-        }\n-\n-        String policyName = indexMetaData.getSettings().get(LifecycleSettings.LIFECYCLE_NAME);\n-        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(indexMetaData);\n-        final String snapshotRepository = executionState.getSnapshotRepository();\n-        if (Strings.hasText(snapshotRepository) == false) {\n-            String errorMessage = String.format(Locale.ROOT, \"snapshot repository is not present for policy [%s] and index [%s]\",\n-                policyName, indexName);\n-            logger.debug(errorMessage);\n-            return new Result(false, new Info(errorMessage));\n-        }\n-        final String snapshotName = executionState.getSnapshotName();\n-        if (Strings.hasText(snapshotName) == false) {\n-            String errorMessage = String.format(Locale.ROOT, \"snapshot name was not generated for policy [%s] and index [%s]\",\n-                policyName, indexName);\n-            logger.debug(errorMessage);\n-            return new Result(false, new Info(errorMessage));\n-        }\n-        final SnapshotsInProgress snapshotsInProgress = clusterState.custom(SnapshotsInProgress.TYPE);\n-        // we got here before the cluster state was updated with the (or any) snapshot being started, so we'll wait\n-        if (snapshotsInProgress == null) {\n-            return new Result(false, new Info(String.format(Locale.ROOT,\n-                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n-        }\n-        List<SnapshotInfo> repositorySnapshots = SnapshotsService.currentSnapshots(snapshotsInProgress, snapshotRepository);\n-        List<SnapshotInfo> configuredSnapshotInProgress =\n-            repositorySnapshots.stream().filter(si -> si.snapshotId().getName().equals(snapshotName)).collect(Collectors.toList());\n-\n-        if (configuredSnapshotInProgress.isEmpty()) {\n-            return new Result(true, null);\n-        } else {\n-            return new Result(false, new Info(String.format(Locale.ROOT,\n-                \"snapshot [%s] generated by policy [%s] for index [%s] is still in progress\", snapshotName, policyName, indexName)));\n-        }\n-    }\n-\n-    static final class Info implements ToXContentObject {\n-\n-        private final String message;\n-\n-        static final ParseField MESSAGE = new ParseField(\"message\");\n-\n-        Info(String message) {\n-            this.message = message;\n-        }\n-\n-        @Override\n-        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n-            builder.startObject();\n-            builder.field(MESSAGE.getPreferredName(), message);\n-            builder.endObject();\n-            return builder;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (o == null || getClass() != o.getClass()) {\n-                return false;\n-            }\n-            Info info = (Info) o;\n-            return Objects.equals(message, info.message);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(message);\n-        }\n-    }\n-}\n"}}, {"oid": "01222af9d73ca08f70b7a0c19b6223994b746588", "url": "https://github.com/elastic/elasticsearch/commit/01222af9d73ca08f70b7a0c19b6223994b746588", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-30T15:53:12Z", "type": "commit"}, {"oid": "64a903d5bd9234e1f985c15ec0b1389738d1ab9e", "url": "https://github.com/elastic/elasticsearch/commit/64a903d5bd9234e1f985c15ec0b1389738d1ab9e", "message": "Update exception message\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-30T15:57:41Z", "type": "commit"}, {"oid": "6e4ede4c8d37e4f57615bc22a432d6dc9c206bc9", "url": "https://github.com/elastic/elasticsearch/commit/6e4ede4c8d37e4f57615bc22a432d6dc9c206bc9", "message": "Update javadoc\n\nCo-Authored-By: Lee Hinman <dakrone@users.noreply.github.com>", "committedDate": "2020-03-30T15:58:21Z", "type": "commit"}, {"oid": "864f4c320c4933b1a0320586cb68c7cc762aa1b4", "url": "https://github.com/elastic/elasticsearch/commit/864f4c320c4933b1a0320586cb68c7cc762aa1b4", "message": "Add example of generated snapshot name", "committedDate": "2020-03-30T16:08:06Z", "type": "commit"}, {"oid": "9bbb9dfd0575cb880a5d30a4dd0eb08867a823fb", "url": "https://github.com/elastic/elasticsearch/commit/9bbb9dfd0575cb880a5d30a4dd0eb08867a823fb", "message": "Fail CleanupSnapshotStep if the request is not acked", "committedDate": "2020-03-30T16:35:35Z", "type": "commit"}, {"oid": "2c61f0063170ca84ffe1db811a49fa00fd7be9fc", "url": "https://github.com/elastic/elasticsearch/commit/2c61f0063170ca84ffe1db811a49fa00fd7be9fc", "message": "Move empty settings check before target index check", "committedDate": "2020-03-30T16:39:21Z", "type": "commit"}, {"oid": "ac574b218493a9436f398882224b35da55bf89fd", "url": "https://github.com/elastic/elasticsearch/commit/ac574b218493a9436f398882224b35da55bf89fd", "message": "Delete WaitForSnapshotInProgressStepTests\n\nWe'll add a new way to save snapshot status api calls based on the\nrepository data generation in a future PR.", "committedDate": "2020-03-31T16:06:23Z", "type": "commit"}, {"oid": "567d067c116e335f97bbb5decf64c7623a78dcc4", "url": "https://github.com/elastic/elasticsearch/commit/567d067c116e335f97bbb5decf64c7623a78dcc4", "message": "Merge branch 'feature/searchable-snapshots' into ilm-searchable-snapshot-action", "committedDate": "2020-03-31T16:11:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401089093", "bodyText": "Super minor, but there's a typo here (and in the name of the file):\nSearchableSnaposhotActionTests vs\nSearchableSnapshotActionTests", "author": "dakrone", "createdAt": "2020-03-31T17:29:16Z", "path": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnaposhotActionTests.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.ilm;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusAction;\n+import org.elasticsearch.action.admin.cluster.snapshots.status.SnapshotsStatusRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.client.NoOpClient;\n+import org.elasticsearch.xpack.core.ilm.OnAsyncWaitBranchingStep.BranchingStepListener;\n+import org.elasticsearch.xpack.core.ilm.Step.StepKey;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.NAME;\n+import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.getCheckSnapshotStatusAsyncAction;\n+import static org.hamcrest.Matchers.is;\n+\n+public class SearchableSnaposhotActionTests extends AbstractActionTestCase<SearchableSnapshotAction> {", "originalCommit": "567d067c116e335f97bbb5decf64c7623a78dcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NzM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401157382", "bodyText": "Ah, it was hard to spot the typo, great eyes, thanks @dakrone !\nRegarding the action name, I renamed it to \"searchable_snapshot\" (lowercase) on purpose when we renamed \"snapshot-repository\" to \"snapshot_repository\" as I thought it was confusing to have a configuration that mixes scores and underscores eg.:\n  \"searchable-snapshot\" : { \n    \"snapshot_repository\" : \"snapshotRepositoryName\"\n  }\n\nI using underscores everywhere employs less cognitive load:\n  \"searchable_snapshot\" : { \n    \"snapshot_repository\" : \"snapshotRepositoryName\"\n  }", "author": "andreidan", "createdAt": "2020-03-31T19:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTIzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401159235", "bodyText": "The other \"composed\" action we have is set_priority so it would be inconsistent to use scores. If you don't have a strong opinion on this, I think I'd prefer we use underscores everywhere.", "author": "andreidan", "createdAt": "2020-03-31T19:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MDk5NA==", "url": "https://github.com/elastic/elasticsearch/pull/52585#discussion_r401190994", "bodyText": "I read the other one as the step name rather than the action name, I agree that the action name should use underscores (like our other ones), sorry about that!", "author": "dakrone", "createdAt": "2020-03-31T20:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA4OTA5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b766806365d2a48157207275c3ca48f85c95fb8b", "chunk": "diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnaposhotActionTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotActionTests.java\nsimilarity index 98%\nrename from x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnaposhotActionTests.java\nrename to x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotActionTests.java\nindex 5e4981ce284..f6a8808154a 100644\n--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnaposhotActionTests.java\n+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/SearchableSnapshotActionTests.java\n\n@@ -30,7 +30,7 @@ import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.NAME;\n import static org.elasticsearch.xpack.core.ilm.SearchableSnapshotAction.getCheckSnapshotStatusAsyncAction;\n import static org.hamcrest.Matchers.is;\n \n-public class SearchableSnaposhotActionTests extends AbstractActionTestCase<SearchableSnapshotAction> {\n+public class SearchableSnapshotActionTests extends AbstractActionTestCase<SearchableSnapshotAction> {\n \n     @Override\n     public void testToSteps() {\n"}}, {"oid": "b766806365d2a48157207275c3ca48f85c95fb8b", "url": "https://github.com/elastic/elasticsearch/commit/b766806365d2a48157207275c3ca48f85c95fb8b", "message": "Fix typo", "committedDate": "2020-03-31T19:23:45Z", "type": "commit"}]}