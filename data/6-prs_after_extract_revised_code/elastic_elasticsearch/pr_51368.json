{"pr_number": 51368, "pr_title": "[Transform] avoid mapping problems with index templates", "pr_createdAt": "2020-01-23T18:50:34Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51368", "timeline": [{"oid": "54ecb1ff2f79a892a450ba3a8dfb0a0517382257", "url": "https://github.com/elastic/elasticsearch/commit/54ecb1ff2f79a892a450ba3a8dfb0a0517382257", "message": "insert explict mappings for objects in nested output to avoid clashes with\nindex templates\n\nfixes #51321", "committedDate": "2020-01-23T16:10:35Z", "type": "commit"}, {"oid": "d657711a74353466507f767eae17ab633a24a621", "url": "https://github.com/elastic/elasticsearch/commit/d657711a74353466507f767eae17ab633a24a621", "message": "add unit test", "committedDate": "2020-01-23T18:37:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r370293842", "bodyText": "essential change in this file, called on line 176", "author": "hendrikmuhs", "createdAt": "2020-01-23T18:51:18Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {", "originalCommit": "d657711a74353466507f767eae17ab633a24a621", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NzY2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371287665", "bodyText": "\ud83d\udc4d thanks for differentiating the code changes from the formatting changes", "author": "davidkyle", "createdAt": "2020-01-27T14:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Mzg0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjQ3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371276475", "bodyText": "An empty string would also return -1. Do you mean disallow strings containing a single '.' that is at the beginning? Wouldn't that be an error case anyway?\nI ran a quick check in jshell:\njshell> \"\".lastIndexOf('.')\n$3 ==> -1", "author": "davidkyle", "createdAt": "2020-01-27T14:38:41Z", "path": "x-pack/plugin/transform/src/main/java/org/elasticsearch/xpack/transform/transforms/pivot/SchemaUtil.java", "diffHunk": "@@ -165,34 +171,75 @@ public static void getDestinationFieldMappings(final Client client,\n                 targetMapping.put(targetFieldName, \"keyword\");\n             }\n         });\n+\n+        // insert object mappings for nested fields\n+        insertNestedObjectMappings(targetMapping);\n+\n         return targetMapping;\n     }\n \n     /*\n      * Very \"magic\" helper method to extract the source mappings\n      */\n-    private static void getSourceFieldMappings(Client client, String[] index, String[] fields,\n-                                               ActionListener<Map<String, String>> listener) {\n-        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest()\n-            .indices(index)\n+    private static void getSourceFieldMappings(\n+        Client client,\n+        String[] index,\n+        String[] fields,\n+        ActionListener<Map<String, String>> listener\n+    ) {\n+        FieldCapabilitiesRequest fieldCapabilitiesRequest = new FieldCapabilitiesRequest().indices(index)\n             .fields(fields)\n             .indicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN);\n-        client.execute(FieldCapabilitiesAction.INSTANCE, fieldCapabilitiesRequest, ActionListener.wrap(\n-            response -> listener.onResponse(extractFieldMappings(response)),\n-            listener::onFailure));\n+        client.execute(\n+            FieldCapabilitiesAction.INSTANCE,\n+            fieldCapabilitiesRequest,\n+            ActionListener.wrap(response -> listener.onResponse(extractFieldMappings(response)), listener::onFailure)\n+        );\n     }\n \n     private static Map<String, String> extractFieldMappings(FieldCapabilitiesResponse response) {\n         Map<String, String> extractedTypes = new HashMap<>();\n \n-        response.get().forEach((fieldName, capabilitiesMap) -> {\n-            // TODO: overwrites types, requires resolve if\n-            // types are mixed\n-            capabilitiesMap.forEach((name, capability) -> {\n-                logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n-                extractedTypes.put(fieldName, capability.getType());\n-            });\n-        });\n+        response.get()\n+            .forEach(\n+                (fieldName, capabilitiesMap) -> {\n+                    // TODO: overwrites types, requires resolve if\n+                    // types are mixed\n+                    capabilitiesMap.forEach((name, capability) -> {\n+                        logger.trace(\"Extracted type for [{}] : [{}]\", fieldName, capability.getType());\n+                        extractedTypes.put(fieldName, capability.getType());\n+                    });\n+                }\n+            );\n         return extractedTypes;\n     }\n+\n+    /**\n+     * Insert object mappings for fields like:\n+     *\n+     * a.b.c : some_type\n+     *\n+     * in which case it creates additional mappings:\n+     *\n+     * a.b : object\n+     * a : object\n+     *\n+     * avoids snafu with index templates injecting incompatible mappings\n+     *\n+     * @param fieldMappings field mappings to inject to\n+     */\n+    static void insertNestedObjectMappings(Map<String, String> fieldMappings) {\n+        Map<String, String> additionalMappings = new HashMap<>();\n+        fieldMappings.keySet().stream().filter(key -> key.contains(\".\")).forEach(key -> {\n+            int pos;\n+            String objectKey = key;\n+            // lastIndexOf returns -1 on mismatch, but to disallow empty strings check for > 0", "originalCommit": "d657711a74353466507f767eae17ab633a24a621", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMxODk0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/51368#discussion_r371318949", "bodyText": "yes, when I worked on this PR, I discovered that you could create fields with '.' at start or end, which did not work properly (e.g. bulk indexing errors). I fixed it in #51369.\nSo, you are right: this code is \"defense in depth\".", "author": "hendrikmuhs", "createdAt": "2020-01-27T15:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjQ3NQ=="}], "type": "inlineReview", "revised_code": null}]}