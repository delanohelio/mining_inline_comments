{"pr_number": 56371, "pr_title": "Speed up time interval arounding around dst", "pr_createdAt": "2020-05-07T17:22:04Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56371", "timeline": [{"oid": "825fbfee08625b865884564612adcff65cf7524d", "url": "https://github.com/elastic/elasticsearch/commit/825fbfee08625b865884564612adcff65cf7524d", "message": "Speed up time interval arounding around dst\n\nWhen an index spans a daylight savings time transition we can't use our\noptimization that rewrites the requested time zone to a fixed time zone\nand instead we used to fall back to a java.util.time based rounding\nimplementation. In #55559 we optimized \"time unit\" rounding. This\noptimizes \"time interval\" rounding.\n\nThe java.util.time based implementation is about 1650% slower than the\nrounding implementation for a fixed time zone. This replaces it with a\nsimilar optimization that is only about 30% slower than the fixed time\nzone. The java.util.time implementation allocates a ton of short lived\nobjects but the optimized implementation doesn't. So it *might* end up\nbeing faster than the microbenchmarks imply.", "committedDate": "2020-05-07T17:07:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2ODM1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421668352", "bodyText": "I renamed this method because the name seemed wrong to me when I read it this time around.", "author": "nik9000", "createdAt": "2020-05-07T17:22:30Z", "path": "server/src/main/java/org/elasticsearch/common/LocalTimeOffset.java", "diffHunk": "@@ -91,7 +91,7 @@ public static Lookup lookup(ZoneId zone, long minUtcMillis, long maxUtcMillis) {\n      *\n      * @return a lookup function of {@code null} if none could be built \n      */\n-    public static LocalTimeOffset lookupFixedOffset(ZoneId zone) {\n+    public static LocalTimeOffset fixedOffset(ZoneId zone) {", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2ODc1NA==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421668754", "bodyText": "These add support for time interval rounding.", "author": "nik9000", "createdAt": "2020-05-07T17:23:08Z", "path": "benchmarks/src/main/java/org/elasticsearch/common/RoundingBenchmark.java", "diffHunk": "@@ -60,8 +62,8 @@\n     @Param({ \"UTC\", \"America/New_York\" })\n     public String zone;\n \n-    @Param({ \"MONTH_OF_YEAR\", \"HOUR_OF_DAY\" })\n-    public String timeUnit;\n+    @Param({ \"calendar year\", \"calendar hour\", \"10d\", \"5d\", \"1h\" })\n+    public String interval;", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2ODk4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421668982", "bodyText": "Removed silly ; because it made my eyes hurt.", "author": "nik9000", "createdAt": "2020-05-07T17:23:32Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -555,7 +555,7 @@ public long inGap(long localMillis, Gap gap) {\n             @Override\n             public long beforeGap(long localMillis, Gap gap) {\n                 return gap.previous().localToUtc(localMillis, this);\n-            };\n+            }", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTE4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421669186", "bodyText": "We don't need this any more because we can just ask the lookup if it is fixed across the bounds we need.", "author": "nik9000", "createdAt": "2020-05-07T17:23:55Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -739,21 +739,15 @@ public final long nextRoundingValue(long utcMillis) {\n \n     static class TimeIntervalRounding extends Rounding {\n         static final byte ID = 2;\n-        /** Since, there is no offset of -1 ms, it is safe to use -1 for non-fixed timezones */\n-        private static final long TZ_OFFSET_NON_FIXED = -1;\n \n         private final long interval;\n         private final ZoneId timeZone;\n-        /** For fixed offset timezones, this is the offset in milliseconds, otherwise TZ_OFFSET_NON_FIXED */\n-        private final long fixedOffsetMillis;", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTQzMA==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421669430", "bodyText": "And here we go with the actual change!", "author": "nik9000", "createdAt": "2020-05-07T17:24:19Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -773,88 +767,32 @@ public byte id() {\n \n         @Override\n         public Prepared prepare(long minUtcMillis, long maxUtcMillis) {\n-            return prepareForUnknown();\n+            long minLookup = minUtcMillis - interval;", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTc0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421669749", "bodyText": "This is pretty much what we used to do. It ain't fast, but we can make it faster later.", "author": "nik9000", "createdAt": "2020-05-07T17:24:52Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -888,6 +826,133 @@ public boolean equals(Object obj) {\n         public String toString() {\n             return \"Rounding[\" + interval + \" in \" + timeZone + \"]\";\n         }\n+\n+        private long roundKey(long value, long interval) {\n+            if (value < 0) {\n+                return (value - interval + 1) / interval;\n+            } else {\n+                return value / interval;\n+            }\n+        }\n+\n+        private class FixedRounding implements Prepared {\n+            private final LocalTimeOffset offset;\n+\n+            FixedRounding(LocalTimeOffset offset) {\n+                this.offset = offset;\n+            }\n+\n+            @Override\n+            public long round(long utcMillis) {\n+                return offset.localToUtcInThisOffset(roundKey(offset.utcToLocalTime(utcMillis), interval) * interval);\n+            }\n+\n+            @Override\n+            public long nextRoundingValue(long utcMillis) {\n+                // TODO this is used in date range's collect so we should optimize it too", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b13110f01425b19006d8ba87a288f57b87a73ec2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 81c4ca4d86f..4a49a5ff3e7 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -835,6 +835,15 @@ public abstract class Rounding implements Writeable {\n             }\n         }\n \n+        /**\n+         * Rounds to down inside of a time zone with an \"effectively fixed\"\n+         * time zone. A time zone can be \"effectively fixed\" if:\n+         * <ul>\n+         * <li>It is UTC</li>\n+         * <li>It is a fixed offset from UTC at all times (UTC-5, America/Phoenix)</li>\n+         * <li>It is fixed over the entire range of dates that will be rounded</li>\n+         * </ul>\n+         */\n         private class FixedRounding implements Prepared {\n             private final LocalTimeOffset offset;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421669896", "bodyText": "This is just shuffled from where it used to be.", "author": "nik9000", "createdAt": "2020-05-07T17:25:08Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -888,6 +826,133 @@ public boolean equals(Object obj) {\n         public String toString() {\n             return \"Rounding[\" + interval + \" in \" + timeZone + \"]\";\n         }\n+\n+        private long roundKey(long value, long interval) {\n+            if (value < 0) {\n+                return (value - interval + 1) / interval;\n+            } else {\n+                return value / interval;\n+            }\n+        }\n+\n+        private class FixedRounding implements Prepared {\n+            private final LocalTimeOffset offset;\n+\n+            FixedRounding(LocalTimeOffset offset) {\n+                this.offset = offset;\n+            }\n+\n+            @Override\n+            public long round(long utcMillis) {\n+                return offset.localToUtcInThisOffset(roundKey(offset.utcToLocalTime(utcMillis), interval) * interval);\n+            }\n+\n+            @Override\n+            public long nextRoundingValue(long utcMillis) {\n+                // TODO this is used in date range's collect so we should optimize it too\n+                return new JavaTimeRounding().nextRoundingValue(utcMillis);\n+            }\n+        }\n+\n+        private class VariableRounding implements Prepared, LocalTimeOffset.Strategy {\n+            private final LocalTimeOffset.Lookup lookup;\n+\n+            VariableRounding(LocalTimeOffset.Lookup lookup) {\n+                this.lookup = lookup;\n+            }\n+\n+            @Override\n+            public long round(long utcMillis) {\n+                LocalTimeOffset offset = lookup.lookup(utcMillis);\n+                return offset.localToUtc(roundKey(offset.utcToLocalTime(utcMillis), interval) * interval, this);\n+            }\n+\n+            @Override\n+            public long nextRoundingValue(long utcMillis) {\n+                // TODO this is used in date range's collect so we should optimize it too\n+                return new JavaTimeRounding().nextRoundingValue(utcMillis);\n+            }\n+\n+            @Override\n+            public long inGap(long localMillis, Gap gap) {\n+                return gap.startUtcMillis();\n+            }\n+\n+            @Override\n+            public long beforeGap(long localMillis, Gap gap) {\n+                return gap.previous().localToUtc(localMillis, this);\n+            }\n+\n+            @Override\n+            public long inOverlap(long localMillis, Overlap overlap) {\n+                // Convert the overlap at this offset because that'll produce the largest result.\n+                return overlap.localToUtcInThisOffset(localMillis);\n+            }\n+\n+            @Override\n+            public long beforeOverlap(long localMillis, Overlap overlap) {\n+                return overlap.previous().localToUtc(roundKey(overlap.firstNonOverlappingLocalTime() - 1, interval) * interval, this);\n+            }\n+        }\n+\n+\n+        private class JavaTimeRounding implements Prepared {\n+            @Override\n+            public long round(long utcMillis) {", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b13110f01425b19006d8ba87a288f57b87a73ec2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 81c4ca4d86f..4a49a5ff3e7 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -835,6 +835,15 @@ public abstract class Rounding implements Writeable {\n             }\n         }\n \n+        /**\n+         * Rounds to down inside of a time zone with an \"effectively fixed\"\n+         * time zone. A time zone can be \"effectively fixed\" if:\n+         * <ul>\n+         * <li>It is UTC</li>\n+         * <li>It is a fixed offset from UTC at all times (UTC-5, America/Phoenix)</li>\n+         * <li>It is fixed over the entire range of dates that will be rounded</li>\n+         * </ul>\n+         */\n         private class FixedRounding implements Prepared {\n             private final LocalTimeOffset offset;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDcwMg==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421670702", "bodyText": "These were fun examples that came up in the random tests that failed. It makes it a ton easier to rerun them if I pull them out like this.", "author": "nik9000", "createdAt": "2020-05-07T17:26:25Z", "path": "server/src/test/java/org/elasticsearch/common/RoundingTests.java", "diffHunk": "@@ -778,6 +803,18 @@ public void testPrepareLongRangeRoundsNotToMidnight() {\n         assertThat(prepared.round(time(\"9000-03-31T15:25:15.148Z\")), isDate(time(\"9000-03-31T15:00:00Z\"), tz));\n     }\n \n+    public void testIntervalBeforeGap() {", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcwMTU4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421701585", "bodyText": "Can you add a comment/javadoc to this, please?  It's unclear to me why this particular data would be problematic", "author": "not-napoleon", "createdAt": "2020-05-07T18:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDcwMg=="}], "type": "inlineReview", "revised_code": {"commit": "8ed00223338d16c028eff115716210e7ef8d03f8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/common/RoundingTests.java b/server/src/test/java/org/elasticsearch/common/RoundingTests.java\nindex b121e3f4ac8..2f32398ed28 100644\n--- a/server/src/test/java/org/elasticsearch/common/RoundingTests.java\n+++ b/server/src/test/java/org/elasticsearch/common/RoundingTests.java\n\n@@ -803,12 +803,20 @@ public class RoundingTests extends ESTestCase {\n         assertThat(prepared.round(time(\"9000-03-31T15:25:15.148Z\")), isDate(time(\"9000-03-31T15:00:00Z\"), tz));\n     }\n \n+    /**\n+     * Example of when we round past when local clocks were wound forward.\n+     */\n     public void testIntervalBeforeGap() {\n         ZoneId tz = ZoneId.of(\"Africa/Cairo\");\n         Rounding rounding = Rounding.builder(TimeValue.timeValueDays(257)).timeZone(tz).build();\n         assertThat(rounding.round(time(\"1969-07-08T09:00:14.599Z\")), isDate(time(\"1969-04-18T22:00:00Z\"), tz));\n     }\n \n+    /**\n+     * Example of when we round past when local clocks were wound backwards,\n+     * <strong>and</strong> then past the time they were wound forwards before\n+     * that. So, we jumped back a long, long way.\n+     */\n     public void testIntervalTwoTransitions() {\n         ZoneId tz = ZoneId.of(\"America/Detroit\");\n         Rounding rounding = Rounding.builder(TimeValue.timeValueDays(279)).timeZone(tz).build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5NjQzNg==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421696436", "bodyText": "I know this is private, but I still think a bit of javadoc to explain when you want Variable and when you want Fixed would help future generations.", "author": "not-napoleon", "createdAt": "2020-05-07T18:09:06Z", "path": "server/src/main/java/org/elasticsearch/common/Rounding.java", "diffHunk": "@@ -888,6 +826,133 @@ public boolean equals(Object obj) {\n         public String toString() {\n             return \"Rounding[\" + interval + \" in \" + timeZone + \"]\";\n         }\n+\n+        private long roundKey(long value, long interval) {\n+            if (value < 0) {\n+                return (value - interval + 1) / interval;\n+            } else {\n+                return value / interval;\n+            }\n+        }\n+\n+        private class FixedRounding implements Prepared {\n+            private final LocalTimeOffset offset;\n+\n+            FixedRounding(LocalTimeOffset offset) {\n+                this.offset = offset;\n+            }\n+\n+            @Override\n+            public long round(long utcMillis) {\n+                return offset.localToUtcInThisOffset(roundKey(offset.utcToLocalTime(utcMillis), interval) * interval);\n+            }\n+\n+            @Override\n+            public long nextRoundingValue(long utcMillis) {\n+                // TODO this is used in date range's collect so we should optimize it too\n+                return new JavaTimeRounding().nextRoundingValue(utcMillis);\n+            }\n+        }\n+\n+        private class VariableRounding implements Prepared, LocalTimeOffset.Strategy {", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b13110f01425b19006d8ba87a288f57b87a73ec2", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/Rounding.java b/server/src/main/java/org/elasticsearch/common/Rounding.java\nindex 81c4ca4d86f..4a49a5ff3e7 100644\n--- a/server/src/main/java/org/elasticsearch/common/Rounding.java\n+++ b/server/src/main/java/org/elasticsearch/common/Rounding.java\n\n@@ -835,6 +835,15 @@ public abstract class Rounding implements Writeable {\n             }\n         }\n \n+        /**\n+         * Rounds to down inside of a time zone with an \"effectively fixed\"\n+         * time zone. A time zone can be \"effectively fixed\" if:\n+         * <ul>\n+         * <li>It is UTC</li>\n+         * <li>It is a fixed offset from UTC at all times (UTC-5, America/Phoenix)</li>\n+         * <li>It is fixed over the entire range of dates that will be rounded</li>\n+         * </ul>\n+         */\n         private class FixedRounding implements Prepared {\n             private final LocalTimeOffset offset;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5OTY4NA==", "url": "https://github.com/elastic/elasticsearch/pull/56371#discussion_r421699684", "bodyText": "This is a good test.  I like this test.", "author": "not-napoleon", "createdAt": "2020-05-07T18:14:40Z", "path": "server/src/test/java/org/elasticsearch/common/RoundingTests.java", "diffHunk": "@@ -387,23 +387,48 @@ public void testIntervalRounding_HalfDay_DST() {\n \n     public void testRandomTimeIntervalRounding() {\n         for (int i = 0; i < 1000; i++) {\n+            int unitCount = randomIntBetween(1, 365);\n             TimeUnit unit = randomFrom(TimeUnit.MINUTES, TimeUnit.HOURS, TimeUnit.DAYS);\n-            long interval = unit.toMillis(randomIntBetween(1, 365));\n+            long interval = unit.toMillis(unitCount);\n             ZoneId tz = randomZone();\n             Rounding rounding = new Rounding.TimeIntervalRounding(interval, tz);\n             long mainDate = Math.abs(randomLong() % (2 * (long) 10e11)); // 1970-01-01T00:00:00Z - 2033-05-18T05:33:20.000+02:00\n             if (randomBoolean()) {\n                 mainDate = nastyDate(mainDate, tz, interval);\n             }\n+            long min = mainDate - 2 * interval;\n+            long max = mainDate + 2 * interval;\n+\n+            // Round a whole bunch of dates and make sure they line up with the known good java time implementation\n+            Rounding.Prepared prepared = rounding.prepare(min, max);\n+            Rounding.Prepared javaTimeRounding = rounding.prepareJavaTime();\n+            for (int d = 0; d < 1000; d++) {", "originalCommit": "825fbfee08625b865884564612adcff65cf7524d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "8ed00223338d16c028eff115716210e7ef8d03f8", "url": "https://github.com/elastic/elasticsearch/commit/8ed00223338d16c028eff115716210e7ef8d03f8", "message": "Javadoc", "committedDate": "2020-05-07T19:53:20Z", "type": "commit"}, {"oid": "b13110f01425b19006d8ba87a288f57b87a73ec2", "url": "https://github.com/elastic/elasticsearch/commit/b13110f01425b19006d8ba87a288f57b87a73ec2", "message": "Javadoc", "committedDate": "2020-05-07T20:05:33Z", "type": "commit"}]}