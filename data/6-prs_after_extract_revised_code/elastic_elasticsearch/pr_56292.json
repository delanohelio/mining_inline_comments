{"pr_number": 56292, "pr_title": "Improve logging around SniffConnectionStrategy", "pr_createdAt": "2020-05-06T16:17:52Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/56292", "timeline": [{"oid": "77400cdfeead158a5835cac03cee07d5f3ddfbc4", "url": "https://github.com/elastic/elasticsearch/commit/77400cdfeead158a5835cac03cee07d5f3ddfbc4", "message": "Improve logging around SniffConnectionStrategy\n\nCurrently, the logging around the SniffConnectionStrategy is limited.\nThe log messages are inconsistent and sometimes wrong. This commit\ncleans up these log message to describe when connections are happening\nand what failed if a step fails.\n\nAdditionally, this commit enables TRACE logging for a problematic test\n(testEnsureWeReconnect).", "committedDate": "2020-05-06T16:14:14Z", "type": "commit"}, {"oid": "653a012238485d573762a444b87785fa66a7fc6d", "url": "https://github.com/elastic/elasticsearch/commit/653a012238485d573762a444b87785fa66a7fc6d", "message": "Merge remote-tracking branch 'upstream/master' into improve_ensure_client_test", "committedDate": "2020-05-06T16:51:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNjEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/56292#discussion_r420926103", "bodyText": "NIT: maybe use .get instead of .actionGet to get the full stacktrace logged on failure?", "author": "original-brownbear", "createdAt": "2020-05-06T16:28:35Z", "path": "server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java", "diffHunk": "@@ -86,37 +90,26 @@ public void testEnsureWeReconnect() throws Exception {\n                 .put(\"cluster.remote.test.seeds\",\n                     remoteNode.getAddress().getAddress() + \":\" + remoteNode.getAddress().getPort()).build();\n             try (MockTransportService service = MockTransportService.createNewService(localSettings, Version.CURRENT, threadPool, null)) {\n-                Semaphore semaphore = new Semaphore(1);\n                 service.start();\n-                service.getRemoteClusterService().getConnections().forEach(con -> {\n-                    con.getConnectionManager().addListener(new TransportConnectionListener() {\n-                        @Override\n-                        public void onNodeDisconnected(DiscoveryNode node, Transport.Connection connection) {\n-                            if (remoteNode.equals(node)) {\n-                                semaphore.release();\n-                            }\n-                        }\n-                    });\n-                });\n                 // this test is not perfect since we might reconnect concurrently but it will fail most of the time if we don't have\n                 // the right calls in place in the RemoteAwareClient\n                 service.acceptIncomingRequests();\n+                RemoteClusterService remoteClusterService = service.getRemoteClusterService();\n+                assertBusy(() -> assertTrue(remoteClusterService.isRemoteNodeConnected(\"test\", remoteNode)));\n                 for (int i = 0; i < 10; i++) {\n-                    semaphore.acquire();\n-                    try {\n-                        service.getRemoteClusterService().getConnections().forEach(con -> {\n-                            con.getConnectionManager().disconnectFromNode(remoteNode);\n-                        });\n-                        semaphore.acquire();\n-                        RemoteClusterService remoteClusterService = service.getRemoteClusterService();\n-                        Client client = remoteClusterService.getRemoteClusterClient(threadPool, \"test\");\n-                        ClusterStateResponse clusterStateResponse = client.admin().cluster().prepareState().execute().get();\n-                        assertNotNull(clusterStateResponse);\n-                        assertEquals(\"foo_bar_cluster\", clusterStateResponse.getState().getClusterName().value());\n-                        assertTrue(remoteClusterService.isRemoteNodeConnected(\"test\", remoteNode));\n-                    } finally {\n-                        semaphore.release();\n-                    }\n+                    RemoteClusterConnection remoteClusterConnection = remoteClusterService.getRemoteClusterConnection(\"test\");\n+                    ConnectionManager connectionManager = remoteClusterConnection.getConnectionManager();\n+                    Transport.Connection connection = connectionManager.getConnection(remoteNode);\n+                    PlainActionFuture<Void> closeFuture = PlainActionFuture.newFuture();\n+                    connection.addCloseListener(closeFuture);\n+                    connectionManager.disconnectFromNode(remoteNode);\n+                    closeFuture.actionGet();", "originalCommit": "77400cdfeead158a5835cac03cee07d5f3ddfbc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1bd3620256fa393348d55a7a33fa53195ba4e59a", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java b/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java\nindex e4cd798785e..32a1db5dfeb 100644\n--- a/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java\n+++ b/server/src/test/java/org/elasticsearch/transport/RemoteClusterClientTests.java\n\n@@ -103,7 +103,7 @@ public class RemoteClusterClientTests extends ESTestCase {\n                     PlainActionFuture<Void> closeFuture = PlainActionFuture.newFuture();\n                     connection.addCloseListener(closeFuture);\n                     connectionManager.disconnectFromNode(remoteNode);\n-                    closeFuture.actionGet();\n+                    closeFuture.get();\n \n                     Client client = remoteClusterService.getRemoteClusterClient(threadPool, \"test\");\n                     ClusterStateResponse clusterStateResponse = client.admin().cluster().prepareState().execute().get();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNzc2OA==", "url": "https://github.com/elastic/elasticsearch/pull/56292#discussion_r420927768", "bodyText": "NIT: probably doesn't matter much but maybe make it a message supplier now that it's debug level logging here? (same goes for the other debug that uses a new ParameterizedMessage  added below)", "author": "original-brownbear", "createdAt": "2020-05-06T16:30:59Z", "path": "server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java", "diffHunk": "@@ -255,17 +254,21 @@ private void collectRemoteNodes(Iterator<Supplier<DiscoveryNode>> seedNodes, Act\n \n             final StepListener<Void> fullConnectionStep = new StepListener<>();\n             handshakeStep.whenComplete(handshakeResponse -> {\n-                final DiscoveryNode handshakeNode = maybeAddProxyAddress(proxyAddress, handshakeResponse.getDiscoveryNode());\n+                final DiscoveryNode handshakeNode = handshakeResponse.getDiscoveryNode();\n \n                 if (nodePredicate.test(handshakeNode) && shouldOpenMoreConnections()) {\n-                    connectionManager.connectToNode(handshakeNode, null,\n-                        transportService.connectionValidator(handshakeNode), fullConnectionStep);\n+                    logger.trace(\"[{}] opening managed connection to seed node: [{}] proxy address: [{}]\", clusterAlias, handshakeNode,\n+                        proxyAddress);\n+                    final DiscoveryNode handshakeNodeWithProxy = maybeAddProxyAddress(proxyAddress, handshakeNode);\n+                    connectionManager.connectToNode(handshakeNodeWithProxy, null,\n+                        transportService.connectionValidator(handshakeNodeWithProxy), fullConnectionStep);\n                 } else {\n                     fullConnectionStep.onResponse(null);\n                 }\n             }, e -> {\n                 final Transport.Connection connection = openConnectionStep.result();\n-                logger.warn(new ParameterizedMessage(\"failed to connect to seed node [{}]\", connection.getNode()), e);\n+                final DiscoveryNode node = connection.getNode();\n+                logger.debug(new ParameterizedMessage(\"[{}] failed to handshake with seed node: [{}]\", clusterAlias, node), e);", "originalCommit": "77400cdfeead158a5835cac03cee07d5f3ddfbc4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1bd3620256fa393348d55a7a33fa53195ba4e59a", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java b/server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java\nindex 0441fb07535..e09e413728e 100644\n--- a/server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java\n+++ b/server/src/main/java/org/elasticsearch/transport/SniffConnectionStrategy.java\n\n@@ -268,7 +268,7 @@ public class SniffConnectionStrategy extends RemoteConnectionStrategy {\n             }, e -> {\n                 final Transport.Connection connection = openConnectionStep.result();\n                 final DiscoveryNode node = connection.getNode();\n-                logger.debug(new ParameterizedMessage(\"[{}] failed to handshake with seed node: [{}]\", clusterAlias, node), e);\n+                logger.debug(() -> new ParameterizedMessage(\"[{}] failed to handshake with seed node: [{}]\", clusterAlias, node), e);\n                 IOUtils.closeWhileHandlingException(connection);\n                 onFailure.accept(e);\n             });\n"}}, {"oid": "1bd3620256fa393348d55a7a33fa53195ba4e59a", "url": "https://github.com/elastic/elasticsearch/commit/1bd3620256fa393348d55a7a33fa53195ba4e59a", "message": "Chnages", "committedDate": "2020-05-07T16:51:48Z", "type": "commit"}, {"oid": "2cfb8ca90f1411b908e916345e1f9dcc161a5d27", "url": "https://github.com/elastic/elasticsearch/commit/2cfb8ca90f1411b908e916345e1f9dcc161a5d27", "message": "Merge remote-tracking branch 'upstream/master' into improve_ensure_client_test", "committedDate": "2020-05-07T16:52:11Z", "type": "commit"}]}