{"pr_number": 61596, "pr_title": "Search - add case insensitive flag for \"term\" family of queries", "pr_createdAt": "2020-08-26T17:39:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/61596", "timeline": [{"oid": "3ad28df1e1e18055942928902616d22a13f6bd0c", "url": "https://github.com/elastic/elasticsearch/commit/3ad28df1e1e18055942928902616d22a13f6bd0c", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-08-27T16:26:29Z", "type": "forcePushed"}, {"oid": "5b9a7bf76d235c46ae8f715f7f6d1c3a420d2b08", "url": "https://github.com/elastic/elasticsearch/commit/5b9a7bf76d235c46ae8f715f7f6d1c3a420d2b08", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-08-27T17:02:46Z", "type": "forcePushed"}, {"oid": "cc70b86f100c3d417c17f921205f08fcb224675e", "url": "https://github.com/elastic/elasticsearch/commit/cc70b86f100c3d417c17f921205f08fcb224675e", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-08-27T17:59:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY1MTQzNw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r479651437", "bodyText": "@markharwood  I see typo in CaseInsensitiveAutomatonQuery & AutomatonQuery. Shouldn't it be 'Automation' ? Or is there anything I missed to understand ?", "author": "vijaykriishna", "createdAt": "2020-08-29T13:46:00Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.lucene.search;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.AutomatonQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automata;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.MinimizationOperations;\n+import org.apache.lucene.util.automaton.Operations;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Base class for queries that use case insensitive string patterns\n+ */\n+public class CaseInsensitiveAutomatonQuery extends AutomatonQuery {", "originalCommit": "cc70b86f100c3d417c17f921205f08fcb224675e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAxOTIzNg==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r481019236", "bodyText": "Thanks, but Automaton is the correct spelling. See Finite State Automaton", "author": "markharwood", "createdAt": "2020-09-01T10:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY1MTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzMTk0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r481031941", "bodyText": "Good to know. Thanks", "author": "vijaykriishna", "createdAt": "2020-09-01T10:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY1MTQzNw=="}], "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java b/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java\ndeleted file mode 100644\nindex d314bbcffa1..00000000000\n--- a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java\n+++ /dev/null\n\n@@ -1,84 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.common.lucene.search;\n-\n-import org.apache.lucene.index.Term;\n-import org.apache.lucene.search.AutomatonQuery;\n-import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.automaton.Automata;\n-import org.apache.lucene.util.automaton.Automaton;\n-import org.apache.lucene.util.automaton.MinimizationOperations;\n-import org.apache.lucene.util.automaton.Operations;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-/**\n- * Base class for queries that use case insensitive string patterns\n- */\n-public class CaseInsensitiveAutomatonQuery extends AutomatonQuery {\n-\n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary) {\n-        super(term, automaton, maxDeterminizedStates, isBinary);\n-    }\n-    \n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates) {\n-        super(term, automaton, maxDeterminizedStates);\n-    }    \n-    \n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton) {\n-        super(term, automaton);\n-    }     \n-    \n-    protected static Automaton toCaseInsensitiveChar(int codepoint, int maxDeterminizedStates) {\n-        Automaton case1 = Automata.makeChar(codepoint);\n-        // For now we only work with ASCII characters\n-        if (codepoint > 128) {\n-            return case1;\n-        }\n-        int altCase = Character.isLowerCase(codepoint) ? Character.toUpperCase(codepoint) : Character.toLowerCase(codepoint);\n-        Automaton result;\n-        if (altCase != codepoint) {\n-            result = Operations.union(case1, Automata.makeChar(altCase));\n-            result = MinimizationOperations.minimize(result, maxDeterminizedStates);\n-        } else {\n-            result = case1;\n-        }\n-        return result;\n-    }\n-\n-    protected static Automaton toCaseInsensitiveString(BytesRef br, int maxDeterminizedStates) {\n-        return toCaseInsensitiveString(br.utf8ToString(), maxDeterminizedStates);\n-    }\n-    \n-    public static Automaton toCaseInsensitiveString(String s, int maxDeterminizedStates) {\n-        List<Automaton> list = new ArrayList<>();\n-        Iterator<Integer> iter = s.codePoints().iterator();\n-        while (iter.hasNext()) {\n-            list.add(toCaseInsensitiveChar(iter.next(), maxDeterminizedStates));\n-        }\n-\n-        Automaton a = Operations.concatenate(list);\n-        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n-        return a;\n-    }\n-\n-}\n"}}, {"oid": "c3ea3fffdc1b4a42599350ebca9a47b86c5be001", "url": "https://github.com/elastic/elasticsearch/commit/c3ea3fffdc1b4a42599350ebca9a47b86c5be001", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-01T09:04:49Z", "type": "forcePushed"}, {"oid": "e01f2c5882850f915227cf46c7f913aac8b1926b", "url": "https://github.com/elastic/elasticsearch/commit/e01f2c5882850f915227cf46c7f913aac8b1926b", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-04T16:48:51Z", "type": "forcePushed"}, {"oid": "970c3c73c23e260403caed27d8c8979972d2206e", "url": "https://github.com/elastic/elasticsearch/commit/970c3c73c23e260403caed27d8c8979972d2206e", "message": "Missing Locale", "committedDate": "2020-09-07T08:56:39Z", "type": "forcePushed"}, {"oid": "053aee19a799635daab588dd95123c60ec6b2fa7", "url": "https://github.com/elastic/elasticsearch/commit/053aee19a799635daab588dd95123c60ec6b2fa7", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-07T12:44:33Z", "type": "forcePushed"}, {"oid": "0539abcd7f9272e670fcb1b14c6e95c8d9352da9", "url": "https://github.com/elastic/elasticsearch/commit/0539abcd7f9272e670fcb1b14c6e95c8d9352da9", "message": "Doc changes", "committedDate": "2020-09-07T13:49:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NTExMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r484885111", "bodyText": "I'd copy the javadoc too, just so that when I hover over the method call I can see it.", "author": "nik9000", "createdAt": "2020-09-08T12:42:59Z", "path": "server/src/main/java/org/elasticsearch/common/regex/Regex.java", "diffHunk": "@@ -75,21 +75,31 @@ public static Automaton simpleMatchToAutomaton(String... patterns) {\n         return Operations.union(automata);\n     }\n \n+    // Case sensitive version of simple match", "originalCommit": "0539abcd7f9272e670fcb1b14c6e95c8d9352da9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b82974a8cdeceb53d716740004a2710800759d41", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/regex/Regex.java b/server/src/main/java/org/elasticsearch/common/regex/Regex.java\nindex ed9c641106c..bd7a90f2a9a 100644\n--- a/server/src/main/java/org/elasticsearch/common/regex/Regex.java\n+++ b/server/src/main/java/org/elasticsearch/common/regex/Regex.java\n\n@@ -75,7 +75,16 @@ public class Regex {\n         return Operations.union(automata);\n     }\n \n-    // Case sensitive version of simple match\n+    /**\n+     * Match a String against the given pattern, supporting the following simple\n+     * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n+     * arbitrary number of pattern parts), as well as direct equality.\n+     * Matching is case sensitive.\n+     *\n+     * @param pattern the pattern to match against\n+     * @param str     the String to match\n+     * @return whether the String matches the given pattern\n+     */\n     public static boolean simpleMatch(String pattern, String str) {\n         return simpleMatch(pattern, str, false);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwOTExMA==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485009110", "bodyText": "what do we gain shortening CaseInsensitive to CI here?", "author": "javanna", "createdAt": "2020-09-08T15:27:09Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java", "diffHunk": "@@ -70,18 +70,40 @@ private static String valueToString(Object value) {\n     @Override\n     public final Query termQuery(Object value, QueryShardContext context) {\n         String pattern = valueToString(value);\n-        if (matches(pattern, context)) {\n+        if (matches(pattern, false, context)) {\n             return Queries.newMatchAllQuery();\n         } else {\n             return new MatchNoDocsQuery();\n         }\n     }\n \n+    @Override\n+    public final Query termQueryCI(Object value, QueryShardContext context) {\n+        String pattern = valueToString(value);\n+        if (matches(pattern, true, context)) {\n+            return Queries.newMatchAllQuery();\n+        } else {\n+            return new MatchNoDocsQuery();\n+        }\n+    }\n+    \n     @Override\n     public final Query termsQuery(List<?> values, QueryShardContext context) {\n         for (Object value : values) {\n             String pattern = valueToString(value);\n-            if (matches(pattern, context)) {\n+            if (matches(pattern, false, context)) {\n+                // `terms` queries are a disjunction, so one matching term is enough\n+                return Queries.newMatchAllQuery();\n+            }\n+        }\n+        return new MatchNoDocsQuery();\n+    }    \n+\n+    @Override\n+    public final Query termsQueryCI(List<?> values, QueryShardContext context) {", "originalCommit": "29d895a7a3f3eebe6908d6cd3278fb27dc1eb7c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNzg0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485037846", "bodyText": "Was the suggestion from @jimczi  - I'm not averse to changing. Jim?", "author": "markharwood", "createdAt": "2020-09-08T16:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwOTExMA=="}], "type": "inlineReview", "revised_code": {"commit": "b82974a8cdeceb53d716740004a2710800759d41", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java b/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\nindex a5244381f9b..1aa57d73136 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/ConstantFieldType.java\n\n@@ -78,7 +78,7 @@ public abstract class ConstantFieldType extends MappedFieldType {\n     }\n \n     @Override\n-    public final Query termQueryCI(Object value, QueryShardContext context) {\n+    public final Query termQueryCaseInsensitive(Object value, QueryShardContext context) {\n         String pattern = valueToString(value);\n         if (matches(pattern, true, context)) {\n             return Queries.newMatchAllQuery();\n"}}, {"oid": "b82974a8cdeceb53d716740004a2710800759d41", "url": "https://github.com/elastic/elasticsearch/commit/b82974a8cdeceb53d716740004a2710800759d41", "message": "Rename method", "committedDate": "2020-09-09T09:30:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMDc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485530753", "bodyText": "Do we need this extra class ? You could add helpers to create case insensitive prefix, wildcard and term automaton and then use the plain AutomatonQuery ?", "author": "jimczi", "createdAt": "2020-09-09T11:14:29Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.lucene.search;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.AutomatonQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automata;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.MinimizationOperations;\n+import org.apache.lucene.util.automaton.Operations;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Base class for queries that use case insensitive string patterns\n+ */\n+public class CaseInsensitiveAutomatonQuery extends AutomatonQuery {", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java b/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java\ndeleted file mode 100644\nindex d314bbcffa1..00000000000\n--- a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveAutomatonQuery.java\n+++ /dev/null\n\n@@ -1,84 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.common.lucene.search;\n-\n-import org.apache.lucene.index.Term;\n-import org.apache.lucene.search.AutomatonQuery;\n-import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.automaton.Automata;\n-import org.apache.lucene.util.automaton.Automaton;\n-import org.apache.lucene.util.automaton.MinimizationOperations;\n-import org.apache.lucene.util.automaton.Operations;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-/**\n- * Base class for queries that use case insensitive string patterns\n- */\n-public class CaseInsensitiveAutomatonQuery extends AutomatonQuery {\n-\n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates, boolean isBinary) {\n-        super(term, automaton, maxDeterminizedStates, isBinary);\n-    }\n-    \n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton, int maxDeterminizedStates) {\n-        super(term, automaton, maxDeterminizedStates);\n-    }    \n-    \n-    public CaseInsensitiveAutomatonQuery(Term term, Automaton automaton) {\n-        super(term, automaton);\n-    }     \n-    \n-    protected static Automaton toCaseInsensitiveChar(int codepoint, int maxDeterminizedStates) {\n-        Automaton case1 = Automata.makeChar(codepoint);\n-        // For now we only work with ASCII characters\n-        if (codepoint > 128) {\n-            return case1;\n-        }\n-        int altCase = Character.isLowerCase(codepoint) ? Character.toUpperCase(codepoint) : Character.toLowerCase(codepoint);\n-        Automaton result;\n-        if (altCase != codepoint) {\n-            result = Operations.union(case1, Automata.makeChar(altCase));\n-            result = MinimizationOperations.minimize(result, maxDeterminizedStates);\n-        } else {\n-            result = case1;\n-        }\n-        return result;\n-    }\n-\n-    protected static Automaton toCaseInsensitiveString(BytesRef br, int maxDeterminizedStates) {\n-        return toCaseInsensitiveString(br.utf8ToString(), maxDeterminizedStates);\n-    }\n-    \n-    public static Automaton toCaseInsensitiveString(String s, int maxDeterminizedStates) {\n-        List<Automaton> list = new ArrayList<>();\n-        Iterator<Integer> iter = s.codePoints().iterator();\n-        while (iter.hasNext()) {\n-            list.add(toCaseInsensitiveChar(iter.next(), maxDeterminizedStates));\n-        }\n-\n-        Automaton a = Operations.concatenate(list);\n-        a = MinimizationOperations.minimize(a, maxDeterminizedStates);\n-        return a;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMDkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485530914", "bodyText": "Same here, I don't think we need the extra class.", "author": "jimczi", "createdAt": "2020-09-09T11:14:48Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitivePrefixQuery.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.lucene.search;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automata;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.MinimizationOperations;\n+import org.apache.lucene.util.automaton.Operations;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/** A Query that matches documents containing terms with a specified prefix, regardless of case. \n+ * A PrefixQuery built by QueryParser for input like <code>App*</code>.\n+ */\n+\n+public class CaseInsensitivePrefixQuery extends CaseInsensitiveAutomatonQuery {", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitivePrefixQuery.java b/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitivePrefixQuery.java\ndeleted file mode 100644\nindex 9e1eaaa6c0b..00000000000\n--- a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitivePrefixQuery.java\n+++ /dev/null\n\n@@ -1,104 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.common.lucene.search;\n-\n-import org.apache.lucene.index.Term;\n-import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.automaton.Automata;\n-import org.apache.lucene.util.automaton.Automaton;\n-import org.apache.lucene.util.automaton.MinimizationOperations;\n-import org.apache.lucene.util.automaton.Operations;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-/** A Query that matches documents containing terms with a specified prefix, regardless of case. \n- * A PrefixQuery built by QueryParser for input like <code>App*</code>.\n- */\n-\n-public class CaseInsensitivePrefixQuery extends CaseInsensitiveAutomatonQuery {\n-\n-    /** Constructs a case insensitive query for terms starting with <code>prefix</code>. */\n-    public CaseInsensitivePrefixQuery(Term prefix) {\n-        // It's OK to pass unlimited maxDeterminizedStates: the automaton is born small and determinized:\n-        super(prefix, toAutomaton(prefix.bytes()), Integer.MAX_VALUE, true);\n-    }\n-\n-    /** Build an automaton accepting all terms with the specified prefix, case insensitive. */\n-    public static Automaton toAutomaton(BytesRef prefix) {\n-        if (prefix == null) {\n-            throw new NullPointerException(\"prefix must not be null\");\n-        }\n-        List<Automaton> list = new ArrayList<>();\n-        String s = prefix.utf8ToString();\n-        Iterator<Integer> iter = s.codePoints().iterator();\n-        while (iter.hasNext()) {\n-            list.add(toCaseInsensitiveChar(iter.next(), Integer.MAX_VALUE));\n-        }\n-        list.add(Automata.makeAnyString());\n-\n-        Automaton a = Operations.concatenate(list);\n-        a = MinimizationOperations.minimize(a, Integer.MAX_VALUE);\n-        return a;\n-    }\n-\n-    /** Returns the prefix of this query. */\n-    public Term getPrefix() {\n-        return term;\n-    }\n-\n-    /** Prints a user-readable version of this query. */\n-    @Override\n-    public String toString(String field) {\n-        StringBuilder buffer = new StringBuilder();\n-        if (!getField().equals(field)) {\n-            buffer.append(getField());\n-            buffer.append(':');\n-        }\n-        buffer.append(term.text());\n-        buffer.append('*');\n-        return buffer.toString();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        final int prime = 31;\n-        int result = super.hashCode();\n-        result = prime * result + term.hashCode();\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!super.equals(obj)) {\n-            return false;\n-        }\n-        // super.equals() ensures we are the same class\n-        CaseInsensitivePrefixQuery other = (CaseInsensitivePrefixQuery) obj;\n-        if (!term.equals(other.term)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMTA2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485531063", "bodyText": "Same here", "author": "jimczi", "createdAt": "2020-09-09T11:15:03Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveTermQuery.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.lucene.search;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.MultiTermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automaton;\n+\n+/** A Query that matches documents containing terms with a specified prefix, regardless of case. \n+ * A PrefixQuery built by QueryParser for input like <code>App*</code>.\n+ *\n+ * <p>This query uses the {@link\n+ * MultiTermQuery#CONSTANT_SCORE_REWRITE}\n+ * rewrite method. */\n+\n+public class CaseInsensitiveTermQuery extends CaseInsensitiveAutomatonQuery {", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveTermQuery.java b/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveTermQuery.java\ndeleted file mode 100644\nindex 03c10359773..00000000000\n--- a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveTermQuery.java\n+++ /dev/null\n\n@@ -1,87 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.common.lucene.search;\n-\n-import org.apache.lucene.index.Term;\n-import org.apache.lucene.search.MultiTermQuery;\n-import org.apache.lucene.util.BytesRef;\n-import org.apache.lucene.util.automaton.Automaton;\n-\n-/** A Query that matches documents containing terms with a specified prefix, regardless of case. \n- * A PrefixQuery built by QueryParser for input like <code>App*</code>.\n- *\n- * <p>This query uses the {@link\n- * MultiTermQuery#CONSTANT_SCORE_REWRITE}\n- * rewrite method. */\n-\n-public class CaseInsensitiveTermQuery extends CaseInsensitiveAutomatonQuery {\n-\n-    /** Constructs a case insensitive query for terms starting with <code>prefix</code>. */\n-    public CaseInsensitiveTermQuery(Term term) {\n-        // It's OK to pass unlimited maxDeterminizedStates: the automaton is born small and determinized:\n-        super(term, toAutomaton(term.bytes()), Integer.MAX_VALUE, true);\n-    }\n-\n-    /** Build an automaton accepting all terms with the specified prefix, case insensitive. */\n-    public static Automaton toAutomaton(BytesRef prefix) {\n-        return toCaseInsensitiveString(prefix,Integer.MAX_VALUE);\n-    }\n-\n-    /** Returns the prefix of this query. */\n-    public Term getPrefix() {\n-        return term;\n-    }\n-\n-    /** Prints a user-readable version of this query. */\n-    @Override\n-    public String toString(String field) {\n-        StringBuilder buffer = new StringBuilder();\n-        if (!getField().equals(field)) {\n-            buffer.append(getField());\n-            buffer.append(':');\n-        }\n-        buffer.append(term.text());\n-        return buffer.toString();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        final int prime = 31;\n-        int result = super.hashCode();\n-        result = prime * result + term.hashCode();\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!super.equals(obj)) {\n-            return false;\n-        }\n-        // super.equals() ensures we are the same class\n-        CaseInsensitiveTermQuery other = (CaseInsensitiveTermQuery) obj;\n-        if (!term.equals(other.term)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMTEzMA==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485531130", "bodyText": "And here ;)", "author": "jimczi", "createdAt": "2020-09-09T11:15:11Z", "path": "server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveWildcardQuery.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.common.lucene.search;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.util.automaton.Automata;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.Operations;\n+\n+/** Implements the wildcard search query. Supported wildcards are <code>*</code>, which\n+ * matches any character sequence (including the empty one), and <code>?</code>,\n+ * which matches any single character. '\\' is the escape character.\n+ * <p>\n+ * Note this query can be slow, as it\n+ * needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,\n+ * a Wildcard term should not start with the wildcard <code>*</code>\n+ * \n+ * Non-wildcard ASCII characters are converted into A or a variations\n+ *\n+ */\n+public class CaseInsensitiveWildcardQuery extends CaseInsensitiveAutomatonQuery {", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveWildcardQuery.java b/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveWildcardQuery.java\ndeleted file mode 100644\nindex 314177aae89..00000000000\n--- a/server/src/main/java/org/elasticsearch/common/lucene/search/CaseInsensitiveWildcardQuery.java\n+++ /dev/null\n\n@@ -1,124 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.common.lucene.search;\n-\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.apache.lucene.index.Term;\n-import org.apache.lucene.util.automaton.Automata;\n-import org.apache.lucene.util.automaton.Automaton;\n-import org.apache.lucene.util.automaton.Operations;\n-\n-/** Implements the wildcard search query. Supported wildcards are <code>*</code>, which\n- * matches any character sequence (including the empty one), and <code>?</code>,\n- * which matches any single character. '\\' is the escape character.\n- * <p>\n- * Note this query can be slow, as it\n- * needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,\n- * a Wildcard term should not start with the wildcard <code>*</code>\n- * \n- * Non-wildcard ASCII characters are converted into A or a variations\n- *\n- */\n-public class CaseInsensitiveWildcardQuery extends CaseInsensitiveAutomatonQuery {\n-  /** String equality with support for wildcards */\n-  public static final char WILDCARD_STRING = '*';\n-\n-  /** Char equality with support for wildcards */\n-  public static final char WILDCARD_CHAR = '?';\n-\n-  /** Escape character */\n-  public static final char WILDCARD_ESCAPE = '\\\\';\n-  \n-  /**\n-   * Constructs a query for terms matching <code>term</code>. \n-   */\n-  public CaseInsensitiveWildcardQuery(Term term) {\n-    super(term, toAutomaton(term, Integer.MAX_VALUE));\n-  }\n-  \n-  /**\n-   * Constructs a query for terms matching <code>term</code>.\n-   * @param maxDeterminizedStates maximum number of states in the resulting\n-   *   automata.  If the automata would need more than this many states\n-   *   TooComplextToDeterminizeException is thrown.  Higher number require more\n-   *   space but can process more complex automata.\n-   */\n-  public CaseInsensitiveWildcardQuery(Term term, int maxDeterminizedStates) {\n-    super(term, toAutomaton(term, maxDeterminizedStates), maxDeterminizedStates);\n-  }\n-\n-  /**\n-   * Convert Lucene wildcard syntax into an automaton.\n-   */\n-  @SuppressWarnings(\"fallthrough\")\n-  public static Automaton toAutomaton(Term wildcardquery, int maxDeterminizedStates) {\n-    List<Automaton> automata = new ArrayList<>();\n-    \n-    String wildcardText = wildcardquery.text();\n-    \n-    for (int i = 0; i < wildcardText.length();) {\n-      final int c = wildcardText.codePointAt(i);\n-      int length = Character.charCount(c);\n-      switch(c) {\n-        case WILDCARD_STRING: \n-          automata.add(Automata.makeAnyString());\n-          break;\n-        case WILDCARD_CHAR:\n-          automata.add(Automata.makeAnyChar());\n-          break;\n-        case WILDCARD_ESCAPE:\n-          // add the next codepoint instead, if it exists\n-          if (i + length < wildcardText.length()) {\n-            final int nextChar = wildcardText.codePointAt(i + length);\n-            length += Character.charCount(nextChar);\n-            automata.add(Automata.makeChar(nextChar));\n-            break;\n-          } // else fallthru, lenient parsing with a trailing \\\n-        default:\n-          automata.add(toCaseInsensitiveChar(c, maxDeterminizedStates));\n-      }\n-      i += length;\n-    }\n-    \n-    return Operations.concatenate(automata);\n-  }\n-  \n-  /**\n-   * Returns the pattern term.\n-   */\n-  public Term getTerm() {\n-    return term;\n-  }\n-  \n-  /** Prints a user-readable version of this query. */\n-  @Override\n-  public String toString(String field) {\n-    StringBuilder buffer = new StringBuilder();\n-    if (!getField().equals(field)) {\n-      buffer.append(getField());\n-      buffer.append(\":\");\n-    }\n-    buffer.append(term.text());\n-    return buffer.toString();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzNjU0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485536547", "bodyText": "Would it be easier to lowercase only the ascii chars of the pattern and the str pre-matching ? That way you don't need to modify the indexOf and it's consistent with the lowercasing that we apply on queries.", "author": "jimczi", "createdAt": "2020-09-09T11:26:08Z", "path": "server/src/main/java/org/elasticsearch/common/regex/Regex.java", "diffHunk": "@@ -79,17 +79,36 @@ public static Automaton simpleMatchToAutomaton(String... patterns) {\n      * Match a String against the given pattern, supporting the following simple\n      * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n      * arbitrary number of pattern parts), as well as direct equality.\n+     * Matching is case sensitive.\n      *\n      * @param pattern the pattern to match against\n      * @param str     the String to match\n      * @return whether the String matches the given pattern\n      */\n     public static boolean simpleMatch(String pattern, String str) {\n+        return simpleMatch(pattern, str, false);\n+    }\n+    \n+    \n+    /**\n+     * Match a String against the given pattern, supporting the following simple\n+     * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n+     * arbitrary number of pattern parts), as well as direct equality.\n+     *\n+     * @param pattern the pattern to match against\n+     * @param str     the String to match\n+     * @param caseInsensitive  true if case differences should be ignored\n+     * @return whether the String matches the given pattern\n+     */\n+    public static boolean simpleMatch(String pattern, String str, boolean caseInsensitive) {", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/regex/Regex.java b/server/src/main/java/org/elasticsearch/common/regex/Regex.java\nindex bd7a90f2a9a..65e5b5770fe 100644\n--- a/server/src/main/java/org/elasticsearch/common/regex/Regex.java\n+++ b/server/src/main/java/org/elasticsearch/common/regex/Regex.java\n\n@@ -97,18 +97,23 @@ public class Regex {\n      *\n      * @param pattern the pattern to match against\n      * @param str     the String to match\n-     * @param caseInsensitive  true if case differences should be ignored\n+     * @param caseInsensitive  true if ASCII case differences should be ignored\n      * @return whether the String matches the given pattern\n      */\n     public static boolean simpleMatch(String pattern, String str, boolean caseInsensitive) {\n         if (pattern == null || str == null) {\n             return false;\n         }\n+        if (caseInsensitive) {\n+            pattern = Strings.toLowercaseAscii(pattern);\n+            str = Strings.toLowercaseAscii(str);\n+        }\n+        return simpleMatchWithNormalizedStrings(pattern, str);\n+    }\n+    \n+    private static boolean simpleMatchWithNormalizedStrings(String pattern, String str) {\n         final int firstIndex = pattern.indexOf('*');\n         if (firstIndex == -1) {\n-            if(caseInsensitive) {\n-                return pattern.equalsIgnoreCase(str);                \n-            }\n             return pattern.equals(str);\n         }\n         if (firstIndex == 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzNjg2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485536869", "bodyText": "Should it use a specific locale to avoid lowercasing more than ASCII chars ?", "author": "jimczi", "createdAt": "2020-09-09T11:26:44Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java", "diffHunk": "@@ -53,7 +54,12 @@ public String typeName() {\n         }\n \n         @Override\n-        protected boolean matches(String pattern, QueryShardContext context) {\n+        protected boolean matches(String pattern, boolean caseInsensitive, QueryShardContext context) {\n+            if (caseInsensitive) {\n+                // Thankfully, all index names are lower-cased so we don't have to pass a case_insensitive mode flag\n+                // down to all the index name-matching logic. We just lower-case the search string\n+                pattern = pattern.toLowerCase(Locale.ROOT);", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485584263", "bodyText": "Do you know which one would make sense?", "author": "markharwood", "createdAt": "2020-09-09T12:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzNjg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java\nindex 056d428c14f..2a88f7ac53d 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/IndexFieldMapper.java\n\n@@ -58,7 +58,7 @@ public class IndexFieldMapper extends MetadataFieldMapper {\n             if (caseInsensitive) {\n                 // Thankfully, all index names are lower-cased so we don't have to pass a case_insensitive mode flag\n                 // down to all the index name-matching logic. We just lower-case the search string\n-                pattern = pattern.toLowerCase(Locale.ROOT);\n+                pattern = Strings.toLowercaseAscii(pattern);\n             }            \n             return context.indexMatches(pattern);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzODU3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485538576", "bodyText": "Should we restrict the lowercasing to ASCII ?", "author": "jimczi", "createdAt": "2020-09-09T11:30:17Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptBooleanMappedFieldType.java", "diffHunk": "@@ -201,6 +229,9 @@ private static boolean toBoolean(Object value) {\n         } else {\n             sValue = value.toString();\n         }\n+        if (caseInsensitive) {\n+            sValue = sValue.toLowerCase(Locale.ROOT);", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptBooleanMappedFieldType.java b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptBooleanMappedFieldType.java\nindex 380925f6770..7622a36b2f6 100644\n--- a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptBooleanMappedFieldType.java\n+++ b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/mapper/ScriptBooleanMappedFieldType.java\n\n@@ -230,7 +230,7 @@ public class ScriptBooleanMappedFieldType extends AbstractScriptMappedFieldType\n             sValue = value.toString();\n         }\n         if (caseInsensitive) {\n-            sValue = sValue.toLowerCase(Locale.ROOT);\n+            sValue = Strings.toLowercaseAscii(sValue);\n         }\n         return Booleans.parseBoolean(sValue);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzOTEwNg==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485539106", "bodyText": "We shouldn't rely on the root locale ?", "author": "jimczi", "createdAt": "2020-09-09T11:31:23Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java", "diffHunk": "@@ -12,25 +12,37 @@\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.util.List;\n+import java.util.Locale;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class StringScriptFieldTermsQuery extends AbstractStringScriptFieldQuery {\n     private final Set<String> terms;\n+    private final boolean caseInsensitive;\n \n     public StringScriptFieldTermsQuery(\n         Script script,\n         StringScriptFieldScript.LeafFactory leafFactory,\n         String fieldName,\n-        Set<String> terms\n+        Set<String> terms,\n+        boolean caseInsensitive\n     ) {\n         super(script, leafFactory, fieldName);\n-        this.terms = terms;\n+        if (caseInsensitive) {\n+            this.terms = terms.stream().map(s -> s.toLowerCase(Locale.ROOT)).collect(Collectors.toSet());", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\nindex 3141b22c50c..b4447a99e6c 100644\n--- a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\n+++ b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\n\n@@ -8,11 +8,11 @@ package org.elasticsearch.xpack.runtimefields.query;\n \n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.QueryVisitor;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.util.List;\n-import java.util.Locale;\n import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzOTE4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485539186", "bodyText": "Same here ?", "author": "jimczi", "createdAt": "2020-09-09T11:31:32Z", "path": "x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java", "diffHunk": "@@ -12,25 +12,37 @@\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.util.List;\n+import java.util.Locale;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class StringScriptFieldTermsQuery extends AbstractStringScriptFieldQuery {\n     private final Set<String> terms;\n+    private final boolean caseInsensitive;\n \n     public StringScriptFieldTermsQuery(\n         Script script,\n         StringScriptFieldScript.LeafFactory leafFactory,\n         String fieldName,\n-        Set<String> terms\n+        Set<String> terms,\n+        boolean caseInsensitive\n     ) {\n         super(script, leafFactory, fieldName);\n-        this.terms = terms;\n+        if (caseInsensitive) {\n+            this.terms = terms.stream().map(s -> s.toLowerCase(Locale.ROOT)).collect(Collectors.toSet());\n+        } else {\n+            this.terms = terms;\n+        }\n+        this.caseInsensitive = caseInsensitive;\n     }\n \n     @Override\n     protected boolean matches(List<String> values) {\n         for (String value : values) {\n+            if (caseInsensitive) {\n+                value = value.toLowerCase(Locale.ROOT);", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "chunk": "diff --git a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\nindex 3141b22c50c..b4447a99e6c 100644\n--- a/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\n+++ b/x-pack/plugin/runtime-fields/src/main/java/org/elasticsearch/xpack/runtimefields/query/StringScriptFieldTermsQuery.java\n\n@@ -8,11 +8,11 @@ package org.elasticsearch.xpack.runtimefields.query;\n \n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.QueryVisitor;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.script.Script;\n import org.elasticsearch.xpack.runtimefields.StringScriptFieldScript;\n \n import java.util.List;\n-import java.util.Locale;\n import java.util.Objects;\n import java.util.Set;\n import java.util.stream.Collectors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485542307", "bodyText": "I wonder what we should do here ? We'd need to add the support for case insensitive matching in TermInSetQuery if we want to avoid building giant boolean query in the keyword field. For now I think it's ok to not provide this option on terms query since we cannot support them efficiently ?", "author": "jimczi", "createdAt": "2020-09-09T11:37:14Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java", "diffHunk": "@@ -176,7 +176,24 @@ public boolean isAggregatable() {\n      */\n     // TODO: Standardize exception types\n     public abstract Query termQuery(Object value, @Nullable QueryShardContext context);\n-\n+    \n+    \n+    // Case insensitive form of term query (not supported by all fields so must be overridden to enable)\n+    public Query termQueryCaseInsensitive(Object value, @Nullable QueryShardContext context) {\n+        throw new QueryShardException(context, \"[\" + name + \"] field which is of type [\" + typeName() + \n+            \"], does not support case insensitive term queries\");\n+    }    \n+\n+    \n+    // Case insensitive form of terms query\n+    public Query termsQueryCaseInsensitive(List<?> values, @Nullable QueryShardContext context) {        ", "originalCommit": "2c7ee17a361ce2dd59d69424db16f0f12b67956d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzODQxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485638411", "bodyText": "@jimczi terms query is currently used by eql for more obvious queries like file where file_name in (\"wininit.exe\", \"lsass.exe\") and (less obvious) for cidrMatch function for matching an IP address in a list of CIDR blocks. Would be useful to have case insensitive support for it as well.", "author": "astefan", "createdAt": "2020-09-09T14:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4NzMyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485687325", "bodyText": "(less obvious) for cidrMatch function for matching an IP address in a list of CIDR blocks.\n\nNeat! I just want to make sure you aren't expanding the cidr blocks or anything - we natively support the cidr match in the term and terms query.", "author": "nik9000", "createdAt": "2020-09-09T15:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0MTkwNA==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485741904", "bodyText": "I just want to make sure you aren't expanding the cidr blocks or anything - we natively support the cidr match in the term and terms query.\n\nWe're not, we just pass the block to ES.\nWhen dealing with an expression that forces us to do scripting, we use the underlying Lucene class for matching.", "author": "costin", "createdAt": "2020-09-09T16:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MjU4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r485842583", "bodyText": "Nice.\nHopefully you'll be able to use runtime field before too long!", "author": "nik9000", "createdAt": "2020-09-09T18:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwNTY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r486205686", "bodyText": "For now I think it's ok to not provide this option on terms query since we cannot support them efficiently ?\n\nIf we don't support it won't people just be forced to do what we do internally and create a bool should array of term queries?\nIs there a query-complexity circuit-breaker we're somehow missing here?", "author": "markharwood", "createdAt": "2020-09-10T09:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEwMDk3NA==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r490100974", "bodyText": "Adding a +1 to have this supported in terms query. The alternative in EQL, in case we decide to not support this, would probably be (as @markharwood mentioned) to create a bool query with a bunch of term queries in it. CC @jimczi", "author": "astefan", "createdAt": "2020-09-17T09:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEyMzU4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r490123586", "bodyText": "My worry is that we'd internally create an array of should term queries because the TermsInSet query doesn't handle case insensitive queries. It's maybe not a big issue but that wouldn't be consistent since a case insensitive terms query would fail with  more than 1024 terms (the max boolean clause limit) while the normal one would use the optimized TermsInSet query. So my take on  this is that we should implement a proper support in TermInSet if we really want to handle terms case insensitive query. For EQL and SQL I don't think there's a real need to handle terms though. The in operator doesn't need to handle thousands of terms so imo that would be acceptable to translate it into an array of term query. Same for the cidrMatch function that also work on term queries.", "author": "jimczi", "createdAt": "2020-09-17T10:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg0MzA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r490843091", "bodyText": "OK - I'll pull the  termsQueryCaseInsensitive method for now. We can always add in another PR later. This PR probably has enough changes to consider already", "author": "markharwood", "createdAt": "2020-09-18T10:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MjMwNw=="}], "type": "inlineReview", "revised_code": {"commit": "de8c3d25091cf7da02f4e4e66160f286329c31b5", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java b/server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java\nindex 093e5943d31..35ac0a9f112 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java\n\n@@ -184,16 +184,6 @@ public abstract class MappedFieldType {\n             \"], does not support case insensitive term queries\");\n     }    \n \n-    \n-    // Case insensitive form of terms query\n-    public Query termsQueryCaseInsensitive(List<?> values, @Nullable QueryShardContext context) {        \n-        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n-        for (Object value : values) {\n-            builder.add(termQueryCaseInsensitive(value, context), Occur.SHOULD);\n-        }\n-        return new ConstantScoreQuery(builder.build());\n-    }    \n-    \n     /** Build a constant-scoring query that matches all values. The default implementation uses a\n      * {@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses\n      * are generated with {@link #termQuery}. */\n"}}, {"oid": "698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "url": "https://github.com/elastic/elasticsearch/commit/698b62ac6e48619cb14cc2e5fdfa0daa4104aa1f", "message": "Removed specialised CI classes. Added helper function for lowercasing ASCII only and removed String.toLowercase(Locale.ROOT) uses.\nI have NOT removed terms query CI support yet as it looks like discussions ongoing.", "committedDate": "2020-09-15T08:32:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzcyNw==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r490897727", "bodyText": "simpleMatchCaseInsensitive ?", "author": "jimczi", "createdAt": "2020-09-18T11:53:45Z", "path": "server/src/main/java/org/elasticsearch/common/regex/Regex.java", "diffHunk": "@@ -79,15 +79,39 @@ public static Automaton simpleMatchToAutomaton(String... patterns) {\n      * Match a String against the given pattern, supporting the following simple\n      * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n      * arbitrary number of pattern parts), as well as direct equality.\n+     * Matching is case sensitive.\n      *\n      * @param pattern the pattern to match against\n      * @param str     the String to match\n      * @return whether the String matches the given pattern\n      */\n     public static boolean simpleMatch(String pattern, String str) {\n+        return simpleMatch(pattern, str, false);\n+    }\n+    \n+    \n+    /**\n+     * Match a String against the given pattern, supporting the following simple\n+     * pattern styles: \"xxx*\", \"*xxx\", \"*xxx*\" and \"xxx*yyy\" matches (with an\n+     * arbitrary number of pattern parts), as well as direct equality.\n+     *\n+     * @param pattern the pattern to match against\n+     * @param str     the String to match\n+     * @param caseInsensitive  true if ASCII case differences should be ignored\n+     * @return whether the String matches the given pattern\n+     */\n+    public static boolean simpleMatch(String pattern, String str, boolean caseInsensitive) {\n         if (pattern == null || str == null) {\n             return false;\n         }\n+        if (caseInsensitive) {\n+            pattern = Strings.toLowercaseAscii(pattern);\n+            str = Strings.toLowercaseAscii(str);\n+        }\n+        return simpleMatchWithNormalizedStrings(pattern, str);\n+    }\n+    \n+    private static boolean simpleMatchWithNormalizedStrings(String pattern, String str) {", "originalCommit": "6676b9b7a21a8cb5e4f39b9ac479e2c8335910a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk5NzY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r490997661", "bodyText": "That name might suggest the case insensitivity is built into the method (it's not).\nI wanted something less explicit (\"post-normalization\"?) that suggested the strings were assumed to have already been normalised (which for argument's sake could have been uppercasing not lowercasing).", "author": "markharwood", "createdAt": "2020-09-18T14:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwMjY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/61596#discussion_r491002686", "bodyText": "fair enough", "author": "jimczi", "createdAt": "2020-09-18T14:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzcyNw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "de8c3d25091cf7da02f4e4e66160f286329c31b5", "url": "https://github.com/elastic/elasticsearch/commit/de8c3d25091cf7da02f4e4e66160f286329c31b5", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-18T13:03:57Z", "type": "forcePushed"}, {"oid": "8f9ad7333722096c644394b4fca3f03e825d7c2e", "url": "https://github.com/elastic/elasticsearch/commit/8f9ad7333722096c644394b4fca3f03e825d7c2e", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-18T13:16:25Z", "type": "forcePushed"}, {"oid": "685a4199a1acc9eeeb614348cddb2f8084014b43", "url": "https://github.com/elastic/elasticsearch/commit/685a4199a1acc9eeeb614348cddb2f8084014b43", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-18T14:37:05Z", "type": "commit"}, {"oid": "685a4199a1acc9eeeb614348cddb2f8084014b43", "url": "https://github.com/elastic/elasticsearch/commit/685a4199a1acc9eeeb614348cddb2f8084014b43", "message": "First cut at adding case insensitive flag for term, terms, termsInSet, prefix, wildcard queries\n\nCloses #61546", "committedDate": "2020-09-18T14:37:05Z", "type": "forcePushed"}, {"oid": "83f565836b87bde87b0904caba496202aeb14ef9", "url": "https://github.com/elastic/elasticsearch/commit/83f565836b87bde87b0904caba496202aeb14ef9", "message": "Formatting fix", "committedDate": "2020-09-18T14:50:00Z", "type": "commit"}]}