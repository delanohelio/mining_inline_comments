{"pr_number": 52680, "pr_title": "Adds resiliency to read-only filesystems #45286", "pr_createdAt": "2020-02-23T11:45:38Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52680", "timeline": [{"oid": "569e8ccd0d729f017783b36f55872ecd4361b4fe", "url": "https://github.com/elastic/elasticsearch/commit/569e8ccd0d729f017783b36f55872ecd4361b4fe", "message": "Merge pull request #2 from elastic/master\n\nRebase from fork", "committedDate": "2019-07-04T06:45:38Z", "type": "commit"}, {"oid": "64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "url": "https://github.com/elastic/elasticsearch/commit/64815f13a38bb47ac0cc5188f15e0b0ba3b27ebd", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-02-22T18:16:13Z", "type": "commit"}, {"oid": "b598944ca305f803b27c817e860133ebfd1a7d78", "url": "https://github.com/elastic/elasticsearch/commit/b598944ca305f803b27c817e860133ebfd1a7d78", "message": " [Initial DRAFT] Adds a FsHealthService that periodically tries to write to all paths and emits a stats is_writable as a part of node stats API.\n FsReadOnlyMonitor pulls up the stats and tries to remove the node if not all paths are found to be writable.\n Addresses #45286.", "committedDate": "2020-02-23T11:37:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383135577", "bodyText": "This (and the extensions to ClusterInfoService) seem unnecessary. It would be preferable for the FollowersChecker to report a node as unhealthy directly.", "author": "DaveCTurner", "createdAt": "2020-02-24T08:46:40Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.cluster.*;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.node.DiscoveryNodes;\n+import org.elasticsearch.common.collect.ImmutableOpenMap;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Monitor runs on master and listens for events from #ClusterInfoService on node stats. It checks to see if\n+ * a node has all paths writable if not removes the node from the cluster based on the setting monitor.fs.unhealthy.remove_enabled\n+ */\n+public class FsReadOnlyMonitor {", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA3MDMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411070322", "bodyText": "If I understand correctly we don't want NodeClient pulling up FS stats. Instead the FollowerChecker ping should pull the FS health info too?", "author": "Bukhtawar", "createdAt": "2020-04-20T03:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA3MDY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411070641", "bodyText": "I'll change the current implementation and use the Transport request handler. Let me know if thats what is expected", "author": "Bukhtawar", "createdAt": "2020-04-20T03:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTU3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java\ndeleted file mode 100644\nindex 92e82aa2461..00000000000\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsReadOnlyMonitor.java\n+++ /dev/null\n\n@@ -1,102 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.monitor.fs;\n-\n-import com.carrotsearch.hppc.cursors.ObjectObjectCursor;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.cluster.*;\n-import org.elasticsearch.cluster.node.DiscoveryNode;\n-import org.elasticsearch.cluster.node.DiscoveryNodes;\n-import org.elasticsearch.common.collect.ImmutableOpenMap;\n-import org.elasticsearch.common.settings.ClusterSettings;\n-import org.elasticsearch.common.settings.Setting;\n-import org.elasticsearch.common.settings.Settings;\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.BiConsumer;\n-import java.util.function.Supplier;\n-\n-/**\n- * Monitor runs on master and listens for events from #ClusterInfoService on node stats. It checks to see if\n- * a node has all paths writable if not removes the node from the cluster based on the setting monitor.fs.unhealthy.remove_enabled\n- */\n-public class FsReadOnlyMonitor {\n-\n-    private static final Logger logger = LogManager.getLogger(FsReadOnlyMonitor.class);\n-    private final AtomicBoolean checkInProgress = new AtomicBoolean();\n-    private volatile boolean nodeRemovalEnabled;\n-    private final Supplier<ClusterState> clusterStateSupplier;\n-    private final BiConsumer<DiscoveryNode, String> removeNode;\n-    private final Supplier<DiscoveryNode> localNodeSupplier;\n-\n-    public static final Setting<Boolean> REMOVE_UNHEALTHY_FS_ENABLED_SETTING =\n-        Setting.boolSetting(\"monitor.fs.unhealthy.remove_enabled\", true, Setting.Property.Dynamic,\n-            Setting.Property.NodeScope);\n-\n-\n-    public FsReadOnlyMonitor(Settings settings, ClusterSettings clusterSettings, Supplier<ClusterState> clusterStateSupplier,\n-                             Supplier<DiscoveryNode> localNodeSupplier, BiConsumer<DiscoveryNode, String> removeNode,\n-                             ClusterInfoService clusterInfoService) {\n-        this.clusterStateSupplier = clusterStateSupplier;\n-        this.removeNode = removeNode;\n-        this.localNodeSupplier = localNodeSupplier;\n-        this.nodeRemovalEnabled = REMOVE_UNHEALTHY_FS_ENABLED_SETTING.get(settings);\n-        clusterInfoService.addListener(this::onNewInfo);\n-        clusterSettings.addSettingsUpdateConsumer(REMOVE_UNHEALTHY_FS_ENABLED_SETTING, this::setEnabled);\n-    }\n-\n-    private void setEnabled(boolean nodeRemovalEnabled){\n-        this.nodeRemovalEnabled = nodeRemovalEnabled;\n-    }\n-\n-    public void onNewInfo(ClusterInfo info) {\n-        if (checkInProgress.compareAndSet(false, true) == false) {\n-            logger.info(\"Skipping FS readonly monitor as a check is already in progress\");\n-            return;\n-        }\n-        ImmutableOpenMap<String, Boolean> allPathsWritable = info.getNodeAllPathsWritable();\n-        final ClusterState state = clusterStateSupplier.get();\n-        DiscoveryNodes discoveryNodes = state.nodes();\n-        if(allPathsWritable == null)\n-            return;\n-        for (final ObjectObjectCursor<String, Boolean> entry : allPathsWritable) {\n-            final String node = entry.key;\n-            final Boolean allPathWritableForNode = entry.value;\n-            final DiscoveryNode discoveryNode = discoveryNodes.get(node);\n-            if(allPathWritableForNode == Boolean.FALSE){\n-                if (discoveryNode != localNodeSupplier.get()){\n-                    checkAndRemove(discoveryNode);\n-                }\n-            }\n-        }\n-        checkFinished();\n-    }\n-\n-    private void checkFinished() {\n-        final boolean checkFinished = checkInProgress.compareAndSet(true, false);\n-        assert checkFinished;\n-    }\n-\n-    private void checkAndRemove(DiscoveryNode discoveryNode){\n-        if(nodeRemovalEnabled)\n-            removeNode.accept(discoveryNode, \"read-only-filesystem\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136412", "bodyText": "This is too weak a check IMO. It doesn't write any data or fsync anything.", "author": "DaveCTurner", "createdAt": "2020-02-24T08:48:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Nzg1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067852", "bodyText": "Added fsync check", "author": "Bukhtawar", "createdAt": "2020-03-25T18:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 9e8b9d02811..cd4498a1f8e 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjcyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383136724", "bodyText": "I don't understand why we don't count this as UNHEALTHY too. Can you explain?", "author": "DaveCTurner", "createdAt": "2020-02-24T08:49:45Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setRefreshInterval(TimeValue refreshInterval) {\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    public void setHealthcheckTimeoutInterval(TimeValue healthcheckTimeoutInterval) {\n+        this.healthcheckTimeoutInterval = healthcheckTimeoutInterval;\n+    }\n+\n+    public Boolean isWritable(Path path){\n+        if (!enabled){\n+            return null;\n+        }\n+        Status status = pathHealthStats.getOrDefault(path, Status.UNKNOWN);\n+        if (status == Status.UNHEALTHY)\n+            return Boolean.FALSE;\n+        else if (lastSuccessfulRunTimeMillis.get() < currentTimeMillisSupplier.getAsLong() - healthcheckTimeoutInterval.getMillis()){\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    private class FsHealthMonitor implements Runnable {\n+\n+        private static final String TEMP_FILE_NAME = \".es_temp_file\";\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth(){\n+\n+            Map<Path, Status> pathHealthStats = new HashMap<>();\n+            try {\n+                for (Path path : nodeEnv.nodeDataPaths()) {\n+                    try {\n+                        if (Files.exists(path)) {\n+                            Path resolve = path.resolve(TEMP_FILE_NAME);\n+                            // delete any lingering file from a previous failure\n+                            Files.deleteIfExists(resolve);\n+                            Files.createFile(resolve);\n+                            Files.delete(resolve);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                    }catch(IOException ex){\n+                        logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                        pathHealthStats.put(path, Status.UNHEALTHY);\n+                    } catch(Exception ex){", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NzUyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067524", "bodyText": "Removed. Initial thought was any unanticipated bug causing parent Exception", "author": "Bukhtawar", "createdAt": "2020-03-25T18:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNjcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 9e8b9d02811..cd4498a1f8e 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2MTIzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383161239", "bodyText": "5 minutes seems a very long timeout to me. Do we really want to consider a node healthy if it's taking literally minutes to pass this simple check?\nI also think we should be stricter about the UNHEALTHY -> HEALTHY transition to try and avoid flapping. What about keeping the node UNHEALTHY until the check passes very quickly (~1 second?)", "author": "DaveCTurner", "createdAt": "2020-02-24T09:43:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2NzEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398067101", "bodyText": "Done", "author": "Bukhtawar", "createdAt": "2020-03-25T18:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2MTIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 9e8b9d02811..cd4498a1f8e 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2NzA3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r383167077", "bodyText": "I think this should not be on the SAME threadpool since it's doing IO that's potentially slow. GENERIC would be ok, but then I think we need protection to make sure there's only one check running at once.", "author": "DaveCTurner", "createdAt": "2020-02-24T09:54:56Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthcheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private AtomicLong lastSuccessfulRunTimeMillis = new AtomicLong(Long.MIN_VALUE);\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(5), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> HEALTHCHECK_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.unhealthy_timeout\", TimeValue.timeValueMinutes(5), TimeValue.timeValueMinutes(2),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthcheckTimeoutInterval = HEALTHCHECK_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(REFRESH_INTERVAL_SETTING, this::setRefreshInterval);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHCHECK_TIMEOUT_SETTING, this::setHealthcheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        //TODO check if this needs to be a part of a dedicated threadpool\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval, ThreadPool.Names.SAME);", "originalCommit": "b598944ca305f803b27c817e860133ebfd1a7d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2Njk4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398066981", "bodyText": "Done. Also modified the scheduled checks to be one per data path to honour the 1s HEALTHY SLA", "author": "Bukhtawar", "createdAt": "2020-03-25T18:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE2NzA3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 9e8b9d02811..cd4498a1f8e 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -26,6 +26,7 @@ import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n"}}, {"oid": "d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "url": "https://github.com/elastic/elasticsearch/commit/d4fb892602213f62cff1c191eea3ddb3d2f9f8c8", "message": "Test case addition and PR comments", "committedDate": "2020-03-25T13:35:02Z", "type": "commit"}, {"oid": "38f1a4eabe9952b98d138322c4faa5a88b204a68", "url": "https://github.com/elastic/elasticsearch/commit/38f1a4eabe9952b98d138322c4faa5a88b204a68", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-03-25T13:56:53Z", "type": "commit"}, {"oid": "f3ac906bb0a67da98c5070a80085e3e2ab435b26", "url": "https://github.com/elastic/elasticsearch/commit/f3ac906bb0a67da98c5070a80085e3e2ab435b26", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-03-25T14:03:45Z", "type": "commit"}, {"oid": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "url": "https://github.com/elastic/elasticsearch/commit/79948f3fc5938a837696bdfda98b186d1c81d2b5", "message": "Changes for FsHealthService and tests", "committedDate": "2020-03-25T18:08:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTcyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398075722", "bodyText": "Accidentally removed the test. I'll add it back", "author": "Bukhtawar", "createdAt": "2020-03-25T18:24:04Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -165,11 +184,14 @@ public void testStartsElectionIfOtherNodeIsQuorum() {\n         assertTrue(electionOccurred);\n     }\n \n-    public void testDoesNotStartsElectionIfOtherNodeIsQuorumAndDoesNotRespond() {\n+    public void testNonWritableNodeDoesNotOfferPreVote() {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\nindex 16ba9edd93f..c600a1ffc9d 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\n\n@@ -184,14 +181,20 @@ public class PreVoteCollectorTests extends ESTestCase {\n         assertTrue(electionOccurred);\n     }\n \n+    public void testDoesNotStartsElectionIfOtherNodeIsQuorumAndDoesNotRespond() {\n+        final DiscoveryNode otherNode = new DiscoveryNode(\"other-node\", buildNewFakeTransportAddress(), Version.CURRENT);\n+        responsesByNode.put(otherNode, null);\n+        startAndRunCollector(otherNode);\n+        assertFalse(electionOccurred);\n+    }\n+\n     public void testNonWritableNodeDoesNotOfferPreVote() {\n         final long term = randomNonNegativeLong();\n-        FsInfo mockFsStats = mockFsStats(Boolean.FALSE);\n-        Mockito.when(fsService.stats()).thenReturn(mockFsStats);\n+        healthStatus = NodeHealthService.Status.UNHEALTHY;\n         final DiscoveryNode otherNode = new DiscoveryNode(\"other-node\", buildNewFakeTransportAddress(), Version.CURRENT);\n         RemoteTransportException remoteTransportException = expectThrows(RemoteTransportException.class, () ->\n             handlePreVoteRequestViaTransportService(new PreVoteRequest(otherNode, term)));\n-        assertThat(remoteTransportException.getCause(), instanceOf(CoordinationStateRejectedException.class));\n+        assertThat(remoteTransportException.getCause(), instanceOf(FsHealthcheckFailureException.class));\n     }\n \n     public void testDoesNotStartElectionIfStopped() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3Njk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r398076966", "bodyText": "I have left out spaces assuming checkStyles would catch. But unfortunate. I'll fix white spacing", "author": "Bukhtawar", "createdAt": "2020-03-25T18:26:08Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1173,6 +1179,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if(fsService.stats().getTotal().isWritable() == Boolean.FALSE){", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\nindex dc542399838..d90f3f41993 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\n\n@@ -1179,7 +1178,7 @@ public class Coordinator extends AbstractLifecycleComponent implements Discovery\n                             return;\n                         }\n \n-                        if(fsService.stats().getTotal().isWritable() == Boolean.FALSE){\n+                        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n                             logger.warn(\"skip prevoting as local node is not writable: {}\",\n                                 lastAcceptedState.coordinationMetaData());\n                             return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNTA1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411205051", "bodyText": "These tests are very weak, they simply override the checks that FsHealthService performs which means we're not really checking its behaviour at all.\nI would prefer to see tests that use a custom FileSystemProvider to inject failures that the real FsHealthService can detect. Most should use a DeterministicTaskQueue to verify that the checks keep on being scheduled at the right times, without needing to wait for timeouts to occur. Since we also want to detect things hanging I think we'll also need a genuinely multithreaded test with short timeouts to show that we do indeed detect that IO hangs.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:50:10Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+import static org.mockito.Mockito.mock;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 3c931cb97fe..47f6d3085e5 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -17,93 +17,68 @@\n  * under the License.\n  */\n \n+\n package org.elasticsearch.monitor.fs;\n \n \n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.TestThreadPool;\n import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n \n import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.nio.file.attribute.FileAttribute;\n import java.util.Set;\n-import java.util.TreeSet;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.LongSupplier;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n-import static org.mockito.Mockito.mock;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n \n \n public class FsHealthServiceTests extends ESTestCase {\n \n-    public void testIsPathWritable() throws Exception {\n-        Map<Path, FsHealthService.TimeStampedStatus> pathHealthStats = new HashMap<>();\n-        try (NodeEnvironment env = newNodeEnvironment()) {\n-            pathHealthStats.put(env.nodeDataPaths()[0], new FsHealthService.TimeStampedStatus(FsHealthService.Status.HEALTHY));\n-            final Settings settings = Settings.EMPTY;\n-            final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n-            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, null,\n-                env, ()  ->  1){\n-                @Override\n-                Map<Path, TimeStampedStatus> getPathHealthStats() {\n-                    return pathHealthStats;\n-                }\n-            };\n-            assertTrue(fsHealthService.isWritable(env.nodeDataPaths()[0]));\n-            assertNull(fsHealthService.isWritable(mock(Path.class)));\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n \n-            pathHealthStats.put(env.nodeDataPaths()[0], new FsHealthService.TimeStampedStatus(FsHealthService.Status.UNHEALTHY));\n-            fsHealthService = new FsHealthService(settings, clusterSettings, null,\n-                env, ()  ->  1){\n-                @Override\n-                Map<Path, TimeStampedStatus> getPathHealthStats() {\n-                    return pathHealthStats;\n-                }\n-            };\n-            assertFalse(fsHealthService.isWritable(env.nodeDataPaths()[0]));\n-            assertNull(fsHealthService.isWritable(mock(Path.class)));\n-        }\n     }\n \n-    public void testIsPathWritableOnStaleHealth() throws Exception {\n-        Map<Path, FsHealthService.TimeStampedStatus> pathHealthStats = new HashMap<>();\n+    public void testReturnsUnhealthyAfterTimeout() throws Exception {\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n         try (NodeEnvironment env = newNodeEnvironment()) {\n-            pathHealthStats.put(env.nodeDataPaths()[0], new FsHealthService.TimeStampedStatus(FsHealthService.Status.HEALTHY));\n-            final Settings settings = Settings.builder().put(FsHealthService.HEALTHY_TIMEOUT_SETTING.getKey(), 1000 + \"ms\").build();;\n-            final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n-            LongSupplier currentTimeSupplier = () -> System.currentTimeMillis() + randomLongBetween(1001, 10000);\n-            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, null,\n-                env, currentTimeSupplier){\n-                @Override\n-                Map<Path, TimeStampedStatus> getPathHealthStats() {\n-                    return pathHealthStats;\n-                }\n-            };\n-            assertFalse(fsHealthService.isWritable(env.nodeDataPaths()[0]));\n-            assertNull(fsHealthService.isWritable(mock(Path.class)));\n-\n-            pathHealthStats.put(env.nodeDataPaths()[0], new FsHealthService.TimeStampedStatus(FsHealthService.Status.UNHEALTHY));\n-            fsHealthService = new FsHealthService(settings, clusterSettings, null,\n-                env, currentTimeSupplier){\n-                @Override\n-                Map<Path, TimeStampedStatus> getPathHealthStats() {\n-                    return pathHealthStats;\n-                }\n-            };\n-            assertFalse(fsHealthService.isWritable(env.nodeDataPaths()[0]));\n-            assertNull(fsHealthService.isWritable(mock(Path.class)));\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            deterministicTaskQueue.scheduleAt(randomLongBetween(\n+                FsHealthService.HEALTHY_TIMEOUT_SETTING.get(settings).millis()\n+                    + FsHealthService.REFRESH_INTERVAL_SETTING.get(settings).millis() + 1, 10000), () -> {});\n+            deterministicTaskQueue.advanceTime();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n         }\n     }\n \n-    public void testPathHealthMonitorSchedule() throws IOException {\n+    public void testSchedulesFsHealthMonitor() throws IOException {\n         NodeEnvironment env = newNodeEnvironment();\n         AtomicBoolean scheduled = new AtomicBoolean();\n         Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), TimeValue.timeValueMillis(1000))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNzMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411207337", "bodyText": "This doesn't seem necessary, it's enough for followers to reject the today's health checks.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:53:42Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsRequest;\n+import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.common.TriConsumer;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.monitor.fs.FsHealthService;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.ReceiveTimeoutTransportException;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+public class NodeFsHealthChecker {", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTY0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412435643", "bodyText": "Agree. That simplifies a great deal", "author": "Bukhtawar", "createdAt": "2020-04-21T19:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNzMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java b/server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java\ndeleted file mode 100644\nindex c632391c612..00000000000\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/NodeFsHealthChecker.java\n+++ /dev/null\n\n@@ -1,131 +0,0 @@\n-/*\n- * Licensed to Elasticsearch under one or more contributor\n- * license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright\n- * ownership. Elasticsearch licenses this file to you under\n- * the Apache License, Version 2.0 (the \"License\"); you may\n- * not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.elasticsearch.cluster.coordination;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.action.admin.cluster.node.stats.NodeStats;\n-import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsRequest;\n-import org.elasticsearch.action.admin.cluster.node.stats.NodesStatsResponse;\n-import org.elasticsearch.client.Client;\n-import org.elasticsearch.cluster.block.ClusterBlockException;\n-import org.elasticsearch.cluster.node.DiscoveryNode;\n-import org.elasticsearch.common.TriConsumer;\n-import org.elasticsearch.common.settings.Setting;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.unit.TimeValue;\n-import org.elasticsearch.monitor.fs.FsHealthService;\n-import org.elasticsearch.threadpool.ThreadPool;\n-import org.elasticsearch.transport.ReceiveTimeoutTransportException;\n-import org.elasticsearch.transport.TransportService;\n-\n-import java.util.Set;\n-import java.util.function.Supplier;\n-\n-public class NodeFsHealthChecker {\n-\n-    private static final Logger logger = LogManager.getLogger(FollowersChecker.class);\n-\n-    public static final Setting<TimeValue> FS_HEALTH_CHECK_INTERVAL_SETTING =\n-        Setting.timeSetting(\"cluster.fault_detection.fs_health_check.interval\",\n-            TimeValue.timeValueMillis(5000), TimeValue.timeValueMillis(100), Setting.Property.NodeScope);\n-\n-    private final TimeValue fsHealthCheckInterval;\n-    private final boolean fsHealthCheckEnabled;\n-    private final TriConsumer<DiscoveryNode, String, Supplier<Boolean>> failFollower;\n-    private final TransportService transportService;\n-    private final Supplier<Set<DiscoveryNode>> followerNodesSupplier;\n-    private final Client nodeClient;\n-\n-    public NodeFsHealthChecker(Settings settings, TransportService transportService, Client nodeClient, TriConsumer<DiscoveryNode,\n-        String, Supplier<Boolean>> failFollower, Supplier<Set<DiscoveryNode>> followerNodesSupplier){\n-        fsHealthCheckEnabled = FsHealthService.ENABLED_SETTING.get(settings);\n-        fsHealthCheckInterval = FS_HEALTH_CHECK_INTERVAL_SETTING.get(settings);\n-        this.followerNodesSupplier = followerNodesSupplier;\n-        this.failFollower = failFollower;\n-        this.transportService = transportService;\n-        this.nodeClient = nodeClient;\n-    }\n-\n-\n-    void start() {\n-        handleWakeUp();\n-    }\n-\n-\n-    private void scheduleNextWakeUp() {\n-        if (followerNodesSupplier.get().isEmpty() == false) {\n-            transportService.getThreadPool().schedule(new Runnable() {\n-                @Override\n-                public void run() {\n-                    handleWakeUp();\n-                }\n-\n-                @Override\n-                public String toString() {\n-                    return NodeFsHealthChecker.this + \"::handleWakeUp\";\n-                }\n-            }, fsHealthCheckInterval, ThreadPool.Names.SAME);\n-        }\n-    }\n-\n-\n-    private void handleWakeUp() {\n-        if (fsHealthCheckEnabled && followerNodesSupplier.get().isEmpty() == false) {\n-            NodesStatsRequest nodesStatsRequest = new NodesStatsRequest().clear().fs(true).timeout(fsHealthCheckInterval);\n-            NodesStatsResponse nodesStatsResponse = fetchNodeStats(nodesStatsRequest);\n-            if(nodesStatsResponse == null){\n-                return;\n-            }\n-            for (NodeStats nodeStats : nodesStatsResponse.getNodes()) {\n-                if (nodeStats.getFs() == null) {\n-                    logger.warn(\"Unable to retrieve node FS stats for {}\", nodeStats.getNode().getName());\n-                } else {\n-                    if (nodeStats.getFs().getTotal().isWritable() == Boolean.FALSE) {\n-                        failFollower.apply(nodeStats.getNode(), \"read-only-file-system\", () ->\n-                            followerNodesSupplier.get().contains(nodeStats.getNode()));\n-                    }\n-                }\n-            }\n-        }\n-        scheduleNextWakeUp();\n-    }\n-\n-    private NodesStatsResponse fetchNodeStats(NodesStatsRequest nodeStatsRequest) {\n-        NodesStatsResponse nodesStatsResponse = null;\n-        try {\n-            nodesStatsResponse = nodeClient.admin().cluster().nodesStats(nodeStatsRequest).actionGet();\n-        } catch (Exception e){\n-            if (e instanceof ReceiveTimeoutTransportException) {\n-                logger.error(\"NodeStatsRequest timed out for FollowerChecker\", e);\n-            } else {\n-                if (e instanceof ClusterBlockException) {\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"Failed to execute NodeStatsRequest for FollowerChecker\", e);\n-                    }\n-                } else {\n-                    logger.warn(\"Failed to execute NodeStatsRequest for FollowerChecker\", e);\n-                }\n-            }\n-        }\n-        return nodesStatsResponse;\n-    }\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411209403", "bodyText": "I don't think we should add this to the stats -- we aim to remove read-only nodes from the cluster, so this will effectively always be true when collecting stats.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:56:46Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java", "diffHunk": "@@ -48,16 +48,19 @@\n         long total = -1;\n         long free = -1;\n         long available = -1;\n+        @Nullable\n+        Boolean isWritable;", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NDExMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411854113", "bodyText": "Sure but when we actually have a read-only node removed, it would still stay around unless an operator intervenes by either fixing some of the issues or replacing it. I feel /_nodes/_local/stats might still serve a good purpose and would let the system know it needs an attention.", "author": "Bukhtawar", "createdAt": "2020-04-21T04:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MDE1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411950152", "bodyText": "I think this is already handled by the cluster health API -- the faulty node will report red health when it is removed from the cluster which is a much clearer indication that action is needed, and we can record helpful details in the logs since we always check the logs in this kind of situation.", "author": "DaveCTurner", "createdAt": "2020-04-21T07:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTQ3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412425479", "bodyText": "While I understand we don't want to expose the stats, is the interface FsService#stats().getTotal().isWritable()  acceptable at multiple places that I have used to reject requests @ PrevoteCollector/JoinHelper/FollowersChecker or should FsService expose another interface without touching FsInfo at all\nSimply having a RED node from health API may not be able to differentiate a N/W /GC pause/FS issue distinctly and remediations actions might differ. Having a metric may help with some automation which would otherwise need a log dive.\nLet me know your thoughts anyways.", "author": "Bukhtawar", "createdAt": "2020-04-21T19:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3OTcwNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412679704", "bodyText": "I'll change this to FsService.FsHealthService#isWritable() elsewhere I don't think we need to carry any other baggage. Do you think FsHealthService can exist independently outside MonitorService ?", "author": "Bukhtawar", "createdAt": "2020-04-22T05:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc2OTU5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412769597", "bodyText": "Yes, I don't think FsService should be involved here. FsHealthService makes sense on its own.", "author": "DaveCTurner", "createdAt": "2020-04-22T08:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwOTQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java\nindex 6f0eec84331..0a408b353ee 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsInfo.java\n\n@@ -48,19 +48,16 @@ public class FsInfo implements Iterable<FsInfo.Path>, Writeable, ToXContentFragm\n         long total = -1;\n         long free = -1;\n         long available = -1;\n-        @Nullable\n-        Boolean isWritable;\n \n         public Path() {\n         }\n \n-        public Path(String path, @Nullable String mount, long total, long free, long available, @Nullable Boolean isWritable) {\n+        public Path(String path, @Nullable String mount, long total, long free, long available) {\n             this.path = path;\n             this.mount = mount;\n             this.total = total;\n             this.free = free;\n             this.available = available;\n-            this.isWritable = isWritable;\n         }\n \n         /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411210570", "bodyText": "I think we only need to schedule one task which loops through all paths itself. There's no need to check them in parallel like this.", "author": "DaveCTurner", "createdAt": "2020-04-20T08:58:37Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;\n+    private volatile Set<Scheduler.Cancellable> scheduledFutures;\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueSeconds(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv,\n+                    LongSupplier currentTimeMillisSupplier) {\n+        this.scheduledFutures = new HashSet<>();\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = currentTimeMillisSupplier;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>();\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        for (Path path : nodeEnv.nodeDataPaths()) {\n+            scheduledFutures.add(threadPool.scheduleWithFixedDelay(new FsPathHealthMonitor(path), refreshInterval,", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411855013", "bodyText": "The idea behind it is there is still a possibility that multiple data paths can  be mounted on separate (network) volumes and can fail independently. Since we were publishing stats per data path, it made sense to individually report the health per data path. Let me know if you think otherwise. If you don't think /_node/_local/stats adds any value we can consider alternatives", "author": "Bukhtawar", "createdAt": "2020-04-21T04:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MTM3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411951378", "bodyText": "It's true that the paths can fail independently but this doesn't matter, we will fail the node if any of the paths are broken. I see that independent checks may be useful for stats but as per my previous comment I don't think we need to expose this in stats.", "author": "DaveCTurner", "createdAt": "2020-04-21T07:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDU3MA=="}], "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 6f5f72c3e5f..524258eab27 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -28,6 +28,7 @@ import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r411212995", "bodyText": "This seems unnecessarily detailed. I think we only really need to keep track of the time of the last successful check.", "author": "DaveCTurner", "createdAt": "2020-04-20T09:02:05Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, TimeStampedStatus> pathHealthStats;", "originalCommit": "79948f3fc5938a837696bdfda98b186d1c81d2b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjA3Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r412436076", "bodyText": "Sure based on the above discussion I'll simplify further", "author": "Bukhtawar", "createdAt": "2020-04-21T19:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 6f5f72c3e5f..524258eab27 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -28,6 +28,7 @@ import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n import org.elasticsearch.threadpool.Scheduler;\n import org.elasticsearch.threadpool.ThreadPool;\n \n"}}, {"oid": "20d9ba2374db52764f4bff520d375d5a3aa21bec", "url": "https://github.com/elastic/elasticsearch/commit/20d9ba2374db52764f4bff520d375d5a3aa21bec", "message": "Review comments for simplication and better tests", "committedDate": "2020-05-03T10:50:04Z", "type": "commit"}, {"oid": "fa3ed380323c163bf0131cb4193b06b671f775ef", "url": "https://github.com/elastic/elasticsearch/commit/fa3ed380323c163bf0131cb4193b06b671f775ef", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-03T10:53:08Z", "type": "commit"}, {"oid": "1646319e6613f7baef5779c62d451bca9ed0bce0", "url": "https://github.com/elastic/elasticsearch/commit/1646319e6613f7baef5779c62d451bca9ed0bce0", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-05-03T16:03:52Z", "type": "commit"}, {"oid": "5305ebb1b39a812f7d64dae67889750bb311355a", "url": "https://github.com/elastic/elasticsearch/commit/5305ebb1b39a812f7d64dae67889750bb311355a", "message": "Fixing tests and check styles", "committedDate": "2020-05-03T23:22:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MTc4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419541788", "bodyText": "Suggest collapsing UNKNOWN with HEALTHY, there's no need to distinguish these cases IMO.", "author": "DaveCTurner", "createdAt": "2020-05-04T15:55:50Z", "path": "server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor;\n+\n+@FunctionalInterface\n+public interface NodeHealthService {\n+\n+    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MTkzMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419641932", "bodyText": "Intent was if the healthcheck hasn't yet started(not sure if thats possible) while the consumers have started to poll for health. Changed for now as suggested", "author": "Bukhtawar", "createdAt": "2020-05-04T18:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0MTc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java b/server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java\nindex 6cc4e296c05..649a06878ae 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/NodeHealthService.java\n\n@@ -22,7 +22,7 @@ package org.elasticsearch.monitor;\n @FunctionalInterface\n public interface NodeHealthService {\n \n-    enum Status { HEALTHY, UNHEALTHY, UNKNOWN }\n+    enum Status { HEALTHY, UNHEALTHY }\n \n     Status getHealth();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NTg1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419545856", "bodyText": "I checked a few example systems in production and it seems like it's not that unusual to see delays of a few 10s of seconds that eventually succeed. This is common enough that I think it would be bad to start failing nodes in those cases by default. I will follow up with some of my systems engineering colleagues to agree on a sensible default here, but 1s is certainly too low.\nAlso a reminder about having a shorter timeout for the UNHEALTHY -> HEALTHY transition vs the HEALTHY -> UNHEALTHY one, mentioned first here: #52680 (comment)", "author": "DaveCTurner", "createdAt": "2020-05-04T16:01:32Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjE4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419546187", "bodyText": "I think Status.HEALTHY is fine here.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:01:59Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MzMxNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419643317", "bodyText": "Changed", "author": "Bukhtawar", "createdAt": "2020-05-04T18:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0ODU3Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419548573", "bodyText": "If this individual check saw no exceptions but took longer than the timeout interval then I don't think we should record it as a successful run as is done here, since that will result in a fatally-slow node still occasionally reporting itself as healthy, joining the cluster, and then failing again.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:05:34Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MTkyMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419791921", "bodyText": "Good point. My bad I missed this", "author": "Bukhtawar", "createdAt": "2020-05-04T23:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0ODU3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419554590", "bodyText": "I would like us to log when we become unhealthy in this service rather than relying on its clients logging warnings/errors, since I am concerned that the clients' messages may be hard to interpret and they vary a lot which will make analysis a good deal harder. That means I think we'll need to schedule a timeout handler for each check. It would be mightily useful if that log message were to include which path(s) were faulty, and how long it took to check each path.\nI'd also like us to log when a check takes longer than some threshold (say, 10s by default) but not long enough to fail the node. This kind of sub-threshold warning can be a useful leading indicator of impending doom. See e.g. cluster.publish.info_timeout vs cluster.publish.timeout.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:14:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4NjAxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419786010", "bodyText": "Should we consider multiple logging levels here like separate thresholds for info/warn levels?", "author": "Bukhtawar", "createdAt": "2020-05-04T23:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA3MzE1MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r420073150", "bodyText": "I don't think we need multiple warnings before hitting the threshold for failure, but I think it's reasonable to log the warning at WARN and then log the actual failure at ERROR.", "author": "DaveCTurner", "createdAt": "2020-05-05T12:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NDU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjcyNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419562724", "bodyText": "Also why Math.max? I think that currentTimeMillisSupplier is ThreadPool#relativeTimeInMillis which is monotonic.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:26:10Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {\n+                logger.warn(\"Skipping Monitor for disk health as a check is already in progress\");\n+                return;\n+            }\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                            pathHealthStats.put(path, Status.HEALTHY);\n+                        }\n+                        Files.delete(tempDataPath);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform writes on path {} due to {}\", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+                }\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> Math.max(l, currentTimeMillisSupplier.getAsLong()));", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NzI4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419647289", "bodyText": "Ahh.. I started lastRunTimeMillis as Long.MIN_VALUE originally", "author": "Bukhtawar", "createdAt": "2020-05-04T18:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419564461", "bodyText": "Can that happen? I think threadPool.scheduleWithFixedDelay avoids this?", "author": "DaveCTurner", "createdAt": "2020-05-04T16:28:44Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue healthCheckTimeoutInterval;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+    private AtomicBoolean checkInProgress = new AtomicBoolean();\n+\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(10),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> HEALTHY_TIMEOUT_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.healthy_timeout\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.healthCheckTimeoutInterval = HEALTHY_TIMEOUT_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(HEALTHY_TIMEOUT_SETTING, this::setHealthCheckTimeoutInterval);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+\n+    public void setHealthCheckTimeoutInterval(TimeValue healthCheckTimeoutInterval) {\n+        this.healthCheckTimeoutInterval = healthCheckTimeoutInterval;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.UNKNOWN;\n+        }\n+        else if ((currentTimeMillisSupplier.getAsLong() - lastRunTimeMillis.get()) >\n+            (refreshInterval.millis() + healthCheckTimeoutInterval.millis())) {\n+            return Status.UNHEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for disk health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring disk health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            if (checkInProgress.compareAndSet(false, true) == false) {", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MTI1Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419571252", "bodyText": "My bad, I asked for this in #52680 (comment) it seems.", "author": "DaveCTurner", "createdAt": "2020-05-04T16:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTc2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419645761", "bodyText": ":) I added it just an additional guarantee. I too think its not needed", "author": "Bukhtawar", "createdAt": "2020-05-04T18:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 839bdfaf09a..89f93b6f3c7 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,6 +19,7 @@\n \n package org.elasticsearch.monitor.fs;\n \n+import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTIzNA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419565234", "bodyText": "Nit: \"health check\" is two words:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class FsHealthcheckFailureException extends ElasticsearchException {\n          \n          \n            \n            public class FsHealthCheckFailureException extends ElasticsearchException {", "author": "DaveCTurner", "createdAt": "2020-05-04T16:29:57Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.cluster.coordination;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+\n+import java.io.IOException;\n+\n+/**\n+ * This exception is thrown if the File system is reported unhealthy by @{@link org.elasticsearch.monitor.fs.FsHealthService}\n+ * and this nodes needs to be removed from the cluster\n+ */\n+\n+public class FsHealthcheckFailureException extends ElasticsearchException {", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java b/server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthCheckFailureException.java\nsimilarity index 86%\nrename from server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java\nrename to server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthCheckFailureException.java\nindex 85c7fb464cf..ad9899f2869 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthcheckFailureException.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FsHealthCheckFailureException.java\n\n@@ -29,13 +29,13 @@ import java.io.IOException;\n  * and this nodes needs to be removed from the cluster\n  */\n \n-public class FsHealthcheckFailureException extends ElasticsearchException {\n+public class FsHealthCheckFailureException extends ElasticsearchException {\n \n-    public FsHealthcheckFailureException(String msg, Object... args) {\n+    public FsHealthCheckFailureException(String msg, Object... args) {\n         super(msg, args);\n     }\n \n-    public FsHealthcheckFailureException(StreamInput in) throws IOException {\n+    public FsHealthCheckFailureException(StreamInput in) throws IOException {\n         super(in);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NjE4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r419566188", "bodyText": "nit: two words\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,\n          \n          \n            \n                    FS_HEALTH_CHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthCheckFailureException.class,", "author": "DaveCTurner", "createdAt": "2020-05-04T16:31:25Z", "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1041,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,", "originalCommit": "5305ebb1b39a812f7d64dae67889750bb311355a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ElasticsearchException.java b/server/src/main/java/org/elasticsearch/ElasticsearchException.java\nindex 8ba16fe2a35..70ea27ebcbf 100644\n--- a/server/src/main/java/org/elasticsearch/ElasticsearchException.java\n+++ b/server/src/main/java/org/elasticsearch/ElasticsearchException.java\n\n@@ -1042,8 +1043,8 @@ public class ElasticsearchException extends RuntimeException implements ToXConte\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n                 Version.V_7_5_0),\n-        FS_HEALTHCHECK_FAILURE_EXCEPTION(org.elasticsearch.cluster.coordination.FsHealthcheckFailureException.class,\n-            org.elasticsearch.cluster.coordination.FsHealthcheckFailureException::new, 158, Version.V_8_0_0),;\n+        FS_HEALTH_CHECK_FAILURE_EXCEPTION(FsHealthCheckFailureException.class,\n+            FsHealthCheckFailureException::new, 158, Version.V_8_0_0),;\n \n         final Class<? extends ElasticsearchException> exceptionClass;\n         final CheckedFunction<StreamInput, ? extends ElasticsearchException, IOException> constructor;\n"}}, {"oid": "26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "url": "https://github.com/elastic/elasticsearch/commit/26fbce7f91d6fa9c34e39ceab9d9d0f0e375f2b9", "message": "FsHealthService comments on slow IO", "committedDate": "2020-05-05T14:49:44Z", "type": "commit"}, {"oid": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "url": "https://github.com/elastic/elasticsearch/commit/8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "message": "Restricting FS health checks to IOExceptions", "committedDate": "2020-05-11T12:12:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5OTI5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426699290", "bodyText": "Please format this like the other declarations:\n\nmultiple lines\nfully-qualified class names rather than an import\nno trailing comma", "author": "DaveCTurner", "createdAt": "2020-05-18T15:12:11Z", "path": "server/src/main/java/org/elasticsearch/ElasticsearchException.java", "diffHunk": "@@ -1041,7 +1042,9 @@ public String toString() {\n                 org.elasticsearch.ingest.IngestProcessorException.class,\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n-                Version.V_7_5_0);\n+                Version.V_7_5_0),\n+        FS_HEALTH_CHECK_FAILURE_EXCEPTION(FsHealthCheckFailureException.class,", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/ElasticsearchException.java b/server/src/main/java/org/elasticsearch/ElasticsearchException.java\nindex 70ea27ebcbf..65d2e02682f 100644\n--- a/server/src/main/java/org/elasticsearch/ElasticsearchException.java\n+++ b/server/src/main/java/org/elasticsearch/ElasticsearchException.java\n\n@@ -1043,8 +1042,11 @@ public class ElasticsearchException extends RuntimeException implements ToXConte\n                 org.elasticsearch.ingest.IngestProcessorException::new,\n                 157,\n                 Version.V_7_5_0),\n-        FS_HEALTH_CHECK_FAILURE_EXCEPTION(FsHealthCheckFailureException.class,\n-            FsHealthCheckFailureException::new, 158, Version.V_8_0_0),;\n+        FS_HEALTH_CHECK_FAILURE_EXCEPTION(\n+                org.elasticsearch.cluster.coordination.NodeHealthCheckFailureException.class,\n+                org.elasticsearch.cluster.coordination.NodeHealthCheckFailureException::new,\n+                158,\n+                Version.V_8_0_0);\n \n         final Class<? extends ElasticsearchException> exceptionClass;\n         final CheckedFunction<StreamInput, ? extends ElasticsearchException, IOException> constructor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMDQ5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426700498", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"skip prevoting as local node is not writable: {}\",\n          \n          \n            \n                                        logger.debug(\"skip prevoting as local node is not writable: {}\",\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: local node is not writeable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:13:52Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java", "diffHunk": "@@ -1197,6 +1202,12 @@ public void run() {\n                             return;\n                         }\n \n+                        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+                            logger.warn(\"skip prevoting as local node is not writable: {}\",", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\nindex 5aa234a87a7..807a5edda1a 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/Coordinator.java\n\n@@ -1202,8 +1203,8 @@ public class Coordinator extends AbstractLifecycleComponent implements Discovery\n                             return;\n                         }\n \n-                        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n-                            logger.warn(\"skip prevoting as local node is not writable: {}\",\n+                        if (nodeHealthService.getHealth().getStatus() == UNHEALTHY) {\n+                            logger.debug(\"skip prevoting as local due to {} : {}\", nodeHealthService.getHealth().getInfo(),\n                                 lastAcceptedState.coordinationMetadata());\n                             return;\n                         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426701042", "bodyText": "An error here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n          \n            \n                        logger.debug(\"Rejecting health check request {} as all data paths are not writable\", request);\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:14:36Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Nzg3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426777872", "bodyText": "Do you think it makes sense to change the interface to below and throwing a checked exception to all the consumers as stated above\npublic interface NodeHealthService {\n   void ensureHealthy() throws HealthCheckFailureException;", "author": "Bukhtawar", "createdAt": "2020-05-18T17:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwMTg1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426801857", "bodyText": "HealthCheckFailureException  could either be a generic exception or FsHealthCheckFailureException if needed can sub-class it. Let me know what you think. @DaveCTurner your thoughts on the proposal?", "author": "Bukhtawar", "createdAt": "2020-05-18T17:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMzkzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r427423939", "bodyText": "I think its better to add more info along with status since we are not actually performing health check but returning pre-computed results. I have also changed FsHealthCheckFailureException to HealthCheckFailureException to maintain the generic interface of NodeHealthService\n@FunctionalInterface\npublic interface NodeHealthService {\n\n    StatusInfo getHealth();\n\n    enum Status { HEALTHY, UNHEALTHY }\n\n    class StatusInfo {\n        private Status status;\n        private String info;\n\n        public StatusInfo(Status status, String info) {\n            this.status = status;\n            this.info = info;\n        }\n\n        public String getInfo() {\n            return info;\n        }\n\n        public Status getStatus() {\n            return status;\n        }\n    }\n}", "author": "Bukhtawar", "createdAt": "2020-05-19T16:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTA0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\nindex 1fe57d9b5b3..d83f4867c56 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\n\n@@ -162,9 +163,10 @@ public class FollowersChecker {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n-            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n-            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" since not all paths are writable \" + this);\n+        if (nodeHealthService.getHealth().getStatus() == UNHEALTHY) {\n+            String message = \"Rejecting health check request \"+ request + \"due to \" + nodeHealthService.getHealth().getInfo();\n+            logger.debug(message);\n+            throw new NodeHealthCheckFailureException(message);\n         }\n \n         FastResponseState responder = this.fastResponseState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzMwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703303", "bodyText": "Suggest removing this from the message, it's not relevant for the exception.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:17:49Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java", "diffHunk": "@@ -160,8 +162,12 @@ public void updateFastResponseState(final long term, final Mode mode) {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        FastResponseState responder = this.fastResponseState;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n+            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" since not all paths are writable \" + this);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\nindex 1fe57d9b5b3..d83f4867c56 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/FollowersChecker.java\n\n@@ -162,9 +163,10 @@ public class FollowersChecker {\n     }\n \n     private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {\n-        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n-            logger.error(\"Rejecting health check request {} as all data paths are not writable\", request);\n-            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" since not all paths are writable \" + this);\n+        if (nodeHealthService.getHealth().getStatus() == UNHEALTHY) {\n+            String message = \"Rejecting health check request \"+ request + \"due to \" + nodeHealthService.getHealth().getInfo();\n+            logger.debug(message);\n+            throw new NodeHealthCheckFailureException(message);\n         }\n \n         FastResponseState responder = this.fastResponseState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMzY5NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426703694", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"All paths are not writable. Blocking join request\");\n          \n          \n            \n                        logger.debug(\"All paths are not writable. Blocking join request\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:18:27Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java", "diffHunk": "@@ -232,6 +237,10 @@ void logLastFailedJoinAttempt() {\n \n     public void sendJoinRequest(DiscoveryNode destination, long term, Optional<Join> optionalJoin) {\n         assert destination.isMasterNode() : \"trying to join master-ineligible \" + destination;\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"All paths are not writable. Blocking join request\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java\nindex 49698c3526d..09e9aed9e8d 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/JoinHelper.java\n\n@@ -237,8 +239,8 @@ public class JoinHelper {\n \n     public void sendJoinRequest(DiscoveryNode destination, long term, Optional<Join> optionalJoin) {\n         assert destination.isMasterNode() : \"trying to join master-ineligible \" + destination;\n-        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n-            logger.warn(\"All paths are not writable. Blocking join request\");\n+        if (nodeHealthService.getHealth().getStatus() == UNHEALTHY) {\n+            logger.debug(\"Blocking join request due to [{}]\", nodeHealthService.getHealth().getInfo());\n             return;\n         }\n         final JoinRequest joinRequest = new JoinRequest(transportService.getLocalNode(), term, optionalJoin);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzIyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426707227", "bodyText": "A warning here isn't helpful, we should be logging the failure elsewhere so this will simply result in confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Reject offering pre-vote as all paths are not writable\");\n          \n          \n            \n                        logger.debug(\"Reject offering pre-vote as all paths are not writable\");\n          \n      \n    \n    \n  \n\nAlso, we have this generic NodeHealthService but the log message is very specific: all data paths are not writable. Maybe the NodeHealthService should describe the problem rather than returning a simple boolean. Possibly makes sense to construct the exception within the NodeHealthService.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:23:31Z", "path": "server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java", "diffHunk": "@@ -105,6 +108,12 @@ private PreVoteResponse handlePreVoteRequest(final PreVoteRequest request) {\n         final DiscoveryNode leader = state.v1();\n         final PreVoteResponse response = state.v2();\n \n+        //TODO verify if the placement makes sense\n+        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n+            logger.warn(\"Reject offering pre-vote as all paths are not writable\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java b/server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java\nindex ed0b2c659d1..4a819259f91 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/coordination/PreVoteCollector.java\n\n@@ -108,10 +110,10 @@ public class PreVoteCollector {\n         final DiscoveryNode leader = state.v1();\n         final PreVoteResponse response = state.v2();\n \n-        //TODO verify if the placement makes sense\n-        if (nodeHealthService.getHealth() == NodeHealthService.Status.UNHEALTHY) {\n-            logger.warn(\"Reject offering pre-vote as all paths are not writable\");\n-            throw new FsHealthCheckFailureException(\"rejecting \" + request + \" as not all paths are writable\");\n+        if (nodeHealthService.getHealth().getStatus() == UNHEALTHY) {\n+            String message = \"Rejecting health check request \" + request + \" due to \" + nodeHealthService.getHealth().getInfo();\n+            logger.debug(message);\n+            throw new NodeHealthCheckFailureException(message);\n         }\n \n         if (leader == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTgzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426715837", "bodyText": "This spawns (and hopefully cancels) a lot of tasks each iteration. Given that we're not considering timing out here, let's just log at the end of each path's check if it was slow. This has the added advantage that we can report exactly how long it took, not just that it took >5s.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:36:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTkwOA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r427029908", "bodyText": "The reason why I think the timeout handler works better, is if the node is already stuck on IO we won't get to know till it recovers. Let me know what you think", "author": "Bukhtawar", "createdAt": "2020-05-19T04:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNTgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 5f0cde165ea..2895495fec3 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,7 +19,6 @@\n \n package org.elasticsearch.monitor.fs;\n \n-import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjE0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716141", "bodyText": "Is this used? I think we can drop it.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:36:32Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 5f0cde165ea..2895495fec3 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,7 +19,6 @@\n \n package org.elasticsearch.monitor.fs;\n \n-import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNjU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426716563", "bodyText": "This is only called in one place, I think we can inline it.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:37:06Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 5f0cde165ea..2895495fec3 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,7 +19,6 @@\n \n package org.elasticsearch.monitor.fs;\n \n-import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxNzgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426717822", "bodyText": "Suggest a message of the form checking writability of [{}] took [{}ms] which is above the warn threshold of [{}] since this is the wording used in other similar messages.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:38:52Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.LongSupplier;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+    private volatile Scheduler.Cancellable slowPathHealthCheckTimeoutHandler;\n+    private final AtomicLong lastRunTimeMillis = new AtomicLong();\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+        slowPathHealthCheckTimeoutHandler.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public Status getHealth() {\n+        if (enabled == false) {\n+            return Status.HEALTHY;\n+        }\n+        return pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == Status.UNHEALTHY) ? Status.UNHEALTHY\n+            : Status.HEALTHY;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"Monitor for FS health ran successfully {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception monitoring FS health\", e);\n+            }\n+        }\n+\n+        private void monitorFSHealth() {\n+            for (Path path : nodeEnv.nodeDataPaths()) {\n+                long executionStartTime = currentTimeMillisSupplier.getAsLong();\n+                slowPathHealthCheckTimeoutHandler = threadPool.schedule(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logSlowDataPath(Level.WARN, path, executionStartTime);\n+                    }\n+                    @Override\n+                    public String toString() {\n+                        return \"Scheduled timeout for logging slow IO \" + FsHealthService.FsHealthMonitor.this;\n+                    }\n+                }, slowPathLoggingThreshold, ThreadPool.Names.GENERIC);\n+\n+                try {\n+                    if (Files.exists(path)) {\n+                        Path tempDataPath = path.resolve(TEMP_FILE_NAME);\n+                        Files.deleteIfExists(tempDataPath);\n+                        try (OutputStream os = Files.newOutputStream(tempDataPath, StandardOpenOption.CREATE_NEW)) {\n+                            new Random().nextBytes(byteToWrite);\n+                            os.write(byteToWrite);\n+                            IOUtils.fsync(tempDataPath, false);\n+                        }\n+                        Files.delete(tempDataPath);\n+                        pathHealthStats.put(path, Status.HEALTHY);\n+                    }\n+                } catch (Exception ex) {\n+                    logger.error(\"Failed to perform FS health check on path {} due to {} \", path, ex);\n+                    pathHealthStats.put(path,  Status.UNHEALTHY);\n+\n+                }\n+                cancelTimeoutHandler();\n+            }\n+            lastRunTimeMillis.getAndUpdate(l -> currentTimeMillisSupplier.getAsLong());\n+        }\n+\n+         private void cancelTimeoutHandler() {\n+             if (slowPathHealthCheckTimeoutHandler != null) {\n+                 slowPathHealthCheckTimeoutHandler.cancel();\n+             }\n+         }\n+\n+         private void logSlowDataPath(Level level, Path path, long executionStartTime) {\n+             final TimeValue elapsedTime = TimeValue.timeValueMillis(currentTimeMillisSupplier.getAsLong() - executionStartTime);\n+             logger.log(level, \"Slow IO detected on path [{}], FS health check elapsed time [{}]\", path, elapsedTime);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 5f0cde165ea..2895495fec3 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -19,7 +19,6 @@\n \n package org.elasticsearch.monitor.fs;\n \n-import org.apache.logging.log4j.Level;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxOTg2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426719860", "bodyText": "Could we instead dynamically change a node to become unhealthy and verify that it's removed from the cluster?", "author": "DaveCTurner", "createdAt": "2020-05-18T15:41:46Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\nindex 621809bec5d..9910a3c9fcd 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n\n@@ -161,44 +162,46 @@ public class CoordinatorTests extends AbstractCoordinatorTestCase {\n         }\n     }\n \n-    public void testNoElectedLeaderForNonWritableNodes() {\n-        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n-            cluster.runRandomly();\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n-            final List<ClusterNode> leaders = cluster.getAllLeaders();\n-            assertThat(leaders, empty());\n-        }\n-    }\n-\n-    public void testNonWritableNodeCannotBecomeLeader() {\n-        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+    public void testUnhealthyNodesGetsRemoved() {\n+        AtomicReference<StatusInfo> healthStatusInfo = new AtomicReference<>(\n+            new StatusInfo(HEALTHY, \"healthy-info\"));\n+        try (Cluster cluster = new Cluster(3)) {\n             cluster.runRandomly();\n             cluster.stabilise();\n \n             final ClusterNode leader = cluster.getAnyLeader();\n-            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n-                () -> NodeHealthService.Status.UNHEALTHY);\n-            cluster.clusterNodes.add(nonWritableNode);\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n-            assertThat(nonWritableNode.getId() + \" should be a candidate\", nonWritableNode.coordinator.getMode(), equalTo(CANDIDATE));\n-\n-            final ClusterNode disconnect1 = cluster.getAnyLeader();\n-            logger.info(\"--> disconnecting leader {}\", disconnect1);\n-            disconnect1.disconnect();\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for fault detection\");\n+            logger.info(\"--> adding two new healthy nodes\");\n+            ClusterNode newNode1 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            ClusterNode newNode2 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            cluster.clusterNodes.add(newNode1);\n+            cluster.clusterNodes.add(newNode2);\n+            cluster.stabilise();\n+\n+            {\n+                assertThat(leader.coordinator.getMode(), is(Mode.LEADER));\n+                final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be all nodes\", lastCommittedConfiguration.getNodeIds(),\n+                    equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));\n+            }\n \n-            final ClusterNode newLeader = cluster.getAnyLeader();\n-            logger.info(\"-->New leader {}\", newLeader);\n-            assertThat(nonWritableNode.coordinator.getMode(), is(CANDIDATE));\n-            assertThat(newLeader, not(nonWritableNode));\n+            logger.info(\"setting auto-shrink reconfiguration to true\");\n+            leader.submitSetAutoShrinkVotingConfiguration(true);\n+            cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n+            assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));\n \n-            ClusterNode anotherNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n-                () -> NodeHealthService.Status.HEALTHY);\n-            cluster.clusterNodes.add(anotherNode);\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            logger.info(\"--> changing health of newly added nodes to unhealthy\");\n+            healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n \n-            for (final ClusterNode clusterNode : cluster.getAllNodesExcept(newLeader, nonWritableNode, disconnect1)) {\n-                assertThat(clusterNode.getId() + \" should be a follower\", clusterNode.coordinator.getMode(), equalTo(FOLLOWER));\n+            cluster.stabilise();\n+            {\n+                final ClusterNode newLeader = cluster.getAnyLeader();\n+                final VotingConfiguration lastCommittedConfiguration\n+                    = newLeader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be 3 nodes\", lastCommittedConfiguration.getNodeIds().size(), equalTo(3));\n+                assertFalse(lastCommittedConfiguration.getNodeIds().contains(newNode1.getId()));\n+                assertFalse(lastCommittedConfiguration.getNodeIds().contains(newNode2.getId()));\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMDM5OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426720399", "bodyText": "I think we can strengthen cluster.stabilise() to work correctly in the light of unhealthy nodes, so we get the benefits of all the assertions it makes that the cluster has stabilised.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:42:38Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +161,48 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testNoElectedLeaderForNonWritableNodes() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n+            cluster.runRandomly();\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            final List<ClusterNode> leaders = cluster.getAllLeaders();\n+            assertThat(leaders, empty());\n+        }\n+    }\n+\n+    public void testNonWritableNodeCannotBecomeLeader() {\n+        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> NodeHealthService.Status.UNHEALTHY);\n+            cluster.clusterNodes.add(nonWritableNode);\n+            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\nindex 621809bec5d..9910a3c9fcd 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n\n@@ -161,44 +162,46 @@ public class CoordinatorTests extends AbstractCoordinatorTestCase {\n         }\n     }\n \n-    public void testNoElectedLeaderForNonWritableNodes() {\n-        try (Cluster cluster = new Cluster(randomIntBetween(1, 5), true, Settings.EMPTY, () -> NodeHealthService.Status.UNHEALTHY)) {\n-            cluster.runRandomly();\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n-            final List<ClusterNode> leaders = cluster.getAllLeaders();\n-            assertThat(leaders, empty());\n-        }\n-    }\n-\n-    public void testNonWritableNodeCannotBecomeLeader() {\n-        try (Cluster cluster = new Cluster(randomIntBetween(3, 5))) {\n+    public void testUnhealthyNodesGetsRemoved() {\n+        AtomicReference<StatusInfo> healthStatusInfo = new AtomicReference<>(\n+            new StatusInfo(HEALTHY, \"healthy-info\"));\n+        try (Cluster cluster = new Cluster(3)) {\n             cluster.runRandomly();\n             cluster.stabilise();\n \n             final ClusterNode leader = cluster.getAnyLeader();\n-            ClusterNode nonWritableNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n-                () -> NodeHealthService.Status.UNHEALTHY);\n-            cluster.clusterNodes.add(nonWritableNode);\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n-            assertThat(nonWritableNode.getId() + \" should be a candidate\", nonWritableNode.coordinator.getMode(), equalTo(CANDIDATE));\n-\n-            final ClusterNode disconnect1 = cluster.getAnyLeader();\n-            logger.info(\"--> disconnecting leader {}\", disconnect1);\n-            disconnect1.disconnect();\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for fault detection\");\n+            logger.info(\"--> adding two new healthy nodes\");\n+            ClusterNode newNode1 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            ClusterNode newNode2 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            cluster.clusterNodes.add(newNode1);\n+            cluster.clusterNodes.add(newNode2);\n+            cluster.stabilise();\n+\n+            {\n+                assertThat(leader.coordinator.getMode(), is(Mode.LEADER));\n+                final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be all nodes\", lastCommittedConfiguration.getNodeIds(),\n+                    equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));\n+            }\n \n-            final ClusterNode newLeader = cluster.getAnyLeader();\n-            logger.info(\"-->New leader {}\", newLeader);\n-            assertThat(nonWritableNode.coordinator.getMode(), is(CANDIDATE));\n-            assertThat(newLeader, not(nonWritableNode));\n+            logger.info(\"setting auto-shrink reconfiguration to true\");\n+            leader.submitSetAutoShrinkVotingConfiguration(true);\n+            cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n+            assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));\n \n-            ClusterNode anotherNode = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n-                () -> NodeHealthService.Status.HEALTHY);\n-            cluster.clusterNodes.add(anotherNode);\n-            cluster.runFor(DEFAULT_STABILISATION_TIME, \"allowing time for stabilization\");\n+            logger.info(\"--> changing health of newly added nodes to unhealthy\");\n+            healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n \n-            for (final ClusterNode clusterNode : cluster.getAllNodesExcept(newLeader, nonWritableNode, disconnect1)) {\n-                assertThat(clusterNode.getId() + \" should be a follower\", clusterNode.coordinator.getMode(), equalTo(FOLLOWER));\n+            cluster.stabilise();\n+            {\n+                final ClusterNode newLeader = cluster.getAnyLeader();\n+                final VotingConfiguration lastCommittedConfiguration\n+                    = newLeader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be 3 nodes\", lastCommittedConfiguration.getNodeIds().size(), equalTo(3));\n+                assertFalse(lastCommittedConfiguration.getNodeIds().contains(newNode1.getId()));\n+                assertFalse(lastCommittedConfiguration.getNodeIds().contains(newNode2.getId()));\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMTkyMw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426721923", "bodyText": "Suspect this comment was removed from master recently.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated\n          \n          \n            \n                    }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus);", "author": "DaveCTurner", "createdAt": "2020-05-18T15:44:54Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java", "diffHunk": "@@ -112,7 +120,7 @@ public String toString() {\n             assert electionOccurred == false;\n             electionOccurred = true;\n         }, l -> {\n-        }, ElectionStrategy.DEFAULT_INSTANCE);\n+        }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\nindex 29f7b156f48..1b388e5b063 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/PreVoteCollectorTests.java\n\n@@ -120,7 +122,7 @@ public class PreVoteCollectorTests extends ESTestCase {\n             assert electionOccurred == false;\n             electionOccurred = true;\n         }, l -> {\n-        }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus); // TODO need tests that check that the max term seen is updated\n+        }, ElectionStrategy.DEFAULT_INSTANCE, () -> healthStatus);\n         preVoteCollector.update(getLocalPreVoteResponse(), null);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNTQ1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426725457", "bodyText": "I'd rather not add this to the public interface of DeterministicTaskQueue and instead test the behaviour we want: if we keep on advancing time then we keep on executing this task. See e.g. ClusterFormationFailureHelperTests#testScheduling.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:49:56Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 6094b199d04..8e6b4060004 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -21,20 +21,27 @@\n package org.elasticsearch.monitor.fs;\n \n \n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n import org.apache.lucene.mockfile.FilterFileSystemProvider;\n import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n import org.elasticsearch.common.io.PathUtils;\n import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.env.NodeEnvironment;\n-import org.elasticsearch.monitor.NodeHealthService;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n import org.elasticsearch.threadpool.TestThreadPool;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.junit.Before;\n \n import java.io.IOException;\n+import java.io.OutputStream;\n import java.nio.channels.FileChannel;\n import java.nio.file.FileSystem;\n import java.nio.file.OpenOption;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyNjI5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r426726296", "bodyText": "I'd prefer that we also check the behaviour on writes and syncs, effectively to assert that we do detect failures for both of those activities too.", "author": "DaveCTurner", "createdAt": "2020-05-18T15:51:06Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAndSlowPathLoggingPeriodically() throws Exception {\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(Settings.EMPTY, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            //schedules the first health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis());\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            //schedules the next health check at refresh interval\n+            assertEquals(deterministicTaskQueue.getNextDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis()) * 2);\n+\n+            //We schedule a slow logging timeout handler per path\n+            assertEquals(deterministicTaskQueue.getDeferredTasks().size(), env.nodeDataPaths().length + 1);\n+\n+            //Verify schedules slow path logging at the timeout\n+            assertEquals(deterministicTaskQueue.getLatestDeferredExecutionTime(),\n+                (FsHealthService.REFRESH_INTERVAL_SETTING.get(Settings.EMPTY).millis() +\n+                    FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(Settings.EMPTY).millis()));\n+\n+            deterministicTaskQueue.advanceTime();\n+            deterministicTaskQueue.runAllRunnableTasks();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+\n+            fsHealthService.doStop();\n+            // run deferred tasks\n+            while (deterministicTaskQueue.hasDeferredTasks()) {\n+                deterministicTaskQueue.advanceTime();\n+                deterministicTaskQueue.runAllRunnableTasks();\n+            }\n+            // no tasks post service stop\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathIOException() throws IOException {\n+        FileSystem current = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(current);\n+        PathUtilsForTesting.installMock(disruptFileSystemProvider.getFileSystem(null));\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.HEALTHY);\n+\n+            //disrupt file system on single path\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            disruptFileSystemProvider.restrictPathPrefix(randomFrom(paths).toString());\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth(), NodeHealthService.Status.UNHEALTHY);\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), 1);\n+\n+        } finally {\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+            disruptFileSystemProvider.injectIOException.set(false);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            if (injectIOException.get()){", "originalCommit": "8a8605145cd69f1bab3c7f66121714df7aa6a5c2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 6094b199d04..8e6b4060004 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -21,20 +21,27 @@\n package org.elasticsearch.monitor.fs;\n \n \n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n import org.apache.lucene.mockfile.FilterFileSystemProvider;\n import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n import org.elasticsearch.common.io.PathUtils;\n import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.env.NodeEnvironment;\n-import org.elasticsearch.monitor.NodeHealthService;\n import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n import org.elasticsearch.threadpool.TestThreadPool;\n import org.elasticsearch.threadpool.ThreadPool;\n import org.junit.Before;\n \n import java.io.IOException;\n+import java.io.OutputStream;\n import java.nio.channels.FileChannel;\n import java.nio.file.FileSystem;\n import java.nio.file.OpenOption;\n"}}, {"oid": "c9dd1a7934c8f88903882a6405196da04be9e9c8", "url": "https://github.com/elastic/elasticsearch/commit/c9dd1a7934c8f88903882a6405196da04be9e9c8", "message": "Addressing comments on logging and tests", "committedDate": "2020-05-20T12:23:29Z", "type": "commit"}, {"oid": "c99a68eef519e60740b594897cebdeba41217624", "url": "https://github.com/elastic/elasticsearch/commit/c99a68eef519e60740b594897cebdeba41217624", "message": "Minor edits", "committedDate": "2020-05-20T14:31:03Z", "type": "commit"}, {"oid": "545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "url": "https://github.com/elastic/elasticsearch/commit/545eaf5328fedf536c7882cfdc5ff98e4251d5b1", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-05-27T05:57:11Z", "type": "commit"}, {"oid": "86fa7c9501e46d814428612975e4627ff827f81c", "url": "https://github.com/elastic/elasticsearch/commit/86fa7c9501e46d814428612975e4627ff827f81c", "message": "Updated the exception id", "committedDate": "2020-05-27T06:01:29Z", "type": "commit"}, {"oid": "8102c819c467bb42ff06752e0a785e58842db0ca", "url": "https://github.com/elastic/elasticsearch/commit/8102c819c467bb42ff06752e0a785e58842db0ca", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-06-04T04:48:26Z", "type": "commit"}, {"oid": "043db9301654ecc42de863c18571dfe9afc72bef", "url": "https://github.com/elastic/elasticsearch/commit/043db9301654ecc42de863c18571dfe9afc72bef", "message": "Fix merge conflict", "committedDate": "2020-06-16T08:14:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTAxMg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440675012", "bodyText": "This needs some synchronisation since it's accessed on multiple threads.\nI suggest making this field volatile, constructing a new local object on each check and then assigning the local object to this field at the end of the check.\nI also suggest a Set<Path> of unhealthy paths rather than tracking them all -- the healthy ones are never used here. We could even mark this as @Nullable and use null instead of an empty set if we wanted to save on long-lived objects.", "author": "DaveCTurner", "createdAt": "2020-06-16T08:25:47Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "136bc441feebcb5be4d377ebd5480878b6770ae4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 2895495fec3..9f4d4d6e9dc 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -111,18 +111,18 @@ public class FsHealthService extends AbstractLifecycleComponent implements NodeH\n     public StatusInfo getHealth() {\n         StatusInfo statusInfo;\n         if (enabled == false) {\n-            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n         }\n         else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n-            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n                 .stream().filter(v -> v.getValue() == UNHEALTHY)\n                 .map(k -> k.getKey().toString())\n-                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+                .collect(Collectors.joining(\",\")) + \"]\";\n \n             statusInfo = new StatusInfo(UNHEALTHY, info);\n         }\n         else {\n-            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n         }\n         return statusInfo;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjYzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440676631", "bodyText": "I think the default frequency should be a lot more relaxed; an fsync per node per second is going to cause problems on slower disks. Let's align this with the lag detector:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n          \n          \n            \n                    Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),", "author": "DaveCTurner", "createdAt": "2020-06-16T08:28:23Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "136bc441feebcb5be4d377ebd5480878b6770ae4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 2895495fec3..9f4d4d6e9dc 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -111,18 +111,18 @@ public class FsHealthService extends AbstractLifecycleComponent implements NodeH\n     public StatusInfo getHealth() {\n         StatusInfo statusInfo;\n         if (enabled == false) {\n-            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n         }\n         else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n-            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n                 .stream().filter(v -> v.getValue() == UNHEALTHY)\n                 .map(k -> k.getKey().toString())\n-                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+                .collect(Collectors.joining(\",\")) + \"]\";\n \n             statusInfo = new StatusInfo(UNHEALTHY, info);\n         }\n         else {\n-            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n         }\n         return statusInfo;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTM0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440679349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile TimeValue refreshInterval;\n          \n          \n            \n                private final TimeValue refreshInterval;", "author": "DaveCTurner", "createdAt": "2020-06-16T08:32:39Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "136bc441feebcb5be4d377ebd5480878b6770ae4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 2895495fec3..9f4d4d6e9dc 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -111,18 +111,18 @@ public class FsHealthService extends AbstractLifecycleComponent implements NodeH\n     public StatusInfo getHealth() {\n         StatusInfo statusInfo;\n         if (enabled == false) {\n-            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n         }\n         else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n-            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n                 .stream().filter(v -> v.getValue() == UNHEALTHY)\n                 .map(k -> k.getKey().toString())\n-                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+                .collect(Collectors.joining(\",\")) + \"]\";\n \n             statusInfo = new StatusInfo(UNHEALTHY, info);\n         }\n         else {\n-            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n         }\n         return statusInfo;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MDI3OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440680278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    static final String TEMP_FILE_NAME = \".es_temp_file\";\n          \n          \n            \n                    private static final String TEMP_FILE_NAME = \".es_temp_file\";", "author": "DaveCTurner", "createdAt": "2020-06-16T08:34:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "136bc441feebcb5be4d377ebd5480878b6770ae4", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex 2895495fec3..9f4d4d6e9dc 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -111,18 +111,18 @@ public class FsHealthService extends AbstractLifecycleComponent implements NodeH\n     public StatusInfo getHealth() {\n         StatusInfo statusInfo;\n         if (enabled == false) {\n-            statusInfo = new StatusInfo(HEALTHY, \"FS health checks are disabled\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n         }\n         else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n-            String info = \"Path(s) \" + pathHealthStats.entrySet()\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n                 .stream().filter(v -> v.getValue() == UNHEALTHY)\n                 .map(k -> k.getKey().toString())\n-                .collect(Collectors.joining(\",\")) + \" have failed writability checks\";\n+                .collect(Collectors.joining(\",\")) + \"]\";\n \n             statusInfo = new StatusInfo(UNHEALTHY, info);\n         }\n         else {\n-            statusInfo = new StatusInfo(HEALTHY, \"All paths have passed writabililty checks\");\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n         }\n         return statusInfo;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjg3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440682875", "bodyText": "Is there a shorter time-bound for stabilisation here?", "author": "DaveCTurner", "createdAt": "2020-06-16T08:38:10Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java", "diffHunk": "@@ -158,6 +162,50 @@ public void testDoesNotElectNonMasterNode() {\n         }\n     }\n \n+    public void testUnhealthyNodesGetsRemoved() {\n+        AtomicReference<StatusInfo> healthStatusInfo = new AtomicReference<>(\n+            new StatusInfo(HEALTHY, \"healthy-info\"));\n+        try (Cluster cluster = new Cluster(3)) {\n+            cluster.runRandomly();\n+            cluster.stabilise();\n+\n+            final ClusterNode leader = cluster.getAnyLeader();\n+            logger.info(\"--> adding two new healthy nodes\");\n+            ClusterNode newNode1 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            ClusterNode newNode2 = cluster.new ClusterNode(nextNodeIndex.getAndIncrement(), true, leader.nodeSettings,\n+                () -> healthStatusInfo.get());\n+            cluster.clusterNodes.add(newNode1);\n+            cluster.clusterNodes.add(newNode2);\n+            cluster.stabilise();\n+\n+            {\n+                assertThat(leader.coordinator.getMode(), is(Mode.LEADER));\n+                final VotingConfiguration lastCommittedConfiguration = leader.getLastAppliedClusterState().getLastCommittedConfiguration();\n+                assertThat(lastCommittedConfiguration + \" should be all nodes\", lastCommittedConfiguration.getNodeIds(),\n+                    equalTo(cluster.clusterNodes.stream().map(ClusterNode::getId).collect(Collectors.toSet())));\n+            }\n+\n+            logger.info(\"setting auto-shrink reconfiguration to true\");\n+            leader.submitSetAutoShrinkVotingConfiguration(true);\n+            cluster.stabilise(DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n+            assertTrue(CLUSTER_AUTO_SHRINK_VOTING_CONFIGURATION.get(leader.getLastAppliedClusterState().metadata().settings()));\n+\n+            logger.info(\"--> changing health of newly added nodes to unhealthy\");\n+            healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n+\n+            cluster.stabilise();", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYzNzQ0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442637449", "bodyText": "Yes.. maybe", "author": "Bukhtawar", "createdAt": "2020-06-19T05:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e41392fc12363ff5383551516490cd3e9238a086", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\nindex 9910a3c9fcd..16337864b2f 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/CoordinatorTests.java\n\n@@ -194,7 +194,27 @@ public class CoordinatorTests extends AbstractCoordinatorTestCase {\n             logger.info(\"--> changing health of newly added nodes to unhealthy\");\n             healthStatusInfo.getAndSet(new StatusInfo(UNHEALTHY, \"unhealthy-info\"));\n \n-            cluster.stabilise();\n+            cluster.stabilise(Math.max(\n+                // Each follower may have just sent a leader check, which receives no response\n+                defaultMillis(LEADER_CHECK_TIMEOUT_SETTING)\n+                    // then wait for the follower to check the leader\n+                    + defaultMillis(LEADER_CHECK_INTERVAL_SETTING)\n+                    // then wait for the exception response\n+                    + DEFAULT_DELAY_VARIABILITY,\n+\n+                // ALSO the leader may have just sent a follower check, which receives no response\n+                defaultMillis(FOLLOWER_CHECK_TIMEOUT_SETTING)\n+                    // wait for the leader to check its followers\n+                    + defaultMillis(FOLLOWER_CHECK_INTERVAL_SETTING)\n+                    // then wait for the exception response\n+                    + DEFAULT_DELAY_VARIABILITY)\n+\n+                // FINALLY:\n+\n+                // wait for the removal to be committed\n+                + DEFAULT_CLUSTER_STATE_UPDATE_DELAY\n+                // then wait for the followup reconfiguration\n+                + DEFAULT_CLUSTER_STATE_UPDATE_DELAY);\n             {\n                 final ClusterNode newLeader = cluster.getAnyLeader();\n                 final VotingConfiguration lastCommittedConfiguration\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MzA3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440683079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));\n          \n          \n            \n                    }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"healthy-info\"));", "author": "DaveCTurner", "createdAt": "2020-06-16T08:38:30Z", "path": "server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java", "diffHunk": "@@ -105,12 +109,11 @@ protected void onSendRequest(long requestId, String action, TransportRequest req\n             TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundTransportAddress -> localNode, null, emptySet());\n         transportService.start();\n         transportService.acceptIncomingRequests();\n-\n         final FollowersChecker followersChecker = new FollowersChecker(settings, transportService, fcr -> {\n             assert false : fcr;\n         }, (node, reason) -> {\n             assert false : node;\n-        });\n+        }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "befd8228ac2995653fdb618bf3c17bc57bf283cc", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java b/server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java\nindex f030d303200..fdb0360a258 100644\n--- a/server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java\n+++ b/server/src/test/java/org/elasticsearch/cluster/coordination/FollowersCheckerTests.java\n\n@@ -113,7 +113,7 @@ public class FollowersCheckerTests extends ESTestCase {\n             assert false : fcr;\n         }, (node, reason) -> {\n             assert false : node;\n-        }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"unhealthy-info\"));\n+        }, () -> new StatusInfo(StatusInfo.Status.HEALTHY, \"healthy-info\"));\n \n         followersChecker.setCurrentNodes(discoveryNodesHolder[0]);\n         deterministicTaskQueue.runAllTasks();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NjY2OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r440696668", "bodyText": "Could we do this with a fake clock (e.g. a DeterministicTaskQueue) rather than a sleep of a few hundred milliseconds?", "author": "DaveCTurner", "createdAt": "2020-06-16T08:59:22Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400));\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\"+ ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"checking writability of [\" + path.toString() + \"]\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"Path(s) \"+ String.join(\",\", disruptedPath)\n+                + \" have failed writability checks\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            try {\n+                                Thread.sleep(delay);", "originalCommit": "043db9301654ecc42de863c18571dfe9afc72bef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 8e6b4060004..4f006e2673e 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -110,7 +110,7 @@ public class FsHealthServiceTests extends ESTestCase {\n             FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n             fsHealthService.new FsHealthMonitor().run();\n             assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n-            assertEquals(fsHealthService.getHealth().getInfo(), \"All paths have passed writabililty checks\");\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n \n             //disrupt file system\n             disruptFileSystemProvider.injectIOException.set(true);\n"}}, {"oid": "bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "url": "https://github.com/elastic/elasticsearch/commit/bbf55176ba89d6ab097e9ddfb87ebef23ef67d70", "message": "Fix spacing in StatusInfo#toString", "committedDate": "2020-06-18T10:53:46Z", "type": "commit"}, {"oid": "1459937cf7763892b346b23eab4893805f7a7331", "url": "https://github.com/elastic/elasticsearch/commit/1459937cf7763892b346b23eab4893805f7a7331", "message": "Tidy 'skip prevoting' log message", "committedDate": "2020-06-18T10:54:04Z", "type": "commit"}, {"oid": "8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "url": "https://github.com/elastic/elasticsearch/commit/8eb5e2087b37eac9fb71b03308c4ca8ded70d6dc", "message": "Tidy response messages in FollowersChecker", "committedDate": "2020-06-18T11:00:21Z", "type": "commit"}, {"oid": "2095d82b3c1cd9eaa21401030845f745f2a46fcf", "url": "https://github.com/elastic/elasticsearch/commit/2095d82b3c1cd9eaa21401030845f745f2a46fcf", "message": "Tidy log message in JoinHelper", "committedDate": "2020-06-18T11:02:05Z", "type": "commit"}, {"oid": "39a0565941f9cb7eed461e161a39a16bf0695097", "url": "https://github.com/elastic/elasticsearch/commit/39a0565941f9cb7eed461e161a39a16bf0695097", "message": "Tidy message in PreVoteCollector", "committedDate": "2020-06-18T11:04:03Z", "type": "commit"}, {"oid": "136bc441feebcb5be4d377ebd5480878b6770ae4", "url": "https://github.com/elastic/elasticsearch/commit/136bc441feebcb5be4d377ebd5480878b6770ae4", "message": "Tidy info messages", "committedDate": "2020-06-18T11:08:59Z", "type": "commit"}, {"oid": "1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "url": "https://github.com/elastic/elasticsearch/commit/1ab13b26dce3bb3bc8fa086f2c0b48ce27889d73", "message": "Tidy tracing messages", "committedDate": "2020-06-18T11:09:28Z", "type": "commit"}, {"oid": "4143f8f378e7cfec487e88162887495cad0e7e2f", "url": "https://github.com/elastic/elasticsearch/commit/4143f8f378e7cfec487e88162887495cad0e7e2f", "message": "Tidy warn/error messages", "committedDate": "2020-06-18T11:10:57Z", "type": "commit"}, {"oid": "1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "url": "https://github.com/elastic/elasticsearch/commit/1d9a7abdb2c27a0ba661657a9a8ceba3dc046874", "message": "Fix up tests", "committedDate": "2020-06-18T11:19:47Z", "type": "commit"}, {"oid": "f2225299287205e5b0050d8c6e551c2642130eab", "url": "https://github.com/elastic/elasticsearch/commit/f2225299287205e5b0050d8c6e551c2642130eab", "message": "Fix too-short delay", "committedDate": "2020-06-18T11:27:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442157715", "bodyText": "Can this happen? Looks to me that we already catch and log all exceptions in monitorFSHealth.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:29:05Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private volatile TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private Map<Path, StatusInfo.Status> pathHealthStats;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(1), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        this.pathHealthStats = new HashMap<>(1);\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() throws IOException {\n+\n+    }\n+\n+    public void setEnabled(boolean enabled) { this.enabled = enabled; }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        }\n+        else if (pathHealthStats.entrySet().stream().anyMatch(map -> map.getValue() == UNHEALTHY)) {\n+            String info = \"health check failed on [\" + pathHealthStats.entrySet()\n+                .stream().filter(v -> v.getValue() == UNHEALTHY)\n+                .map(k -> k.getKey().toString())\n+                .collect(Collectors.joining(\",\")) + \"]\";\n+\n+            statusInfo = new StatusInfo(UNHEALTHY, info);\n+        }\n+        else {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        }\n+        return statusInfo;\n+    }\n+\n+     class FsHealthMonitor implements Runnable {\n+\n+        static final String TEMP_FILE_NAME = \".es_temp_file\";\n+        private byte[] byteToWrite;\n+\n+        FsHealthMonitor(){\n+            this.byteToWrite = new byte[20];\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (enabled) {\n+                    monitorFSHealth();\n+                    logger.debug(\"health check succeeded: {}\", pathHealthStats);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"health check failed\", e);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwNzc0Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442307742", "bodyText": "Can happen if nodeEnv.nodeDataPaths() fails with lock assertions", "author": "Bukhtawar", "createdAt": "2020-06-18T15:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMzAxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442703016", "bodyText": "Ohh yes so it can, thanks. For now this is fine but I'll follow up internally to discuss whether we should consider a failure here to be fatal too.", "author": "DaveCTurner", "createdAt": "2020-06-19T08:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1NzcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "befd8228ac2995653fdb618bf3c17bc57bf283cc", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex e0f1fef3d59..5a4401dc8cb 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -22,6 +22,7 @@ package org.elasticsearch.monitor.fs;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.Nullable;\n import org.elasticsearch.common.component.AbstractLifecycleComponent;\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Setting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1ODU5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442158591", "bodyText": "All these usages of assertEquals are backwards: it's assertEquals(expected, actual) but you've put the expected value second.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:30:46Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYyMjE2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442622164", "bodyText": "Done", "author": "Bukhtawar", "createdAt": "2020-06-19T04:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1ODU5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 17c64c5d1a7..75c33c9cfb7 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -109,18 +109,18 @@ public class FsHealthServiceTests extends ESTestCase {\n         try (NodeEnvironment env = newNodeEnvironment()) {\n             FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n             fsHealthService.new FsHealthMonitor().run();\n-            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n-            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+            assertEquals(HEALTHY, fsHealthService.getHealth().getStatus());\n+            assertEquals(\"health check passed\", fsHealthService.getHealth().getInfo());\n \n             //disrupt file system\n             disruptFileSystemProvider.injectIOException.set(true);\n             fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n             fsHealthService.new FsHealthMonitor().run();\n-            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertEquals(UNHEALTHY, fsHealthService.getHealth().getStatus());\n             for (Path path : env.nodeDataPaths()) {\n                 assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n             }\n-            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertEquals(env.nodeDataPaths().length, disruptFileSystemProvider.getInjectedPathCount());\n         } finally {\n             disruptFileSystemProvider.injectIOException.set(false);\n             PathUtilsForTesting.teardown();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1OTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442159064", "bodyText": "NB this needed a loop as a simple Thread.sleep() isn't enough to guarantee that the threadpool's clock has advanced.", "author": "DaveCTurner", "createdAt": "2020-06-18T11:31:42Z", "path": "server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+\n+package org.elasticsearch.monitor.fs;\n+\n+\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.lucene.mockfile.FilterFileChannel;\n+import org.apache.lucene.mockfile.FilterFileSystemProvider;\n+import org.elasticsearch.cluster.coordination.DeterministicTaskQueue;\n+import org.elasticsearch.common.io.PathUtils;\n+import org.elasticsearch.common.io.PathUtilsForTesting;\n+import org.elasticsearch.common.logging.Loggers;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.MockLogAppender;\n+import org.elasticsearch.test.junit.annotations.TestLogging;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.junit.Before;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileAttribute;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+import static org.elasticsearch.node.Node.NODE_NAME_SETTING;\n+import static org.hamcrest.Matchers.is;\n+\n+\n+public class FsHealthServiceTests extends ESTestCase {\n+\n+    private DeterministicTaskQueue deterministicTaskQueue;\n+\n+    @Before\n+    public void createObjects() {\n+        Settings settings = Settings.builder().put(NODE_NAME_SETTING.getKey(), \"node\").build();\n+        deterministicTaskQueue = new DeterministicTaskQueue(settings, random());\n+    }\n+\n+    public void testSchedulesHealthCheckAtRefreshIntervals() throws Exception {\n+        long refreshInterval = randomLongBetween(1000, 12000);\n+        final Settings settings = Settings.builder().put(FsHealthService.REFRESH_INTERVAL_SETTING.getKey(), refreshInterval + \"ms\").build();\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, deterministicTaskQueue.getThreadPool(), env);\n+            final long startTimeMillis = deterministicTaskQueue.getCurrentTimeMillis();\n+            fsHealthService.doStart();\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertTrue(deterministicTaskQueue.hasDeferredTasks());\n+            int rescheduledCount = 0;\n+            for (int i = 1; i <= randomIntBetween(5, 10); i++) {\n+                if (deterministicTaskQueue.hasRunnableTasks()) {\n+                    deterministicTaskQueue.runRandomTask();\n+                } else {\n+                    assertThat(deterministicTaskQueue.getLatestDeferredExecutionTime(), is(refreshInterval * (rescheduledCount + 1)));\n+                    deterministicTaskQueue.advanceTime();\n+                    rescheduledCount++;\n+                }\n+                assertThat(deterministicTaskQueue.getCurrentTimeMillis() - startTimeMillis, is(refreshInterval * rescheduledCount));\n+            }\n+\n+            fsHealthService.doStop();\n+            deterministicTaskQueue.runAllTasksInTimeOrder();\n+\n+            assertFalse(deterministicTaskQueue.hasRunnableTasks());\n+            assertFalse(deterministicTaskQueue.hasDeferredTasks());\n+        }\n+    }\n+\n+    public void testFailsHealthOnIOException() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            for (Path path : env.nodeDataPaths()) {\n+                assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n+            }\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+        } finally {\n+            disruptFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @TestLogging(value = \"org.elasticsearch.monitor.fs:WARN\", reason = \"to ensure that we log on hung IO at WARN level\")\n+    public void testLoggingOnHungIO() throws Exception {\n+        long slowLogThreshold = randomLongBetween(100, 200);\n+        final Settings settings = Settings.builder().put(FsHealthService.SLOW_PATH_LOGGING_THRESHOLD_SETTING.getKey(),\n+            slowLogThreshold + \"ms\").build();\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        FileSystemFsyncHungProvider disruptFileSystemProvider = new FileSystemFsyncHungProvider(fileSystem,\n+            randomLongBetween(slowLogThreshold + 1 , 400), testThreadPool);\n+        fileSystem = disruptFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+\n+        MockLogAppender mockAppender = new MockLogAppender();\n+        mockAppender.start();\n+\n+        Logger logger = LogManager.getLogger(FsHealthService.class);\n+        Loggers.addAppender(logger, mockAppender);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            int counter = 0;\n+            for(Path path : env.nodeDataPaths()){\n+                mockAppender.addExpectation(\n+                    new MockLogAppender.SeenEventExpectation(\n+                        \"test\" + ++counter,\n+                        FsHealthService.class.getCanonicalName(),\n+                        Level.WARN,\n+                        \"health check of [\" + path + \"] took [*ms] which is above the warn threshold*\"));\n+            }\n+\n+            //disrupt file system\n+            disruptFileSystemProvider.injectIOException.set(true);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertBusy(mockAppender::assertAllExpectationsMatched);\n+        } finally {\n+            Loggers.removeAppender(logger, mockAppender);\n+            mockAppender.stop();\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathFsyncFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemFsyncIOExceptionProvider disruptFsyncFileSystemProvider = new FileSystemFsyncIOExceptionProvider(fileSystem);\n+        fileSystem = disruptFsyncFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system fsync on single path\n+            disruptFsyncFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptFsyncFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptFsyncFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptFsyncFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    public void testFailsHealthOnSinglePathWriteFailure() throws IOException {\n+        FileSystem fileSystem = PathUtils.getDefaultFileSystem();\n+        FileSystemIOExceptionProvider disruptWritesFileSystemProvider = new FileSystemIOExceptionProvider(fileSystem);\n+        fileSystem = disruptWritesFileSystemProvider.getFileSystem(null);\n+        PathUtilsForTesting.installMock(fileSystem);\n+        final Settings settings = Settings.EMPTY;\n+        final ClusterSettings clusterSettings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);\n+        TestThreadPool testThreadPool = new TestThreadPool(getClass().getName(), settings);\n+        try (NodeEnvironment env = newNodeEnvironment()) {\n+            Path[] paths = env.nodeDataPaths();\n+            FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n+            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+\n+            //disrupt file system writes on single path\n+            disruptWritesFileSystemProvider.injectIOException.set(true);\n+            String disruptedPath = randomFrom(paths).toString();\n+            disruptWritesFileSystemProvider.restrictPathPrefix(disruptedPath);\n+            fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n+            fsHealthService.new FsHealthMonitor().run();\n+            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertThat(fsHealthService.getHealth().getInfo(), is(\"health check failed on [\" + disruptedPath + \"]\"));\n+            assertEquals(disruptWritesFileSystemProvider.getInjectedPathCount(), 1);\n+        } finally {\n+            disruptWritesFileSystemProvider.injectIOException.set(false);\n+            PathUtilsForTesting.teardown();\n+            ThreadPool.terminate(testThreadPool, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private static class FileSystemIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+            if (injectIOException.get()){\n+                if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                    injectedPaths.incrementAndGet();\n+                    throw new IOException(\"fake IOException\");\n+                }\n+            }\n+            return super.newOutputStream(path, options);\n+        }\n+    }\n+\n+    private static class FileSystemFsyncIOExceptionProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+\n+        FileSystemFsyncIOExceptionProvider(FileSystem inner) {\n+            super(\"disrupt_fs_health://\", inner);\n+        }\n+\n+        public void restrictPathPrefix(String pathPrefix){\n+            this.pathPrefix = pathPrefix;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            throw new IOException(\"fake IOException\");\n+                        }\n+                    }\n+                    super.force(metaData);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static class FileSystemFsyncHungProvider extends FilterFileSystemProvider {\n+\n+        AtomicBoolean injectIOException = new AtomicBoolean();\n+        AtomicInteger injectedPaths = new AtomicInteger();\n+\n+        private String pathPrefix = \"/\";\n+        private long delay;\n+        private final ThreadPool threadPool;\n+\n+        FileSystemFsyncHungProvider(FileSystem inner, long delay, ThreadPool threadPool) {\n+            super(\"disrupt_fs_health://\", inner);\n+            this.delay = delay;\n+            this.threadPool = threadPool;\n+        }\n+\n+        public int getInjectedPathCount(){\n+            return injectedPaths.get();\n+        }\n+\n+        @Override\n+        public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            return new FilterFileChannel(super.newFileChannel(path, options, attrs)) {\n+                @Override\n+                public void force(boolean metaData) throws IOException {\n+                    if (injectIOException.get()) {\n+                        if (path.toString().startsWith(pathPrefix) && path.toString().endsWith(\".es_temp_file\")) {\n+                            injectedPaths.incrementAndGet();\n+                            final long startTimeMillis = threadPool.relativeTimeInMillis();\n+                            do {\n+                                try {\n+                                    Thread.sleep(delay);\n+                                } catch (InterruptedException e) {\n+                                    throw new AssertionError(e);\n+                                }\n+                            } while (threadPool.relativeTimeInMillis() <= startTimeMillis + delay);", "originalCommit": "f2225299287205e5b0050d8c6e551c2642130eab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyNDM5OA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r442324398", "bodyText": "Got it thanks", "author": "Bukhtawar", "createdAt": "2020-06-18T15:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE1OTA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\nindex 17c64c5d1a7..75c33c9cfb7 100644\n--- a/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n+++ b/server/src/test/java/org/elasticsearch/monitor/fs/FsHealthServiceTests.java\n\n@@ -109,18 +109,18 @@ public class FsHealthServiceTests extends ESTestCase {\n         try (NodeEnvironment env = newNodeEnvironment()) {\n             FsHealthService fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n             fsHealthService.new FsHealthMonitor().run();\n-            assertEquals(fsHealthService.getHealth().getStatus(), HEALTHY);\n-            assertEquals(fsHealthService.getHealth().getInfo(), \"health check passed\");\n+            assertEquals(HEALTHY, fsHealthService.getHealth().getStatus());\n+            assertEquals(\"health check passed\", fsHealthService.getHealth().getInfo());\n \n             //disrupt file system\n             disruptFileSystemProvider.injectIOException.set(true);\n             fsHealthService = new FsHealthService(settings, clusterSettings, testThreadPool, env);\n             fsHealthService.new FsHealthMonitor().run();\n-            assertEquals(fsHealthService.getHealth().getStatus(), UNHEALTHY);\n+            assertEquals(UNHEALTHY, fsHealthService.getHealth().getStatus());\n             for (Path path : env.nodeDataPaths()) {\n                 assertTrue(fsHealthService.getHealth().getInfo().contains(path.toString()));\n             }\n-            assertEquals(disruptFileSystemProvider.getInjectedPathCount(), env.nodeDataPaths().length);\n+            assertEquals(env.nodeDataPaths().length, disruptFileSystemProvider.getInjectedPathCount());\n         } finally {\n             disruptFileSystemProvider.injectIOException.set(false);\n             PathUtilsForTesting.teardown();\n"}}, {"oid": "befd8228ac2995653fdb618bf3c17bc57bf283cc", "url": "https://github.com/elastic/elasticsearch/commit/befd8228ac2995653fdb618bf3c17bc57bf283cc", "message": "Minor fixes to Follower and FsHealthService", "committedDate": "2020-06-18T15:18:49Z", "type": "commit"}, {"oid": "061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "url": "https://github.com/elastic/elasticsearch/commit/061dd3311bdb1ddeadb07f1d9124ab2a586eb546", "message": "Fix assertions", "committedDate": "2020-06-18T15:30:38Z", "type": "commit"}, {"oid": "cda2179f9da031607e7ddd3426d0b03a561d47f8", "url": "https://github.com/elastic/elasticsearch/commit/cda2179f9da031607e7ddd3426d0b03a561d47f8", "message": "Leader checks", "committedDate": "2020-06-18T17:34:28Z", "type": "commit"}, {"oid": "4d83de02f19a4d35effdefce93b49b024569bf01", "url": "https://github.com/elastic/elasticsearch/commit/4d83de02f19a4d35effdefce93b49b024569bf01", "message": "Leader check tests", "committedDate": "2020-06-19T05:13:05Z", "type": "commit"}, {"oid": "e41392fc12363ff5383551516490cd3e9238a086", "url": "https://github.com/elastic/elasticsearch/commit/e41392fc12363ff5383551516490cd3e9238a086", "message": "cluster reduce stabilization time after unhealthy node", "committedDate": "2020-06-19T06:49:59Z", "type": "commit"}, {"oid": "67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "url": "https://github.com/elastic/elasticsearch/commit/67d49bb5fbf3b3f76910439c6f78fb486a884bc2", "message": "Minor fix up", "committedDate": "2020-06-19T06:57:20Z", "type": "commit"}, {"oid": "fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "url": "https://github.com/elastic/elasticsearch/commit/fa3cc697fdabf23e4d1007ea0decc90c51f9beab", "message": "ClusterFormationFailureHelper changes and more tests", "committedDate": "2020-06-19T11:55:50Z", "type": "commit"}, {"oid": "89035fb50b690c171859d1c9cd2345329b79d752", "url": "https://github.com/elastic/elasticsearch/commit/89035fb50b690c171859d1c9cd2345329b79d752", "message": "Minor changes to LeaderChecker", "committedDate": "2020-06-21T08:42:57Z", "type": "commit"}, {"oid": "adbe670e530c1be18278c9156da17f5a05261c4c", "url": "https://github.com/elastic/elasticsearch/commit/adbe670e530c1be18278c9156da17f5a05261c4c", "message": "Pass StatusInfo to ClusterFormationState and simplify message", "committedDate": "2020-06-24T15:30:25Z", "type": "commit"}, {"oid": "fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "url": "https://github.com/elastic/elasticsearch/commit/fdcdf45bad1d1dc71da4487beab8937b4e5938a4", "message": "Whitespace", "committedDate": "2020-06-24T15:37:55Z", "type": "commit"}, {"oid": "deafeca4a0a3197389bb4728a25c7f4dca74dd74", "url": "https://github.com/elastic/elasticsearch/commit/deafeca4a0a3197389bb4728a25c7f4dca74dd74", "message": "Imports", "committedDate": "2020-06-24T15:55:43Z", "type": "commit"}, {"oid": "1120428f20792607767d89cb9da69e0d9fa9fddb", "url": "https://github.com/elastic/elasticsearch/commit/1120428f20792607767d89cb9da69e0d9fa9fddb", "message": "Fixing Random", "committedDate": "2020-06-24T17:40:02Z", "type": "commit"}, {"oid": "23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "url": "https://github.com/elastic/elasticsearch/commit/23bc4e5ceae2cac7f9603e35685b4b60f63f9d48", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-06-24T17:41:10Z", "type": "commit"}, {"oid": "06b14b8435569b7032047fc518b2d2aa387b331e", "url": "https://github.com/elastic/elasticsearch/commit/06b14b8435569b7032047fc518b2d2aa387b331e", "message": "Merge branch 'master' into ro-fs-handling", "committedDate": "2020-06-24T17:44:00Z", "type": "commit"}, {"oid": "56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "url": "https://github.com/elastic/elasticsearch/commit/56fb9b3e21cae8fa4dce8fbbfbd49dbf440d10b0", "message": "ForbiddenApis for charset", "committedDate": "2020-06-24T17:55:23Z", "type": "commit"}, {"oid": "0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "url": "https://github.com/elastic/elasticsearch/commit/0d7b72f69e3afaf3409fa1c4fe4bab8bf3448c24", "message": "Fix logger", "committedDate": "2020-06-24T18:21:46Z", "type": "commit"}, {"oid": "f390ed875090811dde3eb3da5c66c9009bcf4859", "url": "https://github.com/elastic/elasticsearch/commit/f390ed875090811dde3eb3da5c66c9009bcf4859", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-06-24T19:21:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r446914720", "bodyText": "This could yield a NullPointerException if unhealthyPaths were set to null since the previous time we read it. Suggest performing a single read of the volatile field into a local variable and then using that instead.", "author": "DaveCTurner", "createdAt": "2020-06-29T11:59:07Z", "path": "server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.monitor.fs;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.component.AbstractLifecycleComponent;\n+import org.elasticsearch.common.settings.ClusterSettings;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.core.internal.io.IOUtils;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.monitor.NodeHealthService;\n+import org.elasticsearch.monitor.StatusInfo;\n+import org.elasticsearch.threadpool.Scheduler;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.LongSupplier;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.monitor.StatusInfo.Status.HEALTHY;\n+import static org.elasticsearch.monitor.StatusInfo.Status.UNHEALTHY;\n+\n+/**\n+ * Runs periodically and attempts to create a temp file to see if the filesystem is writable. If not then it marks the\n+ * path as unhealthy.\n+ */\n+public class FsHealthService extends AbstractLifecycleComponent implements NodeHealthService {\n+\n+    private static final Logger logger = LogManager.getLogger(FsHealthService.class);\n+    private final ThreadPool threadPool;\n+    private volatile boolean enabled;\n+    private final TimeValue refreshInterval;\n+    private volatile TimeValue slowPathLoggingThreshold;\n+    private final NodeEnvironment nodeEnv;\n+    private final LongSupplier currentTimeMillisSupplier;\n+    private volatile Scheduler.Cancellable scheduledFuture;\n+\n+    @Nullable\n+    private volatile Set<Path> unhealthyPaths;\n+\n+    public static final Setting<Boolean> ENABLED_SETTING =\n+        Setting.boolSetting(\"monitor.fs.health.enabled\", true, Setting.Property.NodeScope, Setting.Property.Dynamic);\n+    public static final Setting<TimeValue> REFRESH_INTERVAL_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.refresh_interval\", TimeValue.timeValueSeconds(120), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> SLOW_PATH_LOGGING_THRESHOLD_SETTING =\n+        Setting.timeSetting(\"monitor.fs.health.slow_path_logging_threshold\", TimeValue.timeValueSeconds(5), TimeValue.timeValueMillis(1),\n+            Setting.Property.NodeScope, Setting.Property.Dynamic);\n+\n+\n+    public FsHealthService(Settings settings, ClusterSettings clusterSettings, ThreadPool threadPool, NodeEnvironment nodeEnv) {\n+        this.threadPool = threadPool;\n+        this.enabled = ENABLED_SETTING.get(settings);\n+        this.refreshInterval = REFRESH_INTERVAL_SETTING.get(settings);\n+        this.slowPathLoggingThreshold = SLOW_PATH_LOGGING_THRESHOLD_SETTING.get(settings);\n+        this.currentTimeMillisSupplier = threadPool::relativeTimeInMillis;\n+        this.nodeEnv = nodeEnv;\n+        clusterSettings.addSettingsUpdateConsumer(SLOW_PATH_LOGGING_THRESHOLD_SETTING, this::setSlowPathLoggingThreshold);\n+        clusterSettings.addSettingsUpdateConsumer(ENABLED_SETTING, this::setEnabled);\n+    }\n+\n+    @Override\n+    protected void doStart() {\n+        scheduledFuture = threadPool.scheduleWithFixedDelay(new FsHealthMonitor(), refreshInterval,\n+                ThreadPool.Names.GENERIC);\n+    }\n+\n+    @Override\n+    protected void doStop() {\n+        scheduledFuture.cancel();\n+    }\n+\n+    @Override\n+    protected void doClose() {\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    public void setSlowPathLoggingThreshold(TimeValue slowPathLoggingThreshold) {\n+        this.slowPathLoggingThreshold = slowPathLoggingThreshold;\n+    }\n+\n+    @Override\n+    public StatusInfo getHealth() {\n+        StatusInfo statusInfo;\n+        if (enabled == false) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n+        } else if (unhealthyPaths == null) {\n+            statusInfo = new StatusInfo(HEALTHY, \"health check passed\");\n+        } else {\n+            String info = \"health check failed on [\" + unhealthyPaths.stream()", "originalCommit": "f390ed875090811dde3eb3da5c66c9009bcf4859", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNDA2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52680#discussion_r446934065", "bodyText": "Thanks @DaveCTurner  nice catch fixed!!", "author": "Bukhtawar", "createdAt": "2020-06-29T12:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\nindex bcc6a77166d..ecfb71cd441 100644\n--- a/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n+++ b/server/src/main/java/org/elasticsearch/monitor/fs/FsHealthService.java\n\n@@ -114,6 +114,7 @@ public class FsHealthService extends AbstractLifecycleComponent implements NodeH\n     @Override\n     public StatusInfo getHealth() {\n         StatusInfo statusInfo;\n+        Set<Path> unhealthyPaths = this.unhealthyPaths;\n         if (enabled == false) {\n             statusInfo = new StatusInfo(HEALTHY, \"health check disabled\");\n         } else if (unhealthyPaths == null) {\n"}}, {"oid": "f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "url": "https://github.com/elastic/elasticsearch/commit/f44cf0d658ebb6e3c9f5e4950dff0bade0dd9f0f", "message": "NPE handling", "committedDate": "2020-06-29T12:31:08Z", "type": "commit"}, {"oid": "97a4c02a9eafbea0122e1226cf64042eba8c48b2", "url": "https://github.com/elastic/elasticsearch/commit/97a4c02a9eafbea0122e1226cf64042eba8c48b2", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-06-29T13:20:36Z", "type": "commit"}, {"oid": "54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "url": "https://github.com/elastic/elasticsearch/commit/54d7c98fc4f0ee6fe1a27e64eb5ec1a6e9f7503a", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-07-02T05:31:35Z", "type": "commit"}, {"oid": "aae514278d14d9c5a56903b5c18df54def23db95", "url": "https://github.com/elastic/elasticsearch/commit/aae514278d14d9c5a56903b5c18df54def23db95", "message": "Merge remote-tracking branch 'upstream/master' into ro-fs-handling", "committedDate": "2020-07-03T11:25:52Z", "type": "commit"}]}