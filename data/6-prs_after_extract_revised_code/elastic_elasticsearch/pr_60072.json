{"pr_number": 60072, "pr_title": "Move mapper validation to the mappers themselves", "pr_createdAt": "2020-07-22T17:39:48Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60072", "timeline": [{"oid": "3654d66e6fae77bd74503fca7335ec23004c388a", "url": "https://github.com/elastic/elasticsearch/commit/3654d66e6fae77bd74503fca7335ec23004c388a", "message": "Move mapper validation to the mappers themselves", "committedDate": "2020-07-22T17:07:38Z", "type": "commit"}, {"oid": "4827184df4f069a9d3eac7762ee35536968c948f", "url": "https://github.com/elastic/elasticsearch/commit/4827184df4f069a9d3eac7762ee35536968c948f", "message": "parent-join test", "committedDate": "2020-07-22T19:04:05Z", "type": "commit"}, {"oid": "913cffb1dcd54d4c30fdd6c17bb06fc0d60a9eb1", "url": "https://github.com/elastic/elasticsearch/commit/913cffb1dcd54d4c30fdd6c17bb06fc0d60a9eb1", "message": "Merge remote-tracking branch 'origin/master' into mapper/validation", "committedDate": "2020-07-23T11:17:53Z", "type": "commit"}, {"oid": "423b27618d5967348bfddb1d25b1f1ccf62d8833", "url": "https://github.com/elastic/elasticsearch/commit/423b27618d5967348bfddb1d25b1f1ccf62d8833", "message": "test", "committedDate": "2020-07-23T11:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzY5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459437697", "bodyText": "Should this be in FieldAliasMapper?", "author": "nik9000", "createdAt": "2020-07-23T13:12:25Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -83,4 +123,89 @@ public Analyzer indexAnalyzer() {\n     public Iterator<Mapper> iterator() {\n         return fieldMappers.values().iterator();\n     }\n+\n+    public void checkFieldLimit(long limit) {\n+        if (fieldMappers.size() + objectMappers.size() - metadataFieldCount > limit) {\n+            throw new IllegalArgumentException(\"Limit of total fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public void checkObjectDepthLimit(long limit) {\n+        for (String objectPath : objectMappers.keySet()) {\n+            int numDots = 0;\n+            for (int i = 0; i < objectPath.length(); ++i) {\n+                if (objectPath.charAt(i) == '.') {\n+                    numDots += 1;\n+                }\n+            }\n+            final int depth = numDots + 2;\n+            if (depth > limit) {\n+                throw new IllegalArgumentException(\"Limit of mapping depth [\" + limit +\n+                    \"] has been exceeded due to object field [\" + objectPath + \"]\");\n+            }\n+        }\n+    }\n+\n+    public void checkFieldNameLengthLimit(long limit) {\n+        Stream.of(objectMappers.values().stream(), fieldMappers.values().stream())\n+            .reduce(Stream::concat)\n+            .orElseGet(Stream::empty)\n+            .forEach(mapper -> {\n+                String name = mapper.simpleName();\n+                if (name.length() > limit) {\n+                    throw new IllegalArgumentException(\"Field name [\" + name + \"] is longer than the limit of [\" + limit + \"] characters\");\n+                }\n+            });\n+    }\n+\n+    public void checkNestedLimit(long limit) {\n+        long actualNestedFields = 0;\n+        for (ObjectMapper objectMapper : objectMappers.values()) {\n+            if (objectMapper.nested().isNested()) {\n+                actualNestedFields++;\n+            }\n+        }\n+        if (actualNestedFields > limit) {\n+            throw new IllegalArgumentException(\"Limit of nested fields [\" + limit + \"] has been exceeded\");\n+        }\n+    }\n+\n+    public boolean hasNested() {\n+        return hasNested;\n+    }\n+\n+    public Map<String, ObjectMapper> objectMappers() {\n+        return objectMappers;\n+    }\n+\n+    public boolean isAlias(String path) {", "originalCommit": "423b27618d5967348bfddb1d25b1f1ccf62d8833", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzI1NA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477254", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-07-23T14:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNzY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9faebee05dd01681ea4430c75295b6532b796485", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java b/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\nindex 2b2a83b83a7..09cc3369f6e 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\n\n@@ -178,10 +178,6 @@ public final class DocumentFieldMappers implements Iterable<Mapper> {\n         return objectMappers;\n     }\n \n-    public boolean isAlias(String path) {\n-        return getMapper(path) instanceof FieldAliasMapper;\n-    }\n-\n     public boolean isMultiField(String field) {\n         String sourceParent = parentObject(field);\n         return sourceParent != null && fieldMappers.containsKey(sourceParent);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODgxOA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459438818", "bodyText": "Do you think these should be on tests for the mappers you are validating?", "author": "nik9000", "createdAt": "2020-07-23T13:14:17Z", "path": "server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java", "diffHunk": "@@ -21,56 +21,60 @@\n import org.elasticsearch.Version;\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.lucene.Lucene;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.test.ESTestCase;\n \n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.List;\n \n import static java.util.Collections.emptyList;\n import static java.util.Collections.emptyMap;\n import static java.util.Collections.singletonList;\n \n-public class MapperMergeValidatorTests extends ESTestCase {\n+public class MapperValidatorTests extends ESTestCase {", "originalCommit": "423b27618d5967348bfddb1d25b1f1ccf62d8833", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzE1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477151", "bodyText": "They're all for aliases, I'll rename the class to FieldAliasMapperValidationTests - I think it's probably still worth having as a separate class.", "author": "romseygeek", "createdAt": "2020-07-23T14:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzODgxOA=="}], "type": "inlineReview", "revised_code": {"commit": "9faebee05dd01681ea4430c75295b6532b796485", "chunk": "diff --git a/server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java b/server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java\nsimilarity index 99%\nrename from server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java\nrename to server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java\nindex 850e37bb5c3..719776a16ce 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/MapperValidatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/FieldAliasMapperValidationTests.java\n\n@@ -33,7 +33,7 @@ import static java.util.Collections.emptyList;\n import static java.util.Collections.emptyMap;\n import static java.util.Collections.singletonList;\n \n-public class MapperValidatorTests extends ESTestCase {\n+public class FieldAliasMapperValidationTests extends ESTestCase {\n \n     public void testDuplicateFieldAliasAndObject() {\n         ObjectMapper objectMapper = createObjectMapper(\"some.path\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzOTM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459439380", "bodyText": "Probably worth javadoc just because all the mappers are going to have to deal with it.", "author": "nik9000", "createdAt": "2020-07-23T13:15:08Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/Mapper.java", "diffHunk": "@@ -190,4 +190,6 @@ public final String simpleName() {\n      *  Both {@code this} and {@code mergeWith} will be left unmodified. */\n     public abstract Mapper merge(Mapper mergeWith);\n \n+    public abstract void validate(DocumentFieldMappers mappers);", "originalCommit": "423b27618d5967348bfddb1d25b1f1ccf62d8833", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NzM1NA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459477354", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-07-23T14:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzOTM4MA=="}], "type": "inlineReview", "revised_code": {"commit": "9faebee05dd01681ea4430c75295b6532b796485", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/Mapper.java b/server/src/main/java/org/elasticsearch/index/mapper/Mapper.java\nindex 360fce35734..e9f4c37fe00 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/Mapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/Mapper.java\n\n@@ -190,6 +190,10 @@ public abstract class Mapper implements ToXContentFragment, Iterable<Mapper> {\n      *  Both {@code this} and {@code mergeWith} will be left unmodified. */\n     public abstract Mapper merge(Mapper mergeWith);\n \n+    /**\n+     * Validate any cross-field references made by this mapper\n+     * @param mappers a {@link DocumentFieldMappers} that can produce references to other mappers\n+     */\n     public abstract void validate(DocumentFieldMappers mappers);\n \n }\n"}}, {"oid": "9faebee05dd01681ea4430c75295b6532b796485", "url": "https://github.com/elastic/elasticsearch/commit/9faebee05dd01681ea4430c75295b6532b796485", "message": "feedback", "committedDate": "2020-07-23T14:10:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459158345", "bodyText": "To me it feels fragile to put these checks in a method that can be overridden. If an implementor forgets to call super.validate(...) then we would forget to enforce these important constraints. Perhaps we could keep this logic in a higher-level (non-pluggable) class instead.", "author": "jtibshirani", "createdAt": "2020-07-23T00:35:45Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java", "diffHunk": "@@ -292,6 +292,46 @@ protected FieldMapper clone() {\n         }\n     }\n \n+    @Override\n+    public void validate(DocumentFieldMappers mappers) {\n+        if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {", "originalCommit": "4827184df4f069a9d3eac7762ee35536968c948f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMjUyNw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459622527", "bodyText": "We've done this sort of thing a lot in the aggs framework and it has led to some weird methods, doValidate, innerValidate, doInnerValidate and stuff like that. I really wish there were a clean way to force an overrides to call super. Its not something you can force with checkstyle. At least, I don't think it is.", "author": "nik9000", "createdAt": "2020-07-23T17:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDEwMw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354103", "bodyText": "I've made validate final and added a doValidate() subclassable method.", "author": "romseygeek", "createdAt": "2020-08-03T11:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwODYxNA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464608614", "bodyText": "It makes me sad, but if @jtibshirani prefers it that is ok with me.", "author": "nik9000", "createdAt": "2020-08-03T19:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDk2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464620965", "bodyText": "I do prefer it as it's more robust. Unfortunately I can't see a cleaner way to handle this. Would smoothing over the naming make you a bit less sad, perhaps using validateOptions instead of doValidate?", "author": "jtibshirani", "createdAt": "2020-08-03T19:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTA2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464645067", "bodyText": "Would smoothing over the naming make you a bit less sad, perhaps using validateOptions instead of doValidate?\n\nThe name doesn't really matter. I'll know in my heart that we're doing it because we can't force subclasses to call the superclass implementation. It's cool. Compromise is a way of life.", "author": "nik9000", "createdAt": "2020-08-03T20:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1ODM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "351433229baef229885680903a75364cab2e2ea8", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java\nindex 7b1f5118f17..7ff8435bbe0 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java\n\n@@ -292,6 +347,7 @@ public abstract class FieldMapper extends Mapper implements Cloneable {\n         }\n     }\n \n+\n     @Override\n     public void validate(DocumentFieldMappers mappers) {\n         if (this.copyTo() != null && this.copyTo().copyToFields().isEmpty() == false) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NTI1Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459585256", "bodyText": "It would be nice to rework the name DocumentFieldMappers -- it doesn't fit so well now that it contains object mappers, as well as FieldTypeLookup. Maybe something like MappingLookup?", "author": "jtibshirani", "createdAt": "2020-07-23T16:43:15Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -27,12 +27,16 @@\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.stream.Stream;\n \n public final class DocumentFieldMappers implements Iterable<Mapper> {\n \n     /** Full field name to mapper */\n     private final Map<String, Mapper> fieldMappers;\n-\n+    private final Map<String, ObjectMapper> objectMappers;", "originalCommit": "9faebee05dd01681ea4430c75295b6532b796485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354195", "bodyText": "++ to MappingLookup", "author": "romseygeek", "createdAt": "2020-08-03T11:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4NTI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java b/server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\nsimilarity index 73%\nrename from server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\nrename to server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\nindex 09cc3369f6e..64cd4fc4cb9 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\n\n@@ -20,16 +20,19 @@\n package org.elasticsearch.index.mapper;\n \n import org.apache.lucene.analysis.Analyzer;\n+import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.analysis.FieldNameAnalyzer;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.stream.Stream;\n \n-public final class DocumentFieldMappers implements Iterable<Mapper> {\n+public final class MappingLookup implements Iterable<Mapper> {\n \n     /** Full field name to mapper */\n     private final Map<String, Mapper> fieldMappers;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTUwNA==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459595504", "bodyText": "Instead of storing these data structures again, MapperService could just delegate to mapper to retrieve field types, etc. That would clarify who actually 'owns' this data.", "author": "jtibshirani", "createdAt": "2020-07-23T17:00:26Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MapperService.java", "diffHunk": "@@ -347,67 +341,17 @@ private synchronized DocumentMapper internalMerge(DocumentMapper mapper, MergeRe\n             newMapper = mapper;\n         }\n         newMapper.root().fixRedundantIncludes();\n-\n-        // check basic sanity of the new mapping\n-        List<ObjectMapper> objectMappers = new ArrayList<>();\n-        List<FieldMapper> fieldMappers = new ArrayList<>();\n-        List<FieldAliasMapper> fieldAliasMappers = new ArrayList<>();\n-        MetadataFieldMapper[] metadataMappers = newMapper.mapping().metadataMappers;\n-        Collections.addAll(fieldMappers, metadataMappers);\n-        MapperUtils.collect(newMapper.mapping().root(), objectMappers, fieldMappers, fieldAliasMappers);\n-\n-        MapperMergeValidator.validateNewMappers(objectMappers, fieldMappers, fieldAliasMappers);\n-        checkPartitionedIndexConstraints(newMapper);\n-\n-        // update lookup data-structures\n-        FieldTypeLookup newFieldTypes = new FieldTypeLookup(fieldMappers, fieldAliasMappers);\n-\n-        for (ObjectMapper objectMapper : objectMappers) {\n-            if (fullPathObjectMappers == this.fullPathObjectMappers) {\n-                // first time through the loops\n-                fullPathObjectMappers = new HashMap<>(this.fullPathObjectMappers);\n-            }\n-            fullPathObjectMappers.put(objectMapper.fullPath(), objectMapper);\n-\n-            if (objectMapper.nested().isNested()) {\n-                hasNested = true;\n-            }\n-        }\n-\n-        MapperMergeValidator.validateFieldReferences(fieldMappers, fieldAliasMappers,\n-            fullPathObjectMappers, newFieldTypes, metadataMappers, newMapper);\n-\n-        ContextMapping.validateContextPaths(indexSettings.getIndexVersionCreated(), fieldMappers, newFieldTypes::get);\n-\n-        if (reason != MergeReason.MAPPING_RECOVERY) {\n-            // These checks will only be performed on the master node when an index is created, or\n-            // there is a call to the update mapping API. For all other cases like the master node\n-            // restoring mappings from disk or data nodes deserializing cluster state that was sent\n-            // by the master node, these checks will be skipped.\n-            // Also, don't take metadata mappers into account for the field limit check\n-            checkTotalFieldsLimit(objectMappers.size() + fieldMappers.size() - metadataMappers.length\n-                + fieldAliasMappers.size() );\n-            checkFieldNameSoftLimit(objectMappers, fieldMappers, fieldAliasMappers);\n-            checkNestedFieldsLimit(fullPathObjectMappers);\n-            checkDepthLimit(fullPathObjectMappers.keySet());\n-        }\n-        checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);\n+        newMapper.validate(indexSettings, reason != MergeReason.MAPPING_RECOVERY);\n \n         if (reason == MergeReason.MAPPING_UPDATE_PREFLIGHT) {\n             return newMapper;\n         }\n \n-        // only need to immutably rewrap these if the previous reference was changed.\n-        // if not then they are already implicitly immutable.\n-        if (fullPathObjectMappers != this.fullPathObjectMappers) {\n-            fullPathObjectMappers = Collections.unmodifiableMap(fullPathObjectMappers);\n-        }\n-\n         // commit the change\n         this.mapper = newMapper;\n-        this.fieldTypes = newFieldTypes;\n-        this.hasNested = hasNested;\n-        this.fullPathObjectMappers = fullPathObjectMappers;\n+        this.fieldTypes = newMapper.fieldTypes();", "originalCommit": "9faebee05dd01681ea4430c75295b6532b796485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDI4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354287", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-08-03T11:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/MapperService.java b/server/src/main/java/org/elasticsearch/index/mapper/MapperService.java\nindex cf2307618f7..6f231c60fda 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/MapperService.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/MapperService.java\n\n@@ -349,10 +318,6 @@ public class MapperService extends AbstractIndexComponent implements Closeable {\n \n         // commit the change\n         this.mapper = newMapper;\n-        this.fieldTypes = newMapper.fieldTypes();\n-        this.hasNested = newMapper.hasNestedObjects();\n-        this.fullPathObjectMappers = newMapper.objectMappers();\n-\n         assert assertSerialization(newMapper);\n \n         return newMapper;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTc2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459595765", "bodyText": "We can also add an @Override to DataStreamTimestampMapper#validate.", "author": "jtibshirani", "createdAt": "2020-07-23T17:00:53Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java", "diffHunk": "@@ -70,6 +70,7 @@ protected MetadataFieldMapper(FieldType fieldType, MappedFieldType mappedFieldTy\n      * Called when mapping gets merged. Provides the opportunity to validate other fields a metadata field mapper\n      * is supposed to work with before a mapping update is completed.\n      */\n+    @Override", "originalCommit": "9faebee05dd01681ea4430c75295b6532b796485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDMzMg==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354332", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-08-03T11:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NTc2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java\nindex 68c4fc753e6..e74652509d3 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/MetadataFieldMapper.java\n\n@@ -66,15 +66,6 @@ public abstract class MetadataFieldMapper extends FieldMapper {\n         super(mappedFieldType.name(), fieldType, mappedFieldType, MultiFields.empty(), CopyTo.empty());\n     }\n \n-    /**\n-     * Called when mapping gets merged. Provides the opportunity to validate other fields a metadata field mapper\n-     * is supposed to work with before a mapping update is completed.\n-     */\n-    @Override\n-    public void validate(DocumentFieldMappers lookup) {\n-        // noop by default\n-    }\n-\n     /**\n      * Called before {@link FieldMapper#parse(ParseContext)} on the {@link RootObjectMapper}.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459601366", "bodyText": "Small comment, we could expose all these checks as a single method DocumentFieldMappers#checkLimits(IndexSettings settings).", "author": "jtibshirani", "createdAt": "2020-07-23T17:10:31Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java", "diffHunk": "@@ -306,6 +289,25 @@ public DocumentMapper merge(Mapping mapping, MergeReason reason) {\n         return new DocumentMapper(mapperService, merged);\n     }\n \n+    public void validate(IndexSettings settings, boolean checkLimits) {\n+        this.mapping.validate(this.fieldMappers);\n+        if (settings.getIndexMetadata().isRoutingPartitionedIndex()) {\n+            if (routingFieldMapper().required() == false) {\n+                throw new IllegalArgumentException(\"mapping type [\" + type() + \"] must have routing \"\n+                    + \"required for partitioned index [\" + settings.getIndex().getName() + \"]\");\n+            }\n+        }\n+        if (settings.getIndexSortConfig().hasIndexSort() && hasNestedObjects()) {\n+            throw new IllegalArgumentException(\"cannot have nested fields when index sort is activated\");\n+        }\n+        if (checkLimits) {\n+            this.fieldMappers.checkFieldLimit(settings.getMappingTotalFieldsLimit());", "originalCommit": "9faebee05dd01681ea4430c75295b6532b796485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NDQxMg==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464354412", "bodyText": "++", "author": "romseygeek", "createdAt": "2020-08-03T11:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMTM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java\nindex bd5a3aa6c30..daf0c84b7f6 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java\n\n@@ -301,10 +284,7 @@ public class DocumentMapper implements ToXContentFragment {\n             throw new IllegalArgumentException(\"cannot have nested fields when index sort is activated\");\n         }\n         if (checkLimits) {\n-            this.fieldMappers.checkFieldLimit(settings.getMappingTotalFieldsLimit());\n-            this.fieldMappers.checkObjectDepthLimit(settings.getMappingDepthLimit());\n-            this.fieldMappers.checkFieldNameLengthLimit(settings.getMappingFieldNameLengthLimit());\n-            this.fieldMappers.checkNestedLimit(settings.getMappingNestedFieldsLimit());\n+            this.fieldMappers.checkLimits(settings);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r459612585", "bodyText": "Instead of recalculating this, could we pass in the metadata field mappers directly from DocumentMapper?", "author": "jtibshirani", "createdAt": "2020-07-23T17:29:51Z", "path": "server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java", "diffHunk": "@@ -43,22 +47,54 @@ private static void put(Map<String, Analyzer> analyzers, String key, Analyzer va\n     }\n \n     public DocumentFieldMappers(Collection<FieldMapper> mappers,\n+                                Collection<ObjectMapper> objectMappers,\n                                 Collection<FieldAliasMapper> aliasMappers,\n                                 Analyzer defaultIndex) {\n         Map<String, Mapper> fieldMappers = new HashMap<>();\n         Map<String, Analyzer> indexAnalyzers = new HashMap<>();\n+        Map<String, ObjectMapper> objects = new HashMap<>();\n+\n+        boolean hasNested = false;\n+        for (ObjectMapper mapper : objectMappers) {\n+            if (objects.put(mapper.fullPath(), mapper) != null) {\n+                throw new MapperParsingException(\"Object mapper [\" + mapper.fullPath() + \"] is defined more than once\");\n+            }\n+            if (mapper.nested().isNested()) {\n+                hasNested = true;\n+            }\n+        }\n+        this.hasNested = hasNested;\n+\n+        int metadataFieldCount = 0;", "originalCommit": "9faebee05dd01681ea4430c75295b6532b796485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1NTE2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464355169", "bodyText": "I've changed things slightly so that the constructor takes the field count directly, but also added a static factory method that will build a MappingLookup from a Mapper and Analyzer.  This also means that we can move MapperUtils.collect into a private static method on MappingLookup and remove the MapperUtils enum entirely.", "author": "romseygeek", "createdAt": "2020-08-03T11:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNjI4Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60072#discussion_r464606283", "bodyText": "Great, this turned out nicely.", "author": "jtibshirani", "createdAt": "2020-08-03T19:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMjU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java b/server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\nsimilarity index 73%\nrename from server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\nrename to server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\nindex 09cc3369f6e..64cd4fc4cb9 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/MappingLookup.java\n\n@@ -46,10 +49,45 @@ public final class DocumentFieldMappers implements Iterable<Mapper> {\n         analyzers.put(key, value);\n     }\n \n-    public DocumentFieldMappers(Collection<FieldMapper> mappers,\n-                                Collection<ObjectMapper> objectMappers,\n-                                Collection<FieldAliasMapper> aliasMappers,\n-                                Analyzer defaultIndex) {\n+    public static MappingLookup fromMapping(Mapping mapping, Analyzer defaultIndex) {\n+        List<ObjectMapper> newObjectMappers = new ArrayList<>();\n+        List<FieldMapper> newFieldMappers = new ArrayList<>();\n+        List<FieldAliasMapper> newFieldAliasMappers = new ArrayList<>();\n+        for (MetadataFieldMapper metadataMapper : mapping.metadataMappers) {\n+            if (metadataMapper != null) {\n+                newFieldMappers.add(metadataMapper);\n+            }\n+        }\n+        collect(mapping.root, newObjectMappers, newFieldMappers, newFieldAliasMappers);\n+        return new MappingLookup(newFieldMappers, newObjectMappers, newFieldAliasMappers, mapping.metadataMappers.length, defaultIndex);\n+    }\n+\n+    private static void collect(Mapper mapper, Collection<ObjectMapper> objectMappers,\n+                               Collection<FieldMapper> fieldMappers,\n+                               Collection<FieldAliasMapper> fieldAliasMappers) {\n+        if (mapper instanceof RootObjectMapper) {\n+            // root mapper isn't really an object mapper\n+        } else if (mapper instanceof ObjectMapper) {\n+            objectMappers.add((ObjectMapper)mapper);\n+        } else if (mapper instanceof FieldMapper) {\n+            fieldMappers.add((FieldMapper)mapper);\n+        } else if (mapper instanceof FieldAliasMapper) {\n+            fieldAliasMappers.add((FieldAliasMapper) mapper);\n+        } else {\n+            throw new IllegalStateException(\"Unrecognized mapper type [\" +\n+                mapper.getClass().getSimpleName() + \"].\");\n+        }\n+\n+        for (Mapper child : mapper) {\n+            collect(child, objectMappers, fieldMappers, fieldAliasMappers);\n+        }\n+    }\n+\n+    public MappingLookup(Collection<FieldMapper> mappers,\n+                         Collection<ObjectMapper> objectMappers,\n+                         Collection<FieldAliasMapper> aliasMappers,\n+                         int metadataFieldCount,\n+                         Analyzer defaultIndex) {\n         Map<String, Mapper> fieldMappers = new HashMap<>();\n         Map<String, Analyzer> indexAnalyzers = new HashMap<>();\n         Map<String, ObjectMapper> objects = new HashMap<>();\n"}}, {"oid": "351433229baef229885680903a75364cab2e2ea8", "url": "https://github.com/elastic/elasticsearch/commit/351433229baef229885680903a75364cab2e2ea8", "message": "Merge remote-tracking branch 'origin/master' into mapper/validation", "committedDate": "2020-08-03T08:37:20Z", "type": "commit"}, {"oid": "f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "url": "https://github.com/elastic/elasticsearch/commit/f02d47ada20206decb56aa83f413f6e8ab9e1dd7", "message": "feedback", "committedDate": "2020-08-03T10:27:51Z", "type": "commit"}, {"oid": "9b39979dbc56e08f9403c81b7f0a0e16dac4f80d", "url": "https://github.com/elastic/elasticsearch/commit/9b39979dbc56e08f9403c81b7f0a0e16dac4f80d", "message": "Merge branch 'master' into mapper/validation", "committedDate": "2020-08-04T08:02:28Z", "type": "commit"}]}