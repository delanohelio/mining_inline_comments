{"pr_number": 50691, "pr_title": "Teach ObjectParser a happy pattern", "pr_createdAt": "2020-01-06T23:10:24Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/50691", "timeline": [{"oid": "7d4bdfb92a5f37eae6aec00e7438632966ec7852", "url": "https://github.com/elastic/elasticsearch/commit/7d4bdfb92a5f37eae6aec00e7438632966ec7852", "message": "Teach ObjectParser a happy pattern\n\nWe *very* commonly have object with ctors like:\n```\npublic Foo(String name)\n```\n\nAnd then declare a bunch of setters on the object. Every aggregation\nworks like this, for example. This change teaches `ObjectParser` how to\nbuild these aggregations all on its own, without any help. This'll make\nit much cleaner to parse aggs, and, probably, a bunch of other things.\nIt'll let us remove lots of wrapping. I've used this new power for the\n`avg` aggregation just to prove that it works outside of a unit test.", "committedDate": "2020-01-06T23:02:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU1NDg4OA==", "url": "https://github.com/elastic/elasticsearch/pull/50691#discussion_r363554888", "bodyText": "From here the payoff doesn't look that good, but we can remove the parses method entirely in a follow-up  and call the parser directly. We can't do it right now because the order of the arguments is backwards.", "author": "nik9000", "createdAt": "2020-01-07T01:15:54Z", "path": "server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java", "diffHunk": "@@ -42,14 +42,13 @@\n public class AvgAggregationBuilder extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource.Numeric, AvgAggregationBuilder> {\n     public static final String NAME = \"avg\";\n \n-    private static final ObjectParser<AvgAggregationBuilder, Void> PARSER;\n+    private static final ObjectParser<AvgAggregationBuilder, String> PARSER = new ObjectParser<>(NAME, AvgAggregationBuilder::new);\n     static {\n-        PARSER = new ObjectParser<>(AvgAggregationBuilder.NAME);\n         ValuesSourceParserHelper.declareNumericFields(PARSER, true, true, false);\n     }\n \n     public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {\n-        return PARSER.parse(parser, new AvgAggregationBuilder(aggregationName), null);\n+        return PARSER.parse(parser, aggregationName);", "originalCommit": "7d4bdfb92a5f37eae6aec00e7438632966ec7852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cac4dbf9981490b1e452030106e7e000835c1443", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java\nindex 0aec0f36286..32e9aaf5e2b 100644\n--- a/server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java\n+++ b/server/src/main/java/org/elasticsearch/search/aggregations/metrics/AvgAggregationBuilder.java\n\n@@ -42,7 +42,7 @@ import java.util.Map;\n public class AvgAggregationBuilder extends ValuesSourceAggregationBuilder.LeafOnly<ValuesSource.Numeric, AvgAggregationBuilder> {\n     public static final String NAME = \"avg\";\n \n-    private static final ObjectParser<AvgAggregationBuilder, String> PARSER = new ObjectParser<>(NAME, AvgAggregationBuilder::new);\n+    private static final ObjectParser<AvgAggregationBuilder, String> PARSER = ObjectParser.fromBuilder(NAME, AvgAggregationBuilder::new);\n     static {\n         ValuesSourceParserHelper.declareNumericFields(PARSER, true, true, false);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU1NTE0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/50691#discussion_r363555143", "bodyText": "All of these are because it couldn't compile now that there are two methods that take two args. It is better not to have the null anyway.", "author": "nik9000", "createdAt": "2020-01-07T01:16:59Z", "path": "server/src/main/java/org/elasticsearch/search/rescore/QueryRescorerBuilder.java", "diffHunk": "@@ -45,7 +45,7 @@\n     private static final ParseField RESCORE_QUERY_WEIGHT_FIELD = new ParseField(\"rescore_query_weight\");\n     private static final ParseField SCORE_MODE_FIELD = new ParseField(\"score_mode\");\n \n-    private static final ObjectParser<InnerBuilder, Void> QUERY_RESCORE_PARSER = new ObjectParser<>(NAME, null);\n+    private static final ObjectParser<InnerBuilder, Void> QUERY_RESCORE_PARSER = new ObjectParser<>(NAME);", "originalCommit": "7d4bdfb92a5f37eae6aec00e7438632966ec7852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzU1NTQ2NA==", "url": "https://github.com/elastic/elasticsearch/pull/50691#discussion_r363555464", "bodyText": "This is because there are two ctors on atomic reference. One that looks like a function and one that looks like a supplier. The compiler was confused when I passed ::new to the ctor.", "author": "nik9000", "createdAt": "2020-01-07T01:18:22Z", "path": "libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java", "diffHunk": "@@ -634,8 +637,9 @@ public void setArray(List<Object> testArray) {\n         assertThat(ex.getMessage(), containsString(\"[foo] failed to parse field [int_array]\"));\n     }\n \n+    private static final Supplier<AtomicReference<String>> NEW_EMPTY_STRING_REF = AtomicReference::new;", "originalCommit": "7d4bdfb92a5f37eae6aec00e7438632966ec7852", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cac4dbf9981490b1e452030106e7e000835c1443", "chunk": "diff --git a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java\nindex adcbb6a9425..96d0f11af7c 100644\n--- a/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java\n+++ b/libs/x-content/src/test/java/org/elasticsearch/common/xcontent/ObjectParserTests.java\n\n@@ -637,9 +635,8 @@ public class ObjectParserTests extends ESTestCase {\n         assertThat(ex.getMessage(), containsString(\"[foo] failed to parse field [int_array]\"));\n     }\n \n-    private static final Supplier<AtomicReference<String>> NEW_EMPTY_STRING_REF = AtomicReference::new;\n     public void testNoopDeclareObject() throws IOException {\n-        ObjectParser<AtomicReference<String>, Void> parser = new ObjectParser<>(\"noopy\", NEW_EMPTY_STRING_REF);\n+        ObjectParser<AtomicReference<String>, Void> parser = new ObjectParser<>(\"noopy\", AtomicReference::new);\n         parser.declareString(AtomicReference::set, new ParseField(\"body\"));\n         parser.declareObject((a,b) -> {}, (p, c) -> null, new ParseField(\"noop\"));\n \n"}}, {"oid": "cac4dbf9981490b1e452030106e7e000835c1443", "url": "https://github.com/elastic/elasticsearch/commit/cac4dbf9981490b1e452030106e7e000835c1443", "message": "Named ctor", "committedDate": "2020-01-07T13:49:03Z", "type": "commit"}]}