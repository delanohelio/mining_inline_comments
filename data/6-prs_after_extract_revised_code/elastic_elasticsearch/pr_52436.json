{"pr_number": 52436, "pr_title": "Do not lock when generating time based uuid", "pr_createdAt": "2020-02-17T19:20:13Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52436", "timeline": [{"oid": "3bd07cfe9368a68043f369e93d7862bf14b0ef85", "url": "https://github.com/elastic/elasticsearch/commit/3bd07cfe9368a68043f369e93d7862bf14b0ef85", "message": "Do not lock when generating time based uuid\n\nCurrently we lock when generating time based uuids. The lock is\nimplemented to prevent concurrent writes to the last timestamp. The uuid\ngeneration is an area of contention when indexing. This commit modifies\nthe code to use atomic compare and set operations to update the last\ntimestamp.", "committedDate": "2020-02-17T18:17:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380362972", "bodyText": "I think we can fold the loop into a convenience method on AtomicLong:\ndiff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\nindex c30a8d0aaa2..aa14d608aa7 100644\n--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n@@ -21,6 +21,7 @@ package org.elasticsearch.common;\n \n import java.util.Base64;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * These are essentially flake ids but we use 6 (not 8) bytes for timestamp, and use 3 (not 2) bytes for sequence number. We also reorder\n@@ -37,7 +38,7 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     private final AtomicInteger sequenceNumber = new AtomicInteger(SecureRandomHolder.INSTANCE.nextInt());\n \n     // Used to ensure clock moves forward:\n-    private long lastTimestamp;\n+    private AtomicLong lastTimestamp = new AtomicLong();\n \n     private static final byte[] SECURE_MUNGED_ADDRESS = MacAddressProvider.getSecureMungedAddress();\n \n@@ -58,21 +59,22 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     @Override\n     public String getBase64UUID()  {\n         final int sequenceId = sequenceNumber.incrementAndGet() & 0xffffff;\n-        long timestamp = currentTimeMillis();\n \n-        synchronized (this) {\n-            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\n-            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n-            // collision:\n-            timestamp = Math.max(lastTimestamp, timestamp);\n+        final long timestamp = lastTimestamp.updateAndGet(\n+            last -> {\n+                // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\n+                // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n+                // collision:\n+                long nonBackwardsCurrentTimestamp = Math.max(last, currentTimeMillis());\n \n-            if (sequenceId == 0) {\n-                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n-                timestamp++;\n-            }\n+                if (sequenceId == 0) {\n+                    // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n+                    nonBackwardsCurrentTimestamp++;\n+                }\n \n-            lastTimestamp = timestamp;\n-        }\n+                return nonBackwardsCurrentTimestamp;\n+            }\n+         );\n \n         final byte[] uuidBytes = new byte[15];\n         int i = 0;", "author": "jasontedor", "createdAt": "2020-02-17T20:55:53Z", "path": "server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java", "diffHunk": "@@ -71,7 +74,9 @@ public String getBase64UUID()  {\n                 timestamp++;\n             }\n \n-            lastTimestamp = timestamp;\n+            if (this.lastTimestamp.compareAndSet(lastTimestamp, timestamp)) {", "originalCommit": "3bd07cfe9368a68043f369e93d7862bf14b0ef85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NDczMA==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380374730", "bodyText": "In your proposal we might call currentTimeMillis() multiple times, but I don't think we have to? It could be computed only once like in master or Tim's proposal?", "author": "jpountz", "createdAt": "2020-02-17T21:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwNzM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380607387", "bodyText": "I missed that, thanks. It can lifted out of the updateAndGet update function as @tbrooks8 did in bf13356.", "author": "jasontedor", "createdAt": "2020-02-18T11:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bf13356b18bcb22e0da0db8a861afae00cd5847b", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\nindex b5c9dbdc287..f053d3ecaf7 100644\n--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n\n@@ -59,25 +59,22 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     @Override\n     public String getBase64UUID()  {\n         final int sequenceId = sequenceNumber.incrementAndGet() & 0xffffff;\n-        long timestamp = currentTimeMillis();\n+        long currentTimeMillis = currentTimeMillis();\n \n-        while (true) {\n-            long lastTimestamp = this.lastTimestamp.get();\n-\n-            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\n-            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n-            // collision:\n-            timestamp = Math.max(lastTimestamp, timestamp);\n+        long timestamp = this.lastTimestamp.updateAndGet(lastTimestamp -> {\n+            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are\n+            // still vulnerable if we are shut down, clock goes backwards, and we restart... for this we\n+            // randomize the sequenceNumber on init to decrease chance of collision:\n+            long nonBackwardsTimestamp = Math.max(lastTimestamp, currentTimeMillis);\n \n             if (sequenceId == 0) {\n-                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n-                timestamp++;\n+                // Always force the clock to increment whenever sequence number is 0, in case we have a long\n+                // time-slip backwards:\n+                nonBackwardsTimestamp++;\n             }\n \n-            if (this.lastTimestamp.compareAndSet(lastTimestamp, timestamp)) {\n-                break;\n-            }\n-        }\n+            return nonBackwardsTimestamp;\n+        });\n \n         final byte[] uuidBytes = new byte[15];\n         int i = 0;\n"}}, {"oid": "bf13356b18bcb22e0da0db8a861afae00cd5847b", "url": "https://github.com/elastic/elasticsearch/commit/bf13356b18bcb22e0da0db8a861afae00cd5847b", "message": "Use update and get", "committedDate": "2020-02-18T01:36:06Z", "type": "commit"}]}