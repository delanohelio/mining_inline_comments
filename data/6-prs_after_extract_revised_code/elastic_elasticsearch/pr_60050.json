{"pr_number": 60050, "pr_title": "Introduce 64-bit unsigned long field type", "pr_createdAt": "2020-07-22T14:50:41Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/60050", "timeline": [{"oid": "8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "url": "https://github.com/elastic/elasticsearch/commit/8861d6d9645311bbd2388c90dafa4ecb48fbceeb", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434", "committedDate": "2020-07-22T19:28:26Z", "type": "forcePushed"}, {"oid": "c276ffdcb301251979c8ee467464802019ce1683", "url": "https://github.com/elastic/elasticsearch/commit/c276ffdcb301251979c8ee467464802019ce1683", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434", "committedDate": "2020-07-22T20:08:38Z", "type": "forcePushed"}, {"oid": "dffd748747fabf2be412e878db904db907caa6e1", "url": "https://github.com/elastic/elasticsearch/commit/dffd748747fabf2be412e878db904db907caa6e1", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434", "committedDate": "2020-07-22T20:54:17Z", "type": "commit"}, {"oid": "dffd748747fabf2be412e878db904db907caa6e1", "url": "https://github.com/elastic/elasticsearch/commit/dffd748747fabf2be412e878db904db907caa6e1", "message": "Introduce 64-bit unsigned long field type\n\nThis field type supports\n- indexing of integer values from [0, 18446744073709551615]\n- precise queries (term, range)\n- sorting and aggregations is based on conversion of long values\n  to double and can be imprecise for large values.\n\nCloses #32434", "committedDate": "2020-07-22T20:54:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1OTE1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459359157", "bodyText": "do we really need to have support for unsigned longs at such a low level, or could we implement parsing of unsigned longs in the field mapper directly?", "author": "jpountz", "createdAt": "2020-07-23T10:37:48Z", "path": "libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java", "diffHunk": "@@ -166,6 +167,26 @@ public long doLongValue() throws IOException {\n         return parser.getLongValue();\n     }\n \n+    @Override\n+    protected long doUnsignedLongValue() throws IOException {\n+        JsonParser.NumberType numberType = parser.getNumberType();\n+        if ((numberType == JsonParser.NumberType.INT) || (numberType == JsonParser.NumberType.LONG)) {\n+            long longValue = parser.getLongValue();\n+            if (longValue < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + longValue + \"] is out of range for unsigned long.\");\n+            }\n+            return longValue;\n+        } else if (numberType == JsonParser.NumberType.BIG_INTEGER) {\n+            BigInteger bigIntegerValue = parser.getBigIntegerValue();\n+            if (bigIntegerValue.compareTo(BIGINTEGER_MAX_UNSIGNED_LONG_VALUE) > 0 || bigIntegerValue.compareTo(BigInteger.ZERO) < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + bigIntegerValue + \"] is out of range for unsigned long\");\n+            }\n+            return bigIntegerValue.longValue();\n+        } else { // for all other value types including numbers with decimal parts\n+            throw new IllegalArgumentException(\"For input string: [\" + parser.getValueAsString() + \"].\");\n+        }\n+    }", "originalCommit": "dffd748747fabf2be412e878db904db907caa6e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b1411be89318d0f858a8d4d634724ec9be91139", "chunk": "diff --git a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java\nindex ca17d923068..7489222df2e 100644\n--- a/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java\n+++ b/libs/x-content/src/main/java/org/elasticsearch/common/xcontent/json/JsonXContentParser.java\n\n@@ -167,26 +166,6 @@ public class JsonXContentParser extends AbstractXContentParser {\n         return parser.getLongValue();\n     }\n \n-    @Override\n-    protected long doUnsignedLongValue() throws IOException {\n-        JsonParser.NumberType numberType = parser.getNumberType();\n-        if ((numberType == JsonParser.NumberType.INT) || (numberType == JsonParser.NumberType.LONG)) {\n-            long longValue = parser.getLongValue();\n-            if (longValue < 0) {\n-                throw new IllegalArgumentException(\"Value [\" + longValue + \"] is out of range for unsigned long.\");\n-            }\n-            return longValue;\n-        } else if (numberType == JsonParser.NumberType.BIG_INTEGER) {\n-            BigInteger bigIntegerValue = parser.getBigIntegerValue();\n-            if (bigIntegerValue.compareTo(BIGINTEGER_MAX_UNSIGNED_LONG_VALUE) > 0 || bigIntegerValue.compareTo(BigInteger.ZERO) < 0) {\n-                throw new IllegalArgumentException(\"Value [\" + bigIntegerValue + \"] is out of range for unsigned long\");\n-            }\n-            return bigIntegerValue.longValue();\n-        } else { // for all other value types including numbers with decimal parts\n-            throw new IllegalArgumentException(\"For input string: [\" + parser.getValueAsString() + \"].\");\n-        }\n-    }\n-\n     @Override\n     public float doFloatValue() throws IOException {\n         return parser.getFloatValue();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NDM3OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r459364379", "bodyText": "without context I'd guess that this is doing a cast, maybe make the method name more explicit, e.g. unsignedToSortableSignedLong", "author": "jpountz", "createdAt": "2020-07-23T10:48:58Z", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {\n+\n+        public UnsignedLongFieldType(String name, boolean indexed, boolean hasDocValues, Map<String, String> meta) {\n+            super(name, indexed, hasDocValues, TextSearchInfo.SIMPLE_MATCH_ONLY, meta);\n+        }\n+\n+        public UnsignedLongFieldType(String name) {\n+            this(name, true, true, Collections.emptyMap());\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return CONTENT_TYPE;\n+        }\n+\n+        @Override\n+        public Query existsQuery(QueryShardContext context) {\n+            if (hasDocValues()) {\n+                return new DocValuesFieldExistsQuery(name());\n+            } else {\n+                return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));\n+            }\n+        }\n+\n+        @Override\n+        public Query termQuery(Object value, QueryShardContext context) {\n+            failIfNotIndexed();\n+            Long longValue = parseTerm(value);\n+            if (longValue == null) {\n+                return new MatchNoDocsQuery();\n+            }\n+            Query query = LongPoint.newExactQuery(name(), convertToSignedLong(longValue));\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query termsQuery(List<?> values, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long[] lvalues = new long[values.size()];\n+            int upTo = 0;\n+            for (int i = 0; i < values.size(); i++) {\n+                Object value = values.get(i);\n+                Long longValue = parseTerm(value);\n+                if (longValue != null) {\n+                    lvalues[upTo++] = convertToSignedLong(longValue);\n+                }\n+            }\n+            if (upTo == 0) {\n+                return new MatchNoDocsQuery();\n+            }\n+            if (upTo != lvalues.length) {\n+                lvalues = Arrays.copyOf(lvalues, upTo);\n+            }\n+            Query query = LongPoint.newSetQuery(name(), lvalues);\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {\n+            failIfNotIndexed();\n+            long l = Long.MIN_VALUE;\n+            long u = Long.MAX_VALUE;\n+            if (lowerTerm != null) {\n+                Long lt = parseLowerRangeTerm(lowerTerm, includeLower);\n+                if (lt == null) return new MatchNoDocsQuery();\n+                l = convertToSignedLong(lt);\n+            }\n+            if (upperTerm != null) {\n+                Long ut = parseUpperRangeTerm(upperTerm, includeUpper);\n+                if (ut == null) return new MatchNoDocsQuery();\n+                u = convertToSignedLong(ut);\n+            }\n+            if (l > u) return new MatchNoDocsQuery();\n+\n+            Query query = LongPoint.newRangeQuery(name(), l, u);\n+            if (hasDocValues()) {\n+                Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(name(), l, u);\n+                query = new IndexOrDocValuesQuery(query, dvQuery);\n+                if (context.indexSortedOnField(name())) {\n+                    query = new IndexSortSortedNumericDocValuesRangeQuery(name(), l, u, query);\n+                }\n+            }\n+            if (boost() != 1f) {\n+                query = new BoostQuery(query, boost());\n+            }\n+            return query;\n+        }\n+\n+        @Override\n+        public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {\n+            failIfNoDocValues();\n+            return (cache, breakerService, mapperService) -> {\n+                final IndexNumericFieldData signedLongValues = new SortedNumericIndexFieldData.Builder(\n+                    name(),\n+                    IndexNumericFieldData.NumericType.LONG\n+                ).build(cache, breakerService, mapperService);\n+                return new UnsignedLongIndexFieldData(signedLongValues);\n+            };\n+        }\n+\n+        @Override\n+        public Object valueForDisplay(Object value) {\n+            if (value == null) {\n+                return null;\n+            }\n+            return convertToOriginal(((Number) value).longValue());\n+        }\n+\n+        @Override\n+        public DocValueFormat docValueFormat(String format, ZoneId timeZone) {\n+            if (timeZone != null) {\n+                throw new IllegalArgumentException(\n+                    \"Field [\" + name() + \"] of type [\" + typeName() + \"] does not support custom time zones\"\n+                );\n+            }\n+            if (format == null) {\n+                return DocValueFormat.RAW;\n+            } else {\n+                return new DocValueFormat.Decimal(format);\n+            }\n+        }\n+\n+        @Override\n+        public Function<byte[], Number> pointReaderIfPossible() {\n+            if (isSearchable()) {\n+                return (value) -> LongPoint.decodeDimension(value, 0);\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Parses value to unsigned long for Term Query\n+         * @param value to to parse\n+         * @return parsed value, if a value represents an unsigned long in the range [0, 18446744073709551615]\n+         *         null, if a value represents some other number\n+         *         throws an exception if a value is wrongly formatted number\n+         */\n+        protected static Long parseTerm(Object value) {\n+            if (value instanceof Number) {\n+                if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                    long lv = ((Number) value).longValue();\n+                    if (lv >= 0) {\n+                        return lv;\n+                    }\n+                } else if (value instanceof BigInteger) {\n+                    BigInteger bigIntegerValue = (BigInteger) value;\n+                    if (bigIntegerValue.compareTo(BigInteger.ZERO) >= 0 && bigIntegerValue.compareTo(BIGINTEGER_2_64_MINUS_ONE) <= 0) {\n+                        return bigIntegerValue.longValue();\n+                    }\n+                }\n+            } else {\n+                String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+                try {\n+                    return Long.parseUnsignedLong(stringValue);\n+                } catch (NumberFormatException e) {\n+                    // try again in case a number was negative or contained decimal\n+                    Double.parseDouble(stringValue); // throws an exception if it is an improper number\n+                }\n+            }\n+            return null; // any other number: decimal or beyond the range of unsigned long\n+        }\n+\n+        /**\n+         * Parses a lower term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      0, if value is less than 0\n+         *      a value truncated to long, if value is in range [0, 18446744073709551615]\n+         *      null, if value is higher than the maximum allowed value for unsigned long\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseLowerRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if (longValue < 0) return 0L; // limit lowerTerm to min value for unsigned long: 0\n+                if (include == false) { // start from the next value\n+                    // for unsigned long, the next value for Long.MAX_VALUE is -9223372036854775808L\n+                    longValue = longValue == Long.MAX_VALUE ? Long.MIN_VALUE : ++longValue;\n+                }\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            if (bigDecimalValue.compareTo(BigDecimal.ZERO) <= 0) {\n+                return 0L; // for values <=0, set lowerTerm to 0\n+            }\n+            int c = bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE);\n+            if (c > 0 || (c == 0 && include == false)) {\n+                return null; // lowerTerm is beyond maximum value\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false || hasDecimal) {\n+                ++longValue;\n+            }\n+            return longValue;\n+        }\n+\n+        /**\n+         * Parses an upper term for a range query\n+         * @param value to parse\n+         * @param include whether a value should be included\n+         * @return parsed value to long considering include parameter\n+         *      null, if value is less that 0, as value is lower than the minimum allowed value for unsigned long\n+         *      a value truncated to long if value is in range [0, 18446744073709551615]\n+         *      -1 (unsigned long of 18446744073709551615) for values greater than 18446744073709551615\n+         *      throws an exception is value represents wrongly formatted number\n+         */\n+        protected static Long parseUpperRangeTerm(Object value, boolean include) {\n+            if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+                long longValue = ((Number) value).longValue();\n+                if ((longValue < 0) || (longValue == 0 && include == false)) return null; // upperTerm is below minimum\n+                longValue = include ? longValue : --longValue;\n+                return longValue;\n+            }\n+            String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+            final BigDecimal bigDecimalValue = new BigDecimal(stringValue);  // throws an exception if it is an improper number\n+            int c = bigDecimalValue.compareTo(BigDecimal.ZERO);\n+            if (c < 0 || (c == 0 && include == false)) {\n+                return null; // upperTerm is below minimum\n+            }\n+            if (bigDecimalValue.compareTo(BIGDECIMAL_2_64_MINUS_ONE) > 0) {\n+                return -1L; // limit upperTerm to max value for unsigned long: 18446744073709551615\n+            }\n+            long longValue = bigDecimalValue.longValue();\n+            boolean hasDecimal = (bigDecimalValue.scale() > 0 && bigDecimalValue.stripTrailingZeros().scale() > 0);\n+            if (include == false && hasDecimal == false) {\n+                --longValue;\n+            }\n+            return longValue;\n+        }\n+    }\n+\n+    private Explicit<Boolean> ignoreMalformed;\n+    private final String nullValue;\n+    private final Long nullValueNumeric;\n+\n+    private UnsignedLongFieldMapper(\n+        String simpleName,\n+        FieldType fieldType,\n+        UnsignedLongFieldType mappedFieldType,\n+        Explicit<Boolean> ignoreMalformed,\n+        MultiFields multiFields,\n+        CopyTo copyTo,\n+        String nullValue\n+    ) {\n+        super(simpleName, fieldType, mappedFieldType, multiFields, copyTo);\n+        this.nullValue = nullValue;\n+        this.nullValueNumeric = nullValue == null ? null : convertToSignedLong(parseUnsignedLong(nullValue));\n+        this.ignoreMalformed = ignoreMalformed;\n+    }\n+\n+    @Override\n+    public UnsignedLongFieldType fieldType() {\n+        return (UnsignedLongFieldType) super.fieldType();\n+    }\n+\n+    @Override\n+    protected String contentType() {\n+        return CONTENT_TYPE;\n+    }\n+\n+    @Override\n+    protected UnsignedLongFieldMapper clone() {\n+        return (UnsignedLongFieldMapper) super.clone();\n+    }\n+\n+    @Override\n+    protected void parseCreateField(ParseContext context) throws IOException {\n+        XContentParser parser = context.parser();\n+        Long numericValue;\n+        if (context.externalValueSet()) {\n+            numericValue = parseUnsignedLong(context.externalValue());\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {\n+            numericValue = null;\n+        } else if (parser.currentToken() == XContentParser.Token.VALUE_STRING && parser.textLength() == 0) {\n+            numericValue = null;\n+        } else {\n+            try {\n+                numericValue = parser.unsignedLongValue();\n+            } catch (InputCoercionException | IllegalArgumentException | JsonParseException e) {\n+                if (ignoreMalformed.value() && parser.currentToken().isValue()) {\n+                    context.addIgnoredField(mappedFieldType.name());\n+                    return;\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+        if (numericValue == null) {\n+            numericValue = nullValueNumeric;\n+            if (numericValue == null) return;\n+        } else {\n+            numericValue = convertToSignedLong(numericValue);\n+        }\n+\n+        boolean docValued = fieldType().hasDocValues();\n+        boolean indexed = fieldType().isSearchable();\n+        boolean stored = fieldType.stored();\n+\n+        List<Field> fields = NumberFieldMapper.NumberType.LONG.createFields(fieldType().name(), numericValue, indexed, docValued, stored);\n+        context.doc().addAll(fields);\n+        if (docValued == false && (indexed || stored)) {\n+            createFieldNamesField(context);\n+        }\n+    }\n+\n+    @Override\n+    protected void mergeOptions(FieldMapper other, List<String> conflicts) {\n+        UnsignedLongFieldMapper mergeWith = (UnsignedLongFieldMapper) other;\n+        if (mergeWith.ignoreMalformed.explicit()) {\n+            this.ignoreMalformed = mergeWith.ignoreMalformed;\n+        }\n+    }\n+\n+    @Override\n+    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n+        super.doXContentBody(builder, includeDefaults, params);\n+\n+        if (includeDefaults || ignoreMalformed.explicit()) {\n+            builder.field(\"ignore_malformed\", ignoreMalformed.value());\n+        }\n+        if (nullValue != null) {\n+            builder.field(\"null_value\", nullValue);\n+        }\n+    }\n+\n+    /**\n+     * Parse object to unsigned long\n+     * @param value must represent an unsigned long in rage [0;18446744073709551615] or an exception will be thrown\n+     */\n+    private static long parseUnsignedLong(Object value) {\n+        if ((value instanceof Long) || (value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+            long lv = ((Number) value).longValue();\n+            if (lv < 0) {\n+                throw new IllegalArgumentException(\"Value [\" + lv + \"] is out of range for unsigned long.\");\n+            }\n+            return lv;\n+        }\n+        String stringValue = (value instanceof BytesRef) ? ((BytesRef) value).utf8ToString() : value.toString();\n+        try {\n+            return Long.parseUnsignedLong(stringValue);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"For input string: \\\"\" + stringValue + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Convert an unsigned long to the singed long by subtract 2^63 from it\n+     * @param value \u2013 unsigned long value in the range [0; 2^64-1], values greater than 2^63-1 are negative\n+     * @return signed long value in the range [-2^63; 2^63-1]\n+     */\n+    private static long convertToSignedLong(long value) {", "originalCommit": "dffd748747fabf2be412e878db904db907caa6e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b1411be89318d0f858a8d4d634724ec9be91139", "chunk": "diff --git a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\nindex d8dfc096f74..4d083664a12 100644\n--- a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n+++ b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n\n@@ -251,7 +251,7 @@ public class UnsignedLongFieldMapper extends FieldMapper {\n             if (value == null) {\n                 return null;\n             }\n-            return convertToOriginal(((Number) value).longValue());\n+            return value;\n         }\n \n         @Override\n"}}, {"oid": "3b1411be89318d0f858a8d4d634724ec9be91139", "url": "https://github.com/elastic/elasticsearch/commit/3b1411be89318d0f858a8d4d634724ec9be91139", "message": "Address feedback", "committedDate": "2020-08-18T18:54:07Z", "type": "forcePushed"}, {"oid": "7eb2d4acd6597e07f51e9fe695bd5d195eae14d6", "url": "https://github.com/elastic/elasticsearch/commit/7eb2d4acd6597e07f51e9fe695bd5d195eae14d6", "message": "Address feedback", "committedDate": "2020-08-18T21:10:26Z", "type": "commit"}, {"oid": "612b7daa7d3fe7943636396467988ca9c79bd2f7", "url": "https://github.com/elastic/elasticsearch/commit/612b7daa7d3fe7943636396467988ca9c79bd2f7", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer", "committedDate": "2020-08-18T21:11:08Z", "type": "commit"}, {"oid": "ada3422c7f73a22c714974c1542a4e84b3ecadee", "url": "https://github.com/elastic/elasticsearch/commit/ada3422c7f73a22c714974c1542a4e84b3ecadee", "message": "Modifications after master merge", "committedDate": "2020-08-18T22:18:47Z", "type": "commit"}, {"oid": "ada3422c7f73a22c714974c1542a4e84b3ecadee", "url": "https://github.com/elastic/elasticsearch/commit/ada3422c7f73a22c714974c1542a4e84b3ecadee", "message": "Modifications after master merge", "committedDate": "2020-08-18T22:18:47Z", "type": "forcePushed"}, {"oid": "7551cd6933e74c7e295286d7838a202146b337c6", "url": "https://github.com/elastic/elasticsearch/commit/7551cd6933e74c7e295286d7838a202146b337c6", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer", "committedDate": "2020-08-19T10:21:42Z", "type": "commit"}, {"oid": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "url": "https://github.com/elastic/elasticsearch/commit/e903940c82c2e9e494465f5a1e8633b1bd834d53", "message": "Rename methods", "committedDate": "2020-08-19T20:29:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484343114", "bodyText": "These variables should be final and static ?", "author": "jimczi", "createdAt": "2020-09-07T10:27:50Z", "path": "server/src/main/java/org/elasticsearch/search/DocValueFormat.java", "diffHunk": "@@ -48,6 +49,8 @@\n \n /** A formatter for values as returned by the fielddata/doc-values APIs. */\n public interface DocValueFormat extends NamedWriteable {\n+    long MASK_2_63 = 0x8000000000000000L;\n+    BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1", "originalCommit": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwNDIwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485104205", "bodyText": "@jimczi Thanks Jim, I get a hint from Intellij that final static declarations are unnecessary here, as interface variables are by default final and static.", "author": "mayya-sharipova", "createdAt": "2020-09-08T18:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzODgyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485138825", "bodyText": "oh that's an interface, right. Sorry for the noise", "author": "jimczi", "createdAt": "2020-09-08T19:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MzExNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjQzOA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484346438", "bodyText": "Can you fix the indentation of the blocks ?", "author": "jimczi", "createdAt": "2020-09-07T10:34:49Z", "path": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java", "diffHunk": "@@ -826,7 +827,14 @@ public final void writeOptionalInstant(@Nullable Instant instant) throws IOExcep\n                             o.writeByte((byte) 25);\n                         }\n                         o.writeCollection((Set<?>) v, StreamOutput::writeGenericValue);\n-                    }\n+                    }),\n+            entry(\n+                // TODO: improve serialization of BigInteger\n+                BigInteger.class,\n+                (o, v) -> {\n+                    o.writeByte((byte) 26);\n+                    o.writeString(v.toString());\n+                }", "originalCommit": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2NjI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485166263", "bodyText": "Addressed in 9e057c0", "author": "mayya-sharipova", "createdAt": "2020-09-08T20:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjQzOA=="}], "type": "inlineReview", "revised_code": {"commit": "9e057c08334d30f489903b452ff7d81142541866", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java b/server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java\nindex 0c88ee22b73..bb72b4ec619 100644\n--- a/server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java\n+++ b/server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java\n\n@@ -829,12 +829,12 @@ public abstract class StreamOutput extends OutputStream {\n                         o.writeCollection((Set<?>) v, StreamOutput::writeGenericValue);\n                     }),\n             entry(\n-                // TODO: improve serialization of BigInteger\n-                BigInteger.class,\n-                (o, v) -> {\n-                    o.writeByte((byte) 26);\n-                    o.writeString(v.toString());\n-                }\n+                    // TODO: improve serialization of BigInteger\n+                    BigInteger.class,\n+                    (o, v) -> {\n+                        o.writeByte((byte) 26);\n+                        o.writeString(v.toString());\n+                    }\n             ));\n \n     private static Class<?> getGenericType(Object value) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r484350098", "bodyText": "We'd need to provide the doc value format but that could be done in the ScriptDocValues.Long directly ?", "author": "jimczi", "createdAt": "2020-09-07T10:42:23Z", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.ArrayUtil;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+\n+public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n+    private final SortedNumericDocValues in;\n+    private Number[] values = new Number[0];\n+    private int count;\n+\n+    /**\n+     * Standard constructor.\n+     */\n+    public UnsignedLongScriptDocValues(SortedNumericDocValues in) {\n+        this.in = in;\n+    }\n+\n+    @Override\n+    public void setNextDocId(int docId) throws IOException {\n+        if (in.advanceExact(docId)) {\n+            resize(in.docValueCount());\n+            for (int i = 0; i < count; i++) {\n+                values[i] = (Number) DocValueFormat.UNSIGNED_LONG_SHIFTED.format(in.nextValue());", "originalCommit": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2MDU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485160563", "bodyText": "@jimczi  Thanks for the feedback. I am not very clear what you are suggesting here. Are you suggesting to use ScriptDocValues.Longs instead of creating a new class?   If yes, I have opted to create a new class, as ScriptDocValues.Longs hold values in a array  long[] values, while we need an array of Number[] values as sometimes produced values can be of type long and other times of type BigInteger.", "author": "mayya-sharipova", "createdAt": "2020-09-08T19:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2ODc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485168784", "bodyText": "So today ScriptDocValues.Long returns a Long but it could return a Number instead and rely on a provided doc values format to do the conversion to a number. In the normal case we would conver to a Long but if the provided doc values format is the unsigned_long then it can also return a BigInteger in some cases.\nI am not sure it's a good idea so feel free to keep the code separated if you prefer. In any case I don't think we need to rely on a Number[] array. We can store the unsigned long in a plain long[] array and do the conversion to Number lazily when getValue or get(int) are called.", "author": "jimczi", "createdAt": "2020-09-08T20:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NTUxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485895519", "bodyText": "@jimczi  Thanks Jim, this is a good idea. I explored using Longs but it turned out it involves more modifications as Longs::getValue expects long.  Instead, I followed your 2nd idea to used long[] for values in UnsignedLongScriptDocValues.java   and this is addressed in 2b567c9.", "author": "mayya-sharipova", "createdAt": "2020-09-09T20:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2OTY1MA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r486169650", "bodyText": "++, thanks", "author": "jimczi", "createdAt": "2020-09-10T08:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1MDA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "chunk": "diff --git a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java\nindex 7b6e3329769..680033d078a 100644\n--- a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java\n+++ b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongScriptDocValues.java\n\n@@ -15,7 +15,7 @@ import java.io.IOException;\n \n public class UnsignedLongScriptDocValues extends ScriptDocValues<Number> {\n     private final SortedNumericDocValues in;\n-    private Number[] values = new Number[0];\n+    private long[] values = new long[0];\n     private int count;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485030254", "bodyText": "I didn't review this logic in detail, but I was curious if we considered having this extend NumberFieldType ?", "author": "jtibshirani", "createdAt": "2020-09-08T15:58:25Z", "path": "x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.unsignedlong;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.exc.InputCoercionException;\n+import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.FieldType;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.SortedNumericDocValuesField;\n+import org.apache.lucene.index.IndexOptions;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.BoostQuery;\n+import org.apache.lucene.search.DocValuesFieldExistsQuery;\n+import org.apache.lucene.search.IndexOrDocValuesQuery;\n+import org.apache.lucene.search.IndexSortSortedNumericDocValuesRangeQuery;\n+import org.apache.lucene.search.MatchNoDocsQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.common.Explicit;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.support.XContentMapValues;\n+import org.elasticsearch.index.fielddata.IndexFieldData;\n+import org.elasticsearch.index.fielddata.IndexNumericFieldData;\n+import org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\n+import org.elasticsearch.index.mapper.FieldMapper;\n+import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n+import org.elasticsearch.index.mapper.Mapper;\n+import org.elasticsearch.index.mapper.MapperParsingException;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.index.mapper.ParseContext;\n+import org.elasticsearch.index.mapper.SimpleMappedFieldType;\n+import org.elasticsearch.index.mapper.TextSearchInfo;\n+import org.elasticsearch.index.mapper.TypeParsers;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.search.DocValueFormat;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+public class UnsignedLongFieldMapper extends FieldMapper {\n+    protected static long MASK_2_63 = 0x8000000000000000L;\n+    private static BigInteger BIGINTEGER_2_64_MINUS_ONE = BigInteger.ONE.shiftLeft(64).subtract(BigInteger.ONE); // 2^64 -1\n+    private static BigDecimal BIGDECIMAL_2_64_MINUS_ONE = new BigDecimal(BIGINTEGER_2_64_MINUS_ONE);\n+\n+    public static final String CONTENT_TYPE = \"unsigned_long\";\n+    // use the same default as numbers\n+    private static final FieldType FIELD_TYPE = new FieldType();\n+    static {\n+        FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);\n+    }\n+\n+    public static class Builder extends FieldMapper.Builder<Builder> {\n+\n+        private Boolean ignoreMalformed;\n+        private String nullValue;\n+\n+        public Builder(String name) {\n+            super(name, FIELD_TYPE);\n+            builder = this;\n+        }\n+\n+        public Builder ignoreMalformed(boolean ignoreMalformed) {\n+            this.ignoreMalformed = ignoreMalformed;\n+            return builder;\n+        }\n+\n+        @Override\n+        public Builder indexOptions(IndexOptions indexOptions) {\n+            throw new MapperParsingException(\"index_options not allowed in field [\" + name + \"] of type [\" + CONTENT_TYPE + \"]\");\n+        }\n+\n+        protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {\n+            if (ignoreMalformed != null) {\n+                return new Explicit<>(ignoreMalformed, true);\n+            }\n+            if (context.indexSettings() != null) {\n+                return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false);\n+            }\n+            return NumberFieldMapper.Defaults.IGNORE_MALFORMED;\n+        }\n+\n+        public Builder nullValue(String nullValue) {\n+            this.nullValue = nullValue;\n+            return this;\n+        }\n+\n+        @Override\n+        public UnsignedLongFieldMapper build(BuilderContext context) {\n+            UnsignedLongFieldType type = new UnsignedLongFieldType(buildFullName(context), indexed, hasDocValues, meta);\n+            return new UnsignedLongFieldMapper(\n+                name,\n+                fieldType,\n+                type,\n+                ignoreMalformed(context),\n+                multiFieldsBuilder.build(this, context),\n+                copyTo,\n+                nullValue\n+            );\n+        }\n+    }\n+\n+    public static class TypeParser implements Mapper.TypeParser {\n+        @Override\n+        public Mapper.Builder<?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n+            Builder builder = new Builder(name);\n+            TypeParsers.parseField(builder, name, node, parserContext);\n+            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry<String, Object> entry = iterator.next();\n+                String propName = entry.getKey();\n+                Object propNode = entry.getValue();\n+                if (propName.equals(\"null_value\")) {\n+                    if (propNode == null) {\n+                        throw new MapperParsingException(\"Property [null_value] cannot be null.\");\n+                    }\n+                    parseUnsignedLong(propNode); // confirm that null_value is a proper unsigned_long\n+                    String nullValue = (propNode instanceof BytesRef) ? ((BytesRef) propNode).utf8ToString() : propNode.toString();\n+                    builder.nullValue(nullValue);\n+                    iterator.remove();\n+                } else if (propName.equals(\"ignore_malformed\")) {\n+                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + \".ignore_malformed\"));\n+                    iterator.remove();\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+\n+    public static final class UnsignedLongFieldType extends SimpleMappedFieldType {", "originalCommit": "e903940c82c2e9e494465f5a1e8633b1bd834d53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2ODI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485168263", "bodyText": "@jtibshirani Thanks for the feedback, it did not make sense for me to extend NumberFieldType as logic for almost every query needs to be overwritten.", "author": "mayya-sharipova", "createdAt": "2020-09-08T20:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzYyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r485183629", "bodyText": "Thanks for the explanation.", "author": "jtibshirani", "createdAt": "2020-09-08T20:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzMDI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "chunk": "diff --git a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\nindex b332d1660a1..8ae29396f2c 100644\n--- a/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n+++ b/x-pack/plugin/mapper-unsigned-long/src/main/java/org/elasticsearch/xpack/unsignedlong/UnsignedLongFieldMapper.java\n\n@@ -8,11 +8,8 @@ package org.elasticsearch.xpack.unsignedlong;\n \n import com.fasterxml.jackson.core.JsonParseException;\n import com.fasterxml.jackson.core.exc.InputCoercionException;\n-import org.apache.lucene.document.Field;\n-import org.apache.lucene.document.FieldType;\n import org.apache.lucene.document.LongPoint;\n import org.apache.lucene.document.SortedNumericDocValuesField;\n-import org.apache.lucene.index.IndexOptions;\n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.BoostQuery;\n import org.apache.lucene.search.DocValuesFieldExistsQuery;\n"}}, {"oid": "9e057c08334d30f489903b452ff7d81142541866", "url": "https://github.com/elastic/elasticsearch/commit/9e057c08334d30f489903b452ff7d81142541866", "message": "Address Jim's feedback", "committedDate": "2020-09-08T20:00:04Z", "type": "commit"}, {"oid": "ab54a23fee318cc4827c2e8446949fc01035d3ad", "url": "https://github.com/elastic/elasticsearch/commit/ab54a23fee318cc4827c2e8446949fc01035d3ad", "message": "Include unsigned_long docs into numeric type", "committedDate": "2020-09-08T20:28:04Z", "type": "commit"}, {"oid": "4de3bd06e560d791ac7a561076f6ec195f7b9bb5", "url": "https://github.com/elastic/elasticsearch/commit/4de3bd06e560d791ac7a561076f6ec195f7b9bb5", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer", "committedDate": "2020-09-08T20:36:49Z", "type": "commit"}, {"oid": "2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "url": "https://github.com/elastic/elasticsearch/commit/2b567c961f4dc9331ef7eef25c4c9c8b271a67c8", "message": "Convert UnsignedLongFieldMapper to parametrized\n\n- Convert UnsignedLongFieldMapper to a parametrized form\n- Small adjustments in UnsignedLongScriptDocValues", "committedDate": "2020-09-09T20:05:57Z", "type": "commit"}, {"oid": "07470b5006ed3aac8a635a2953424f635ccd46c0", "url": "https://github.com/elastic/elasticsearch/commit/07470b5006ed3aac8a635a2953424f635ccd46c0", "message": "Small edits in documentation", "committedDate": "2020-09-10T13:55:18Z", "type": "commit"}, {"oid": "17912bc0549aaa275099513383517517c02dc7f9", "url": "https://github.com/elastic/elasticsearch/commit/17912bc0549aaa275099513383517517c02dc7f9", "message": "Address Julie's comment on documentation", "committedDate": "2020-09-16T14:25:35Z", "type": "commit"}, {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b", "url": "https://github.com/elastic/elasticsearch/commit/b2eef4c4ca9997dddface371cfad3b1671fd438b", "message": "Add check that unsigned_long field type can't be sorted with other types", "committedDate": "2020-09-16T19:45:27Z", "type": "commit"}, {"oid": "b2eef4c4ca9997dddface371cfad3b1671fd438b", "url": "https://github.com/elastic/elasticsearch/commit/b2eef4c4ca9997dddface371cfad3b1671fd438b", "message": "Add check that unsigned_long field type can't be sorted with other types", "committedDate": "2020-09-16T19:45:27Z", "type": "forcePushed"}, {"oid": "b315a0fa32ba32ccab8cc6dec9337811ad242569", "url": "https://github.com/elastic/elasticsearch/commit/b315a0fa32ba32ccab8cc6dec9337811ad242569", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer", "committedDate": "2020-09-16T20:24:39Z", "type": "commit"}, {"oid": "7652e6671ce385c670231cc15292500311a8a785", "url": "https://github.com/elastic/elasticsearch/commit/7652e6671ce385c670231cc15292500311a8a785", "message": "Fix build and test failures", "committedDate": "2020-09-16T20:48:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489754889", "bodyText": "Checking my understanding -- are all shards guaranteed to have the same number of sort formats (even if some sort fields are unmapped)?", "author": "jtibshirani", "createdAt": "2020-09-16T21:07:44Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n+     */\n+    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+        boolean[] ulFormats = null;\n+        boolean firstResult = true;\n+        for (SearchPhaseResult entry : queryResults) {\n+            DocValueFormat[] formats = entry.queryResult().sortValueFormats();\n+            if (formats == null) return;", "originalCommit": "b2eef4c4ca9997dddface371cfad3b1671fd438b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NzEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r490147120", "bodyText": "@jtibshirani Indeed, all shards are guaranteed to have the same number of sort formats. If a field is unmapped on a shard, we will get a shard failure, unless we specifically map an unmapped field to something else.", "author": "mayya-sharipova", "createdAt": "2020-09-17T10:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0ODEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r490148100", "bodyText": "Also wondering if @jimczi is ok with this final check I've added in SearchPhaseController", "author": "mayya-sharipova", "createdAt": "2020-09-17T10:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r492321713", "bodyText": "++, that makes sense to me. You can maybe rename the function validateMergeSortValueFormats or something along those lines ?", "author": "jimczi", "createdAt": "2020-09-21T20:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NDg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "24cbe55162a29463c22de9815187b7e48fc65844", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\nindex 3bdb53d0929..92c4ff0bdcf 100644\n--- a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n+++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n\n@@ -492,7 +492,7 @@ public final class SearchPhaseController {\n      * don't work correctly. Throw an error if this kind of sorting is detected.\n      * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n      */\n-    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+    private static void validateMergeSortValueFormats(Collection<? extends SearchPhaseResult> queryResults) {\n         boolean[] ulFormats = null;\n         boolean firstResult = true;\n         for (SearchPhaseResult entry : queryResults) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3NzM5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/60050#discussion_r489777397", "bodyText": "This TODO makes sense. It's unfortunate that we need to do a special check here, but it feels worth it to me to avoid silently returning incorrect results.", "author": "jtibshirani", "createdAt": "2020-09-16T21:57:07Z", "path": "server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java", "diffHunk": "@@ -485,6 +486,36 @@ private static InternalAggregations reduceAggs(InternalAggregation.ReduceContext\n             performFinalReduce ? aggReduceContextBuilder.forFinalReduction() : aggReduceContextBuilder.forPartialReduction());\n     }\n \n+    /**\n+     * Checks that query results from all shards have consistent unsigned_long format.\n+     * Sort queries on a field that has long type in one index, and unsigned_long in another index\n+     * don't work correctly. Throw an error if this kind of sorting is detected.\n+     * //TODO: instead of throwing error, find a way to sort long and unsigned_long together", "originalCommit": "7652e6671ce385c670231cc15292500311a8a785", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "24cbe55162a29463c22de9815187b7e48fc65844", "chunk": "diff --git a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\nindex 3bdb53d0929..92c4ff0bdcf 100644\n--- a/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n+++ b/server/src/main/java/org/elasticsearch/action/search/SearchPhaseController.java\n\n@@ -492,7 +492,7 @@ public final class SearchPhaseController {\n      * don't work correctly. Throw an error if this kind of sorting is detected.\n      * //TODO: instead of throwing error, find a way to sort long and unsigned_long together\n      */\n-    private static void checkSameUnsignedLongSortFormat(Collection<? extends SearchPhaseResult> queryResults) {\n+    private static void validateMergeSortValueFormats(Collection<? extends SearchPhaseResult> queryResults) {\n         boolean[] ulFormats = null;\n         boolean firstResult = true;\n         for (SearchPhaseResult entry : queryResults) {\n"}}, {"oid": "0508e700e0c57b42086e8baeae57a4fecaa32653", "url": "https://github.com/elastic/elasticsearch/commit/0508e700e0c57b42086e8baeae57a4fecaa32653", "message": "Merge remote-tracking branch 'upstream/master' into unsigned64bits_integer", "committedDate": "2020-09-23T14:32:12Z", "type": "commit"}, {"oid": "24cbe55162a29463c22de9815187b7e48fc65844", "url": "https://github.com/elastic/elasticsearch/commit/24cbe55162a29463c22de9815187b7e48fc65844", "message": "Rename the method for validating consistency of merge formats", "committedDate": "2020-09-23T14:37:23Z", "type": "commit"}, {"oid": "cca6b30e1d47295497fc1a34d2ca94881a62317d", "url": "https://github.com/elastic/elasticsearch/commit/cca6b30e1d47295497fc1a34d2ca94881a62317d", "message": "Change unsigned_long mapper based on recent master changes", "committedDate": "2020-09-23T15:10:52Z", "type": "commit"}]}