{"pr_number": 739, "pr_title": "PLANNER-1929 Constraint Verifier properly supports match weights", "pr_createdAt": "2020-04-09T09:28:18Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/739", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3ODU1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406078559", "bodyText": "Public API change.\nThis is a default method, so that the interface remains 100 % backwards compatible.", "author": "triceo", "createdAt": "2020-04-09T09:32:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java", "diffHunk": "@@ -102,6 +102,22 @@\n      */\n     Score_ divide(double divisor);\n \n+    /**\n+     * Return a Score whose every level is a result of dividing the matching levels in this and the divisor.\n+     * When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\n+     * <p>\n+     * If the implementation has a scale/precision, then the unspecified scale/precision of the double divisor\n+     * should have no impact on the returned scale/precision.\n+     * <p>\n+     * Allows division by zero if and only if both levels are zero, in which case the resulting level will also be zero.\n+     * Otherwise {@link ArithmeticException} is thrown.\n+     * @param divisor value by which this Score is to be divided\n+     * @return this / divisor\n+     */\n+    default Score_ divide(Score_ divisor) {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "c76a95d9d3bac1f0f4b477d0534b25491254f647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java\nindex b16c72b6e..3bcb53560 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java\n\n@@ -102,22 +102,6 @@ public interface Score<Score_ extends Score> extends Comparable<Score_> {\n      */\n     Score_ divide(double divisor);\n \n-    /**\n-     * Return a Score whose every level is a result of dividing the matching levels in this and the divisor.\n-     * When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\n-     * <p>\n-     * If the implementation has a scale/precision, then the unspecified scale/precision of the double divisor\n-     * should have no impact on the returned scale/precision.\n-     * <p>\n-     * Allows division by zero if and only if both levels are zero, in which case the resulting level will also be zero.\n-     * Otherwise {@link ArithmeticException} is thrown.\n-     * @param divisor value by which this Score is to be divided\n-     * @return this / divisor\n-     */\n-    default Score_ divide(Score_ divisor) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     /**\n      * Returns a Score whose value is (this ^ exponent).\n      * When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NDE2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406164165", "bodyText": "Soft suggestion: The empty string should be a named constant.", "author": "yurloc", "createdAt": "2020-04-09T12:20:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java", "diffHunk": "@@ -133,11 +133,18 @@ public SimpleScore multiply(double multiplicand) {\n \n     @Override\n     public SimpleScore divide(double divisor) {\n-        return new SimpleScore(\n-                (int) Math.floor(initScore / divisor),\n+        int newInitScore = divideInitScore(divisor);\n+        return ofUninitialized(newInitScore,\n                 (int) Math.floor(score / divisor));\n     }\n \n+    @Override\n+    public SimpleScore divide(SimpleScore divisor) {\n+        int newInitScore = divideInitScore(divisor.initScore);\n+        int newScore = divideScoreLevel(score, divisor.score, \"\");", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java\nindex e99f2fd99..d3e627c95 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java\n\n@@ -133,18 +133,11 @@ public final class SimpleScore extends AbstractScore<SimpleScore> {\n \n     @Override\n     public SimpleScore divide(double divisor) {\n-        int newInitScore = divideInitScore(divisor);\n-        return ofUninitialized(newInitScore,\n+        return new SimpleScore(\n+                (int) Math.floor(initScore / divisor),\n                 (int) Math.floor(score / divisor));\n     }\n \n-    @Override\n-    public SimpleScore divide(SimpleScore divisor) {\n-        int newInitScore = divideInitScore(divisor.initScore);\n-        int newScore = divideScoreLevel(score, divisor.score, \"\");\n-        return ofUninitialized(newInitScore, newScore);\n-    }\n-\n     @Override\n     public SimpleScore power(double exponent) {\n         return new SimpleScore(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3Mjg5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406172891", "bodyText": "Given that s is a ConstraintMatchTotal the variable name seems a bit arbitrary. Is it a mistake?", "author": "yurloc", "createdAt": "2020-04-09T12:36:49Z", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "chunk": "diff --git a/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java b/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\nindex 927db3b9e..e6854ecdd 100644\n--- a/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\n+++ b/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\n\n@@ -36,32 +38,38 @@ public final class SingleConstraintAssertion<Solution_> extends AbstractAssertio\n \n     private final Map<String, ConstraintMatchTotal> constraintMatchTotalMap;\n \n-    SingleConstraintAssertion(SingleConstraintVerifier<Solution_> singleConstraintVerifier,\n+    protected SingleConstraintAssertion(SingleConstraintVerifier<Solution_> singleConstraintVerifier,\n             Map<String, ConstraintMatchTotal> constraintMatchTotalMap) {\n         super(singleConstraintVerifier);\n         this.constraintMatchTotalMap = Collections.unmodifiableMap(constraintMatchTotalMap);\n     }\n \n     private Number getImpact() {\n-        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n-                .getScoreDefinition()\n-                .getZeroScore();\n+        ScoreDefinition scoreDefinition = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition();\n+        Score zeroScore = scoreDefinition.getZeroScore();\n+        Number zero = zeroScore.toLevelNumbers()[0]; // Zero in the exact numeric type expected by the caller.\n         if (constraintMatchTotalMap.isEmpty()) {\n-            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+            return zero;\n         }\n         // We do not know the matchWeight, so we need to deduce it.\n         // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n         // Here, we strip the constraintWeight.\n-        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n-                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n-                .reduce(zero, Score::add);\n+        Score totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(matchScore -> scoreDefinition.divideBySanitizedDivisor(matchScore.getScore(),\n+                        matchScore.getConstraintWeight()))\n+                .reduce(zeroScore, Score::add);\n         // Each level of the resulting score now has to be the same number, the matchWeight.\n+        // Except for where the number is zero.\n         List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n                 .distinct()\n+                .filter(matchWeight -> !Objects.equals(matchWeight, zero))\n                 .collect(Collectors.toList());\n-        if (matchWeightsFound.size() != 1) {\n-            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n-                    + matchWeightsFound + \").\");\n+        if (matchWeightsFound.isEmpty()) {\n+            return 0;\n+        } else if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Impossible state: expecting at most one match weight,\" +\n+                    \" but got matchWeightsFound (\" + matchWeightsFound + \") instead.\");\n         }\n         return matchWeightsFound.get(0);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406176047", "bodyText": "IIUC, what this does is that it fails fast if the constraint impacts different score levels with different weights, so -5medium/-5soft is valid but -1medium/-2soft fails here. Is that correct?", "author": "yurloc", "createdAt": "2020-04-09T12:42:39Z", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3OTU0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406179547", "bodyText": "If yes, why there is such restriction? Maybe there's a technical limitation related to how Constraint Streams are implemented, that is obvious to you but it makes me ask this question. Maybe it's a general OptaPlanner limitation.\nPlease consider leaving a short explanation in the source code comment if you think that kind of information would be relevant here.", "author": "yurloc", "createdAt": "2020-04-09T12:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0MDg2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406240865", "bodyText": "The score here is matchWeight * constraintWeight * matchCount.\nAt this point, I have already divided by it constraintWeight.\nWhat remains is therefore matchWeight * matchCount. And therefore the value in every level of the score must be the same.\nI believe there already is an explanatory comment in the code.\n(That said, you correctly point out a bug in case where one level of the score is 0. Fixing that.)", "author": "triceo", "createdAt": "2020-04-09T14:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0NDYxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406244619", "bodyText": "For example, consider .penalize(\"something\", HardSoftScore.of(1, 2), something -> 2).\nAssume that this penalty is only applied once. In this case:\n\nmatchCount = 1\nmatchWeight = 2\nconstraintWeight = 1hard/2soft\n\nAnd therefore, from the end:\n\nconstraintMatchScore = -2hard/-4soft\nconstraintMatchScore / constraintWeight = -2hard/-2soft\nmatchWeightsFound = [-2]\nresult = -2", "author": "triceo", "createdAt": "2020-04-09T14:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MjUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406272518", "bodyText": "Beautiful explanation, thanks! Now it makes perfect sense.", "author": "yurloc", "createdAt": "2020-04-09T15:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "chunk": "diff --git a/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java b/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\nindex 927db3b9e..e6854ecdd 100644\n--- a/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\n+++ b/optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java\n\n@@ -36,32 +38,38 @@ public final class SingleConstraintAssertion<Solution_> extends AbstractAssertio\n \n     private final Map<String, ConstraintMatchTotal> constraintMatchTotalMap;\n \n-    SingleConstraintAssertion(SingleConstraintVerifier<Solution_> singleConstraintVerifier,\n+    protected SingleConstraintAssertion(SingleConstraintVerifier<Solution_> singleConstraintVerifier,\n             Map<String, ConstraintMatchTotal> constraintMatchTotalMap) {\n         super(singleConstraintVerifier);\n         this.constraintMatchTotalMap = Collections.unmodifiableMap(constraintMatchTotalMap);\n     }\n \n     private Number getImpact() {\n-        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n-                .getScoreDefinition()\n-                .getZeroScore();\n+        ScoreDefinition scoreDefinition = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition();\n+        Score zeroScore = scoreDefinition.getZeroScore();\n+        Number zero = zeroScore.toLevelNumbers()[0]; // Zero in the exact numeric type expected by the caller.\n         if (constraintMatchTotalMap.isEmpty()) {\n-            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+            return zero;\n         }\n         // We do not know the matchWeight, so we need to deduce it.\n         // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n         // Here, we strip the constraintWeight.\n-        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n-                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n-                .reduce(zero, Score::add);\n+        Score totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(matchScore -> scoreDefinition.divideBySanitizedDivisor(matchScore.getScore(),\n+                        matchScore.getConstraintWeight()))\n+                .reduce(zeroScore, Score::add);\n         // Each level of the resulting score now has to be the same number, the matchWeight.\n+        // Except for where the number is zero.\n         List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n                 .distinct()\n+                .filter(matchWeight -> !Objects.equals(matchWeight, zero))\n                 .collect(Collectors.toList());\n-        if (matchWeightsFound.size() != 1) {\n-            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n-                    + matchWeightsFound + \").\");\n+        if (matchWeightsFound.isEmpty()) {\n+            return 0;\n+        } else if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Impossible state: expecting at most one match weight,\" +\n+                    \" but got matchWeightsFound (\" + matchWeightsFound + \") instead.\");\n         }\n         return matchWeightsFound.get(0);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406281372", "bodyText": "Nitpicking: You have just moved one instance of SimpleScore's label to another place. What I was pointing out is that \"\" is the score label of SimpleScore and I noticed the the string literal (\"\") is used multiple times in the SimpleScore class and therefore should be replaced by a constant (provided that all \"\" occurrences have the same meaning, which I presume they do).\nIn another words, what would happen if we decided that SimpleScore will get a new label of simp? We would replace two \"\" occurrences in SimpleScore with \"simp\" and we would probably miss this instance (on line 43).", "author": "yurloc", "createdAt": "2020-04-09T15:18:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -34,6 +35,74 @@\n \n     protected static final String INIT_LABEL = \"init\";\n \n+    protected static int divideScoreLevel(int score, int scoreDivisor) {\n+        return divideScoreLevel(score, scoreDivisor, null);\n+    }\n+\n+    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n+        String label = maybeLabel == null ? \"\" : maybeLabel;", "originalCommit": "9e34cde34bd022aa74eaade7f8a453b870f2992c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mzk2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406283965", "bodyText": "What would happen is that the exception message would continue to say \"X\" instead of \"Xsimp\".\nI really don't consider this a problem - it was a problem before, where I was propagating something that should have been a constant. I don't anymore.", "author": "triceo", "createdAt": "2020-04-09T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NjYyOA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406286628", "bodyText": "OK, that's another, valid point of view that I didn't think of.", "author": "yurloc", "createdAt": "2020-04-09T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java\nindex 66fa732c3..068f42022 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java\n\n@@ -35,74 +34,6 @@ public abstract class AbstractScore<S extends Score> implements Score<S>, Serial\n \n     protected static final String INIT_LABEL = \"init\";\n \n-    protected static int divideScoreLevel(int score, int scoreDivisor) {\n-        return divideScoreLevel(score, scoreDivisor, null);\n-    }\n-\n-    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n-        String label = maybeLabel == null ? \"\" : maybeLabel;\n-        if (scoreDivisor == 0) {\n-            if (score == 0) {\n-                return 0;\n-            } else {\n-                throw new ArithmeticException(\"Can not divide \" + score + label + \" by \" + scoreDivisor + label + \".\");\n-            }\n-        } else {\n-            return (int) Math.floor(score / (double) scoreDivisor);\n-        }\n-    }\n-\n-    protected static long divideScoreLevel(long score, long scoreDivisor) {\n-        return divideScoreLevel(score, scoreDivisor, null);\n-    }\n-\n-    protected static long divideScoreLevel(long score, long scoreDivisor, String maybeLabel) {\n-        String label = maybeLabel == null ? \"\" : maybeLabel;\n-        if (scoreDivisor == 0L) {\n-            if (score == 0L) {\n-                return 0L;\n-            } else {\n-                throw new ArithmeticException(\"Can not divide \" + score + label + \" by \" + scoreDivisor + label + \".\");\n-            }\n-        } else {\n-            return (long) Math.floor(score / (double) scoreDivisor);\n-        }\n-    }\n-\n-    protected static double divideScoreLevel(double score, double scoreDivisor) {\n-        return divideScoreLevel(score, scoreDivisor, null);\n-    }\n-\n-    protected static double divideScoreLevel(double score, double scoreDivisor, String maybeLabel) {\n-        String label = maybeLabel == null ? \"\" : maybeLabel;\n-        if (scoreDivisor == 0d) {\n-            if (score == 0d) {\n-                return 0d;\n-            } else {\n-                throw new ArithmeticException(\"Can not divide \" + score + label + \" by \" + scoreDivisor + label + \".\");\n-            }\n-        } else {\n-            return Math.floor(score / scoreDivisor);\n-        }\n-    }\n-\n-    protected static BigDecimal divideScoreLevel(BigDecimal score, BigDecimal scoreDivisor) {\n-        return divideScoreLevel(score, scoreDivisor, null);\n-    }\n-\n-    protected static BigDecimal divideScoreLevel(BigDecimal score, BigDecimal scoreDivisor, String maybeLabel) {\n-        String label = maybeLabel == null ? \"\" : maybeLabel;\n-        if (scoreDivisor.signum() == 0) {\n-            if (score.signum() == 0) {\n-                return BigDecimal.ZERO;\n-            } else {\n-                throw new ArithmeticException(\"Can not divide \" + score + label + \" by \" + scoreDivisor + label + \".\");\n-            }\n-        } else {\n-            return score.divide(scoreDivisor, score.scale(), RoundingMode.FLOOR);\n-        }\n-    }\n-\n     protected static String[] parseScoreTokens(Class<? extends Score> scoreClass,\n             String scoreString, String... levelSuffixes) {\n         String[] scoreTokens = new String[levelSuffixes.length + 1];\n"}}, {"oid": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "url": "https://github.com/kiegroup/optaplanner/commit/09b1611ae17b63f7989eedb4449fdd413b924ca7", "message": "Merge changes without updates to the API", "committedDate": "2020-04-11T14:28:04Z", "type": "commit"}, {"oid": "b2d1402f2f62f67a70bb7eb229d9898de13736fd", "url": "https://github.com/kiegroup/optaplanner/commit/b2d1402f2f62f67a70bb7eb229d9898de13736fd", "message": "Add new method to the score definition", "committedDate": "2020-04-11T14:59:29Z", "type": "commit"}, {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "url": "https://github.com/kiegroup/optaplanner/commit/5ff0ca627a218c3ac46d81947893f9c9d79e566e", "message": "Add tests", "committedDate": "2020-04-11T15:35:12Z", "type": "commit"}, {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "url": "https://github.com/kiegroup/optaplanner/commit/5ff0ca627a218c3ac46d81947893f9c9d79e566e", "message": "Add tests", "committedDate": "2020-04-11T15:35:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407077890", "bodyText": "My spider sense is tingling, expecting comments here.\nSee table \"Preferred Scales for Results of Arithmetic Operations\" in BigDecimal Javadoc.", "author": "triceo", "createdAt": "2020-04-11T15:39:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/AbstractScoreDefinition.java", "diffHunk": "@@ -30,6 +32,38 @@\n \n     private final String[] levelLabels;\n \n+    protected static int sanitize(int number) {\n+        return number == 0 ? 1 : number;\n+    }\n+\n+    protected static long sanitize(long number) {\n+        return number == 0L ? 1L : number;\n+    }\n+\n+    protected static double sanitize(double number) {\n+        return number == 0d ? 1d : number;\n+    }\n+\n+    protected static BigDecimal sanitize(BigDecimal number) {\n+        return number.signum() == 0 ? BigDecimal.ONE : number;\n+    }\n+\n+    protected static int divide(int dividend, int divisor) {\n+        return (int) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static long divide(long dividend, long divisor) {\n+        return (long) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static double divide(double dividend, double divisor) {\n+        return dividend / divisor;\n+    }\n+\n+    protected static BigDecimal divide(BigDecimal dividend, BigDecimal divisor) {\n+        return dividend.divide(divisor, dividend.scale() - divisor.scale(), RoundingMode.FLOOR);", "originalCommit": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODY4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078680", "bodyText": "This is fine. Our long existing method Score.divide(boolean) has a javadoc that says \"When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\" This is consistent with that.", "author": "ge0ffrey", "createdAt": "2020-04-11T15:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "url": "https://github.com/kiegroup/optaplanner/commit/d65e206b977f4cf50dc636d1c7e3c84e7579f439", "message": "Fix Revapi", "committedDate": "2020-04-11T15:41:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODcyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078721", "bodyText": "javadoc link to Score", "author": "ge0ffrey", "createdAt": "2020-04-11T15:47:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java", "diffHunk": "@@ -152,4 +152,14 @@ default boolean isNegativeOrZero(S score) {\n      */\n     S buildPessimisticBound(InitializingScoreTrend initializingScoreTrend, S score);\n \n+    /**\n+     * Return a Score whose every level is the result of dividing the matching levels in this and the divisor.", "originalCommit": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "74ebcb264f357f568eca02399b3164ea11bdbf1b", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java\nindex 62294f177..329e57121 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java\n\n@@ -153,7 +153,7 @@ public interface ScoreDefinition<S extends Score<S>> {\n     S buildPessimisticBound(InitializingScoreTrend initializingScoreTrend, S score);\n \n     /**\n-     * Return a Score whose every level is the result of dividing the matching levels in this and the divisor.\n+     * Return {@link Score} whose every level is the result of dividing the matching levels in this and the divisor.\n      * When rounding is needed, it is floored (as defined by {@link Math#floor(double)}).\n      * <p>\n      * If any of the levels in the divisor are equal to zero, the method behaves as if they were equal to one instead.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODc4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078789", "bodyText": "Did the buildPessimisticBoundOnlyDown() test get removed?", "author": "ge0ffrey", "createdAt": "2020-04-11T15:48:07Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java", "diffHunk": "@@ -89,14 +89,18 @@ public void buildPessimisticBoundOnlyUp() {\n     }\n \n     @Test\n-    public void buildPessimisticBoundOnlyDown() {\n+    public void divideBySanitizedDivisor() {", "originalCommit": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "74ebcb264f357f568eca02399b3164ea11bdbf1b", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java\nindex bfa8c9795..e52dd5c58 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java\n\n@@ -88,6 +88,17 @@ public class HardSoftScoreDefinitionTest extends AbstractScoreDefinitionTest {\n         assertEquals(-2, pessimisticBound.getSoftScore());\n     }\n \n+    @Test\n+    public void buildPessimisticBoundOnlyDown() {\n+        HardSoftScoreDefinition scoreDefinition = new HardSoftScoreDefinition();\n+        HardSoftScore pessimisticBound = scoreDefinition.buildPessimisticBound(\n+                InitializingScoreTrend.buildUniformTrend(InitializingScoreTrendLevel.ONLY_DOWN, 2),\n+                HardSoftScore.of(-1, -2));\n+        assertEquals(0, pessimisticBound.getInitScore());\n+        assertEquals(Integer.MIN_VALUE, pessimisticBound.getHardScore());\n+        assertEquals(Integer.MIN_VALUE, pessimisticBound.getSoftScore());\n+    }\n+\n     @Test\n     public void divideBySanitizedDivisor() {\n         HardSoftScoreDefinition scoreDefinition = new HardSoftScoreDefinition();\n"}}, {"oid": "74ebcb264f357f568eca02399b3164ea11bdbf1b", "url": "https://github.com/kiegroup/optaplanner/commit/74ebcb264f357f568eca02399b3164ea11bdbf1b", "message": "Address review comments", "committedDate": "2020-04-11T15:51:59Z", "type": "commit"}]}