{"pr_number": 692, "pr_title": "PLANNER-1850 Add min/max collectors for streams of higher cardinality", "pr_createdAt": "2020-02-17T09:44:31Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/692", "timeline": [{"oid": "5f4052966706199b02dbe0d85240dcbee791fc91", "url": "https://github.com/kiegroup/optaplanner/commit/5f4052966706199b02dbe0d85240dcbee791fc91", "message": "Rename argument", "committedDate": "2020-02-17T08:32:11Z", "type": "commit"}, {"oid": "6c8ee4eb5491b7be8d7d4ba6c264f179a0dbeb5e", "url": "https://github.com/kiegroup/optaplanner/commit/6c8ee4eb5491b7be8d7d4ba6c264f179a0dbeb5e", "message": "mapping min/max for uni", "committedDate": "2020-02-17T09:11:51Z", "type": "commit"}, {"oid": "c4347e0ebf9a611b8276d0dcaec8ee3a2477e84a", "url": "https://github.com/kiegroup/optaplanner/commit/c4347e0ebf9a611b8276d0dcaec8ee3a2477e84a", "message": "mapping min/max for other stream cardinalities", "committedDate": "2020-02-17T09:29:37Z", "type": "commit"}, {"oid": "d2d7e6fbe1cddaced0b42a5fbf5acff21302eb52", "url": "https://github.com/kiegroup/optaplanner/commit/d2d7e6fbe1cddaced0b42a5fbf5acff21302eb52", "message": "Code reuse", "committedDate": "2020-02-17T09:43:20Z", "type": "commit"}, {"oid": "1914927f9c28ccd729de99b158ae6bf0c14f1656", "url": "https://github.com/kiegroup/optaplanner/commit/1914927f9c28ccd729de99b158ae6bf0c14f1656", "message": "Fix Javadoc formatting", "committedDate": "2020-02-17T09:46:34Z", "type": "commit"}, {"oid": "78f4d7c477ebc5c2cd20794a26c987a5c2221c6f", "url": "https://github.com/kiegroup/optaplanner/commit/78f4d7c477ebc5c2cd20794a26c987a5c2221c6f", "message": "Add a note to docs regarding equals() consistency", "committedDate": "2020-02-17T09:55:36Z", "type": "commit"}, {"oid": "e0d32f1af0475e22fcf2275277619ac0b57f8173", "url": "https://github.com/kiegroup/optaplanner/commit/e0d32f1af0475e22fcf2275277619ac0b57f8173", "message": "Add base test coverage", "committedDate": "2020-02-17T11:01:52Z", "type": "commit"}, {"oid": "af1deaa708159d5f89253affda6dd1ce255920e3", "url": "https://github.com/kiegroup/optaplanner/commit/af1deaa708159d5f89253affda6dd1ce255920e3", "message": "Finish test coverage", "committedDate": "2020-02-17T11:36:14Z", "type": "commit"}, {"oid": "735f4b99a2fba350ef25278c33a9e1de18c21441", "url": "https://github.com/kiegroup/optaplanner/commit/735f4b99a2fba350ef25278c33a9e1de18c21441", "message": "Whitespace", "committedDate": "2020-02-17T11:36:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NjM5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380146396", "bodyText": "So, fun problem...\nConstraintCollectors.min(BiFunction)\nConstraintCollectors.min(Comparator)\nThese are ambiguous, for example:\nConstraintCollectors.min((Integer a, Integer b) -> a + b);\nIDE doesn't know which one to pick.\nThis is only going to be a problem with bi-stream. tri-stream and quad-stream are fine.\nIt's also only going to be a problem for BiFunction<A, A, Integer>, as that is ambiguous with Comparator<A>.\nWhat now?\n\nWe can't remove the Comparator one, as that's old API.\nPeople could just cast to whichever they prefer, but that's ugly.\nEssentially the only solution is to rename min(BiFunction) to something like minBi(...), and that's too draconian.\n\nConsidering all of that, I don't see it as a big enough problem to warrant this fix. I'd let people solve this corner case by casting.", "author": "triceo", "createdAt": "2020-02-17T12:11:11Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,382 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *     No guarantees are made on which of the two is returned.\n+     *\n+     * @param <A> type of the matched fact\n+     * @return never null\n+     */\n+    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n+        return min(Function.identity(), Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @return never null\n+     */\n+    public static <A, Mapped extends Comparable<Mapped>> UniConstraintCollector<A, ?, Mapped> min(\n+            Function<A, Mapped> groupValueMapping) {\n+        return min(groupValueMapping, Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of elements, using the provided {@link Comparator}.\n+     * <p>\n+     *     It is expected that the {@link Comparator} is consistent with {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the comparator provided treats Person instances as equal when their age equals.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *     No guarantees are made on which of the two is returned.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param comparator never null\n+     * @return never null\n+     */\n     public static <A> UniConstraintCollector<A, ?, A> min(Comparator<A> comparator) {\n-        return minOrMax(comparator, true);\n+        return min(Function.identity(), comparator);\n     }\n \n-    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n-        return min(Comparable::compareTo);\n+    /**\n+     * Returns a collector that finds a minimum value in a group of elements, using the provided {@link Comparator}.\n+     * <p>\n+     *     It is expected that the {@link Comparator} is consistent with {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that the {@link Comparator} provided imposes the usual increasing ordering on numbers.\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @param comparator never null\n+     * @return never null\n+     */\n+    public static <A, Mapped> UniConstraintCollector<A, ?, Mapped> min(Function<A, Mapped> groupValueMapping,\n+            Comparator<Mapped> comparator) {\n+        return minOrMax(groupValueMapping, comparator, true);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following mapped elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David (age = 25), Eric (age = 20).\n+     *     Further assume that Person compares by age.\n+     *     The resulting collector returns 20, as that is the minimum age of all the elements.\n+     *\n+     * @param <A> type of the first matched fact\n+     * @param <B> type of the second matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps matched facts to the result type\n+     * @return never null\n+     */\n+    public static <A, B, Mapped extends Comparable<Mapped>> BiConstraintCollector<A, B, ?, Mapped> min(", "originalCommit": "735f4b99a2fba350ef25278c33a9e1de18c21441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODM0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380518349", "bodyText": "-1 to minBi. (proposal C) The comparator one takes a back seat to the function one, not the other way around.\nI am ok with casting for now. (proposal B)\nProposal A2: Deprecate the Comparator ones, add minWithComparator(Comparator) and maxWithComparator(Comparator). Then we ditch the comparator for 8.0 (whenever that may be, but it could be sooner than later due to kogito), adding it in https://issues.redhat.com/browse/PLANNER-750 so we don't forget.", "author": "ge0ffrey", "createdAt": "2020-02-18T08:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NjM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "78b62fc630d3b830ab111120587f208230554747", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 12081cba5..73f7633b8 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -535,7 +535,7 @@ public final class ConstraintCollectors {\n      *     considered to be {@link #equals(Object)}.\n      * <p>\n      *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David (age = 25), Eric (age = 20).\n+     *     David(age = 25), Eric(age = 20).\n      *     Further assume that the Person type compares by age.\n      *     Such collector returns either Ann or Eric as the minimum element.\n      *     No guarantees are made on which of the two is returned.\n"}}, {"oid": "78b62fc630d3b830ab111120587f208230554747", "url": "https://github.com/kiegroup/optaplanner/commit/78b62fc630d3b830ab111120587f208230554747", "message": "Clean up Javadoc", "committedDate": "2020-02-17T12:17:54Z", "type": "commit"}, {"oid": "8ee64c636beda1959871089f79fdf7f04493ad05", "url": "https://github.com/kiegroup/optaplanner/commit/8ee64c636beda1959871089f79fdf7f04493ad05", "message": "Simplify Javadoc", "committedDate": "2020-02-17T12:50:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNjIzNA==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380506234", "bodyText": "Consistency: other javadocs don't ident after the <p>. Note that we also never do </p> (that didn't work well). All in all, I am happy to re-standarize all code on whatever openJDK is doing, but that's for a separate PR. Let's have this PR follow the rest of the code.", "author": "ge0ffrey", "createdAt": "2020-02-18T07:55:36Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0aca482626dc960175a9dc4008696d77f654063", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 4841d209c..6956e8189 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -529,15 +529,15 @@ public final class ConstraintCollectors {\n     /**\n      * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n      * <p>\n-     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n-     *     {@link #equals(Object)}.\n-     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n-     *     considered to be {@link #equals(Object)}.\n+     * It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     * {@link #equals(Object)}.\n+     * In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     * considered to be {@link #equals(Object)}.\n      * <p>\n-     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David(age = 25), Eric(age = 20).\n-     *     Further assume that the Person type compares by age.\n-     *     Such collector returns either Ann or Eric as the minimum element.\n+     * Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     * David(age = 25), Eric(age = 20).\n+     * Further assume that the Person type compares by age.\n+     * Such collector returns either Ann or Eric as the minimum element.\n      *\n      * @param <A> type of the matched fact\n      * @return never null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwNjQ0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380506445", "bodyText": "\"compare to equal\" -> \"compare to zero\" (it's more specific)", "author": "ge0ffrey", "createdAt": "2020-02-18T07:56:05Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0aca482626dc960175a9dc4008696d77f654063", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 4841d209c..6956e8189 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -529,15 +529,15 @@ public final class ConstraintCollectors {\n     /**\n      * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n      * <p>\n-     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n-     *     {@link #equals(Object)}.\n-     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n-     *     considered to be {@link #equals(Object)}.\n+     * It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     * {@link #equals(Object)}.\n+     * In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     * considered to be {@link #equals(Object)}.\n      * <p>\n-     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David(age = 25), Eric(age = 20).\n-     *     Further assume that the Person type compares by age.\n-     *     Such collector returns either Ann or Eric as the minimum element.\n+     * Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     * David(age = 25), Eric(age = 20).\n+     * Further assume that the Person type compares by age.\n+     * Such collector returns either Ann or Eric as the minimum element.\n      *\n      * @param <A> type of the matched fact\n      * @return never null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUwOTE5OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380509199", "bodyText": "I would change this paragraph into something like this:\nImportant: The {@link Comparable}'s {@link Comparable#compareTo(Object)} must be <i>consistent with equals</i>, such that <tt>e1.compareTo(e2) == 0</tt> has the same boolean value as <tt>e1.equals(e2)</tt>.\nIn other words, if two elements compare to zero, any of them can be returned by the collector. It can even differ between 2 score calculations on the exact same {@link PlanningSolution} state, due to incremental score calculation.\n\nMotivation:\n\nstart with \"important\" to stand out (we do this in a few other javadocs too).\nUse \"must\" instead of \"It is expected that ...\" because that's more direct, stronger (which is appropriate here) and clearer.\nMimic javadocs of Comparable on OpenJDK, use same terminology and phrasing. See 3th paragraph of class javadoc.", "author": "ge0ffrey", "createdAt": "2020-02-18T08:03:39Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0aca482626dc960175a9dc4008696d77f654063", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 4841d209c..6956e8189 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -529,15 +529,15 @@ public final class ConstraintCollectors {\n     /**\n      * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n      * <p>\n-     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n-     *     {@link #equals(Object)}.\n-     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n-     *     considered to be {@link #equals(Object)}.\n+     * It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     * {@link #equals(Object)}.\n+     * In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     * considered to be {@link #equals(Object)}.\n      * <p>\n-     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David(age = 25), Eric(age = 20).\n-     *     Further assume that the Person type compares by age.\n-     *     Such collector returns either Ann or Eric as the minimum element.\n+     * Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     * David(age = 25), Eric(age = 20).\n+     * Further assume that the Person type compares by age.\n+     * Such collector returns either Ann or Eric as the minimum element.\n      *\n      * @param <A> type of the matched fact\n      * @return never null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380510788", "bodyText": "Use {@code Ann(age = 20)} to format example input and output.\nWrap a collection of elements as input or output in [].\nUse formal (pseudo-)code-snippet .groupBy(min(Person::getAge)) instead of assume that the Person type compares by age.\nFind a shorter template for \"input + constraintstream = output\". The \"Such collector\" breaks this flow (too much ceremony).", "author": "ge0ffrey", "createdAt": "2020-02-18T08:07:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMTc0MA==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380511740", "bodyText": "Proposal:\nFor example, {@code [Ann(age = 20), Beth(age = 25), Cathy(age = 30), David(age = 25), Eric(age = 20)]`} with {@code .groupBy(min(Comparator.comparing(Person::getAge)))} returns {@code Ann} or {@code Eric} arbitrary.", "author": "ge0ffrey", "createdAt": "2020-02-18T08:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMjcxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380512719", "bodyText": "If this template proposal works well, let's apply it to all of constraint streams for all example:\nFor example, {@code <input>} with {@code <cs snippet>} returns {@code <output>}.", "author": "ge0ffrey", "createdAt": "2020-02-18T08:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNDc0OA==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380514748", "bodyText": "Also,\nin ConstraintStream.join(Class) we have a hint that they probably want to use join(Class, Joiners) instead if they can. Let's do something similar here, that links to min(Function), telling them theyre probably better off with that one.", "author": "ge0ffrey", "createdAt": "2020-02-18T08:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxNTMzMg==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380515332", "bodyText": "And before the hint, let's recommend the good practice of ending with an identity comparison, by adding a 2th example with .groupBy(min(Comparator.comparing(Person::getAge).comparing(Person::getId)))", "author": "ge0ffrey", "createdAt": "2020-02-18T08:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMDc4OA=="}], "type": "inlineReview", "revised_code": {"commit": "a0aca482626dc960175a9dc4008696d77f654063", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 4841d209c..6956e8189 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -529,15 +529,15 @@ public final class ConstraintCollectors {\n     /**\n      * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n      * <p>\n-     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n-     *     {@link #equals(Object)}.\n-     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n-     *     considered to be {@link #equals(Object)}.\n+     * It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     * {@link #equals(Object)}.\n+     * In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     * considered to be {@link #equals(Object)}.\n      * <p>\n-     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David(age = 25), Eric(age = 20).\n-     *     Further assume that the Person type compares by age.\n-     *     Such collector returns either Ann or Eric as the minimum element.\n+     * Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     * David(age = 25), Eric(age = 20).\n+     * Further assume that the Person type compares by age.\n+     * Such collector returns either Ann or Eric as the minimum element.\n      *\n      * @param <A> type of the matched fact\n      * @return never null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxMzc5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380513791", "bodyText": "Soft suggestion: I'd order this method (min(Function)) before min(Comparator), because we want to stimulate users to use this one (I know, it doesn't change the order in javadocs or code completion, but people do look at the sources too and for us it's a signal too that we consider this one more important).", "author": "ge0ffrey", "createdAt": "2020-02-18T08:15:10Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -526,36 +526,380 @@ private static Runnable innerCountDistinctLong(CountDistinctLongResultContainer\n     // min\n     // ************************************************************************\n \n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Further assume that the Person type compares by age.\n+     *     Such collector returns either Ann or Eric as the minimum element.\n+     *\n+     * @param <A> type of the matched fact\n+     * @return never null\n+     */\n+    public static <A extends Comparable<A>> UniConstraintCollector<A, ?, A> min() {\n+        return min(Function.identity(), Comparable::compareTo);\n+    }\n+\n+    /**\n+     * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n+     * <p>\n+     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     *     {@link #equals(Object)}.\n+     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     *     considered to be {@link #equals(Object)}.\n+     * <p>\n+     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     *     David(age = 25), Eric(age = 20).\n+     *     Using Person::getAge as the groupValueMapping, the resulting collector returns 20, as that is the minimum\n+     *     age of all the elements.\n+     *\n+     * @param <A> type of the matched fact\n+     * @param <Mapped> type of the result\n+     * @param groupValueMapping never null, maps facts from the matched type to the result type\n+     * @return never null\n+     */\n+    public static <A, Mapped extends Comparable<Mapped>> UniConstraintCollector<A, ?, Mapped> min(\n+            Function<A, Mapped> groupValueMapping) {", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0aca482626dc960175a9dc4008696d77f654063", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\nindex 4841d209c..6956e8189 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java\n\n@@ -529,15 +529,15 @@ public final class ConstraintCollectors {\n     /**\n      * Returns a collector that finds a minimum value in a group of {@link Comparable} elements.\n      * <p>\n-     *     It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n-     *     {@link #equals(Object)}.\n-     *     In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n-     *     considered to be {@link #equals(Object)}.\n+     * It is expected that the {@link Comparable}'s {@link Comparable#compareTo(Object)} is consistent with\n+     * {@link #equals(Object)}.\n+     * In other words, if two elements compare to equal, any of them may be returned by the collector as they are\n+     * considered to be {@link #equals(Object)}.\n      * <p>\n-     *     Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n-     *     David(age = 25), Eric(age = 20).\n-     *     Further assume that the Person type compares by age.\n-     *     Such collector returns either Ann or Eric as the minimum element.\n+     * Example: Assume the following elements of type Person: Ann(age = 20), Beth(age = 25), Cathy(age = 30),\n+     * David(age = 25), Eric(age = 20).\n+     * Further assume that the Person type compares by age.\n+     * Such collector returns either Ann or Eric as the minimum element.\n      *\n      * @param <A> type of the matched fact\n      * @return never null\n"}}, {"oid": "a0aca482626dc960175a9dc4008696d77f654063", "url": "https://github.com/kiegroup/optaplanner/commit/a0aca482626dc960175a9dc4008696d77f654063", "message": "Remove comment indentation", "committedDate": "2020-02-18T08:25:48Z", "type": "commit"}, {"oid": "c95973d18d0c0ea67798c6340003b46c07874836", "url": "https://github.com/kiegroup/optaplanner/commit/c95973d18d0c0ea67798c6340003b46c07874836", "message": "Change comparator wording", "committedDate": "2020-02-18T08:29:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMDI1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380520252", "bodyText": "A Class as a firstValue?\nWouldn't it make more sense to either use:\nObject o1 = new Object();\nor use mockito's \"mock()\").\nOr does it need to be a class instance? In that case, let's call it firstClass?", "author": "ge0ffrey", "createdAt": "2020-02-18T08:30:20Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java", "diffHunk": "@@ -1381,6 +1598,224 @@ public void maxNotComparable() {\n         assertResult(collector, container, null);\n     }\n \n+    @Test\n+    public void maxComparableMapped() {\n+        UniConstraintCollector<Class, ?, String> collector = max(Class::getCanonicalName);\n+        Object container = collector.supplier().get();\n+        // add first value, which becomes the max\n+        Class firstValue = ConstraintCollectorsTest.class;", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMTcyNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380521725", "bodyText": "The reason I use Class is that it doesn't implement Comparable, yet it has an easily accessibleString field that does, so it's easy to write a Comparator for it.", "author": "triceo", "createdAt": "2020-02-18T08:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMDI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1915be2cb203e13022c242f48ec5d9e2b188a76e", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\nindex 717d6e19f..2f83e2a47 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\n\n@@ -1598,59 +1542,6 @@ public class ConstraintCollectorsTest {\n         assertResult(collector, container, null);\n     }\n \n-    @Test\n-    public void maxComparableMapped() {\n-        UniConstraintCollector<Class, ?, String> collector = max(Class::getCanonicalName);\n-        Object container = collector.supplier().get();\n-        // add first value, which becomes the max\n-        Class firstValue = ConstraintCollectorsTest.class;\n-        Runnable firstRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // add second value, lesser than the first, result does not change\n-        Class secondValue = ConstraintCollectors.class;\n-        Runnable secondRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // add third value, same as the first, result does not change\n-        Runnable thirdRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // retract one instance of the first value; first value is still the max value, nothing should change\n-        firstRetractor.run();\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // retract final instance of the first value; second value is now the max value\n-        thirdRetractor.run();\n-        assertResult(collector, container, secondValue.getCanonicalName());\n-        // retract last value; there are no values now\n-        secondRetractor.run();\n-        assertResult(collector, container, null);\n-    }\n-\n-    @Test\n-    public void maxNotComparableMapped() {\n-        UniConstraintCollector<Class, ?, Object> collector =\n-                max(Class::getCanonicalName, Comparator.comparing(o -> (String)o));\n-        Object container = collector.supplier().get();\n-        // add first value, which becomes the max\n-        Class firstValue = ConstraintCollectorsTest.class;\n-        Runnable firstRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // add second value, lesser than the first, result does not change\n-        Class secondValue = ConstraintCollectors.class;\n-        Runnable secondRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // add third value, same as the first, result does not change\n-        Runnable thirdRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // retract one instance of the first value; first value is still the max value, nothing should change\n-        firstRetractor.run();\n-        assertResult(collector, container, firstValue.getCanonicalName());\n-        // retract final instance of the first value; second value is now the max value\n-        thirdRetractor.run();\n-        assertResult(collector, container, secondValue.getCanonicalName());\n-        // retract last value; there are no values now\n-        secondRetractor.run();\n-        assertResult(collector, container, null);\n-    }\n-\n     @Test\n     public void maxComparableBi() {\n         BiConstraintCollector<Integer, Integer, ?, Integer> collector = max(\n"}}, {"oid": "7c6f2f8de381136aa28cb58c6f4c2c3586f3530b", "url": "https://github.com/kiegroup/optaplanner/commit/7c6f2f8de381136aa28cb58c6f4c2c3586f3530b", "message": "Reorder methods", "committedDate": "2020-02-18T08:32:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyOTk2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/692#discussion_r380529966", "bodyText": "This test smells like its \"abstracted\". (I am not saying it is an abstracted test)\nI personally favor concrete tests a lot of abstracted tests.\nFor example:\n// Concrete test\nassertEquals(7, calculator.sum(2, 5));\nassertEquals(7, calculator.sum(4, 3));\nassertEquals(9, calculator.sum(4, 5));\n\n// Abstracted test\nfor (i = 0; i < 7; i++) {\n  for (j = 0; j < 7; i++) {\n   assertEquals(i + j, calculator.sum(i, j));\n  }\n}\n\nAbstracted tests do more tests, but often don't increase test coverage. They make it hard to read what happens in corner cases - which can lead to invalid tests. And they often copy-paste the mistakes from the unit into the unit test code (especially corner cases).", "author": "ge0ffrey", "createdAt": "2020-02-18T08:51:05Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java", "diffHunk": "@@ -1324,13 +1325,229 @@ public void minNotComparable() {\n         assertResult(collector, container, null);\n     }\n \n+    @Test\n+    public void minComparableMapped() {", "originalCommit": "8ee64c636beda1959871089f79fdf7f04493ad05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1915be2cb203e13022c242f48ec5d9e2b188a76e", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\nindex 717d6e19f..2f83e2a47 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/ConstraintCollectorsTest.java\n\n@@ -1325,60 +1324,6 @@ public class ConstraintCollectorsTest {\n         assertResult(collector, container, null);\n     }\n \n-    @Test\n-    public void minComparableMapped() {\n-        Function<Class, String> mappingFunction = Class::getCanonicalName;\n-        UniConstraintCollector<Class, ?, String> collector = min(mappingFunction);\n-        Object container = collector.supplier().get();\n-        // add first value, which becomes the min\n-        Class firstValue = ConstraintCollectorsTest.class;\n-        Runnable firstRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, mappingFunction.apply(firstValue));\n-        // add second value, lesser than the first, becomes the new min\n-        Class secondValue = ConstraintCollectors.class;\n-        Runnable secondRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // add third value, same as the second, result does not change\n-        Runnable thirdRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // retract one instance of the second value; second value is still the min value, nothing should change\n-        secondRetractor.run();\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // retract final instance of the second value; first value is now the min value\n-        thirdRetractor.run();\n-        assertResult(collector, container, mappingFunction.apply(firstValue));\n-        // retract last value; there are no values now\n-        firstRetractor.run();\n-        assertResult(collector, container, null);\n-    }\n-\n-    @Test\n-    public void minNotComparableMapped() {\n-        Function<Class, Object> mappingFunction = Class::getCanonicalName;\n-        UniConstraintCollector<Class, ?, Object> collector = min(mappingFunction, Comparator.comparing(o -> (String)o));\n-        Object container = collector.supplier().get();\n-        // add first value, which becomes the min\n-        Class firstValue = ConstraintCollectorsTest.class;\n-        Runnable firstRetractor = accumulate(collector, container, firstValue);\n-        assertResult(collector, container, mappingFunction.apply(firstValue));\n-        // add second value, lesser than the first, becomes the new min\n-        Class secondValue = ConstraintCollectors.class;\n-        Runnable secondRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // add third value, same as the second, result does not change\n-        Runnable thirdRetractor = accumulate(collector, container, secondValue);\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // retract one instance of the second value; second value is still the min value, nothing should change\n-        secondRetractor.run();\n-        assertResult(collector, container, mappingFunction.apply(secondValue));\n-        // retract final instance of the second value; first value is now the min value\n-        thirdRetractor.run();\n-        assertResult(collector, container, mappingFunction.apply(firstValue));\n-        // retract last value; there are no values now\n-        firstRetractor.run();\n-        assertResult(collector, container, null);\n-    }\n-\n     @Test\n     public void minComparableBi() {\n         BiConstraintCollector<Integer, Integer, ?, Integer> collector = min(\n"}}, {"oid": "015c6b0d2dce74f4721178590bf61b8e4f1e0a19", "url": "https://github.com/kiegroup/optaplanner/commit/015c6b0d2dce74f4721178590bf61b8e4f1e0a19", "message": "Refactor Javadoc", "committedDate": "2020-02-18T09:02:42Z", "type": "commit"}, {"oid": "f8f6218a73581f722307d54bad2ee4bfbf82a51d", "url": "https://github.com/kiegroup/optaplanner/commit/f8f6218a73581f722307d54bad2ee4bfbf82a51d", "message": "Mention identity comparisons", "committedDate": "2020-02-18T09:13:46Z", "type": "commit"}, {"oid": "a22c2207a9e79b7bb2b9518bb684af4b41d97298", "url": "https://github.com/kiegroup/optaplanner/commit/a22c2207a9e79b7bb2b9518bb684af4b41d97298", "message": "Simplify test", "committedDate": "2020-02-18T09:20:26Z", "type": "commit"}, {"oid": "1915be2cb203e13022c242f48ec5d9e2b188a76e", "url": "https://github.com/kiegroup/optaplanner/commit/1915be2cb203e13022c242f48ec5d9e2b188a76e", "message": "Address test code review", "committedDate": "2020-02-18T09:31:10Z", "type": "commit"}]}