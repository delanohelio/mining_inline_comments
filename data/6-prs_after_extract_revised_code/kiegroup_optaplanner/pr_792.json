{"pr_number": 792, "pr_title": "PLANNER-1961 Only process trailing entities when there's supply", "pr_createdAt": "2020-05-28T08:16:56Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/792", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY2ODk0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r431668949", "bodyText": "And this is why you don't put types of variables in variable names. This implementation detail now proliferated into places of this PR, which would otherwise be unaffected.", "author": "triceo", "createdAt": "2020-05-28T08:30:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;\n-                }\n-                inverseVariableSupplyList.add(inverseVariableSupply);\n-            }\n+            inverseVariableSupplyMap = variableDescriptorList.stream()\n+                    .filter(GenuineVariableDescriptor::isChained)\n+                    .collect(toMap(Functions.identity(), variableDescriptor -> supplyManager\n+                            .demand(new SingletonInverseVariableDemand(variableDescriptor))));\n         }\n     }\n \n     @Override\n     public void solvingEnded(DefaultSolverScope solverScope) {\n         super.solvingEnded(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = null;\n+            inverseVariableSupplyMap = null;", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "393961a4cdcd29ee810af182798127b841b27a7f", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\nindex 2b14d65721..ece8bde580 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\n\n@@ -94,11 +90,18 @@ public class SwapMoveSelector extends GenericMoveSelector {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n+            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            inverseVariableSupplyMap = variableDescriptorList.stream()\n-                    .filter(GenuineVariableDescriptor::isChained)\n-                    .collect(toMap(Functions.identity(), variableDescriptor -> supplyManager\n-                            .demand(new SingletonInverseVariableDemand(variableDescriptor))));\n+            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n+                SingletonInverseVariableSupply inverseVariableSupply;\n+                if (variableDescriptor.isChained()) {\n+                    inverseVariableSupply = supplyManager.demand(\n+                            new SingletonInverseVariableDemand(variableDescriptor));\n+                } else {\n+                    inverseVariableSupply = null;\n+                }\n+                inverseVariableSupplyList.add(inverseVariableSupply);\n+            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433073985", "bodyText": "So when I have a plannning entity LessonVisit with a chained planning variable previous and a non-chained planning variable room, this code will execute for the room  too? That room should behave like a normal swap. Does it?\nWhat happens to room if it's trailing entities are null, both left and right? I guess it behaves like a normal swap move indeed?", "author": "ge0ffrey", "createdAt": "2020-06-01T07:04:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074285", "bodyText": "I think the code behaves correctly, but we should add a test for it.", "author": "ge0ffrey", "createdAt": "2020-06-01T07:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3Mzk4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "393961a4cdcd29ee810af182798127b841b27a7f", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\nindex f74562ce73..0e69e1b99f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n\n@@ -77,8 +75,8 @@ public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n                     if (oldRightValue == leftEntity) {\n                         // Change the right entity\n                         scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDI2OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074269", "bodyText": "This is where you put the null that is then thrown later.", "author": "triceo", "createdAt": "2020-06-01T07:05:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java", "diffHunk": "@@ -90,26 +94,19 @@ public boolean supportsPhaseAndSolverCaching() {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n-            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n-                SingletonInverseVariableSupply inverseVariableSupply;\n-                if (variableDescriptor.isChained()) {\n-                    inverseVariableSupply = supplyManager.demand(\n-                            new SingletonInverseVariableDemand(variableDescriptor));\n-                } else {\n-                    inverseVariableSupply = null;", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "393961a4cdcd29ee810af182798127b841b27a7f", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\nindex 2b14d65721..ece8bde580 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/SwapMoveSelector.java\n\n@@ -94,11 +90,18 @@ public class SwapMoveSelector extends GenericMoveSelector {\n     public void solvingStarted(DefaultSolverScope solverScope) {\n         super.solvingStarted(solverScope);\n         if (anyChained) {\n+            inverseVariableSupplyList = new ArrayList<>(variableDescriptorList.size());\n             SupplyManager supplyManager = solverScope.getScoreDirector().getSupplyManager();\n-            inverseVariableSupplyMap = variableDescriptorList.stream()\n-                    .filter(GenuineVariableDescriptor::isChained)\n-                    .collect(toMap(Functions.identity(), variableDescriptor -> supplyManager\n-                            .demand(new SingletonInverseVariableDemand(variableDescriptor))));\n+            for (GenuineVariableDescriptor variableDescriptor : variableDescriptorList) {\n+                SingletonInverseVariableSupply inverseVariableSupply;\n+                if (variableDescriptor.isChained()) {\n+                    inverseVariableSupply = supplyManager.demand(\n+                            new SingletonInverseVariableDemand(variableDescriptor));\n+                } else {\n+                    inverseVariableSupply = null;\n+                }\n+                inverseVariableSupplyList.add(inverseVariableSupply);\n+            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433074489", "bodyText": "This is where the null would be thrown.\nI fix that by not iterating over the cases where the null would be thrown. (Non-chained vars.)", "author": "triceo", "createdAt": "2020-06-01T07:06:13Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -31,26 +32,28 @@\n  */\n public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n \n-    protected final List<Object> oldLeftTrailingEntityList;\n-    protected final List<Object> oldRightTrailingEntityList;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap;\n+    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap;\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> variableDescriptorList,\n-            List<SingletonInverseVariableSupply> inverseVariableSupplyList, Object leftEntity, Object rightEntity) {\n+            Map<GenuineVariableDescriptor<Solution_>, SingletonInverseVariableSupply> inverseVariableSupplyMap,\n+            Object leftEntity, Object rightEntity) {\n         super(variableDescriptorList, leftEntity, rightEntity);\n-        oldLeftTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        oldRightTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n-        for (SingletonInverseVariableSupply inverseVariableSupply : inverseVariableSupplyList) {\n-            oldLeftTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(leftEntity));\n-            oldRightTrailingEntityList.add(inverseVariableSupply.getInverseSingleton(rightEntity));", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzcwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077702", "bodyText": "I'd iterate over them, to avoid changing an indexed lookup by a hashed lookup later on, but put in null if they don't exist, instead of throwing an NPE. wdyt?", "author": "ge0ffrey", "createdAt": "2020-06-01T07:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NDQ4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "393961a4cdcd29ee810af182798127b841b27a7f", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\nindex f74562ce73..0e69e1b99f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n\n@@ -32,28 +31,27 @@ import org.optaplanner.core.impl.score.director.ScoreDirector;\n  */\n public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n \n-    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap;\n-    protected final Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap;\n+    protected final List<Object> oldLeftTrailingEntityList;\n+    protected final List<Object> oldRightTrailingEntityList;\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> variableDescriptorList,\n-            Map<GenuineVariableDescriptor<Solution_>, SingletonInverseVariableSupply> inverseVariableSupplyMap,\n-            Object leftEntity, Object rightEntity) {\n+            List<SingletonInverseVariableSupply> inverseVariableSupplyList, Object leftEntity, Object rightEntity) {\n         super(variableDescriptorList, leftEntity, rightEntity);\n-        oldLeftTrailingEntityMap = new LinkedHashMap<>(inverseVariableSupplyMap.size());\n-        oldRightTrailingEntityMap = new LinkedHashMap<>(inverseVariableSupplyMap.size());\n-        inverseVariableSupplyMap.forEach((variableDescriptor, inverseVariableSupply) -> {\n-            oldLeftTrailingEntityMap.put(variableDescriptor, inverseVariableSupply.getInverseSingleton(leftEntity));\n-            oldRightTrailingEntityMap.put(variableDescriptor, inverseVariableSupply.getInverseSingleton(rightEntity));\n-        });\n+        oldLeftTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n+        oldRightTrailingEntityList = new ArrayList<>(inverseVariableSupplyList.size());\n+        for (SingletonInverseVariableSupply inverseVariableSupply : inverseVariableSupplyList) {\n+            boolean hasSupply = inverseVariableSupply != null;\n+            oldLeftTrailingEntityList.add(hasSupply ? inverseVariableSupply.getInverseSingleton(leftEntity) : null);\n+            oldRightTrailingEntityList.add(hasSupply ? inverseVariableSupply.getInverseSingleton(rightEntity) : null);\n+        }\n     }\n \n     public ChainedSwapMove(List<GenuineVariableDescriptor<Solution_>> genuineVariableDescriptors,\n             Object leftEntity, Object rightEntity,\n-            Map<GenuineVariableDescriptor<Solution_>, Object> oldLeftTrailingEntityMap,\n-            Map<GenuineVariableDescriptor<Solution_>, Object> oldRightTrailingEntityMap) {\n+            List<Object> oldLeftTrailingEntityList, List<Object> oldRightTrailingEntityList) {\n         super(genuineVariableDescriptors, leftEntity, rightEntity);\n-        this.oldLeftTrailingEntityMap = oldLeftTrailingEntityMap;\n-        this.oldRightTrailingEntityMap = oldRightTrailingEntityMap;\n+        this.oldLeftTrailingEntityList = oldLeftTrailingEntityList;\n+        this.oldRightTrailingEntityList = oldRightTrailingEntityList;\n     }\n \n     // ************************************************************************\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA3NzI2MA==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433077260", "bodyText": "These map calls are a performance loss. We're replacing an indexed lookup by a hash lookup.\nI'd keep the index lookup (so the trailingEntityList has the same size as variableDescriptorList and their indexes match), but given that \"Object oldLeftTrailingEntity \" can be null, I 'd put a null as an element where we cache that (move constructor)", "author": "ge0ffrey", "createdAt": "2020-06-01T07:14:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java", "diffHunk": "@@ -74,8 +77,8 @@ protected void doMoveOnGenuineVariables(ScoreDirector<Solution_> scoreDirector)\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);", "originalCommit": "caf0ec79730961ed68545fb48958b397960ac89f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "393961a4cdcd29ee810af182798127b841b27a7f", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\nindex f74562ce73..0e69e1b99f 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/generic/chained/ChainedSwapMove.java\n\n@@ -77,8 +75,8 @@ public class ChainedSwapMove<Solution_> extends SwapMove<Solution_> {\n                     scoreDirector.changeVariableFacade(variableDescriptor, leftEntity, oldRightValue);\n                     scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n                 } else {\n-                    Object oldLeftTrailingEntity = oldLeftTrailingEntityMap.get(variableDescriptor);\n-                    Object oldRightTrailingEntity = oldRightTrailingEntityMap.get(variableDescriptor);\n+                    Object oldLeftTrailingEntity = oldLeftTrailingEntityList.get(i);\n+                    Object oldRightTrailingEntity = oldRightTrailingEntityList.get(i);\n                     if (oldRightValue == leftEntity) {\n                         // Change the right entity\n                         scoreDirector.changeVariableFacade(variableDescriptor, rightEntity, oldLeftValue);\n"}}, {"oid": "393961a4cdcd29ee810af182798127b841b27a7f", "url": "https://github.com/kiegroup/optaplanner/commit/393961a4cdcd29ee810af182798127b841b27a7f", "message": "PLANNER-1961 Only create inverse singletons for chained vars", "committedDate": "2020-06-01T14:55:31Z", "type": "commit"}, {"oid": "294762c60ba25c02317b187e2e9b7c3aaa392328", "url": "https://github.com/kiegroup/optaplanner/commit/294762c60ba25c02317b187e2e9b7c3aaa392328", "message": "PLANNER-1961 Add test for correct swap moves", "committedDate": "2020-06-01T15:25:40Z", "type": "commit"}, {"oid": "294762c60ba25c02317b187e2e9b7c3aaa392328", "url": "https://github.com/kiegroup/optaplanner/commit/294762c60ba25c02317b187e2e9b7c3aaa392328", "message": "PLANNER-1961 Add test for correct swap moves", "committedDate": "2020-06-01T15:25:40Z", "type": "forcePushed"}, {"oid": "eec39132a94378b750578cc8a2a566a4fb2c72d5", "url": "https://github.com/kiegroup/optaplanner/commit/eec39132a94378b750578cc8a2a566a4fb2c72d5", "message": "PLANNER-1961 Final fields", "committedDate": "2020-06-01T15:28:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzQ1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/792#discussion_r433857459", "bodyText": "(very soft) I 'd have used TestdataValue as a type for unchainedObject, calling it unchainedValue instead, for consistency with other testdata. But it doesn't matter much.", "author": "ge0ffrey", "createdAt": "2020-06-02T13:03:17Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java", "diffHunk": "@@ -39,7 +39,15 @@\n         return entityDescriptor.getGenuineVariableDescriptor(\"chainedObject\");\n     }\n \n+    public static GenuineVariableDescriptor<TestdataChainedSolution> buildVariableDescriptorForUnchainedObject() {\n+        SolutionDescriptor<TestdataChainedSolution> solutionDescriptor = TestdataChainedSolution.buildSolutionDescriptor();\n+        EntityDescriptor<TestdataChainedSolution> entityDescriptor = solutionDescriptor\n+                .findEntityDescriptorOrFail(TestdataChainedEntity.class);\n+        return entityDescriptor.getGenuineVariableDescriptor(\"unchainedObject\");\n+    }\n+\n     private TestdataChainedObject chainedObject;\n+    private TestdataObject unchainedObject;", "originalCommit": "eec39132a94378b750578cc8a2a566a4fb2c72d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c558c0d3d1d8cd8f3ac9938c7a9311d5fef0a8b6", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java b/optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java\nindex d122654b53..8ada14181d 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/chained/TestdataChainedEntity.java\n\n@@ -39,15 +40,15 @@ public class TestdataChainedEntity extends TestdataObject implements TestdataCha\n         return entityDescriptor.getGenuineVariableDescriptor(\"chainedObject\");\n     }\n \n-    public static GenuineVariableDescriptor<TestdataChainedSolution> buildVariableDescriptorForUnchainedObject() {\n+    public static GenuineVariableDescriptor<TestdataChainedSolution> buildVariableDescriptorForUnchainedValue() {\n         SolutionDescriptor<TestdataChainedSolution> solutionDescriptor = TestdataChainedSolution.buildSolutionDescriptor();\n         EntityDescriptor<TestdataChainedSolution> entityDescriptor = solutionDescriptor\n                 .findEntityDescriptorOrFail(TestdataChainedEntity.class);\n-        return entityDescriptor.getGenuineVariableDescriptor(\"unchainedObject\");\n+        return entityDescriptor.getGenuineVariableDescriptor(\"unchainedValue\");\n     }\n \n     private TestdataChainedObject chainedObject;\n-    private TestdataObject unchainedObject;\n+    private TestdataValue unchainedValue;\n \n     public TestdataChainedEntity() {\n     }\n"}}, {"oid": "c558c0d3d1d8cd8f3ac9938c7a9311d5fef0a8b6", "url": "https://github.com/kiegroup/optaplanner/commit/c558c0d3d1d8cd8f3ac9938c7a9311d5fef0a8b6", "message": "Address final review comment", "committedDate": "2020-06-02T13:18:34Z", "type": "commit"}]}