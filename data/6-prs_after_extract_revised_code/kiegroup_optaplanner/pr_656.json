{"pr_number": 656, "pr_title": "PLANNER-1765 groupBy() on QuadStreams", "pr_createdAt": "2020-01-14T11:17:43Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/656", "timeline": [{"oid": "a152e4beacbb4f95b1eb21ed46f14aed617ff167", "url": "https://github.com/kiegroup/optaplanner/commit/a152e4beacbb4f95b1eb21ed46f14aed617ff167", "message": "Add the basic APIs", "committedDate": "2020-01-14T08:31:23Z", "type": "commit"}, {"oid": "526d07a3a22956dea2ad9835a8d295dc5ffe6d8b", "url": "https://github.com/kiegroup/optaplanner/commit/526d07a3a22956dea2ad9835a8d295dc5ffe6d8b", "message": "Finalize the constraint collectors", "committedDate": "2020-01-14T08:31:33Z", "type": "commit"}, {"oid": "0b9aec6911c1f54406f467d26a2e98ab1a557e26", "url": "https://github.com/kiegroup/optaplanner/commit/0b9aec6911c1f54406f467d26a2e98ab1a557e26", "message": "Remove unusued code", "committedDate": "2020-01-14T08:31:50Z", "type": "commit"}, {"oid": "d355235588a3667d1a91bf6f9c23f47ced345448", "url": "https://github.com/kiegroup/optaplanner/commit/d355235588a3667d1a91bf6f9c23f47ced345448", "message": "Address Javadoc review comments", "committedDate": "2020-01-14T08:32:01Z", "type": "commit"}, {"oid": "4849dc51bf1d714593c47cde7cf612cdd1bfff98", "url": "https://github.com/kiegroup/optaplanner/commit/4849dc51bf1d714593c47cde7cf612cdd1bfff98", "message": "Collect", "committedDate": "2020-01-14T08:48:22Z", "type": "commit"}, {"oid": "372a7b1c827e0b0bf963cb9119e8533520c0afec", "url": "https://github.com/kiegroup/optaplanner/commit/372a7b1c827e0b0bf963cb9119e8533520c0afec", "message": "Single groupBy", "committedDate": "2020-01-14T08:52:30Z", "type": "commit"}, {"oid": "fe8bd1848d5e97316a7e6592f8e361ffab198663", "url": "https://github.com/kiegroup/optaplanner/commit/fe8bd1848d5e97316a7e6592f8e361ffab198663", "message": "Group and collect", "committedDate": "2020-01-14T09:10:54Z", "type": "commit"}, {"oid": "abde1390d4e81dd555c37eb073b5e21c41fb6014", "url": "https://github.com/kiegroup/optaplanner/commit/abde1390d4e81dd555c37eb073b5e21c41fb6014", "message": "Bigroup", "committedDate": "2020-01-14T09:17:59Z", "type": "commit"}, {"oid": "0bcc5251b788681e7e740a1b3ced5edef297a25b", "url": "https://github.com/kiegroup/optaplanner/commit/0bcc5251b788681e7e740a1b3ced5edef297a25b", "message": "Bigroup with collect", "committedDate": "2020-01-14T09:46:02Z", "type": "commit"}, {"oid": "2ce18c6ce9c8829f579ddff43a46dc19067aaba6", "url": "https://github.com/kiegroup/optaplanner/commit/2ce18c6ce9c8829f579ddff43a46dc19067aaba6", "message": "Bigroup with bicollect", "committedDate": "2020-01-14T12:24:19Z", "type": "commit"}, {"oid": "e958fa0a27a94b417b80908a2225d6ff48463a6f", "url": "https://github.com/kiegroup/optaplanner/commit/e958fa0a27a94b417b80908a2225d6ff48463a6f", "message": "Bigroup with bicollect for quad", "committedDate": "2020-01-14T13:12:53Z", "type": "commit"}, {"oid": "d4901f0eeb61b6d5544999e49fde2deb689a1926", "url": "https://github.com/kiegroup/optaplanner/commit/d4901f0eeb61b6d5544999e49fde2deb689a1926", "message": "Bigroup with bicollect for tri", "committedDate": "2020-01-14T13:26:12Z", "type": "commit"}, {"oid": "38567da875dbaf86ea10ad485e2a2ed0c8422bcd", "url": "https://github.com/kiegroup/optaplanner/commit/38567da875dbaf86ea10ad485e2a2ed0c8422bcd", "message": "And it's done", "committedDate": "2020-01-14T13:36:33Z", "type": "commit"}, {"oid": "403be23f358738ebd72de21a219e3aec7aa5cef4", "url": "https://github.com/kiegroup/optaplanner/commit/403be23f358738ebd72de21a219e3aec7aa5cef4", "message": "Fix Revapi", "committedDate": "2020-01-14T13:41:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r366760029", "bodyText": "This is a good reason to think long and hard if we want to support PentaConstraintStreams.\nQuadsStreams are still needed, definitely, despite this. It's worth it. Absolutely.", "author": "ge0ffrey", "createdAt": "2020-01-15T09:05:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -258,6 +259,31 @@\n             Function<A, GroupKeyA_> groupKeyAMapping, Function<A, GroupKeyB_> groupKeyBMapping,\n             UniConstraintCollector<A, ResultContainer_, Result_> collector);\n \n+    /**\n+     * Combines the semantics of {@link #groupBy(Function, Function)} and {@link #groupBy(UniConstraintCollector)}.\n+     * That is, the first and second facts in the tuple follow the {@link #groupBy(Function, Function)} semantics.\n+     * The third fact is the result of applying the first {@link UniConstraintCollector#finisher()} on all the tuples\n+     * of the original {@link UniConstraintStream} that belong to the group.\n+     * The fourth fact is the result of applying the second {@link UniConstraintCollector#finisher()} on all the tuples\n+     * of the original {@link UniConstraintStream} that belong to the group\n+     * @param groupKeyAMapping never null, function to convert the original tuple into a first fact\n+     * @param groupKeyBMapping never null, function to convert the original tuple into a second fact\n+     * @param collectorC never null, the collector to perform the first grouping operation with\n+     * @param collectorD never null, the collector to perform the first grouping operation with\n+     * @param <GroupKeyA_> the type of the first fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <GroupKeyB_> the type of the second fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <ResultContainerC_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <ResultC_> the type of the third fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <ResultContainerD_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <ResultD_> the type of the fourth fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKeyA_, GroupKeyB_, ResultContainerC_, ResultC_, ResultContainerD_, ResultD_>", "originalCommit": "403be23f358738ebd72de21a219e3aec7aa5cef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MjU5NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r366762595", "bodyText": "My thinking on this:\n\nThe number of use cases for n-streams will be decreasing as n is increasing. Therefore when (if) we do penta, hexa will bring even more diminishing results.\nThis could all be solved with dynamic cardinality streams, that can handle any number of parameters. (Essentially varargs.)\nHowever, that would not be done with Java generics. In this kind of work, generics is the one thing that keeps me sane. If all I had throughout constraint streams were Objects, I would have gone mad.\n\nAll in all, if we have to add more streams, I'd much rather go for Penta than for Dynamic.", "author": "triceo", "createdAt": "2020-01-15T09:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxMTkyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367311926", "bodyText": "One more thing to note - with dynamic cardinality streams not only would Lukas lose the type safety, but users as well.", "author": "rsynek", "createdAt": "2020-01-16T09:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwNTk1MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367805951", "bodyText": "At some point, we will need to support dynamic cardinality streams. We can argue whether that's at Penta, Hexa, septi, octo, novem, ..., novemnonagint, centi or higher ;) As indeed users lose type safetly.\nAs for the design, I was thinking of PolyConstraintStream extends AbstractConstraintStream<Object[]>. Either way: out of scope for now (poly and penta).", "author": "ge0ffrey", "createdAt": "2020-01-17T07:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwNjM1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367806352", "bodyText": "Just think about it for a second.\nNovemnonagintConstraintStream<A, B, C, D, E, F, G, ... 99 in total>", "author": "ge0ffrey", "createdAt": "2020-01-17T07:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxMzUzNA==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367813534", "bodyText": "@ge0ffrey The biggest pain seems to be the combinatorial explosion of grouping operations => too many possible groupKeys and collectors that bring you to/from stream of a different arity.", "author": "rsynek", "createdAt": "2020-01-17T08:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDAyOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDk1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r366760952", "bodyText": "Maybe this QuadTuple can also belongs in the quad package?\nBavet's impl does that: it's UniTuple is in the uni package, same for bi, etc.", "author": "ge0ffrey", "createdAt": "2020-01-15T09:07:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/QuadTuple.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;", "originalCommit": "403be23f358738ebd72de21a219e3aec7aa5cef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MzU3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r366763576", "bodyText": "If you open the code in the IDE, you'll see that some of these tuples are being used from more than just one package - therefore I put them all in common for the sake of consistency.", "author": "triceo", "createdAt": "2020-01-15T09:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwODY4Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367808686", "bodyText": "I wonder where the natural conclusion of these PRs (bi, tri, quad, pent..) will be!??\n\nI guess either a future Java release supports dynamic number of generic parameters or we reach the largest natural number. Whatever comes first ;-)\nThe pain we go through so our users can have a strongly typed API... :)", "author": "ge0ffrey", "createdAt": "2020-01-17T08:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MDk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e6816e5e2ce9dddd26ee0bb4ae7f22db369c95f0", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/QuadTuple.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/QuadTuple.java\nindex cbcb79aa3a..75b31fff52 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/QuadTuple.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/QuadTuple.java\n\n@@ -55,6 +55,6 @@ public final class QuadTuple<A, B, C, D> {\n \n     @Override\n     public String toString() {\n-        return \"TriTuple(\" + a + \", \" + b + \", \" + c  + \", \" + d + \")\";\n+        return \"QuadTuple(\" + a + \", \" + b + \", \" + c  + \", \" + d + \")\";\n     }\n }\n"}}, {"oid": "45e07f7b2cc1a3d5101ad0d9053fc112314dfd67", "url": "https://github.com/kiegroup/optaplanner/commit/45e07f7b2cc1a3d5101ad0d9053fc112314dfd67", "message": "Remove needless ResultContainer generic type", "committedDate": "2020-01-15T09:39:55Z", "type": "commit"}, {"oid": "19c57a10b0e452a8a6a502eb6fad1f2b9d3ad7cd", "url": "https://github.com/kiegroup/optaplanner/commit/19c57a10b0e452a8a6a502eb6fad1f2b9d3ad7cd", "message": "Rename pair to tuple", "committedDate": "2020-01-15T09:45:00Z", "type": "commit"}, {"oid": "2603c3bd797addffa2faa3742d26d8840b237ac6", "url": "https://github.com/kiegroup/optaplanner/commit/2603c3bd797addffa2faa3742d26d8840b237ac6", "message": "Remove unused imports", "committedDate": "2020-01-16T09:31:46Z", "type": "commit"}, {"oid": "e6816e5e2ce9dddd26ee0bb4ae7f22db369c95f0", "url": "https://github.com/kiegroup/optaplanner/commit/e6816e5e2ce9dddd26ee0bb4ae7f22db369c95f0", "message": "Fix QuadTuple's toString()", "committedDate": "2020-01-16T09:40:00Z", "type": "commit"}, {"oid": "13e246ee94b553e0bff039ad69eeb937a700eae9", "url": "https://github.com/kiegroup/optaplanner/commit/13e246ee94b553e0bff039ad69eeb937a700eae9", "message": "Remove needless suppliers", "committedDate": "2020-01-16T11:51:38Z", "type": "commit"}, {"oid": "4cc6fb3e58283fb0e402a4c4633e4abafd22fd26", "url": "https://github.com/kiegroup/optaplanner/commit/4cc6fb3e58283fb0e402a4c4633e4abafd22fd26", "message": "Minor Javadoc spelling fix", "committedDate": "2020-01-16T20:49:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyNDI2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367324265", "bodyText": "\"the a fact\"", "author": "rsynek", "createdAt": "2020-01-16T09:53:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java", "diffHunk": "@@ -224,9 +225,9 @@\n      * Convert the {@link BiConstraintStream} to a different {@link BiConstraintStream}, consisting of unique tuples.\n      * <p>\n      * The first fact is the return value of the first group key mapping function, applied on the incoming tuple.\n-     * The second fact is the return value of a given {@link BiConstraintCollector} applied on incoming tuples with the\n-     * same first fact.\n-     * @param groupKeyMapping never null, function to convert a fact in original tuple to a different fact\n+     * The second fact is the return value of a given {@link BiConstraintCollector} applied on all incoming tuples with\n+     * the same first fact.\n+     * @param groupKeyMapping never null, function to convert the a fact in original tuple to a different fact", "originalCommit": "e6816e5e2ce9dddd26ee0bb4ae7f22db369c95f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4cc6fb3e58283fb0e402a4c4633e4abafd22fd26", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java\nindex 67030a0300..780768e31b 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStream.java\n\n@@ -227,7 +227,7 @@ public interface BiConstraintStream<A, B> extends ConstraintStream {\n      * The first fact is the return value of the first group key mapping function, applied on the incoming tuple.\n      * The second fact is the return value of a given {@link BiConstraintCollector} applied on all incoming tuples with\n      * the same first fact.\n-     * @param groupKeyMapping never null, function to convert the a fact in original tuple to a different fact\n+     * @param groupKeyMapping never null, function to convert the fact in the original tuple to a different fact\n      * @param <GroupKey_> the type of the first fact in the destination {@link BiConstraintStream}'s tuple\n      * @param <ResultContainer_> the mutable accumulation type (often hidden as an implementation detail)\n      * @param <Result_> the type of the second fact in the destination {@link BiConstraintStream}'s tuple\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1ODI0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/656#discussion_r367358242", "bodyText": "I noticed there is a potential for some other combinations, e.g.:\n\n3 grouping functions, no collector => TriStream\n3 grouping functions, 1 collector => QuadStream\n\nBut as discussed, these might be added later.", "author": "rsynek", "createdAt": "2020-01-16T11:05:50Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java", "diffHunk": "@@ -61,6 +63,111 @@\n      */\n     QuadConstraintStream<A, B, C, D> filter(QuadPredicate<A, B, C, D> predicate);\n \n+    // ************************************************************************\n+    // Group by\n+    // ************************************************************************\n+\n+    /**\n+     * Convert the {@link QuadConstraintStream} to a {@link UniConstraintStream}, containing only a single tuple, the\n+     * result of applying {@link QuadConstraintCollector}.\n+     * {@link UniConstraintStream} which only has a single tuple, the result of applying\n+     * {@link QuadConstraintCollector}.\n+     * @param collector never null, the collector to perform the grouping operation with\n+     * @param <ResultContainer_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <Result_> the type of a fact in the destination {@link UniConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <ResultContainer_, Result_> UniConstraintStream<Result_> groupBy(\n+            QuadConstraintCollector<A, B, C, D, ResultContainer_, Result_> collector);\n+\n+    /**\n+     * Convert the {@link QuadConstraintStream} to a {@link UniConstraintStream}, containing the set of tuples resulting\n+     * from applying the group key mapping function on all tuples of the original stream.\n+     * Neither tuple of the new stream {@link Objects#equals(Object, Object)} any other.\n+     * @param groupKeyMapping never null, mapping function to convert each element in the stream to a different element\n+     * @param <GroupKey_> the type of a fact in the destination {@link UniConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKey_> UniConstraintStream<GroupKey_> groupBy(QuadFunction<A, B, C, D, GroupKey_> groupKeyMapping);\n+\n+    /**\n+     * Convert the {@link QuadConstraintStream} to a {@link BiConstraintStream}, consisting of unique tuples.\n+     * <p>\n+     * The first fact is the return value of the first group key mapping function, applied on the incoming tuple.\n+     * The second fact is the return value of a given {@link QuadConstraintCollector} applied on all incoming tuples\n+     * with the same first fact.\n+     * @param groupKeyMapping never null, function to convert the a fact in original tuple to a different fact\n+     * @param <GroupKey_> the type of the first fact in the destination {@link BiConstraintStream}'s tuple\n+     * @param <ResultContainer_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <Result_> the type of the second fact in the destination {@link BiConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKey_, ResultContainer_, Result_> BiConstraintStream<GroupKey_, Result_> groupBy(\n+            QuadFunction<A, B, C, D, GroupKey_> groupKeyMapping,\n+            QuadConstraintCollector<A, B, C, D, ResultContainer_, Result_> collector);\n+\n+    /**\n+     * Convert the {@link QuadConstraintStream} to a {@link BiConstraintStream}, consisting of unique tuples.\n+     * <p>\n+     * The first fact is the return value of the first group key mapping function, applied on the incoming tuple.\n+     * The second fact is the return value of the second group key mapping function, applied on all incoming tuples with\n+     * the same first fact.\n+     * @param groupKeyAMapping never null, function to convert the facts in the original tuple to a new fact\n+     * @param groupKeyBMapping never null, function to convert the facts in the original tuple to another new fact\n+     * @param <GroupKeyA_> the type of the first fact in the destination {@link BiConstraintStream}'s tuple\n+     * @param <GroupKeyB_> the type of the second fact in the destination {@link BiConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKeyA_, GroupKeyB_> BiConstraintStream<GroupKeyA_, GroupKeyB_> groupBy(\n+            QuadFunction<A, B, C, D, GroupKeyA_> groupKeyAMapping, QuadFunction<A, B, C, D, GroupKeyB_> groupKeyBMapping);\n+\n+    /**\n+     * Combines the semantics of {@link #groupBy(QuadFunction, QuadFunction)} and\n+     * {@link #groupBy(QuadConstraintCollector)}.\n+     * That is, the first and second facts in the tuple follow the {@link #groupBy(QuadFunction, QuadFunction)}\n+     * semantics,\n+     * and the third fact is the result of applying {@link QuadConstraintCollector#finisher()} on all the tuples of the\n+     * original {@link UniConstraintStream} that belong to the group.\n+     * @param groupKeyAMapping never null, function to convert the original tuple into a first fact\n+     * @param groupKeyBMapping never null, function to convert the original tuple into a second fact\n+     * @param collector never null, the collector to perform the grouping operation with\n+     * @param <GroupKeyA_> the type of the first fact in the destination {@link TriConstraintStream}'s tuple\n+     * @param <GroupKeyB_> the type of the second fact in the destination {@link TriConstraintStream}'s tuple\n+     * @param <ResultContainer_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <Result_> the type of the third fact in the destination {@link TriConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKeyA_, GroupKeyB_, ResultContainer_, Result_> TriConstraintStream<GroupKeyA_, GroupKeyB_, Result_> groupBy(\n+            QuadFunction<A, B, C, D, GroupKeyA_> groupKeyAMapping, QuadFunction<A, B, C, D, GroupKeyB_> groupKeyBMapping,\n+            QuadConstraintCollector<A, B, C, D, ResultContainer_, Result_> collector);\n+\n+    /**\n+     * Combines the semantics of {@link #groupBy(QuadFunction, QuadFunction)} and\n+     * {@link #groupBy(QuadConstraintCollector)}.\n+     * That is, the first and second facts in the tuple follow the {@link #groupBy(QuadFunction, QuadFunction)}\n+     * semantics.\n+     * The third fact is the result of applying the first {@link QuadConstraintCollector#finisher()} on all the tuples\n+     * of the original {@link QuadConstraintStream} that belong to the group.\n+     * The fourth fact is the result of applying the second {@link QuadConstraintCollector#finisher()} on all the tuples\n+     * of the original {@link QuadConstraintStream} that belong to the group\n+     * @param groupKeyAMapping never null, function to convert the original tuple into a first fact\n+     * @param groupKeyBMapping never null, function to convert the original tuple into a second fact\n+     * @param collectorC never null, the collector to perform the first grouping operation with\n+     * @param collectorD never null, the collector to perform the first grouping operation with\n+     * @param <GroupKeyA_> the type of the first fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <GroupKeyB_> the type of the second fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <ResultContainerC_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <ResultC_> the type of the third fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @param <ResultContainerD_> the mutable accumulation type (often hidden as an implementation detail)\n+     * @param <ResultD_> the type of the fourth fact in the destination {@link QuadConstraintStream}'s tuple\n+     * @return never null\n+     */\n+    <GroupKeyA_, GroupKeyB_, ResultContainerC_, ResultC_, ResultContainerD_, ResultD_>", "originalCommit": "e6816e5e2ce9dddd26ee0bb4ae7f22db369c95f0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4cc6fb3e58283fb0e402a4c4633e4abafd22fd26", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java\nindex e0e894e29e..7c39fe2946 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStream.java\n\n@@ -96,7 +96,7 @@ public interface QuadConstraintStream<A, B, C, D> extends ConstraintStream {\n      * The first fact is the return value of the first group key mapping function, applied on the incoming tuple.\n      * The second fact is the return value of a given {@link QuadConstraintCollector} applied on all incoming tuples\n      * with the same first fact.\n-     * @param groupKeyMapping never null, function to convert the a fact in original tuple to a different fact\n+     * @param groupKeyMapping never null, function to convert the fact in the original tuple to a different fact\n      * @param <GroupKey_> the type of the first fact in the destination {@link BiConstraintStream}'s tuple\n      * @param <ResultContainer_> the mutable accumulation type (often hidden as an implementation detail)\n      * @param <Result_> the type of the second fact in the destination {@link BiConstraintStream}'s tuple\n"}}]}