{"pr_number": 1064, "pr_title": "PLANNER-2269: Proper CS-B node indexing", "pr_createdAt": "2020-12-03T15:53:40Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1064", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535359281", "bodyText": "Don't like it, but I needed this for the test.\nThis is not public API, so we should be good.", "author": "triceo", "createdAt": "2020-12-03T15:55:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java", "diffHunk": "@@ -172,4 +172,11 @@ public void afterProblemFactRemoved(Object problemFact) {\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n+    // ************************************************************************\n+    // Getters/setters\n+    // ************************************************************************\n+\n+    public ConstraintSession<Solution_, Score_> getSession() {\n+        return session;\n+    }", "originalCommit": "1abadeb996e5d33f537da94ce7ec6014adff6489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzMzNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197335", "bodyText": "Ok. Someday we need to talk about merging ConstraintStreamSession and ConstraintStreamScoreDirector to avoid unneeded indirection :)", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1OTI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\nindex 0d1d658177..cc2a13dba6 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/stream/ConstraintStreamScoreDirector.java\n\n@@ -172,11 +172,4 @@ public class ConstraintStreamScoreDirector<Solution_, Score_ extends Score<Score\n         super.afterProblemFactRemoved(problemFact);\n     }\n \n-    // ************************************************************************\n-    // Getters/setters\n-    // ************************************************************************\n-\n-    public ConstraintSession<Solution_, Score_> getSession() {\n-        return session;\n-    }\n }\n"}}, {"oid": "5edeb52291e18cf365daf34b7ad2a42958e47364", "url": "https://github.com/kiegroup/optaplanner/commit/5edeb52291e18cf365daf34b7ad2a42958e47364", "message": "Finishing touches", "committedDate": "2020-12-03T16:01:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2NjA5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535366090", "bodyText": "This is the test that checks, for a sufficiently complex stream, that the ordering is correct.", "author": "triceo", "createdAt": "2020-12-03T16:03:53Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bavet;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n+import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n+import org.optaplanner.core.impl.score.stream.bavet.common.BavetScoringNode;\n+import org.optaplanner.core.impl.score.stream.bavet.tri.BavetScoringTriNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n+import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n+import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n+\n+public class BavetConstraintStreamNodeOrderingTest {", "originalCommit": "5edeb52291e18cf365daf34b7ad2a42958e47364", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\ndeleted file mode 100644\nindex 7073d115ad..0000000000\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintStreamNodeOrderingTest.java\n+++ /dev/null\n\n@@ -1,155 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.optaplanner.core.impl.score.stream.bavet;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.optaplanner.core.api.score.stream.Joiners.equal;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n-import org.optaplanner.core.api.score.stream.Constraint;\n-import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n-import org.optaplanner.core.api.score.stream.ConstraintFactory;\n-import org.optaplanner.core.api.score.stream.ConstraintStreamImplType;\n-import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirector;\n-import org.optaplanner.core.impl.score.director.stream.ConstraintStreamScoreDirectorFactory;\n-import org.optaplanner.core.impl.score.stream.bavet.common.BavetScoringNode;\n-import org.optaplanner.core.impl.score.stream.bavet.tri.BavetScoringTriNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetAbstractUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFilterUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetFromUniNode;\n-import org.optaplanner.core.impl.score.stream.bavet.uni.BavetJoinBridgeUniNode;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishEntity;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishSolution;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValue;\n-import org.optaplanner.core.impl.testdata.domain.score.lavish.TestdataLavishValueGroup;\n-\n-public class BavetConstraintStreamNodeOrderingTest {\n-\n-    private final Function<ConstraintFactory, Constraint> constraintProvider =\n-            factory -> factory.fromUniquePair(TestdataLavishEntity.class,\n-                    equal(TestdataLavishEntity::getEntityGroup))\n-                    .groupBy((a, b) -> a, ConstraintCollectors.countBi())\n-                    .filter((a, count) -> count > 0)\n-                    .join(TestdataLavishValueGroup.class)\n-                    .filter((a, b, valueGroup) -> false)\n-                    .penalize(\"Some constraint\", SimpleScore.ONE);\n-    private BavetConstraintSession<TestdataLavishSolution, SimpleScore> session;\n-\n-    @BeforeEach\n-    void initializeSession() {\n-        ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> scoreDirector =\n-                buildScoreDirector(constraintProvider);\n-        scoreDirector.setWorkingSolution(TestdataLavishSolution.generateSolution());\n-        session = (BavetConstraintSession<TestdataLavishSolution, SimpleScore>) scoreDirector.getSession();\n-    }\n-\n-    @Test\n-    void correctNumberOfFromNodes() {\n-        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n-        assertThat(lavishEntityFromNodeList).hasSize(1); // fromUniquePair() uses just one fromNode.\n-        List<BavetFromUniNode<Object>> lavishValueGroupFromNodeList =\n-                session.findFromNodeList(TestdataLavishValueGroup.class);\n-        assertThat(lavishValueGroupFromNodeList).hasSize(1); // join uses just one fromNode.\n-        List<BavetFromUniNode<Object>> lavishValueFromNodeList = session.findFromNodeList(TestdataLavishValue.class);\n-        assertThat(lavishValueFromNodeList).isEmpty(); // Not used in the constraint.\n-    }\n-\n-    @Test\n-    void fromUniquePair() {\n-        List<BavetFromUniNode<Object>> lavishEntityFromNodeList = session.findFromNodeList(TestdataLavishEntity.class);\n-\n-        BavetFromUniNode<Object> fromNode = lavishEntityFromNodeList.get(0);\n-        assertThat(fromNode.getNodeIndex())\n-                .as(\"fromNode is the first node of the constraint stream.\")\n-                .isEqualTo(0);\n-\n-        List<BavetAbstractUniNode<Object>> fromNodeChildNodes = fromNode.getChildNodes();\n-        assertThat(fromNodeChildNodes)\n-                .as(\"fromNode has a single child, a filterNode.\")\n-                .hasSize(1);\n-\n-        BavetFilterUniNode<Object> filterNode = (BavetFilterUniNode<Object>) fromNodeChildNodes.get(0);\n-        assertThat(filterNode.getNodeIndex())\n-                .as(\"filterNode is the second node of the constraint stream.\")\n-                .isEqualTo(1);\n-\n-        List<BavetAbstractUniNode<Object>> filterChildNodes = filterNode.getChildNodes();\n-        assertThat(filterChildNodes)\n-                .as(\"filterNode has two children, left and right join bridge for the unique pair.\")\n-                .hasSize(2);\n-\n-        BavetJoinBridgeUniNode<Object> leftJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(0);\n-        assertThat(leftJoinBridgeNode.getNodeIndex())\n-                .as(\"Left JoinBridge is the third node of the constraint stream.\")\n-                .isEqualTo(2);\n-\n-        BavetJoinBridgeUniNode<Object> rightJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) filterChildNodes.get(1);\n-        assertThat(rightJoinBridgeNode.getNodeIndex())\n-                .as(\"Right JoinBridge is the fourth node of the constraint stream.\")\n-                .isEqualTo(3);\n-    }\n-\n-    @Test\n-    void secondJoin() {\n-        List<BavetFromUniNode<Object>> lavishValueGroupFromNodeList = session.findFromNodeList(TestdataLavishValueGroup.class);\n-\n-        BavetFromUniNode<Object> fromNode = lavishValueGroupFromNodeList.get(0);\n-        assertThat(fromNode.getNodeIndex())\n-                .as(\"Second fromNode follows the join (4), group (6), filter (7), left join bridge (8).\")\n-                .isEqualTo(9);\n-\n-        List<BavetAbstractUniNode<Object>> fromNodeChildNodes = fromNode.getChildNodes();\n-        assertThat(fromNodeChildNodes)\n-                .as(\"Second fromNode has a single child, the right JoinBridge.\")\n-                .hasSize(1);\n-\n-        BavetJoinBridgeUniNode<Object> rightJoinBridgeNode = (BavetJoinBridgeUniNode<Object>) fromNodeChildNodes.get(0);\n-        assertThat(rightJoinBridgeNode.getNodeIndex())\n-                .as(\"Right JoinBridge is the eleventh node of the constraint stream.\")\n-                .isEqualTo(10);\n-    }\n-\n-    @Test\n-    void scoring() {\n-        List<BavetScoringNode> scoringNodeCollection = new ArrayList<>(session.getScoringNodes());\n-        assertThat(scoringNodeCollection).hasSize(1);\n-        assertThat(scoringNodeCollection)\n-                .first()\n-                .isInstanceOf(BavetScoringTriNode.class);\n-        BavetScoringTriNode<Object, Object, Object> scoringNode =\n-                (BavetScoringTriNode<Object, Object, Object>) scoringNodeCollection.get(0);\n-        assertThat(scoringNode.getNodeIndex())\n-                .as(\"Single scoring node follows final join (11) and filter (12).\")\n-                .isEqualTo(13);\n-    }\n-\n-    protected ConstraintStreamScoreDirector<TestdataLavishSolution, SimpleScore> buildScoreDirector(\n-            Function<ConstraintFactory, Constraint> function) {\n-        ConstraintStreamScoreDirectorFactory<TestdataLavishSolution, SimpleScore> scoreDirectorFactory =\n-                new ConstraintStreamScoreDirectorFactory<>(TestdataLavishSolution.buildSolutionDescriptor(),\n-                        (constraintFactory) -> new Constraint[] { function.apply(constraintFactory) },\n-                        ConstraintStreamImplType.BAVET);\n-        return scoreDirectorFactory.buildScoreDirector(false, false);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMDk4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535710984", "bodyText": "This is not consistent with equals().", "author": "triceo", "createdAt": "2020-12-03T23:04:38Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java", "diffHunk": "@@ -21,20 +21,24 @@\n public class BavetAbstractNode implements BavetNode {\n \n     protected final BavetConstraintSession session;\n-    protected final int nodeOrder;\n+    protected final int nodeIndex;\n \n-    public BavetAbstractNode(BavetConstraintSession session, int nodeOrder) {\n+    public BavetAbstractNode(BavetConstraintSession session, int nodeIndex) {\n         this.session = session;\n-        this.nodeOrder = nodeOrder;\n+        this.nodeIndex = nodeIndex;\n     }\n \n     // ************************************************************************\n     // Getters/setters\n     // ************************************************************************\n \n     @Override\n-    public int getNodeOrder() {\n-        return nodeOrder;\n+    public int getNodeIndex() {\n+        return nodeIndex;\n     }\n \n+    @Override\n+    public int compareTo(BavetNode o) {\n+        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n+    }", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\nindex 3673b170f5..2eb137a7ed 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetAbstractNode.java\n\n@@ -37,8 +37,4 @@ public class BavetAbstractNode implements BavetNode {\n         return nodeIndex;\n     }\n \n-    @Override\n-    public int compareTo(BavetNode o) {\n-        return Integer.compare(this.nodeIndex, o.getNodeIndex());\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r535712258", "bodyText": "All node indexes are unique now. Therefore this fail-fast makes no sense anymore.", "author": "triceo", "createdAt": "2020-12-03T23:06:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -37,18 +37,11 @@ public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount)\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public void updateNodeOrderMaximum(int nodeOrder) {\n-        if (nodeOrderMaximum < nodeOrder) {\n-            nodeOrderMaximum = nodeOrder;\n-        }\n-    }\n-\n     public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n         Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        if (node.getNodeOrder() != sharedNode.getNodeOrder()) {\n-            throw new IllegalStateException(\"Impossible state: the node (\" + node\n-                    + \")'s nodeOrder (\" + node.getNodeOrder() + \") differs from the sharedNode (\" + sharedNode\n-                    + \")'s nodeOrder (\" + sharedNode.getNodeOrder() + \").\");", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNzc4Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536217783", "bodyText": "Crap, ideally when a node is replaced by a sharedNode, it doesn't take up an extra nodeIndex.\nBecause it does, the nodeSize will be actually bigger than the number of actual nodes in place. (so it shouldn't be called nodeSize indeed and a comment should specify that strange behaviour). So the queue will have a number of empty spaces. Actually, that hurts performance...\n... so we need to recycle nodeIndexes of nodes that get shared. Maybe upon sharing, call BuildPolicy.undoNextIndex() that does nextNodeIndex--?", "author": "ge0ffrey", "createdAt": "2020-12-04T16:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2NzQzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536267439", "bodyText": "This is not an issue. Node indexes are perfectly sequential, they are never duplicated. (The \"+1 trick\" takes care of that.)", "author": "triceo", "createdAt": "2020-12-04T17:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 68d8ed9a11..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -37,12 +37,19 @@ public class BavetNodeBuildPolicy<Solution_> {\n         constraintIdToScoringNodeMap = new LinkedHashMap<>(constraintCount);\n     }\n \n-    public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n-        Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n-        int nodeIndex = sharedNode.getNodeIndex();\n+    public void updateNodeIndexMaximum(int nodeIndex) {\n         if (nodeIndexMaximum < nodeIndex) {\n             nodeIndexMaximum = nodeIndex;\n         }\n+    }\n+\n+    public <Node_ extends BavetAbstractNode> Node_ retrieveSharedNode(Node_ node) {\n+        Node_ sharedNode = (Node_) sharableNodeMap.computeIfAbsent(node, k -> node);\n+        if (node.getNodeIndex() != sharedNode.getNodeIndex()) {\n+            throw new IllegalStateException(\"Impossible state: the node (\" + node\n+                    + \")'s nodeIndex (\" + node.getNodeIndex() + \") differs from the sharedNode (\" + sharedNode\n+                    + \")'s nodeIndex (\" + sharedNode.getNodeIndex() + \").\");\n+        }\n         return sharedNode;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NzY4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536197680", "bodyText": "Actually, this is now just nodeSize (the number of nodes), I'd argue. Wdyt?", "author": "ge0ffrey", "createdAt": "2020-12-04T15:52:46Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java", "diffHunk": "@@ -48,12 +49,12 @@\n     private final ScoreInliner<Score_> scoreInliner;\n \n     private final Map<Class<?>, BavetFromUniNode<Object>> declaredClassToNodeMap;\n-    private final int nodeOrderSize;\n+    private final int nodeIndexSize;", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb1fec593b0245fd99cd51eff63dacae9e947d32", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\nindex d3741a47b8..9e31c6f010 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/BavetConstraintSession.java\n\n@@ -49,7 +50,8 @@ public final class BavetConstraintSession<Solution_, Score_ extends Score<Score_\n     private final ScoreInliner<Score_> scoreInliner;\n \n     private final Map<Class<?>, BavetFromUniNode<Object>> declaredClassToNodeMap;\n-    private final int nodeIndexSize;\n+    private final List<BavetNode> nodeIndexedNodeMap;\n+    private final int nodeCount;\n     private final Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n \n     private final Map<Class<?>, List<BavetFromUniNode<Object>>> effectiveClassToNodeListMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMTkxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536211919", "bodyText": "I wouldn't write this as an else if because the 2 conditions are unrelated and it creates the confusion that they are.\nSuggestion: replace the else with a line break. - because the sharedNode check is a quick return (special condition for which the main content of this method doesn't apply).", "author": "ge0ffrey", "createdAt": "2020-12-04T16:13:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java", "diffHunk": "@@ -277,39 +277,35 @@ public final Constraint impactScoreConfigurableBigDecimal(String constraintPacka\n     // ************************************************************************\n \n     public BavetAbstractBiNode<A, B> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, nodeOrder, parentNode);\n-        node = processNode(buildPolicy, nodeOrder, parentNode, node);\n-        createChildNodeChains(buildPolicy, constraintWeight, nodeOrder, node);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, parentNode);\n+        node = processNode(buildPolicy, parentNode, node);\n+        createChildNodeChains(buildPolicy, constraintWeight, node);\n         return node;\n     }\n \n-    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy, int nodeOrder,\n+    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n             BavetAbstractBiNode<A, B> parentNode, BavetAbstractBiNode<A, B> node) {\n-        buildPolicy.updateNodeOrderMaximum(nodeOrder);\n         BavetAbstractBiNode<A, B> sharedNode = buildPolicy.retrieveSharedNode(node);\n-        if (sharedNode != node) {\n-            // Share node\n-            node = sharedNode;\n-        } else {\n-            if (parentNode != null) { // TODO remove null check and don't go through this code like this for from and joins\n-                parentNode.addChildNode(node);\n-            }\n+        if (sharedNode != node) { // Share node\n+            return sharedNode;\n+        } else if (parentNode != null) { // TODO remove null check and don't go through this for from and joins", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\nindex 83f280b82f..4fb9d5bd95 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetAbstractBiConstraintStream.java\n\n@@ -277,35 +277,39 @@ public abstract class BavetAbstractBiConstraintStream<Solution_, A, B> extends B\n     // ************************************************************************\n \n     public BavetAbstractBiNode<A, B> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, parentNode);\n-        node = processNode(buildPolicy, parentNode, node);\n-        createChildNodeChains(buildPolicy, constraintWeight, node);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode) {\n+        BavetAbstractBiNode<A, B> node = createNode(buildPolicy, constraintWeight, nodeIndex, parentNode);\n+        node = processNode(buildPolicy, nodeIndex, parentNode, node);\n+        createChildNodeChains(buildPolicy, constraintWeight, nodeIndex, node);\n         return node;\n     }\n \n-    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n+    protected BavetAbstractBiNode<A, B> processNode(BavetNodeBuildPolicy<Solution_> buildPolicy, int nodeIndex,\n             BavetAbstractBiNode<A, B> parentNode, BavetAbstractBiNode<A, B> node) {\n+        buildPolicy.updateNodeIndexMaximum(nodeIndex);\n         BavetAbstractBiNode<A, B> sharedNode = buildPolicy.retrieveSharedNode(node);\n-        if (sharedNode != node) { // Share node\n-            return sharedNode;\n-        } else if (parentNode != null) { // TODO remove null check and don't go through this for from and joins\n-            parentNode.addChildNode(node);\n+        if (sharedNode != node) {\n+            // Share node\n+            node = sharedNode;\n+        } else {\n+            if (parentNode != null) { // TODO remove null check and don't go through this code like this for from and joins\n+                parentNode.addChildNode(node);\n+            }\n         }\n         return node;\n     }\n \n     protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n-            BavetAbstractBiNode<A, B> node) {\n+            int nodeIndex, BavetAbstractBiNode<A, B> node) {\n         if (childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"The stream (\" + this + \") leads to nowhere.\\n\"\n                     + \"Maybe don't create it.\");\n         }\n         for (BavetAbstractBiConstraintStream<Solution_, A, B> childStream : childStreamList) {\n-            childStream.createNodeChain(buildPolicy, constraintWeight, node);\n+            childStream.createNodeChain(buildPolicy, constraintWeight, nodeIndex + 1, node);\n         }\n     }\n \n     protected abstract BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536212968", "bodyText": "(important)\nThis is very wierd.\nI would expect the it take as the next Index from the buildPolicy.\nThis way the next Index doesn't increment. That's a bug I think?", "author": "ge0ffrey", "createdAt": "2020-12-04T16:15:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java", "diffHunk": "@@ -51,8 +51,8 @@ public BavetFilterBiConstraintStream(BavetConstraintFactory<Solution_> constrain\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeOrder, parentNode, predicate);\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODEzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268131", "bodyText": "The index is incremented immediately after this, when the node is checked for sharing. There is a test that checks for this.\nI am interested in counter-examples.", "author": "triceo", "createdAt": "2020-12-04T17:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMjk2OA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\nindex c61f860649..9af0c0e2ef 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetFilterBiConstraintStream.java\n\n@@ -51,8 +51,8 @@ public final class BavetFilterBiConstraintStream<Solution_, A, B> extends BavetA\n \n     @Override\n     protected BavetFilterBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n-        return new BavetFilterBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 1, parentNode, predicate);\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetFilterBiNode<>(buildPolicy.getSession(), nodeIndex, parentNode, predicate);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536213409", "bodyText": "No. This appraoch won't work with composition approaches. For complex networks we can't predict the gaps.", "author": "ge0ffrey", "createdAt": "2020-12-04T16:16:01Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java", "diffHunk": "@@ -50,19 +50,20 @@ public BavetGroupBiConstraintStream(BavetConstraintFactory<Solution_> constraint\n \n     @Override\n     public BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         return (BavetGroupBiNode<GroupKey_, ResultContainer_, Result_>) super.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder, parentNode);\n+                parentNode);\n     }\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeOrder, finisher);\n+        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2ODgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536268819", "bodyText": "Assuming that Group is always preceded by a GroupBridge, this is perfectly safe.\nOtherwise I'll need to see an example of a network where that is not the case.", "author": "triceo", "createdAt": "2020-12-04T17:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxMzQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\nindex 7031d6a5ea..25eae899bc 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBiConstraintStream.java\n\n@@ -50,20 +50,19 @@ public final class BavetGroupBiConstraintStream<Solution_, GroupKey_, ResultCont\n \n     @Override\n     public BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNodeChain(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         return (BavetGroupBiNode<GroupKey_, ResultContainer_, Result_>) super.createNodeChain(buildPolicy, constraintWeight,\n-                parentNode);\n+                nodeIndex, parentNode);\n     }\n \n     @Override\n     protected BavetGroupBiNode<GroupKey_, ResultContainer_, Result_> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n+            Score<?> constraintWeight, int nodeIndex, BavetAbstractBiNode<GroupKey_, Result_> parentNode) {\n         if (parentNode != null) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") cannot have a parentNode (\" + parentNode + \").\");\n         }\n-        // GroupBridgeNodes are created after GroupNodes, so increment by 2 to create room for the bridge inbetween.\n-        return new BavetGroupBiNode<>(buildPolicy.getSession(), buildPolicy.getNodeIndexMaximum() + 2, finisher);\n+        return new BavetGroupBiNode<>(buildPolicy.getSession(), nodeIndex, finisher);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536216091", "bodyText": "My suggestion is to remove this field and instead have\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n          \n          \n            \n                private int nextNodeIndex = 0;\n          \n          \n            \n                \n          \n          \n            \n                public int nextNodeIndex() {\n          \n          \n            \n                    return nextNodeIndex++;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nEvery time a new node is created, it call this method and automatically gets the next one.\nRemember that join nodes are created after both bridges are created, so a join will never be before it's bridges or anything before it (but we should test those nodeIndexes with a unit test).", "author": "ge0ffrey", "createdAt": "2020-12-04T16:19:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -26,7 +26,7 @@\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.", "originalCommit": "611a3b2ef0f4b1804e06af4e17fc56e56daa8fcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI2OTUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r536269518", "bodyText": "No. The entire algorithm depends on the fact, that nodeIndex is only ever actually incremented when node sharing is ruled out. It makes the algorithm incredibly simple and effective - no need for any sort of rollback.", "author": "triceo", "createdAt": "2020-12-04T17:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNjA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 68d8ed9a11..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -26,7 +26,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeIndexMaximum = -1; // So that the first node starts at 0 when it increments.\n+    private int nodeIndexMaximum = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537447074", "bodyText": "This is heavy. Thankfully it is only ever used in BavetConstraintSession constructor.\nConsidering that it gives us a fail-fast on a pretty important thing, I say we need it.", "author": "triceo", "createdAt": "2020-12-07T11:52:44Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +86,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                }, TreeMap::new));\n+        // Ensure there are no gaps in that list.\n+        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n+        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n+        if (maxNodeIndex != expectedMaxNodeIndex) {\n+            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n+                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n+        }\n+        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n+    }", "originalCommit": "98513aa276d23bb2ceac3bfc7f897abc906c6777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTY0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239643", "bodyText": "100% agree that it is worth it.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0NzA3NA=="}], "type": "inlineReview", "revised_code": {"commit": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex 6ca78816f1..6e5241e921 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -86,22 +77,4 @@ public class BavetNodeBuildPolicy<Solution_> {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n-    public List<BavetNode> getCreatedNodes() {\n-        // Make a sequential list of unique nodes.\n-        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n-                constraintIdToScoringNodeMap.values().stream())\n-                .distinct()\n-                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n-                }, TreeMap::new));\n-        // Ensure there are no gaps in that list.\n-        int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n-        int expectedMaxNodeIndex = nodeIndexToNodeMap.size() - 1;\n-        if (maxNodeIndex != expectedMaxNodeIndex) {\n-            throw new IllegalStateException(\"Impossible state: maximum node index (\" + maxNodeIndex +\n-                    \") does not match the expected maximum node count (\" + expectedMaxNodeIndex + \").\");\n-        }\n-        return Collections.unmodifiableList(new ArrayList<>(nodeIndexToNodeMap.values()));\n-    }\n-\n }\n"}}, {"oid": "6dee0a469c93a206012d395d5b6cc72aca40b2fd", "url": "https://github.com/kiegroup/optaplanner/commit/6dee0a469c93a206012d395d5b6cc72aca40b2fd", "message": "NodeOrder becomes NodeIndex", "committedDate": "2020-12-07T13:24:23Z", "type": "commit"}, {"oid": "27fa44052c64164d4601346b7943f38c78c21e4d", "url": "https://github.com/kiegroup/optaplanner/commit/27fa44052c64164d4601346b7943f38c78c21e4d", "message": "BavetNode becomes Comparable", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "url": "https://github.com/kiegroup/optaplanner/commit/fd73950f91e6330bbf5fb96b90ceaaa145b63c5e", "message": "Add a simple node index test", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "a577c40520644bf3c937f8264179be7ad88bfafe", "url": "https://github.com/kiegroup/optaplanner/commit/a577c40520644bf3c937f8264179be7ad88bfafe", "message": "processNode() does not need node index", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "05cd93dfd907bb33499b74c02647722c2cfda9e3", "url": "https://github.com/kiegroup/optaplanner/commit/05cd93dfd907bb33499b74c02647722c2cfda9e3", "message": "internalize node order maximum updates", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "66eaceb994ffd49a63b1050212006a93c3b4fd35", "url": "https://github.com/kiegroup/optaplanner/commit/66eaceb994ffd49a63b1050212006a93c3b4fd35", "message": "Order stuff properly", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "943539854e2fce9fb385cf7b038acf4d4af62eb2", "url": "https://github.com/kiegroup/optaplanner/commit/943539854e2fce9fb385cf7b038acf4d4af62eb2", "message": "Finally remove all node index arguments", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "9eee086026884c89f406ef9ee9f3f5c06079d728", "url": "https://github.com/kiegroup/optaplanner/commit/9eee086026884c89f406ef9ee9f3f5c06079d728", "message": "Finishing touches", "committedDate": "2020-12-07T13:24:24Z", "type": "commit"}, {"oid": "d85f892cacea8d12965a891b40927b62a70dfe8b", "url": "https://github.com/kiegroup/optaplanner/commit/d85f892cacea8d12965a891b40927b62a70dfe8b", "message": "Remove a bit more code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "4c0e92a181a7ab0f4daa502ba16352430beb8513", "url": "https://github.com/kiegroup/optaplanner/commit/4c0e92a181a7ab0f4daa502ba16352430beb8513", "message": "Remove some unused code", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "c7d6e55179f5eb79667316b4b446af33b7e4b247", "url": "https://github.com/kiegroup/optaplanner/commit/c7d6e55179f5eb79667316b4b446af33b7e4b247", "message": "Fix comment", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fc41f88d9974326125ccaf02637d6d574378a1ac", "url": "https://github.com/kiegroup/optaplanner/commit/fc41f88d9974326125ccaf02637d6d574378a1ac", "message": "Create group bridges in sequence", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "url": "https://github.com/kiegroup/optaplanner/commit/6931a46f5fe4d2d5b83d735ab8ecdca95ebe3a0f", "message": "Better node indexing algorithm", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "e5154a1a05c9a512d6a903ea5a685467b20af7cc", "url": "https://github.com/kiegroup/optaplanner/commit/e5154a1a05c9a512d6a903ea5a685467b20af7cc", "message": "Fail fast on node indexing", "committedDate": "2020-12-07T13:24:25Z", "type": "commit"}, {"oid": "fb1fec593b0245fd99cd51eff63dacae9e947d32", "url": "https://github.com/kiegroup/optaplanner/commit/fb1fec593b0245fd99cd51eff63dacae9e947d32", "message": "Make nodes available outside of the session", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "url": "https://github.com/kiegroup/optaplanner/commit/dcd96290c8cdddb8ddbd7d07e9b791bcebc64cf4", "message": "Improve test", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "d356b05b228975847d87854ed088983cbbdc5e43", "url": "https://github.com/kiegroup/optaplanner/commit/d356b05b228975847d87854ed088983cbbdc5e43", "message": "Address code review comments", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "71b570172a360afbf4a710a5ef20bef1cf2a2b41", "url": "https://github.com/kiegroup/optaplanner/commit/71b570172a360afbf4a710a5ef20bef1cf2a2b41", "message": "Make the node list complete", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "fa8e08e69551986e0522a604deb3956a63936d09", "url": "https://github.com/kiegroup/optaplanner/commit/fa8e08e69551986e0522a604deb3956a63936d09", "message": "Remove unused code", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "f9a1e04141463e78f1a976ea90b6165268a2a710", "url": "https://github.com/kiegroup/optaplanner/commit/f9a1e04141463e78f1a976ea90b6165268a2a710", "message": "Nodes need not be Comparable", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "commit"}, {"oid": "e483776c84cf3f5c3cf8842ef231c84d08106714", "url": "https://github.com/kiegroup/optaplanner/commit/e483776c84cf3f5c3cf8842ef231c84d08106714", "message": "Remove test that is no longer necessary", "committedDate": "2020-12-07T13:24:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r537556204", "bodyText": "Not useful anymore. We now have a better test, and that one checks the node indexes directly.", "author": "triceo", "createdAt": "2020-12-07T14:37:54Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1419,45 +1419,6 @@ public void duplicateConstraintId() {\n                 constraintStreamImplType));\n     }\n \n-    @TestTemplate\n-    public void globalNodeOrder() {", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDgzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538244837", "bodyText": "By removing it, this test also doesn't run on CS-D any more?\n+0 to remove if it's fully duplicate for Bavet, including the actual scoreCalculation verification (which seems to be the case).\nYour call.\nIf we do keep it, maybe it should be renamed to something like \"nodeIndexChallenger\" or \"joinFilterLeftBridgeVersusJoinFilterRightBridge\"? Idunno.", "author": "ge0ffrey", "createdAt": "2020-12-08T11:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0Nzk5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538247996", "bodyText": "CS-D never had node indexes, we need not worry about these things there.\nEverything else this test does is covered elsewhere.", "author": "triceo", "createdAt": "2020-12-08T11:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjIwNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzMjkwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538232907", "bodyText": "Interesting approach by pushing that here. It's inline with the rest of what Bavet currently does, so +1.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:44:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetGroupBridgeBiConstraintStream.java", "diffHunk": "@@ -57,20 +57,23 @@ public void setGroupStream(BavetGroupBiConstraintStream<Solution_, NewA, ResultC\n \n     @Override\n     protected BavetAbstractBiNode<A, B> createNode(BavetNodeBuildPolicy<Solution_> buildPolicy,\n-            Score<?> constraintWeight, int nodeOrder, BavetAbstractBiNode<A, B> parentNode) {\n-        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy, constraintWeight,\n-                nodeOrder + 1, null);\n-        BavetGroupBridgeBiNode<A, B, NewA, ResultContainer_, NewB> node = new BavetGroupBridgeBiNode<>(\n-                buildPolicy.getSession(), nodeOrder, parentNode, groupKeyMapping, collector, groupNode);\n-        return node;\n+            Score<?> constraintWeight, BavetAbstractBiNode<A, B> parentNode) {\n+        return new BavetGroupBridgeBiNode<>(buildPolicy.getSession(), buildPolicy.nextNodeIndex(), parentNode,\n+                groupKeyMapping, collector);\n     }\n \n     @Override\n-    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight, int nodeOrder,\n+    protected void createChildNodeChains(BavetNodeBuildPolicy<Solution_> buildPolicy, Score<?> constraintWeight,\n             BavetAbstractBiNode<A, B> node) {\n         if (!childStreamList.isEmpty()) {\n             throw new IllegalStateException(\"Impossible state: the stream (\" + this\n                     + \") has an non-empty childStreamList (\" + childStreamList + \") but it's a groupBy bridge.\");\n         }\n+        BavetGroupBiNode<NewA, ResultContainer_, NewB> groupNode = groupStream.createNodeChain(buildPolicy,\n+                constraintWeight, null);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNTgxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538235819", "bodyText": "Adding that zero is strange. Use at least 16 (or better yet the default): the memory cost of 16 is triviial, especially as only a handfully policy elements will exist, while the cost of sharing 9 nodes will be quite significant already.\nBy the way, due to from() filtering on initialized variables only, there is pretty much always node sharing.\nSo my advise is to remove this line's change.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:48:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -16,39 +16,39 @@\n \n package org.optaplanner.core.impl.score.stream.bavet.common;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import org.optaplanner.core.impl.score.stream.bavet.BavetConstraintSession;\n \n public class BavetNodeBuildPolicy<Solution_> {\n \n     private final BavetConstraintSession session;\n \n-    private int nodeOrderMaximum = 0;\n+    private int nextNodeIndex = 0;\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b496437ad158f4ae76af1f3602a74da64435f92b", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..ff408c3a40 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -38,7 +38,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n     private Map<String, BavetScoringNode> constraintIdToScoringNodeMap;\n     private Map<BavetJoinConstraintStream<Solution_>, BavetJoinBridgeNode> joinConstraintStreamToJoinBridgeNodeMap =\n             new HashMap<>();\n-    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>(0);\n+    private Map<BavetAbstractNode, BavetAbstractNode> sharableNodeMap = new HashMap<>();\n \n     public BavetNodeBuildPolicy(BavetConstraintSession session, int constraintCount) {\n         this.session = session;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzNzc0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538237745", "bodyText": "Why is the distinct needed on the nodes? I'd argue if they are not distinct, then node sharing is broken and we want it to fail fast.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:51:45Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..883e506d06 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -83,7 +83,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n                 constraintIdToScoringNodeMap.values().stream())\n                 .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538238603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n          \n          \n            \n                                throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");", "author": "ge0ffrey", "createdAt": "2020-12-08T10:52:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java", "diffHunk": "@@ -77,4 +77,22 @@ public int getNodeOrderMaximum() {\n         return joinConstraintStreamToJoinBridgeNodeMap;\n     }\n \n+    public List<BavetNode> getCreatedNodes() {\n+        // Make a sequential list of unique nodes.\n+        SortedMap<Integer, BavetNode> nodeIndexToNodeMap = Stream.concat(sharableNodeMap.keySet().stream(),\n+                constraintIdToScoringNodeMap.values().stream())\n+                .distinct()\n+                .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n+                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");", "originalCommit": "e483776c84cf3f5c3cf8842ef231c84d08106714", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzOTAzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1064#discussion_r538239030", "bodyText": "Motivation: grammar (\"the\", etc) and show the node index in that error message if we have it available anyway.", "author": "ge0ffrey", "createdAt": "2020-12-08T10:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzODYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\nindex ac68549ed3..883e506d06 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\n@@ -83,7 +83,7 @@ public class BavetNodeBuildPolicy<Solution_> {\n                 constraintIdToScoringNodeMap.values().stream())\n                 .distinct()\n                 .collect(Collectors.toMap(k -> k.getNodeIndex(), Function.identity(), (a, b) -> {\n-                    throw new IllegalStateException(\"Impossible state: nodes (\" + a + \") and (\" + b + \") share index.\");\n+                    throw new IllegalStateException(\"Impossible state: 2 nodes (\" + a + \", \" + b + \") share the same index (\" + a.getNodeIndex() + \").\");\n                 }, TreeMap::new));\n         // Ensure there are no gaps in that list.\n         int maxNodeIndex = nodeIndexToNodeMap.lastKey();\n"}}, {"oid": "d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "url": "https://github.com/kiegroup/optaplanner/commit/d4d5d3ca1adfc00bfe1495e2121e83fc76555fe5", "message": "Update optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/common/BavetNodeBuildPolicy.java\n\nCo-authored-by: Geoffrey De Smet <gds.geoffrey.de.smet@gmail.com>", "committedDate": "2020-12-08T11:07:46Z", "type": "commit"}, {"oid": "b496437ad158f4ae76af1f3602a74da64435f92b", "url": "https://github.com/kiegroup/optaplanner/commit/b496437ad158f4ae76af1f3602a74da64435f92b", "message": "Address code review comments", "committedDate": "2020-12-08T11:09:13Z", "type": "commit"}, {"oid": "64a07396c3afb79ad49c51513de8c2084bd8d9a0", "url": "https://github.com/kiegroup/optaplanner/commit/64a07396c3afb79ad49c51513de8c2084bd8d9a0", "message": "Fix bug", "committedDate": "2020-12-08T11:27:46Z", "type": "commit"}]}