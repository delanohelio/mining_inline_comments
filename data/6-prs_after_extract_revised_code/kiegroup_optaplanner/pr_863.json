{"pr_number": 863, "pr_title": "PLANNER-1935 Only allow to populate constraint stream from known types", "pr_createdAt": "2020-07-30T09:55:11Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/863", "timeline": [{"oid": "47e495c68e35bf7a8c22d3a3e62caf3c225e8d5c", "url": "https://github.com/kiegroup/optaplanner/commit/47e495c68e35bf7a8c22d3a3e62caf3c225e8d5c", "message": "InnerConstraintFactory becomes an abstract class", "committedDate": "2020-07-28T07:49:26Z", "type": "commit"}, {"oid": "8b6ffde393992cc394f369624e1d8efb87dfa79f", "url": "https://github.com/kiegroup/optaplanner/commit/8b6ffde393992cc394f369624e1d8efb87dfa79f", "message": "PLANNER-1935 Only allow to populate constraint stream from known types", "committedDate": "2020-07-30T09:54:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODU2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/863#discussion_r462888565", "bodyText": "It seems this could be protected to indicate it's only meant to be called by subclasses.", "author": "yurloc", "createdAt": "2020-07-30T10:00:52Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -73,6 +78,34 @@\n         }\n     }\n \n+    public <A> void assertValidFromClass(Class<A> fromClass) {", "originalCommit": "8b6ffde393992cc394f369624e1d8efb87dfa79f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MjIyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/863#discussion_r462892222", "bodyText": "Unfortunately not, I also need to call this from the streams.", "author": "triceo", "createdAt": "2020-07-30T10:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc39fe8ea2186536785d8ccd484c88709a6e2147", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\nindex 3ebdbf8e2..57a2d9487 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\n\n@@ -100,9 +100,13 @@ public abstract class InnerConstraintFactory<Solution_> implements ConstraintFac\n         boolean hasMatchingClass = allAcceptedClassSet.stream()\n                 .anyMatch(fromClass::isAssignableFrom);\n         if (!hasMatchingClass) {\n-            throw new IllegalArgumentException(\"Cannot build a constraint from class (\" + fromClass.getCanonicalName()\n-                    + \") as it is neither the same as, nor a superclass or superinterface of one of planning entities \"\n-                    + \"or problem facts (\" + allAcceptedClassSet + \").\");\n+            throw new IllegalArgumentException(\"Cannot use class (\" + fromClass.getCanonicalName()\n+                    + \") in a constraint stream as it is neither the same as, nor a superclass or superinterface of \"\n+                    + \"one of planning entities or problem facts.\\n\"\n+                    + \"Ensure that all from(), join(), ifExists() and ifNotExists() building blocks only reference \"\n+                    + \"classes assignable from planning entities or problem facts (\" + allAcceptedClassSet + \") \"\n+                    + \"annotated on the planning solution (\" + solutionDescriptor.getSolutionClass().getCanonicalName()\n+                    + \").\");\n         }\n     }\n \n"}}, {"oid": "bc39fe8ea2186536785d8ccd484c88709a6e2147", "url": "https://github.com/kiegroup/optaplanner/commit/bc39fe8ea2186536785d8ccd484c88709a6e2147", "message": "Better exception message", "committedDate": "2020-07-30T10:03:50Z", "type": "commit"}, {"oid": "bc39fe8ea2186536785d8ccd484c88709a6e2147", "url": "https://github.com/kiegroup/optaplanner/commit/bc39fe8ea2186536785d8ccd484c88709a6e2147", "message": "Better exception message", "committedDate": "2020-07-30T10:03:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDQ4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/863#discussion_r462890482", "bodyText": "Static imports are preferred for assertions, mock methods, etc. in tests. I know this is not enforced and what's not enforced that's allowed but I think it's a good idea to follow some extra rules even they're not enforced and more importantly be consistent about them.", "author": "yurloc", "createdAt": "2020-07-30T10:04:35Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStreamTest.java", "diffHunk": "@@ -153,6 +154,21 @@ public void filterConsecutive() {\n     // If (not) exists\n     // ************************************************************************\n \n+    @TestTemplate\n+    public void ifExists_unknownClass() {\n+        assumeDrools();\n+        Assertions.assertThatThrownBy(() -> buildScoreDirector((factory) -> {", "originalCommit": "8b6ffde393992cc394f369624e1d8efb87dfa79f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "894dbfb850fb24aa4fb5d53ffa57727d58d8b362", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStreamTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStreamTest.java\nindex a0f1f65a0..38ae0aa13 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStreamTest.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/quad/QuadConstraintStreamTest.java\n\n@@ -157,7 +156,7 @@ public class QuadConstraintStreamTest extends AbstractConstraintStreamTest {\n     @TestTemplate\n     public void ifExists_unknownClass() {\n         assumeDrools();\n-        Assertions.assertThatThrownBy(() -> buildScoreDirector((factory) -> {\n+        assertThatThrownBy(() -> buildScoreDirector((factory) -> {\n             return factory.from(TestdataLavishEntity.class)\n                     .join(TestdataLavishEntityGroup.class, equal(TestdataLavishEntity::getEntityGroup, identity()))\n                     .join(TestdataLavishValue.class, equal((entity, group) -> entity.getValue(), identity()))\n"}}, {"oid": "b58ea318a2552e951478d6b523254526fada28bf", "url": "https://github.com/kiegroup/optaplanner/commit/b58ea318a2552e951478d6b523254526fada28bf", "message": "Even better exception message", "committedDate": "2020-07-30T10:07:01Z", "type": "commit"}, {"oid": "894dbfb850fb24aa4fb5d53ffa57727d58d8b362", "url": "https://github.com/kiegroup/optaplanner/commit/894dbfb850fb24aa4fb5d53ffa57727d58d8b362", "message": "Address review comments", "committedDate": "2020-07-30T10:09:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NDE1Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/863#discussion_r462894156", "bodyText": "I like this. It improves readability. I used to be afraid of static imports in the past because they make it difficult to guess where the method comes from but in some cases, like this one, they're not confusing at all. In the context of a stream it's always clear what toSet() or toList() means. I'm going to apply this style in my code as well.", "author": "yurloc", "createdAt": "2020-07-30T10:11:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java", "diffHunk": "@@ -96,15 +98,19 @@\n                             ProblemFactCollectionProperty.class, entry.getKey());\n                 });\n         Set<Class> allAcceptedClassSet = concat(concat(entityClassStream, factClassStream), factCollectionClassStream)\n-                .collect(Collectors.toSet());\n+                .collect(toSet());", "originalCommit": "b58ea318a2552e951478d6b523254526fada28bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "14763947f22ab42f319ba25f94aec3137e06707b", "chunk": "diff --git a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\nindex a810929a9..fdf78b5ae 100644\n--- a/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\n+++ b/optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/InnerConstraintFactory.java\n\n@@ -99,14 +99,20 @@ public abstract class InnerConstraintFactory<Solution_> implements ConstraintFac\n                 });\n         Set<Class> allAcceptedClassSet = concat(concat(entityClassStream, factClassStream), factCollectionClassStream)\n                 .collect(toSet());\n-        boolean hasMatchingClass = allAcceptedClassSet.stream()\n-                .anyMatch(fromClass::isAssignableFrom);\n-        if (!hasMatchingClass) {\n+        /*\n+         * Need to support the following situations:\n+         * 1/ FactType == FromType; querying for the declared type.\n+         * 2/ FromType extends/implements FactType; querying for impl type where declared type is its interface.\n+         * 3/ FromType super FactType; querying for interface where declared type is its implementation.\n+         */\n+        boolean hasMatchingType = allAcceptedClassSet.stream()\n+                .anyMatch(factType -> fromType.isAssignableFrom(factType) || factType.isAssignableFrom(fromType));\n+        if (!hasMatchingType) {\n             List<String> canonicalClassNameList = allAcceptedClassSet.stream()\n                     .map(Class::getCanonicalName)\n                     .sorted()\n                     .collect(toList());\n-            throw new IllegalArgumentException(\"Cannot use class (\" + fromClass.getCanonicalName()\n+            throw new IllegalArgumentException(\"Cannot use class (\" + fromType.getCanonicalName()\n                     + \") in a constraint stream as it is neither the same as, nor a superclass or superinterface of \"\n                     + \"one of planning entities or problem facts.\\n\"\n                     + \"Ensure that all from(), join(), ifExists() and ifNotExists() building blocks only reference \"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NjQ4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/863#discussion_r462896482", "bodyText": "If the code throws the IllegalArgumentException in a different situation, the test won't notice. The IAE is one of the most used exceptions in the optaplanner codebase.\nSuggestion: add a check for a specific substring of the exception message.", "author": "rsynek", "createdAt": "2020-07-30T10:15:43Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStreamTest.java", "diffHunk": "@@ -404,6 +404,16 @@ public void join_mixedEqualsAndFiltering() {\n     // If (not) exists\n     // ************************************************************************\n \n+    @TestTemplate\n+    public void ifExists_unknownClass() {\n+        assumeDrools();\n+        assertThatThrownBy(() -> buildScoreDirector((factory) -> {\n+            return factory.fromUniquePair(TestdataLavishEntity.class)\n+                    .ifExists(Integer.class)\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n+        })).isInstanceOf(IllegalArgumentException.class);", "originalCommit": "894dbfb850fb24aa4fb5d53ffa57727d58d8b362", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a76f82df25a7d41e83ce6269908b1c40d13fb0fc", "chunk": "diff --git a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStreamTest.java b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStreamTest.java\nindex 25702c58f..303846ab0 100644\n--- a/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStreamTest.java\n+++ b/optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/bi/BiConstraintStreamTest.java\n\n@@ -411,7 +411,9 @@ public class BiConstraintStreamTest extends AbstractConstraintStreamTest {\n             return factory.fromUniquePair(TestdataLavishEntity.class)\n                     .ifExists(Integer.class)\n                     .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n-        })).isInstanceOf(IllegalArgumentException.class);\n+        })).isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(Integer.class.getCanonicalName())\n+                .hasMessageContaining(\"assignable from\");\n     }\n \n     @TestTemplate\n"}}, {"oid": "14763947f22ab42f319ba25f94aec3137e06707b", "url": "https://github.com/kiegroup/optaplanner/commit/14763947f22ab42f319ba25f94aec3137e06707b", "message": "Fix bug identified by example tests", "committedDate": "2020-07-30T10:30:57Z", "type": "commit"}, {"oid": "a76f82df25a7d41e83ce6269908b1c40d13fb0fc", "url": "https://github.com/kiegroup/optaplanner/commit/a76f82df25a7d41e83ce6269908b1c40d13fb0fc", "message": "Address further code review comments", "committedDate": "2020-07-30T10:37:00Z", "type": "commit"}]}