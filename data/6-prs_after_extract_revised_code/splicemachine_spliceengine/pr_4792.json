{"pr_number": 4792, "pr_title": "DB-10967 added splice.function.timestampFormat", "pr_createdAt": "2020-12-06T22:02:02Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4792", "timeline": [{"oid": "7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "url": "https://github.com/splicemachine/spliceengine/commit/7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "message": "DB-10967 added splice.function.timestampFormat\n\ne.g.\ncall SYSCS_UTIL.SYSCS_SET_GLOBAL_DATABASE_PROPERTY( 'splice.function.timestampFormat', 'yyyy-MM-dd-HH.mm.ss.SSSSSSSS'); -- IBM style", "committedDate": "2020-12-06T22:01:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMzUzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537133537", "bodyText": "I think you can remove this method.", "author": "hatyo", "createdAt": "2020-12-06T22:02:58Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java", "diffHunk": "@@ -730,6 +731,9 @@\n     int getCurrentTimestampPrecision();\n \n     int getTimestampPrecision();", "originalCommit": "7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java b/db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java\nindex 4aee5189c2..0891dded26 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java\n\n@@ -726,11 +725,8 @@ public interface CompilerContext extends Context\n \n     void setCurrentTimestampPrecision(int newValue);\n \n-    void setTimestampPrecision(int newValue);\n-\n     int getCurrentTimestampPrecision();\n \n-    int getTimestampPrecision();\n     void setTimestampFormat(String timestampFormat);\n \n     String getTimestampFormat();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMzc1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537133750", "bodyText": "This can be removed.", "author": "hatyo", "createdAt": "2020-12-06T22:04:10Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -122,6 +127,10 @@ public void setStringFormat(int format) {\n         stringFormat = format;\n     }\n \n+    public void setTimestampFormat(String format) {\n+        timestampFormat = format;\n+    }\n+\n     public void setPrecision(int precision) {\n         this.precision = precision;\n     }", "originalCommit": "7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\nindex 1f564acd3c..2a657f3c12 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n\n@@ -131,10 +129,6 @@ public final class SQLTimestamp extends DataType\n         timestampFormat = format;\n     }\n \n-    public void setPrecision(int precision) {\n-        this.precision = precision;\n-    }\n-\n     // Check for a version 2.0 timestamp out of bounds.\n     public static long checkV2Bounds(Timestamp timestamp) throws StandardException{\n         long millis = timestamp.getTime();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzNDAzMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537134032", "bodyText": "timestampPrecisionString can be removed along with the related logic from GenericStatement.", "author": "hatyo", "createdAt": "2020-12-06T22:05:49Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStatement.java", "diffHunk": "@@ -620,6 +622,21 @@ else if (newMergeJoinString.equals(\"forced\"))\n                 }\n                 cc.setCurrentTimestampPrecision(currentTimestampPrecision);\n \n+                String timestampFormatString =\n+                        PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_TIMESTAMP_FORMAT);\n+                if(timestampFormatString == null)\n+                    cc.setTimestampFormat(CompilerContext.DEFAULT_TIMESTAMP_FORMAT);\n+                else {\n+                    try {\n+                        // DB-10968 we shouldn't even allow setting this to the wrong value\n+                        DateTimeFormatter.ofPattern(timestampFormatString);\n+                    } catch(Exception e)\n+                    {\n+                        timestampFormatString = CompilerContext.DEFAULT_TIMESTAMP_FORMAT;\n+                    }\n+                    cc.setTimestampFormat(timestampFormatString);\n+                }\n+\n                 String timestampPrecisionString =", "originalCommit": "7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStatement.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStatement.java\nindex 1b7428aa1f..26cf977569 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStatement.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericStatement.java\n\n@@ -462,259 +455,27 @@ public class GenericStatement implements Statement{\n                     cc.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);\n                 }\n \n-                /* get the selectivity estimation property so that we know what strategy to use to estimate selectivity */\n-                String selectivityEstimationString = PropertyUtil.getServiceProperty(lcc.getTransactionCompile(),\n-                Property.SELECTIVITY_ESTIMATION_INCLUDING_SKEWED);\n-                Boolean selectivityEstimationIncludingSkewedDefault = Boolean.parseBoolean(selectivityEstimationString);\n-\n-                cc.setSelectivityEstimationIncludingSkewedDefault(selectivityEstimationIncludingSkewedDefault);\n-\n-                /* check if the optimization to do projection pruning is enabled or not */\n-                String projectionPruningOptimizationString = PropertyUtil.getCachedDatabaseProperty(lcc,\n-                Property.PROJECTION_PRUNING_DISABLED);\n-                // if database property is not set, treat it as false\n-                Boolean projectionPruningOptimizationDisabled = false;\n-                try {\n-                    if (projectionPruningOptimizationString != null)\n-                        projectionPruningOptimizationDisabled = Boolean.parseBoolean(projectionPruningOptimizationString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setProjectionPruningEnabled(!projectionPruningOptimizationDisabled);\n-\n-                // User can specify the max length of multicolumn IN list the optimizer may build for\n-                // use as a probe predicate.  Single-column IN lists can be combined up until the point\n-                // where adding in the next IN predicate would push us over the limit.\n-                String maxMulticolumnProbeValuesString = PropertyUtil.getCachedDatabaseProperty(lcc, Property.MAX_MULTICOLUMN_PROBE_VALUES);\n-                int maxMulticolumnProbeValues = CompilerContext.DEFAULT_MAX_MULTICOLUMN_PROBE_VALUES;\n-                try {\n-                    if (maxMulticolumnProbeValuesString != null)\n-                        maxMulticolumnProbeValues = Integer.parseInt(maxMulticolumnProbeValuesString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to an int, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                if (maxMulticolumnProbeValues > MAX_MULTICOLUMN_PROBE_VALUES_MAX_VALUE)\n-                    maxMulticolumnProbeValues = MAX_MULTICOLUMN_PROBE_VALUES_MAX_VALUE;\n-                cc.setMaxMulticolumnProbeValues(maxMulticolumnProbeValues);\n-\n-                String multicolumnInlistProbeOnSparkEnabledString = PropertyUtil.getCachedDatabaseProperty(lcc, Property.MULTICOLUMN_INLIST_PROBE_ON_SPARK_ENABLED);\n-                boolean multicolumnInlistProbeOnSparkEnabled = CompilerContext.DEFAULT_MULTICOLUMN_INLIST_PROBE_ON_SPARK_ENABLED;\n-                try {\n-                    if (multicolumnInlistProbeOnSparkEnabledString != null)\n-                        multicolumnInlistProbeOnSparkEnabled = Boolean.parseBoolean(multicolumnInlistProbeOnSparkEnabledString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setMulticolumnInlistProbeOnSparkEnabled(multicolumnInlistProbeOnSparkEnabled);\n-\n-                String convertMultiColumnDNFPredicatesToInListString = PropertyUtil.getCachedDatabaseProperty(lcc, Property.CONVERT_MULTICOLUMN_DNF_PREDICATES_TO_INLIST);\n-                boolean convertMultiColumnDNFPredicatesToInList = CompilerContext.DEFAULT_CONVERT_MULTICOLUMN_DNF_PREDICATES_TO_INLIST;\n-                try {\n-                    if (convertMultiColumnDNFPredicatesToInListString != null)\n-                        convertMultiColumnDNFPredicatesToInList = Boolean.parseBoolean(convertMultiColumnDNFPredicatesToInListString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setConvertMultiColumnDNFPredicatesToInList(convertMultiColumnDNFPredicatesToInList);\n-\n-                String disablePredicateSimplificationString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.DISABLE_PREDICATE_SIMPLIFICATION);\n-                boolean disablePredicateSimplification = CompilerContext.DEFAULT_DISABLE_PREDICATE_SIMPLIFICATION;\n-                try {\n-                    if (disablePredicateSimplificationString != null)\n-                        disablePredicateSimplification =\n-                        Boolean.parseBoolean(disablePredicateSimplificationString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setDisablePredicateSimplification(disablePredicateSimplification);\n-\n-                String nativeSparkAggregationModeString = PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_NATIVE_SPARK_AGGREGATION_MODE);\n-                CompilerContext.NativeSparkModeType nativeSparkAggregationMode = CompilerContext.DEFAULT_SPLICE_NATIVE_SPARK_AGGREGATION_MODE;\n-                try {\n-                    if (nativeSparkAggregationModeString != null) {\n-                        nativeSparkAggregationModeString = nativeSparkAggregationModeString.toLowerCase();\n-                        switch (nativeSparkAggregationModeString) {\n-                            case \"on\":\n-                                nativeSparkAggregationMode = CompilerContext.NativeSparkModeType.ON;\n-                                break;\n-                            case \"off\":\n-                                nativeSparkAggregationMode = CompilerContext.NativeSparkModeType.OFF;\n-                                break;\n-                            case \"forced\":\n-                                nativeSparkAggregationMode = CompilerContext.NativeSparkModeType.FORCED;\n-                                break;\n-                            default:\n-                                // use default value\n-                                break;\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    // If the property value failed to get decoded to a valid value, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setNativeSparkAggregationMode(nativeSparkAggregationMode);\n-\n-                String allowOverflowSensitiveNativeSparkExpressionsString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_ALLOW_OVERFLOW_SENSITIVE_NATIVE_SPARK_EXPRESSIONS);\n-                boolean allowOverflowSensitiveNativeSparkExpressions = CompilerContext.DEFAULT_SPLICE_ALLOW_OVERFLOW_SENSITIVE_NATIVE_SPARK_EXPRESSIONS;\n-                try {\n-                    if (allowOverflowSensitiveNativeSparkExpressionsString != null)\n-                        allowOverflowSensitiveNativeSparkExpressions =\n-                        Boolean.parseBoolean(allowOverflowSensitiveNativeSparkExpressionsString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setAllowOverflowSensitiveNativeSparkExpressions(allowOverflowSensitiveNativeSparkExpressions);\n-\n-                String newMergeJoinString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_NEW_MERGE_JOIN);\n-                CompilerContext.NewMergeJoinExecutionType newMergeJoin =\n-                CompilerContext.DEFAULT_SPLICE_NEW_MERGE_JOIN;\n-                try {\n-                    if (newMergeJoinString != null) {\n-                        newMergeJoinString = newMergeJoinString.toLowerCase();\n-                        if (newMergeJoinString.equals(\"on\"))\n-                            newMergeJoin = CompilerContext.NewMergeJoinExecutionType.ON;\n-                        else if (newMergeJoinString.equals(\"off\"))\n-                            newMergeJoin = CompilerContext.NewMergeJoinExecutionType.OFF;\n-                        else if (newMergeJoinString.equals(\"forced\"))\n-                            newMergeJoin = CompilerContext.NewMergeJoinExecutionType.FORCED;\n-                    }\n-                } catch (Exception e) {\n-                    // If the property value failed to get decoded to a valid value, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setNewMergeJoin(newMergeJoin);\n-\n-                String disablePerParallelTaskJoinCostingString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.DISABLE_PARALLEL_TASKS_JOIN_COSTING);\n-                boolean disablePerParallelTaskJoinCosting = CompilerContext.DEFAULT_DISABLE_PARALLEL_TASKS_JOIN_COSTING;\n-                try {\n-                    if (disablePerParallelTaskJoinCostingString != null)\n-                        disablePerParallelTaskJoinCosting =\n-                        Boolean.parseBoolean(disablePerParallelTaskJoinCostingString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setDisablePerParallelTaskJoinCosting(disablePerParallelTaskJoinCosting);\n-\n-                String currentTimestampPrecisionString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_CURRENT_TIMESTAMP_PRECISION);\n-                int currentTimestampPrecision = CompilerContext.DEFAULT_SPLICE_CURRENT_TIMESTAMP_PRECISION;\n-                try {\n-                    if (currentTimestampPrecisionString != null)\n-                        currentTimestampPrecision = Integer.parseInt(currentTimestampPrecisionString);\n-                    if (currentTimestampPrecision < 0)\n-                        currentTimestampPrecision = 0;\n-                    if (currentTimestampPrecision > 9)\n-                        currentTimestampPrecision = 9;\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setCurrentTimestampPrecision(currentTimestampPrecision);\n-\n-                String timestampFormatString =\n-                        PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_TIMESTAMP_FORMAT);\n-                if(timestampFormatString == null)\n-                    cc.setTimestampFormat(CompilerContext.DEFAULT_TIMESTAMP_FORMAT);\n-                else {\n-                    try {\n-                        // DB-10968 we shouldn't even allow setting this to the wrong value\n-                        DateTimeFormatter.ofPattern(timestampFormatString);\n-                    } catch(Exception e)\n-                    {\n-                        timestampFormatString = CompilerContext.DEFAULT_TIMESTAMP_FORMAT;\n-                    }\n-                    cc.setTimestampFormat(timestampFormatString);\n-                }\n-\n-                String timestampPrecisionString =\n-                        PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_TIMESTAMP_PRECISION);\n-                int timestampPrecision = CompilerContext.DEFAULT_TIMESTAMP_PRECISION;\n-                try {\n-                    if (timestampPrecisionString != null)\n-                        timestampPrecision = Integer.parseInt(timestampPrecisionString);\n-                    if (timestampPrecision < Limits.MIN_TIMESTAMP_PRECISION)\n-                        timestampPrecision = Limits.MIN_TIMESTAMP_PRECISION;\n-                    if (timestampPrecision > Limits.MAX_TIMESTAMP_PRECISION)\n-                        timestampPrecision = Limits.MAX_TIMESTAMP_PRECISION;\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setTimestampPrecision(timestampPrecision);\n-\n-                String outerJoinFlatteningDisabledString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.OUTERJOIN_FLATTENING_DISABLED);\n-                boolean outerJoinFlatteningDisabled = CompilerContext.DEFAULT_OUTERJOIN_FLATTENING_DISABLED;\n-                try {\n-                    if (outerJoinFlatteningDisabledString != null)\n-                        outerJoinFlatteningDisabled = Boolean.parseBoolean(outerJoinFlatteningDisabledString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setOuterJoinFlatteningDisabled(outerJoinFlatteningDisabled);\n+                setSelectivityEstimationIncludingSkewedDefault(lcc, cc);\n+                setProjectionPruningEnabled(lcc, cc);\n+                setMaxMulticolumnProbeValues(lcc, cc);\n+                setMulticolumnInlistProbeOnSparkEnabled(lcc, cc);\n+                setConvertMultiColumnDNFPredicatesToInList(lcc, cc);\n+                setDisablePredicateSimplification(lcc, cc);\n+                setNativeSparkAggregationMode(lcc, cc);\n+                setAllowOverflowSensitiveNativeSparkExpressions(lcc, cc);\n+                setNewMergeJoin(lcc, cc);\n+                setDisableParallelTaskJoinCosting(lcc, cc);\n+                setCurrentTimestampPrecision(lcc, cc);\n+                setOuterJoinFlatteningDisabled(lcc, cc);\n \n                 if (!cc.isSparkVersionInitialized()) {\n-                    // If splice.spark.version is manually set, use it...\n-                    String spliceSparkVersionString = System.getProperty(SPLICE_SPARK_VERSION);\n-                    SparkVersion sparkVersion = new SimpleSparkVersion(spliceSparkVersionString);\n-\n-                    // ... otherwise pick up the splice compile-time version of spark.\n-                    if (sparkVersion.isUnknown()) {\n-                        spliceSparkVersionString = System.getProperty(SPLICE_SPARK_COMPILE_VERSION);\n-                        sparkVersion = new SimpleSparkVersion(spliceSparkVersionString);\n-                        if (sparkVersion.isUnknown())\n-                            sparkVersion = CompilerContext.DEFAULT_SPLICE_SPARK_VERSION;\n-                    }\n-                    cc.setSparkVersion(sparkVersion);\n-                }\n-\n-                String ssqFlatteningForUpdateDisabledString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.SSQ_FLATTENING_FOR_UPDATE_DISABLED);\n-                boolean ssqFlatteningForUpdateDisabled = CompilerContext.DEFAULT_SSQ_FLATTENING_FOR_UPDATE_DISABLED;\n-                try {\n-                    if (ssqFlatteningForUpdateDisabledString != null)\n-                        ssqFlatteningForUpdateDisabled =\n-                        Boolean.parseBoolean(ssqFlatteningForUpdateDisabledString);\n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n+                    setSparkVersion(cc);\n                 }\n-                cc.setSSQFlatteningForUpdateDisabled(ssqFlatteningForUpdateDisabled);\n-\n-                String varcharDB2CompatibilityModeString =\n-                PropertyUtil.getCachedDatabaseProperty(lcc, Property.SPLICE_DB2_VARCHAR_COMPATIBLE);\n-                boolean varcharDB2CompatibilityMode = CompilerContext.DEFAULT_SPLICE_DB2_VARCHAR_COMPATIBLE;\n-                try {\n-                    if (varcharDB2CompatibilityModeString != null)\n-                        varcharDB2CompatibilityMode =\n-                        Boolean.parseBoolean(varcharDB2CompatibilityModeString);\n-                    if (varcharDB2CompatibilityMode) {\n-                        CharTypeCompiler charTC = getCurrentCharTypeCompiler(lcc);\n-                        if (charTC != null) {\n-                            charTC.setDB2VarcharCompatibilityMode(varcharDB2CompatibilityMode);\n-                            lcc.setDB2VarcharCompatibilityModeNeedsReset(true, charTC);\n-                        }\n-                    }\n \n-                } catch (Exception e) {\n-                    // If the property value failed to convert to a boolean, don't throw an error,\n-                    // just use the default setting.\n-                }\n-                cc.setVarcharDB2CompatibilityMode(varcharDB2CompatibilityMode);\n+                setSSQFlatteningForUpdateDisabled(lcc, cc);\n+                setVarcharDB2CompatibilityMode(lcc, cc);\n             }\n-            fourPhasePrepare(lcc,paramDefaults,timestamps,beginTimestamp,foundInCache,cc,boundAndOptimizedStatement);\n+            fourPhasePrepare(lcc,paramDefaults,timestamps,foundInCache,cc,boundAndOptimizedStatement);\n         }catch(StandardException se){\n             if(foundInCache)\n                 ((GenericLanguageConnectionContext)lcc).removeStatement(this);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzNDIyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537134220", "bodyText": "this can be removed.", "author": "hatyo", "createdAt": "2020-12-06T22:06:40Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CompilerContextImpl.java", "diffHunk": "@@ -1184,6 +1192,8 @@ public int getNextOJLevel() {\n     private       boolean                             allowOverflowSensitiveNativeSparkExpressions = DEFAULT_SPLICE_ALLOW_OVERFLOW_SENSITIVE_NATIVE_SPARK_EXPRESSIONS;\n     private       int                                 currentTimestampPrecision                    = DEFAULT_SPLICE_CURRENT_TIMESTAMP_PRECISION;\n     private       int                                 timestampPrecision                           = DEFAULT_TIMESTAMP_PRECISION;", "originalCommit": "7a25fbc5357297576da32f01ee607c2f2e6fbbe4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CompilerContextImpl.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CompilerContextImpl.java\nindex 5bc32480ab..adce70a4f0 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CompilerContextImpl.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CompilerContextImpl.java\n\n@@ -1191,7 +1185,6 @@ public class CompilerContextImpl extends ContextImpl\n     private       CompilerContext.NativeSparkModeType nativeSparkAggregationMode                   = DEFAULT_SPLICE_NATIVE_SPARK_AGGREGATION_MODE;\n     private       boolean                             allowOverflowSensitiveNativeSparkExpressions = DEFAULT_SPLICE_ALLOW_OVERFLOW_SENSITIVE_NATIVE_SPARK_EXPRESSIONS;\n     private       int                                 currentTimestampPrecision                    = DEFAULT_SPLICE_CURRENT_TIMESTAMP_PRECISION;\n-    private       int                                 timestampPrecision                           = DEFAULT_TIMESTAMP_PRECISION;\n \n     private       String                              timestampFormat                              = DEFAULT_TIMESTAMP_FORMAT;\n     // Used to track the flattened half outer joins.\n"}}, {"oid": "3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "url": "https://github.com/splicemachine/spliceengine/commit/3ef461c4af9b51af8df283ffa7430bbb6c06e3d2", "message": "DB-10967 code review: remove timestampPrecision, some refactoring", "committedDate": "2020-12-07T10:35:36Z", "type": "commit"}, {"oid": "89b16bcb5e27e37045eee255f55a8f538ca34cd0", "url": "https://github.com/splicemachine/spliceengine/commit/89b16bcb5e27e37045eee255f55a8f538ca34cd0", "message": "DB-10967 disallow non-fixedsize timestampFormats", "committedDate": "2020-12-07T12:57:05Z", "type": "forcePushed"}, {"oid": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "url": "https://github.com/splicemachine/spliceengine/commit/e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "message": "DB-10967 disallow non-fixedsize timestampFormats", "committedDate": "2020-12-07T12:58:15Z", "type": "commit"}, {"oid": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "url": "https://github.com/splicemachine/spliceengine/commit/e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "message": "DB-10967 disallow non-fixedsize timestampFormats", "committedDate": "2020-12-07T12:58:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMTQ5Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537511492", "bodyText": "I would elevate it to a standard SQL exception with an error code. DB2 throws error with SQLState 22007 if one attempts e.g. the following:\nINSERT INTO t1 (c1) VALUES (TIMESTAMP_FORMAT('1999-12-31 23:59:59', 'YYYY-MM-sadsdDD HH24:MI:SXXXS'))\n\nSQL20447N  Format string \"YYYY-MM-sadsdDD HH24:MI:SXXXS\" is not valid for the \n\"SYSIBM.TIMESTAMP_FORMAT\" function.  SQLSTATE=22007\n\nI suggest to use the same here.", "author": "hatyo", "createdAt": "2020-12-07T13:37:40Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -169,12 +172,57 @@ public int estimateMemoryUsage()\n         return BASE_MEMORY_USAGE;\n     } // end of estimateMemoryUsage\n \n-    private static String format(Timestamp timestamp, String timeStampFormat) {\n+    /**\n+     * this also checks if the format is a valid fixed-size timestamp format\n+     * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n+     * we support:\n+     * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n+     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * @param format\n+     * @throws IllegalArgumentException if format is not supported\n+     * @return length of format\n+     */\n+    public static int getFormatLength(String format) throws IllegalArgumentException\n+    {\n+        byte[] b = format.getBytes(Bytes.UTF8_CHARSET);\n+        int repeat = 0;\n+        char last = (char)b[0];\n+        int length = b.length;\n+        for(int i=0; i<b.length+1; i++) {\n+            if (i != b.length && (char) b[i] == last) {\n+                repeat++;\n+                continue;\n+            }\n+            int r = repeat;\n+            char l = last;\n+            repeat = 1;\n+            if( i != b.length)\n+                last = (char) b[i];\n+            if ((l == 'y' || l == 'u') && (r == 4 || r == 2)) continue;\n+            else if (r == 2 &&  \"MmdHhs\".indexOf(l) != -1 ) continue;\n+            else if (r == 3 && (l == 'e' || l == 'E')) continue;\n+            else if (l == 'S') continue;\n+            else if (r == 1) {\n+                if (l == 'a') {\n+                    length++;\n+                    continue;\n+                }\n+                if(\" ,.-/:\".indexOf(l) != -1) continue;\n+            }\n+            throw new IllegalArgumentException(\"not supported format \\\"\" + format + \"\\\": '\" + l + \"' can't be repeated \" + r + \" times\");\n+        }", "originalCommit": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NjE1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537586154", "bodyText": "i agree, however customer doesn't see this message currently since we don't check this at call SYSCS_UTIL.SYSCS_SET_GLOBAL_DATABASE_PROPERTY( 'splice.function.timestampFormat', 'yyyy-MM-dd-HH.mm.ss.SSSSSSSS'); but only later where we can't throw . i created a task/bug for this: DB-10968", "author": "martinrupp", "createdAt": "2020-12-07T15:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMTQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8391ba0499afa525833be5ef55aeb33946dcaea1", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\nindex d58b0ff89c..88fccb7fd0 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n\n@@ -177,7 +177,7 @@ public final class SQLTimestamp extends DataType\n      * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n      * we support:\n      * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n-     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * up to 9x S (nanoseconds), and other characters \" ,.-/:\"\n      * @param format\n      * @throws IllegalArgumentException if format is not supported\n      * @return length of format\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxODI2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537518268", "bodyText": "Can you iterate i only until b.length and not b.length+1? i.e. can we rewrite to:\n        for(int i=0; i<b.length; i++) {\n            if ((char) b[i] == last) {\n                repeat++;\n                continue;\n            }\n            int r = repeat;\n            char l = last;\n            repeat = 1;\n            last = (char) b[i];\n            if ((l == 'y' || l == 'u') && (r == 4 || r == 2)) continue;\n            else if (r == 2 &&  \"MmdHhs\".indexOf(l) != -1 ) continue;\n            else if (r == 3 && (l == 'e' || l == 'E')) continue;\n            else if (l == 'S') continue;\n            else if (r == 1) {\n                if (l == 'a') {\n                    length++;\n                    continue;\n                }\n                if(\" ,.-/:\".indexOf(l) != -1) continue;\n            }\n            throw new IllegalArgumentException(\"not supported format \\\"\" + format + \"\\\": '\" + l + \"' can't be repeated \" + r + \" times\");\n        }", "author": "hatyo", "createdAt": "2020-12-07T13:47:46Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -169,12 +172,57 @@ public int estimateMemoryUsage()\n         return BASE_MEMORY_USAGE;\n     } // end of estimateMemoryUsage\n \n-    private static String format(Timestamp timestamp, String timeStampFormat) {\n+    /**\n+     * this also checks if the format is a valid fixed-size timestamp format\n+     * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n+     * we support:\n+     * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n+     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * @param format\n+     * @throws IllegalArgumentException if format is not supported\n+     * @return length of format\n+     */\n+    public static int getFormatLength(String format) throws IllegalArgumentException\n+    {\n+        byte[] b = format.getBytes(Bytes.UTF8_CHARSET);\n+        int repeat = 0;\n+        char last = (char)b[0];\n+        int length = b.length;\n+        for(int i=0; i<b.length+1; i++) {\n+            if (i != b.length && (char) b[i] == last) {\n+                repeat++;\n+                continue;\n+            }\n+            int r = repeat;\n+            char l = last;\n+            repeat = 1;\n+            if( i != b.length)\n+                last = (char) b[i];\n+            if ((l == 'y' || l == 'u') && (r == 4 || r == 2)) continue;\n+            else if (r == 2 &&  \"MmdHhs\".indexOf(l) != -1 ) continue;\n+            else if (r == 3 && (l == 'e' || l == 'E')) continue;\n+            else if (l == 'S') continue;\n+            else if (r == 1) {\n+                if (l == 'a') {\n+                    length++;\n+                    continue;\n+                }\n+                if(\" ,.-/:\".indexOf(l) != -1) continue;\n+            }\n+            throw new IllegalArgumentException(\"not supported format \\\"\" + format + \"\\\": '\" + l + \"' can't be repeated \" + r + \" times\");\n+        }", "originalCommit": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4MTk0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537581944", "bodyText": "iterating to b.length (inclusive) is weird i know but had to be done.\nthe solution you suggest is not checking the last part of the string. you would have to add the same if/else/else code again after the loop is done.\njust checked hh:mm:ss a, it would miss the 'a'.", "author": "martinrupp", "createdAt": "2020-12-07T15:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxODI2OA=="}], "type": "inlineReview", "revised_code": {"commit": "8391ba0499afa525833be5ef55aeb33946dcaea1", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\nindex d58b0ff89c..88fccb7fd0 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n\n@@ -177,7 +177,7 @@ public final class SQLTimestamp extends DataType\n      * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n      * we support:\n      * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n-     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * up to 9x S (nanoseconds), and other characters \" ,.-/:\"\n      * @param format\n      * @throws IllegalArgumentException if format is not supported\n      * @return length of format\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMTM3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537521370", "bodyText": "I guess this would also throw if we have a pattern that looks like this: yyyy----MM-dd HH:mm:ss (notice the tripple-dash), do we want to allow such pattern?", "author": "hatyo", "createdAt": "2020-12-07T13:52:14Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -169,12 +172,57 @@ public int estimateMemoryUsage()\n         return BASE_MEMORY_USAGE;\n     } // end of estimateMemoryUsage\n \n-    private static String format(Timestamp timestamp, String timeStampFormat) {\n+    /**\n+     * this also checks if the format is a valid fixed-size timestamp format\n+     * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n+     * we support:\n+     * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n+     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * @param format\n+     * @throws IllegalArgumentException if format is not supported\n+     * @return length of format\n+     */\n+    public static int getFormatLength(String format) throws IllegalArgumentException", "originalCommit": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU4NDQ1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537584450", "bodyText": "you're right, we can allow such patterns", "author": "martinrupp", "createdAt": "2020-12-07T15:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMTM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "8391ba0499afa525833be5ef55aeb33946dcaea1", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\nindex d58b0ff89c..88fccb7fd0 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java\n\n@@ -177,7 +177,7 @@ public final class SQLTimestamp extends DataType\n      * see also https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html\n      * we support:\n      * yyyy, yy, uuuu, uu, eee, EEE, MM, mm, dd, HH, hh, ss, a\n-     * an arbitrary number of S, and other characters \" ,.-/:\"\n+     * up to 9x S (nanoseconds), and other characters \" ,.-/:\"\n      * @param format\n      * @throws IllegalArgumentException if format is not supported\n      * @return length of format\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMTgwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r537521802", "bodyText": "nice", "author": "hatyo", "createdAt": "2020-12-07T13:52:50Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -127,6 +129,7 @@ public void setStringFormat(int format) {\n \n     public void setTimestampFormat(String format) {\n         timestampFormat = format;\n+        formatter = null; // recreate on demand", "originalCommit": "e238fb626a6e9d5fb1b61090f86355ee3f6f2bee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "8391ba0499afa525833be5ef55aeb33946dcaea1", "url": "https://github.com/splicemachine/spliceengine/commit/8391ba0499afa525833be5ef55aeb33946dcaea1", "message": "DB-10973 fixing cast result of timestamps / upper(timestamp(...))\n\n+ addressed code review", "committedDate": "2020-12-07T15:32:47Z", "type": "commit"}, {"oid": "e7727a9fe9bd6ea5423f2eeeaae6758ccaf57914", "url": "https://github.com/splicemachine/spliceengine/commit/e7727a9fe9bd6ea5423f2eeeaae6758ccaf57914", "message": "fix SQLTypesUnitTest.testTimestampExtractOperatorNode", "committedDate": "2020-12-07T16:39:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5Nzg1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r538197858", "bodyText": "Not quite related to this PR, but that one seems to only be used in SpliceAdmin and should therefore probably be moved out of this class.", "author": "arnaud-splice", "createdAt": "2020-12-08T09:58:55Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/types/SQLTimestamp.java", "diffHunk": "@@ -98,8 +102,7 @@\n     public static final String defaultTimestampFormatString = \"yyyy-MM-dd HH:mm:ss\";", "originalCommit": "e7727a9fe9bd6ea5423f2eeeaae6758ccaf57914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIxOTMyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r538219326", "bodyText": "agreed", "author": "martinrupp", "createdAt": "2020-12-08T10:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5Nzg1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzODc1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r538538758", "bodyText": "The current maximum on-disk timestamp precision is 6 decimal places.  Maybe we should make the default timestamp format match this.  Having a default format with 9 decimal places might make users mistakenly think they can input such data into tables as well.", "author": "msirek", "createdAt": "2020-12-08T16:03:28Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/compile/CompilerContext.java", "diffHunk": "@@ -183,7 +183,7 @@\n     NativeSparkModeType DEFAULT_SPLICE_NATIVE_SPARK_AGGREGATION_MODE = NativeSparkModeType.SYSTEM;\n     boolean DEFAULT_SPLICE_ALLOW_OVERFLOW_SENSITIVE_NATIVE_SPARK_EXPRESSIONS = true;\n     int DEFAULT_SPLICE_CURRENT_TIMESTAMP_PRECISION = 6;\n-    int DEFAULT_TIMESTAMP_PRECISION = 9;\n+    String DEFAULT_TIMESTAMP_FORMAT = \"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\";", "originalCommit": "e7727a9fe9bd6ea5423f2eeeaae6758ccaf57914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI0NDgxNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4792#discussion_r553244814", "bodyText": "agreed", "author": "martinrupp", "createdAt": "2021-01-07T10:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzODc1OA=="}], "type": "inlineReview", "revised_code": null}]}