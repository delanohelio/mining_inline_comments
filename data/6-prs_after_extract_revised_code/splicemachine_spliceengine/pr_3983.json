{"pr_number": 3983, "pr_title": "DB-10006 Reduce memory footprint of CSV reader", "pr_createdAt": "2020-08-13T07:59:07Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3983", "timeline": [{"oid": "53321e9a1f97f108d59d54da3ce7f67be0cb400a", "url": "https://github.com/splicemachine/spliceengine/commit/53321e9a1f97f108d59d54da3ce7f67be0cb400a", "message": "DB-9912 reduce memory copies in csv reader.", "committedDate": "2020-08-10T11:43:09Z", "type": "commit"}, {"oid": "4f17b9bd3f917e7f627a01ea7d457813c30a647d", "url": "https://github.com/splicemachine/spliceengine/commit/4f17b9bd3f917e7f627a01ea7d457813c30a647d", "message": "DB-9912 reformat QuoteTrackingTokenizer.java.", "committedDate": "2020-08-10T11:43:55Z", "type": "commit"}, {"oid": "6e2ab06fba7038900845a68fcbf52edad6f84e18", "url": "https://github.com/splicemachine/spliceengine/commit/6e2ab06fba7038900845a68fcbf52edad6f84e18", "message": "DB-9912 refactor readColumns method.", "committedDate": "2020-08-10T13:39:07Z", "type": "commit"}, {"oid": "7be290009754de1ccdc685b663f7fdf16094b35c", "url": "https://github.com/splicemachine/spliceengine/commit/7be290009754de1ccdc685b663f7fdf16094b35c", "message": "DB-9912 further refactoring of readColumns.", "committedDate": "2020-08-10T14:02:37Z", "type": "commit"}, {"oid": "de6fa0d355f3c38e6307364269cb01c5f124b366", "url": "https://github.com/splicemachine/spliceengine/commit/de6fa0d355f3c38e6307364269cb01c5f124b366", "message": "DB-9912 fix bug in refactoring readColumns.", "committedDate": "2020-08-10T15:16:29Z", "type": "commit"}, {"oid": "77f923e95d87d8194a2ca8c346343146d9544e54", "url": "https://github.com/splicemachine/spliceengine/commit/77f923e95d87d8194a2ca8c346343146d9544e54", "message": "DB-9912 Improve memory footprint of QuoteTrackingTokenizer.\n\n- if the maximum size of some columns exceeds a specific threshold,\n  a perliminary scan of the CSV row is done to calculate actual size\n  needed for each column.\n- the size is used to initialize the StringBuilder used to store the\n  data of the column which should give a more predictable performance.", "committedDate": "2020-08-10T17:50:27Z", "type": "commit"}, {"oid": "809bbe98ee96c350982453707a419e0ac206ae13", "url": "https://github.com/splicemachine/spliceengine/commit/809bbe98ee96c350982453707a419e0ac206ae13", "message": "Merge remote-tracking branch 'origin/master' into DB-9912", "committedDate": "2020-08-11T10:11:19Z", "type": "commit"}, {"oid": "84eeff62d845297aa2a3e71d406d28573cb362a5", "url": "https://github.com/splicemachine/spliceengine/commit/84eeff62d845297aa2a3e71d406d28573cb362a5", "message": "DB-9912 refactor, add tests, fix spotbugs issues.", "committedDate": "2020-08-11T15:43:07Z", "type": "commit"}, {"oid": "00082228b85b949348acef887e2fb267c64161a6", "url": "https://github.com/splicemachine/spliceengine/commit/00082228b85b949348acef887e2fb267c64161a6", "message": "DB-9912 fix bug in handling unmatched quotes.", "committedDate": "2020-08-11T18:06:21Z", "type": "commit"}, {"oid": "ab35782ef3927dcd47daf7212fbf26e268a77d20", "url": "https://github.com/splicemachine/spliceengine/commit/ab35782ef3927dcd47daf7212fbf26e268a77d20", "message": "DB-9912 fix minor bug in test.", "committedDate": "2020-08-11T18:24:40Z", "type": "commit"}, {"oid": "f6e43d17cd971d1f13a19d8e7f10301596ac68a4", "url": "https://github.com/splicemachine/spliceengine/commit/f6e43d17cd971d1f13a19d8e7f10301596ac68a4", "message": "DB-9912 read types from VTI operation only.\n\n- refactoring.\n- adapt handling extra columns in CSV columns to current\n  expected behavior", "committedDate": "2020-08-12T12:22:42Z", "type": "commit"}, {"oid": "1bacf482b73f4afcd5d96fe02fe1cc84ddc65e93", "url": "https://github.com/splicemachine/spliceengine/commit/1bacf482b73f4afcd5d96fe02fe1cc84ddc65e93", "message": "DB-10006 set StringBuilder size for first column.", "committedDate": "2020-08-13T13:05:07Z", "type": "commit"}, {"oid": "0b4d58d6932dac2f841f0ed4e38a63bf6b016516", "url": "https://github.com/splicemachine/spliceengine/commit/0b4d58d6932dac2f841f0ed4e38a63bf6b016516", "message": "DB-10006 address comments.", "committedDate": "2020-08-13T16:15:32Z", "type": "commit"}, {"oid": "21b03cb581804ad5a992efc2b65e0085495f8a0f", "url": "https://github.com/splicemachine/spliceengine/commit/21b03cb581804ad5a992efc2b65e0085495f8a0f", "message": "DB-10006 avoid holding reference to row buffer unnecessarily.\n\n- this prevents GC from recycling this row which could be an issue\n  if the row is too large as in CLOB case.", "committedDate": "2020-08-13T17:04:40Z", "type": "commit"}, {"oid": "28c27d139821078402924fbda4c1880629107015", "url": "https://github.com/splicemachine/spliceengine/commit/28c27d139821078402924fbda4c1880629107015", "message": "DB-10006 fix unit test.", "committedDate": "2020-08-14T09:58:23Z", "type": "commit"}, {"oid": "d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "url": "https://github.com/splicemachine/spliceengine/commit/d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "message": "Merge remote-tracking branch 'origin/master' into DB-10006", "committedDate": "2020-08-14T10:14:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ5NDQyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r471494427", "bodyText": "\"by design\"?", "author": "ascend1", "createdAt": "2020-08-17T13:53:43Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/load/SpliceCsvReader.java", "diffHunk": "@@ -20,13 +20,16 @@\n \n import com.splicemachine.derby.stream.function.QuoteTrackingTokenizer;\n import com.splicemachine.derby.stream.utils.BooleanList;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n import org.supercsv.prefs.CsvPreference;\n \n /**\n  * SpliceCsvReader is a simple reader that reads a row from a CSV file into an array of Strings.\n  *\n  * @author dwinters\n  */\n+@SuppressFBWarnings(value = \"IT_NO_SUCH_ELEMENT\", justification = \"this is be design, the caller is responsible for \" +", "originalCommit": "d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MTM2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472281362", "bodyText": "fixed. thanks!", "author": "hatyo", "createdAt": "2020-08-18T15:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ5NDQyNw=="}], "type": "inlineReview", "revised_code": {"commit": "a84304c880ea6afc0f559b4d96c8c88bb77ee5b6", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/load/SpliceCsvReader.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/load/SpliceCsvReader.java\nindex 037dddaad3..b514808737 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/load/SpliceCsvReader.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/load/SpliceCsvReader.java\n\n@@ -28,7 +28,7 @@ import org.supercsv.prefs.CsvPreference;\n  *\n  * @author dwinters\n  */\n-@SuppressFBWarnings(value = \"IT_NO_SUCH_ELEMENT\", justification = \"this is be design, the caller is responsible for \" +\n+@SuppressFBWarnings(value = \"IT_NO_SUCH_ELEMENT\", justification = \"this is by design, the caller is responsible for \" +\n \t\t\"calling hasNext first to check whether a new element is there.\")\n public class SpliceCsvReader implements Iterator<List<String>> {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNjQwOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r471506408", "bodyText": "I think this call is not needed, we already allocated a StringBuilder big enough for the largest column, the only thing we need is to \"clear\" the StringBuilder (.setLength(0)) right?", "author": "dgomezferro", "createdAt": "2020-08-17T14:11:58Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java", "diffHunk": "@@ -69,211 +140,309 @@\n      * @param preferences the CSV preferences\n      * @throws NullPointerException if reader or preferences is null\n      */\n-    public QuoteTrackingTokenizer(final Reader reader,final CsvPreference preferences){\n-        super(reader,preferences);\n-        this.quoteChar=preferences.getQuoteChar();\n-        this.delimeterChar=preferences.getDelimiterChar();\n-        this.surroundingSpacesNeedQuotes=preferences.isSurroundingSpacesNeedQuotes();\n-        this.ignoreEmptyLines=preferences.isIgnoreEmptyLines();\n-        this.commentMatcher=preferences.getCommentMatcher();\n-        this.maxLinesPerRow=preferences.getMaxLinesPerRow();\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences) {\n+        super(reader, preferences);\n+        this.quoteChar = preferences.getQuoteChar();\n+        this.delimeterChar = preferences.getDelimiterChar();\n+        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n+        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n+        this.commentMatcher = preferences.getCommentMatcher();\n+        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n+        valueSizeHints = null;\n+    }\n+\n+    /**\n+     * Constructs a new <tt>Tokenizer</tt>, which reads the CSV file, line by line.\n+     *\n+     * @param reader         the reader\n+     * @param preferences    the CSV preferences\n+     * @param valueSizeHints the maximum size of each column. this is used to optimize memory footprint of the reader.\n+     * @throws NullPointerException if reader or preferences is null\n+     */\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences, final List<Integer> valueSizeHints) {\n+        super(reader, preferences);\n+        this.quoteChar = preferences.getQuoteChar();\n+        this.delimeterChar = preferences.getDelimiterChar();\n+        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n+        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n+        this.commentMatcher = preferences.getCommentMatcher();\n+        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n+        this.valueSizeHints = valueSizeHints;\n     }\n \n     @Override\n-    public boolean readColumns(final List<String> columns) throws IOException{\n-        return readColumns(columns,null);\n+    public boolean readColumns(final List<String> columns) throws IOException {\n+        return readColumns(columns, null);\n     }\n \n-    public boolean readColumns(final List<String> columns,final BooleanList quotedColumns) throws IOException{\n-        if(columns==null){\n+    private void reset() {\n+        // clear the reusable List and StringBuilders\n+        colIdx = 0;\n+        currentColumn.setLength(0);\n+        // process each character in the line, catering for surrounding quotes (QUOTE_MODE)\n+        state = TokenizerState.NORMAL;\n+        quoteScopeStartingLine = -1;\n+        potentialSpaces = 0;\n+        charIndex = 0;\n+        wasQuoted = false;\n+    }\n+\n+    /**\n+     * Parses the columns from current CSV row.\n+     *\n+     * @param columns       output parameter, the resulting set of parsed columns\n+     * @param quotedColumns output parameter, for each one of the resulting columns: true if the column was quoted, otherwise, false\n+     * @return true if more rows exists, otherwise false.\n+     */\n+    public boolean readColumns(final List<String> columns, final BooleanList quotedColumns) throws IOException {\n+        if (columns == null) {\n             throw new NullPointerException(\"columns should not be null\");\n         }\n-        boolean recordQuotes = quotedColumns!=null;\n-\n-        // clear the reusable List and StringBuilders\n         columns.clear();\n-        if(recordQuotes) quotedColumns.clear();\n-        currentColumn.setLength(0);\n-        currentRow.setLength(0);\n+        if (quotedColumns != null) quotedColumns.clear();\n+\n+        reset();\n+        currentRow.clear();\n \n         // read a line (ignoring empty lines/comments if necessary)\n-        String line;\n-        do{\n-            line=readLine();\n-            if(line==null){\n-                return false; // EOF\n+        if (!readFirstLine()) return false; // EOF\n+\n+        // now, if some column value is larger than scanThreshold we perform the dry run to avoid extra allocation of StringBuilder.\n+        checkExactSizeFirst = false;\n+        if (valueSizeHints != null) {\n+            if (valueSizeHints.stream().max(Integer::compare).get() > scanThresold) {\n+                checkExactSizeFirst = true;\n+                exactColumnSizes = new int[valueSizeHints.size()];\n             }\n         }\n-        while(ignoreEmptyLines && line.isEmpty() || (commentMatcher!=null && commentMatcher.isComment(line)));\n \n-        // update the untokenized CSV row\n-        currentRow.append(line);\n+        if (checkExactSizeFirst) {\n+            runStateMachine(new ArrayList<>(), null); // will only calculate exact size of each column\n+            reset();\n+            checkExactSizeFirst = false; // allow setting the column in the next state machine run instead just counting the characters.\n+            allocateColumnMemory(); // allocate memory for the first column\n+            rowIdx = 0; // rollback to start reading the data (again) from currentRow.\n+        }\n \n-        // process each character in the line, catering for surrounding quotes (QUOTE_MODE)\n-        TokenizerState state=TokenizerState.NORMAL;\n-        int quoteScopeStartingLine=-1; // the line number where a potential multi-line cell starts\n-        int potentialSpaces=0; // keep track of spaces (so leading/trailing space can be removed if required)\n-        int charIndex=0;\n-        boolean wasQuoted = false;\n-        while(true){\n-            boolean endOfLineReached=charIndex==line.length();\n-\n-            if(endOfLineReached){\n-                if(TokenizerState.NORMAL.equals(state)){\n-                    /*\n-\t\t\t\t\t * Newline. Add any required spaces (if surrounding spaces don't need quotes) and return (we've read\n-\t\t\t\t\t * a line!).\n-\t\t\t\t\t */\n-                    if(!surroundingSpacesNeedQuotes){\n-                        appendSpaces(currentColumn,potentialSpaces);\n-                    }\n-                    columns.add(currentColumn.length()>0?currentColumn.toString():null); // \"\" -> null\n-                    if(recordQuotes) quotedColumns.add(wasQuoted);\n-                    wasQuoted = false;\n-                    return true;\n-                }else{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * Newline. Doesn't count as newline while in QUOTESCOPE. Add the newline char, reset the charIndex\n-\t\t\t\t\t * (will update to 0 for next iteration), read in the next line, then then continue to next\n-\t\t\t\t\t * character.\n-\t\t\t\t\t */\n-                    currentColumn.append(NEWLINE);\n-                    currentRow.append(NEWLINE); // specific line terminator lost, \\n will have to suffice\n-\n-                    charIndex=0;\n-\n-                    if(maxLinesPerRow>0 && getLineNumber()-quoteScopeStartingLine+1>=maxLinesPerRow){\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * The quoted section that is being parsed spans too many lines, so to avoid excessive memory\n-\t\t\t\t\t\t * usage parsing something that is probably human error anyways, throw an exception. If each\n-\t\t\t\t\t\t * row is suppose to be a single line and this has been exceeded, throw a more descriptive\n-\t\t\t\t\t\t * exception\n-\t\t\t\t\t\t */\n-                        String msg=maxLinesPerRow==1?\n-                                String.format(\"unexpected end of line while reading quoted column on line %d\",\n-                                        getLineNumber()):\n-                                String.format(\"max number of lines to read exceeded while reading quoted column\"+\n-                                                \" beginning on line %d and ending on line %d\",\n-                                        quoteScopeStartingLine,getLineNumber());\n-                        throw new SuperCsvException(msg);\n-                    }else if((line=readLine())==null){\n-                        throw new SuperCsvException(\n-                                String.format(\n-                                                \"partial record found [%s] while reading quoted column beginning on line %d and ending on line %d\",\n-                                                this.currentColumn, quoteScopeStartingLine,getLineNumber()));\n-                    }\n+        runStateMachine(columns, quotedColumns);\n \n-                    currentRow.append(line); // update untokenized CSV row\n+        clearRow();\n+        return true;\n+    }\n \n-                    if(line.isEmpty()){\n-                        // consecutive newlines\n-                        continue;\n-                    }\n-                }\n+    public void clearRow() {\n+        currentRow.clear();\n+    }\n+\n+    int[] getExactColumnSizes() {\n+        return exactColumnSizes;\n+    }\n+\n+    private void runStateMachine(final List<String> columns, final BooleanList quotedColumns) throws IOException {\n+        while (true) {\n+            switch (state) {\n+                case NORMAL:\n+                    handleNormalState(columns, quotedColumns);\n+                    break;\n+                case QUOTE_MODE:\n+                    handleQuoteState();\n+                    break;\n+                case FINISHED:\n+                    return;\n             }\n+        }\n+    }\n \n-            final char c=line.charAt(charIndex);\n+    private void appendToRowNewLine() {\n+        if (checkExactSizeFirst) {\n+            currentRow.append(String.valueOf(NEWLINE));\n+        } else if (exactColumnSizes != null) {\n+            rowIdx++; // simulate adding a newline by moving a sequence by one\n+        } else {\n+            currentRow.append(String.valueOf(NEWLINE));\n+        }\n+    }\n \n-            if(TokenizerState.NORMAL.equals(state)){\n-                if(c==delimeterChar){\n-\t\t\t\t\t/*\n-\t\t\t\t\t * Delimiter. Save the column (trim trailing space if required) then continue to next character.\n-\t\t\t\t\t */\n-                    if(!surroundingSpacesNeedQuotes){\n-                        appendSpaces(currentColumn,potentialSpaces);\n-                    }\n-                    columns.add(currentColumn.length()>0?currentColumn.toString():null); // \"\" -> null\n-                    potentialSpaces=0;\n+    private void appendToRowFromFile() throws IOException {\n+        if (checkExactSizeFirst) {\n+            currentRow.append(readLine());\n+        } else if (exactColumnSizes != null) {\n+            rowIdx++; // simulate adding a newline by moving a sequence by one\n+        } else {\n+            currentRow.append(readLine());\n+        }\n+    }\n+\n+    private void addToColumn(char c) {\n+        if (checkExactSizeFirst) {\n+            if (colIdx >= exactColumnSizes.length) {\n+                // it seems this could happen, still we want to tolerate it and not throw. (see expected behavior in HdfsImportIT::testNullDatesWithMixedCaseAccuracy)\n+                return;\n+            }\n+            exactColumnSizes[colIdx]++;\n+        } else {\n+            currentColumn.append(c);\n+        }\n+    }\n+\n+    private void allocateColumnMemory() {\n+        if (!checkExactSizeFirst) {\n+            if (exactColumnSizes != null) { // we set the column sizes before, use it to set the SB size correctly\n+                if(colIdx >= exactColumnSizes.length) {\n+                    // it seems this could happen, still we want to tolerate it and not throw. (see expected behavior in HdfsImportIT::testNullDatesWithMixedCaseAccuracy)\n                     currentColumn.setLength(0);\n-                    if(recordQuotes){\n-                        quotedColumns.append(wasQuoted);\n-                    }\n-                    wasQuoted = false;\n-                }else if(c==SPACE){\n-\t\t\t\t\t/*\n-\t\t\t\t\t * Space. Remember it, then continue to next character.\n-\t\t\t\t\t */\n-                    potentialSpaces++;\n-\n-                }else if(c==quoteChar){\n-\t\t\t\t\t/*\n-\t\t\t\t\t * A single quote (\"). Update to QUOTESCOPE (but don't save quote), then continue to next character.\n-\t\t\t\t\t */\n-                    state=TokenizerState.QUOTE_MODE;\n-                    wasQuoted = true;\n-                    quoteScopeStartingLine=getLineNumber();\n-\n-                    // cater for spaces before a quoted section (be lenient!)\n-                    if(!surroundingSpacesNeedQuotes || currentColumn.length()>0){\n-                        appendSpaces(currentColumn,potentialSpaces);\n+                } else {\n+                    if(LOG.isDebugEnabled()) {\n+                        LOG.debug(String.format(\"reinit column StringBuilder to exact size of %d\", exactColumnSizes[colIdx]));\n                     }\n-                    potentialSpaces=0;\n-\n-                }else{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * Just a normal character. Add any required spaces (but trim any leading spaces if surrounding\n-\t\t\t\t\t * spaces need quotes), add the character, then continue to next character.\n-\t\t\t\t\t */\n-                    if(!surroundingSpacesNeedQuotes || currentColumn.length()>0){\n-                        appendSpaces(currentColumn,potentialSpaces);\n+                    int maxExactColumnSize = Arrays.stream(exactColumnSizes).max().getAsInt();\n+                    if(maxExactColumnSize > currentColumn.capacity()) {\n+                        currentColumn = new StringBuilder(maxExactColumnSize);\n+                    } else {\n+                        currentColumn.setLength(0);\n                     }\n-\n-                    potentialSpaces=0;\n-                    currentColumn.append(c);\n                 }\n+            } else { // we didn't because the column size is too small. Just reset the size and let SB grow exponentially.\n+                currentColumn.setLength(0);\n+            }\n+        }  // else is a no-op, we don't care at this moment about the columns\n+    }\n \n-            }else{\n-\t\t\t\t/*\n-\t\t\t\t * QUOTE_MODE (within quotes).\n-\t\t\t\t */\n-                if(c==quoteChar){\n-                    int nextCharIndex=charIndex+1;\n-                    boolean availableCharacters=nextCharIndex<line.length();\n-                    boolean nextCharIsQuote=availableCharacters && line.charAt(nextCharIndex)==quoteChar;\n-                    if(nextCharIsQuote){\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * An escaped quote (\"\"). Add a single quote, then move the cursor so the next iteration of the\n-\t\t\t\t\t\t * loop will read the character following the escaped quote.\n-\t\t\t\t\t\t */\n-                        currentColumn.append(c);\n-                        charIndex++;\n-\n-                    }else{\n-\t\t\t\t\t\t/*\n-\t\t\t\t\t\t * A single quote (\"). Update to NORMAL (but don't save quote), then continue to next character.\n-\t\t\t\t\t\t */\n-                        state=TokenizerState.NORMAL;\n-                        quoteScopeStartingLine=-1; // reset ready for next multi-line cell\n-                    }\n-                }else{\n-\t\t\t\t\t/*\n-\t\t\t\t\t * Just a normal character, delimiter (they don't count in QUOTESCOPE) or space. Add the character,\n-\t\t\t\t\t * then continue to next character.\n-\t\t\t\t\t */\n-                    currentColumn.append(c);\n-                }\n+    private String getCurrentLine() {\n+        if (checkExactSizeFirst) {\n+            return currentRow.last();\n+        } else if (exactColumnSizes != null) {\n+            return currentRow.at(rowIdx);\n+        } else {\n+            return currentRow.last();\n+        }\n+    }\n+\n+    private boolean readFirstLine() throws IOException {\n+        String line;\n+        do {\n+            line = readLine();\n+            if (line == null) {\n+                return false;\n             }\n+        }\n+        while (ignoreEmptyLines && line.isEmpty() || (commentMatcher != null && commentMatcher.isComment(line)));\n+        currentRow.append(line);\n+        return true;\n+    }\n+\n+    private void handleNormalState(final List<String> columns, final BooleanList quotedColumns) {\n+        if (charIndex == getCurrentLine().length()) { // Newline. Add any required spaces (if surrounding spaces don't need quotes) and return (we've read a line!).\n+            finishCol(columns, quotedColumns);\n+            state = TokenizerState.FINISHED;\n+        } else {\n+            final char c = getCurrentLine().charAt(charIndex);\n+            if (c == delimeterChar) { // Delimiter. Save the column (trim trailing space if required) then continue to next character.\n+                finishCol(columns, quotedColumns);\n+                potentialSpaces = 0;\n+                allocateColumnMemory();", "originalCommit": "d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwODA1Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472108057", "bodyText": "You're right, no need for resizing.", "author": "hatyo", "createdAt": "2020-08-18T11:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNjQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIyMzAzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472223030", "bodyText": "... actually we do need this to reset the StringBuilder for the next column, otherwise we keep adding to the StringBuilder over and over again.", "author": "hatyo", "createdAt": "2020-08-18T14:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNjQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "00c3c7542eaa6e1dd17d80360c1ecfb5e09127d9", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\nindex 4b48d813f7..fe29e08467 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n\n@@ -140,15 +131,8 @@ public class QuoteTrackingTokenizer extends AbstractTokenizer {\n      * @param preferences the CSV preferences\n      * @throws NullPointerException if reader or preferences is null\n      */\n-    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences) {\n-        super(reader, preferences);\n-        this.quoteChar = preferences.getQuoteChar();\n-        this.delimeterChar = preferences.getDelimiterChar();\n-        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n-        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n-        this.commentMatcher = preferences.getCommentMatcher();\n-        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n-        valueSizeHints = null;\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences, final boolean oneLineRecord){\n+        this(reader, preferences, oneLineRecord, -1, null);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUxMjA5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r471512091", "bodyText": "Could we add another check here? If we are parsing with oneLineRecords we could check the length of the current line, if it's less than the scanThreshold we avoid the dryRun too\n\n\n\nI think at this point of execution we don't know the actual size of the current CSV line, or maybe I missed some info in your comment?\n\nWe can get the size of the current line with getCurrentLine().length() don't we?\nWhat we don't know is whether we are parsing in oneLineRecords mode, we'd need to pass down that flag into the QuoteTrackingTokenizer, or have a helper method in MutableCSVTokenizer (that one only gets used in oneLineRecords mode)", "author": "dgomezferro", "createdAt": "2020-08-17T14:20:22Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java", "diffHunk": "@@ -69,211 +140,309 @@\n      * @param preferences the CSV preferences\n      * @throws NullPointerException if reader or preferences is null\n      */\n-    public QuoteTrackingTokenizer(final Reader reader,final CsvPreference preferences){\n-        super(reader,preferences);\n-        this.quoteChar=preferences.getQuoteChar();\n-        this.delimeterChar=preferences.getDelimiterChar();\n-        this.surroundingSpacesNeedQuotes=preferences.isSurroundingSpacesNeedQuotes();\n-        this.ignoreEmptyLines=preferences.isIgnoreEmptyLines();\n-        this.commentMatcher=preferences.getCommentMatcher();\n-        this.maxLinesPerRow=preferences.getMaxLinesPerRow();\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences) {\n+        super(reader, preferences);\n+        this.quoteChar = preferences.getQuoteChar();\n+        this.delimeterChar = preferences.getDelimiterChar();\n+        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n+        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n+        this.commentMatcher = preferences.getCommentMatcher();\n+        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n+        valueSizeHints = null;\n+    }\n+\n+    /**\n+     * Constructs a new <tt>Tokenizer</tt>, which reads the CSV file, line by line.\n+     *\n+     * @param reader         the reader\n+     * @param preferences    the CSV preferences\n+     * @param valueSizeHints the maximum size of each column. this is used to optimize memory footprint of the reader.\n+     * @throws NullPointerException if reader or preferences is null\n+     */\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences, final List<Integer> valueSizeHints) {\n+        super(reader, preferences);\n+        this.quoteChar = preferences.getQuoteChar();\n+        this.delimeterChar = preferences.getDelimiterChar();\n+        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n+        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n+        this.commentMatcher = preferences.getCommentMatcher();\n+        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n+        this.valueSizeHints = valueSizeHints;\n     }\n \n     @Override\n-    public boolean readColumns(final List<String> columns) throws IOException{\n-        return readColumns(columns,null);\n+    public boolean readColumns(final List<String> columns) throws IOException {\n+        return readColumns(columns, null);\n     }\n \n-    public boolean readColumns(final List<String> columns,final BooleanList quotedColumns) throws IOException{\n-        if(columns==null){\n+    private void reset() {\n+        // clear the reusable List and StringBuilders\n+        colIdx = 0;\n+        currentColumn.setLength(0);\n+        // process each character in the line, catering for surrounding quotes (QUOTE_MODE)\n+        state = TokenizerState.NORMAL;\n+        quoteScopeStartingLine = -1;\n+        potentialSpaces = 0;\n+        charIndex = 0;\n+        wasQuoted = false;\n+    }\n+\n+    /**\n+     * Parses the columns from current CSV row.\n+     *\n+     * @param columns       output parameter, the resulting set of parsed columns\n+     * @param quotedColumns output parameter, for each one of the resulting columns: true if the column was quoted, otherwise, false\n+     * @return true if more rows exists, otherwise false.\n+     */\n+    public boolean readColumns(final List<String> columns, final BooleanList quotedColumns) throws IOException {\n+        if (columns == null) {\n             throw new NullPointerException(\"columns should not be null\");\n         }\n-        boolean recordQuotes = quotedColumns!=null;\n-\n-        // clear the reusable List and StringBuilders\n         columns.clear();\n-        if(recordQuotes) quotedColumns.clear();\n-        currentColumn.setLength(0);\n-        currentRow.setLength(0);\n+        if (quotedColumns != null) quotedColumns.clear();\n+\n+        reset();\n+        currentRow.clear();\n \n         // read a line (ignoring empty lines/comments if necessary)\n-        String line;\n-        do{\n-            line=readLine();\n-            if(line==null){\n-                return false; // EOF\n+        if (!readFirstLine()) return false; // EOF\n+\n+        // now, if some column value is larger than scanThreshold we perform the dry run to avoid extra allocation of StringBuilder.\n+        checkExactSizeFirst = false;\n+        if (valueSizeHints != null) {\n+            if (valueSizeHints.stream().max(Integer::compare).get() > scanThresold) {", "originalCommit": "d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4MDE1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472280156", "bodyText": "done, it made the parsing logic slightly more complicated but it is totally worth it. Thanks!", "author": "hatyo", "createdAt": "2020-08-18T15:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUxMjA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "00c3c7542eaa6e1dd17d80360c1ecfb5e09127d9", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\nindex 4b48d813f7..fe29e08467 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n\n@@ -140,15 +131,8 @@ public class QuoteTrackingTokenizer extends AbstractTokenizer {\n      * @param preferences the CSV preferences\n      * @throws NullPointerException if reader or preferences is null\n      */\n-    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences) {\n-        super(reader, preferences);\n-        this.quoteChar = preferences.getQuoteChar();\n-        this.delimeterChar = preferences.getDelimiterChar();\n-        this.surroundingSpacesNeedQuotes = preferences.isSurroundingSpacesNeedQuotes();\n-        this.ignoreEmptyLines = preferences.isIgnoreEmptyLines();\n-        this.commentMatcher = preferences.getCommentMatcher();\n-        this.maxLinesPerRow = preferences.getMaxLinesPerRow();\n-        valueSizeHints = null;\n+    public QuoteTrackingTokenizer(final Reader reader, final CsvPreference preferences, final boolean oneLineRecord){\n+        this(reader, preferences, oneLineRecord, -1, null);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUxNTA3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r471515070", "bodyText": "If you want to add a configuration option:\n\nYou'd get the config option with SIDriver.driver().getConfiguration().getCsvScanThreshold() (or whatever name you come up with)\nYou need to add that method to the interface, implementation and ConfigurationBuilder\nAdd the configuration to a *Configuration class (possibly SQLConfiguration, that's where importMaxQuotedColumnLines is defined)", "author": "dgomezferro", "createdAt": "2020-08-17T14:24:53Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java", "diffHunk": "@@ -30,18 +33,86 @@\n  * versus columns with values {@code \"Foo\"}.\n  *\n  * @author Scott Fines\n- *         Date: 9/29/16\n+ * Date: 9/29/16\n  */\n-public class QuoteTrackingTokenizer extends AbstractTokenizer{\n+public class QuoteTrackingTokenizer extends AbstractTokenizer {\n+\n+    private static final Logger LOG=Logger.getLogger(QuoteTrackingTokenizer.class);\n+\n+    private final List<Integer> valueSizeHints;\n+    // the line number where a potential multi-line cell starts\n+    private int potentialSpaces;\n+    private int charIndex;\n+    private boolean wasQuoted;\n+    // the line number where a potential multi-line cell starts\n+    private int quoteScopeStartingLine;\n+    private TokenizerState state;\n+    private int colIdx;\n+    private boolean firstRun;\n+    private boolean checkExactSizeFirst = false;\n+    private int rowIdx = 0;\n+    private int[] exactColumnSizes = null;\n+    final static int SCAN_THRESHOLD = 10000;", "originalCommit": "d4cccff9ec2c2f143bc79e32057aeb0940729dc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzNTI0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472135245", "bodyText": "done. Thanks for the explanation.", "author": "hatyo", "createdAt": "2020-08-18T12:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUxNTA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "00c3c7542eaa6e1dd17d80360c1ecfb5e09127d9", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\nindex 4b48d813f7..fe29e08467 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n\n@@ -37,8 +38,9 @@ import java.util.List;\n  */\n public class QuoteTrackingTokenizer extends AbstractTokenizer {\n \n-    private static final Logger LOG=Logger.getLogger(QuoteTrackingTokenizer.class);\n-\n+    private static final Logger LOG = Logger.getLogger(QuoteTrackingTokenizer.class);\n+    private static final char NEWLINE = '\\n';\n+    private static final char SPACE = ' ';\n     private final List<Integer> valueSizeHints;\n     // the line number where a potential multi-line cell starts\n     private int potentialSpaces;\n"}}, {"oid": "00c3c7542eaa6e1dd17d80360c1ecfb5e09127d9", "url": "https://github.com/splicemachine/spliceengine/commit/00c3c7542eaa6e1dd17d80360c1ecfb5e09127d9", "message": "DB-10006 further optimizations.\n\n- when reading one-line record CSV we skip the dry-run scan and\n  instead, immediately assign the column StringBuilder to the size\n  of the row itself.\n- add row scan size threshold to configurations.\n- throw exception if one-line record CSV is read and we encounter\n  a multi-line column inside quotes.\n- add test and address SpotBugs issues.", "committedDate": "2020-08-18T15:15:40Z", "type": "commit"}, {"oid": "4d1100dce3d3f721d36b68ec17c8d270e5391d10", "url": "https://github.com/splicemachine/spliceengine/commit/4d1100dce3d3f721d36b68ec17c8d270e5391d10", "message": "Merge remote-tracking branch 'origin/master' into DB-10006", "committedDate": "2020-08-18T15:16:41Z", "type": "commit"}, {"oid": "a84304c880ea6afc0f559b4d96c8c88bb77ee5b6", "url": "https://github.com/splicemachine/spliceengine/commit/a84304c880ea6afc0f559b4d96c8c88bb77ee5b6", "message": "DB-10006 fix typo.", "committedDate": "2020-08-18T15:23:16Z", "type": "commit"}, {"oid": "a19aeb07a14d8b1ccaf50f72a0469207eb2c0e2b", "url": "https://github.com/splicemachine/spliceengine/commit/a19aeb07a14d8b1ccaf50f72a0469207eb2c0e2b", "message": "Merge remote-tracking branch 'origin/master' into DB-10006", "committedDate": "2020-08-18T16:31:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNzMxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472337313", "bodyText": "size is calculated here. Do you want to change sizeCached to true?", "author": "jyuanca", "createdAt": "2020-08-18T16:47:13Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java", "diffHunk": "@@ -30,36 +34,94 @@\n  * versus columns with values {@code \"Foo\"}.\n  *\n  * @author Scott Fines\n- *         Date: 9/29/16\n+ * Date: 9/29/16\n  */\n-public class QuoteTrackingTokenizer extends AbstractTokenizer{\n-\n-    private static final char NEWLINE='\\n';\n+public class QuoteTrackingTokenizer extends AbstractTokenizer {\n+\n+    private static final Logger LOG = Logger.getLogger(QuoteTrackingTokenizer.class);\n+    private static final char NEWLINE = '\\n';\n+    private static final char SPACE = ' ';\n+    private final List<Integer> valueSizeHints;\n+    // the line number where a potential multi-line cell starts\n+    private int potentialSpaces;\n+    private int charIndex;\n+    private boolean wasQuoted;\n+    // the line number where a potential multi-line cell starts\n+    private int quoteScopeStartingLine;\n+    private TokenizerState state;\n+    private int colIdx;\n+    private boolean firstRun;\n+    private boolean checkExactSizeFirst = false;\n+    private int rowIdx = 0;\n+    private int[] exactColumnSizes = null;\n+    private StringBuilder currentColumn = new StringBuilder();\n+    /* the raw, untokenized CSV row (may span multiple lines) */\n+    private final LazyStringBuilder currentRow = new LazyStringBuilder();\n+    private final int quoteChar;\n+    private final int delimeterChar;\n+    private final boolean surroundingSpacesNeedQuotes;\n+    private final boolean ignoreEmptyLines;\n+    private final CommentMatcher commentMatcher;\n+    private final int maxLinesPerRow;\n+    private long scanThresold;\n+    private final boolean oneLineRecord;\n+    private int oneLineRecordLength = 0;\n \n-    private static final char SPACE=' ';\n+    private static class LazyStringBuilder {\n \n-    private final StringBuilder currentColumn=new StringBuilder();\n+        final List<String> bufferList;\n+        int size = 0;\n+        boolean sizeCached = false;\n \n-    /* the raw, untokenized CSV row (may span multiple lines) */\n-    private final StringBuilder currentRow=new StringBuilder();\n+        public LazyStringBuilder() {\n+            this.bufferList = new ArrayList<String>(1000);\n+        }\n \n-    private final int quoteChar;\n+        public int length() {\n+            if (sizeCached) {\n+                return size;\n+            }\n+            size = 0;\n+            for (String s : bufferList) {", "originalCommit": "a19aeb07a14d8b1ccaf50f72a0469207eb2c0e2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4OTE0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3983#discussion_r472389144", "bodyText": "Thank you, yes I forgot that, I will fix it \ud83d\udc4d", "author": "hatyo", "createdAt": "2020-08-18T18:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNzMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "d03b31739cc25a006ac622a8a08a93c869d6ed09", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\nindex fe29e08467..8cfc0fd0d6 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/QuoteTrackingTokenizer.java\n\n@@ -85,6 +85,7 @@ public class QuoteTrackingTokenizer extends AbstractTokenizer {\n             for (String s : bufferList) {\n                 size += s.length();\n             }\n+            sizeCached = true;\n             return size;\n         }\n \n"}}, {"oid": "d03b31739cc25a006ac622a8a08a93c869d6ed09", "url": "https://github.com/splicemachine/spliceengine/commit/d03b31739cc25a006ac622a8a08a93c869d6ed09", "message": "DB-10006 address comment.", "committedDate": "2020-08-18T18:31:32Z", "type": "commit"}, {"oid": "c7bd85383fbdc5a0483f5673e63c3a2bb1a5f7d7", "url": "https://github.com/splicemachine/spliceengine/commit/c7bd85383fbdc5a0483f5673e63c3a2bb1a5f7d7", "message": "DB-10006 fix test.", "committedDate": "2020-08-19T08:40:08Z", "type": "commit"}, {"oid": "c7bd85383fbdc5a0483f5673e63c3a2bb1a5f7d7", "url": "https://github.com/splicemachine/spliceengine/commit/c7bd85383fbdc5a0483f5673e63c3a2bb1a5f7d7", "message": "DB-10006 fix test.", "committedDate": "2020-08-19T08:40:08Z", "type": "forcePushed"}]}