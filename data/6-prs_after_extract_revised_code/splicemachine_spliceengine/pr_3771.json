{"pr_number": 3771, "pr_title": "DB-9715 AS OF should also accept a timestamp expression", "pr_createdAt": "2020-07-06T15:45:26Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3771", "timeline": [{"oid": "49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "url": "https://github.com/splicemachine/spliceengine/commit/49ecb0fde526b1f6baf19453462a6e2760dbe7bd", "message": "Support time travel SELECT statements with tx id.\n\n- add parser extensions to support AS OF clause.\n- only the tx id is supported.\n- propagate the transaction id down the execution tree to\n  TableScanOperation.\n- adapt code generation to pass the tx id to TableScanOperation\n  at runtime.\n- add tests", "committedDate": "2020-06-17T20:40:01Z", "type": "commit"}, {"oid": "69c5064cfb517f637292c9a9198520b0667c49ff", "url": "https://github.com/splicemachine/spliceengine/commit/69c5064cfb517f637292c9a9198520b0667c49ff", "message": "Addressed comments.", "committedDate": "2020-07-06T18:46:41Z", "type": "commit"}, {"oid": "ebae97a79a00a8a55d4c12047bc338909c2e06ec", "url": "https://github.com/splicemachine/spliceengine/commit/ebae97a79a00a8a55d4c12047bc338909c2e06ec", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-06T18:47:54Z", "type": "commit"}, {"oid": "d9c4480364623cc4fb382a64183e0d2ec70f18d0", "url": "https://github.com/splicemachine/spliceengine/commit/d9c4480364623cc4fb382a64183e0d2ec70f18d0", "message": "Disallow time travel clause on external tables and views.\n\n- Add tests.", "committedDate": "2020-07-06T20:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NDY1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450764658", "bodyText": "@yxia92 @jyuanca do we need to do something here regarding upgrades?", "author": "dgomezferro", "createdAt": "2020-07-07T10:27:06Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java", "diffHunk": "@@ -1012,7 +1013,8 @@ NoPutResultSet getTableScanResultSet(\n \t\t\t\t\t\t\t\tString location,\n \t\t\t\t\t\t\t\tint partitionByRefItem,\n \t\t\t\t\t\t\t\tGeneratedMethod defaultRowFunc,\n-\t\t\t\t\t\t\t\tint defaultValueMapItem\n+\t\t\t\t\t\t\t\tint defaultValueMapItem,\n+\t\t\t\t\t\t\t\tGeneratedMethod pastTxFunctor", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java b/db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java\nindex a436c54a37..732ea2fae2 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/sql/execute/ResultSetFactory.java\n\n@@ -1014,7 +1014,7 @@ public interface ResultSetFactory {\n \t\t\t\t\t\t\t\tint partitionByRefItem,\n \t\t\t\t\t\t\t\tGeneratedMethod defaultRowFunc,\n \t\t\t\t\t\t\t\tint defaultValueMapItem,\n-\t\t\t\t\t\t\t\tGeneratedMethod pastTxFunctor\n+\t\t\t\t\t\t\t\tlong pastTxId\n \t\t\t\t\t\t\t\t)\n \t\t\tthrows StandardException;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765072", "bodyText": "I'm not a fan of the isBulkDeleteOrTxId parameter, would it be possible to add an extra parameter for the transaction id ?", "author": "dgomezferro", "createdAt": "2020-07-07T10:27:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -196,36 +196,30 @@\n     private AggregateNode aggrForSpecialMaxScan;\n \n     private boolean isBulkDelete = false;\n+\n+    private ValueNode pastTxIdExpression = null;\n+\n     @Override\n     public boolean isParallelizable(){\n         return false;\n     }\n \n     /**\n-     * Initializer for a table in a FROM list. Parameters are as follows:\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * <li>tableProperties    The Properties list associated with the table.</li>\n-     * </ul>\n-     * <p/>\n-     * <p>\n-     * - OR -\n-     * </p>\n-     * <p/>\n-     * <ul>\n-     * <li>tableName            The name of the table</li>\n-     * <li>correlationName    The correlation name</li>\n-     * <li>updateOrDelete    Table is being updated/deleted from. </li>\n-     * <li>derivedRCL        The derived column list</li>\n-     * </ul>\n+     * Initializer for a table in a FROM list.\n+     * @param tableName The name of the table\n+     * @param correlationName The correlation name\n+     * @param rclOrUD update/delete flag or result column list\n+     * @param propsOrRcl properties or result column list\n+     * @param isBulkDeleteOrTxId bulk delete flag or past tx id expression.\n      */\n     @Override\n-    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete){\n+    public void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDeleteOrTxId){\n+        if(isBulkDeleteOrTxId instanceof Boolean) {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzAyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463024", "bodyText": "Right, I did it in the base change (DB-9714). The new signature looks like this:\npublic void init(Object tableName,Object correlationName,Object rclOrUD,Object propsOrRcl, Object isBulkDelete, Object pastTxIdExpr)", "author": "hatyo", "createdAt": "2020-07-14T15:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\nindex ee55bae569..1c12e4e769 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\n@@ -197,7 +197,7 @@ public class FromBaseTable extends FromTable {\n \n     private boolean isBulkDelete = false;\n \n-    private ValueNode pastTxIdExpression = null;\n+    private long pastTxId = -1;\n \n     @Override\n     public boolean isParallelizable(){\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450765565", "bodyText": "Remove comments", "author": "dgomezferro", "createdAt": "2020-07-07T10:28:56Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -3410,7 +3431,11 @@ private String getClassName(String niceIndexName) throws StandardException {\n         if(niceIndexName!=null){\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n-            cName = \"TableScan[\"+getPrettyTableName()+\"]\";\n+            cName = \"TableScan[\"+getPrettyTableName();\n+//            if(pastTxIdExpression >= 0){", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2MzUxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454463513", "bodyText": "Done", "author": "hatyo", "createdAt": "2020-07-14T15:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc2NTU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\nindex ee55bae569..1c12e4e769 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\n@@ -3432,9 +3423,9 @@ public class FromBaseTable extends FromTable {\n             cName = \"IndexScan[\"+niceIndexName+\"]\";\n         }else{\n             cName = \"TableScan[\"+getPrettyTableName();\n-//            if(pastTxIdExpression >= 0){\n-//                cName += \"timeTravelTx(\" + pastTxIdExpression + \")\";\n-//            }\n+            if(pastTxId >= 0){\n+                cName += \" timeTravelTx(\" + pastTxId + \")\";\n+            }\n             cName += \"]\";\n         }\n         if(isMultiProbing())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770046", "bodyText": "If I'm understanding this correctly, this is mapping the Txn begin timestamp to the instant when the transaction was last updated. This would be wrong for long running transactions:\n\ntxn1 is created at instant1\na long time passes\ntxn1 is committed at instant500\nthis function maps txnId 1 to instant 500 (it should map txnId 1 to instant 1)", "author": "dgomezferro", "createdAt": "2020-07-07T10:37:55Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MTMwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r454481309", "bodyText": "You're right, what's a better way to correlate? maybe parse and check the timestamp of COMMIT_QUALIFIER_BYTES or STATE_QUALIFIER_BYTES (sorry maybe we already went through this once, but I just want to make sure).", "author": "hatyo", "createdAt": "2020-07-14T16:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MzUyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456343527", "bodyText": "I think the best option would be to scan for STATE_QUALIFIER_BYTES with ACTIVE value (0x00), since that's what's written when the transaction is first created. In principle there should only be 2 states at most (ACTIVE, superseded by COMMITTED or ROLLEDBACK) but I think I saw some cases where ROLLEDBACK was written multiple times. If there's such a case and the ACTIVE keyvalue is not available I'd ignore that row.", "author": "dgomezferro", "createdAt": "2020-07-17T09:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5Mzc0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393746", "bodyText": "Done, we're reading now the STATE_QUALIFIER_BYTES qualifier (all versions), iterate over the results and pick the timestamp of ACTIVE state if found, if not found, we simply ignore the row and proceed further.", "author": "hatyo", "createdAt": "2020-07-23T11:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java\ndeleted file mode 100644\nindex 132739c8a2..0000000000\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java\n+++ /dev/null\n\n@@ -1,101 +0,0 @@\n-package com.splicemachine.si.impl.region;\n-\n-import com.splicemachine.hbase.CellUtils;\n-import com.splicemachine.si.impl.TxnUtils;\n-import com.splicemachine.utils.Pair;\n-import com.splicemachine.utils.Source;\n-import org.apache.hadoop.hbase.Cell;\n-import org.apache.hadoop.hbase.client.Scan;\n-import org.apache.hadoop.hbase.filter.PrefixFilter;\n-import org.apache.hadoop.hbase.regionserver.HRegion;\n-import org.apache.hadoop.hbase.regionserver.RegionScanner;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-\n-public class HBaseTxnFinder implements TxnFinder {\n-\n-    private HRegion region;\n-\n-    public HBaseTxnFinder(HRegion region) {\n-        this.region = region;\n-    }\n-\n-    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n-        private final RegionScanner regionScanner;\n-        protected Pair<Long, Long> next;\n-        private List<Cell> currentResults;\n-\n-        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n-            if(keyValues.size()<=0) return null;\n-            Cell dataKv=null;\n-            long ts = 0;\n-\n-            for(Cell kv : keyValues){\n-                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n-                    dataKv=kv;\n-                }\n-                if(ts <  kv.getTimestamp()) {\n-                    ts = kv.getTimestamp(); // get last update\n-                }\n-            }\n-            if(dataKv==null) return null;\n-            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n-            return new Pair<>(txnId, ts);\n-        }\n-\n-\n-        public ScanTimestampIterator(RegionScanner scanner){\n-            this.regionScanner=scanner;\n-        }\n-\n-        @Override\n-        public boolean hasNext() throws IOException{\n-            if(next!=null) return true;\n-            if(currentResults==null)\n-                currentResults=new ArrayList<>(10);\n-            boolean shouldContinue;\n-            do{\n-                shouldContinue=regionScanner.next(currentResults);\n-                if(currentResults.size()<=0) return false;\n-\n-                this.next = decode(currentResults);\n-                currentResults.clear();\n-            }while(next==null && shouldContinue);\n-\n-            return next!=null;\n-        }\n-\n-        @Override\n-        public Pair<Long, Long> next() throws IOException{\n-            if(!hasNext()) throw new NoSuchElementException();\n-            Pair<Long, Long> n=next;\n-            next=null;\n-            return n;\n-        }\n-\n-        @Override\n-        public void close() throws IOException{\n-            regionScanner.close();\n-        }\n-    }\n-\n-    @Override\n-    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n-        Scan s = new Scan();\n-        byte[] arr = {bucket};\n-        s.setReversed(reverse).setFilter(new PrefixFilter(arr)); // todo get one row only\n-\n-        if(begin != null) {\n-            s.withStartRow(begin);\n-        }\n-        HBaseTxnFinder.ScanTimestampIterator si = new HBaseTxnFinder.ScanTimestampIterator(region.getScanner(s));\n-        if(si.hasNext()) {\n-            return si.next;\n-        } else {\n-            return null;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450770687", "bodyText": "You can specify the column you are interested in directly in the scan, so you don't have to check for the right KV.", "author": "dgomezferro", "createdAt": "2020-07-07T10:39:16Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.hbase.CellUtils;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.Source;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.filter.PrefixFilter;\n+import org.apache.hadoop.hbase.regionserver.HRegion;\n+import org.apache.hadoop.hbase.regionserver.RegionScanner;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class HBaseTxnFinder implements TxnFinder {\n+\n+    private HRegion region;\n+\n+    public HBaseTxnFinder(HRegion region) {\n+        this.region = region;\n+    }\n+\n+    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n+        private final RegionScanner regionScanner;\n+        protected Pair<Long, Long> next;\n+        private List<Cell> currentResults;\n+\n+        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n+            if(keyValues.size()<=0) return null;\n+            Cell dataKv=null;\n+            long ts = 0;\n+\n+            for(Cell kv : keyValues){\n+                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n+                    dataKv=kv;\n+                }\n+                if(ts <  kv.getTimestamp()) {\n+                    ts = kv.getTimestamp(); // get last update\n+                }\n+            }\n+            if(dataKv==null) return null;\n+            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n+            return new Pair<>(txnId, ts);\n+        }\n+\n+\n+        public ScanTimestampIterator(RegionScanner scanner){\n+            this.regionScanner=scanner;\n+        }\n+\n+        @Override\n+        public boolean hasNext() throws IOException{\n+            if(next!=null) return true;\n+            if(currentResults==null)\n+                currentResults=new ArrayList<>(10);\n+            boolean shouldContinue;\n+            do{\n+                shouldContinue=regionScanner.next(currentResults);\n+                if(currentResults.size()<=0) return false;\n+\n+                this.next = decode(currentResults);\n+                currentResults.clear();\n+            }while(next==null && shouldContinue);\n+\n+            return next!=null;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> next() throws IOException{\n+            if(!hasNext()) throw new NoSuchElementException();\n+            Pair<Long, Long> n=next;\n+            next=null;\n+            return n;\n+        }\n+\n+        @Override\n+        public void close() throws IOException{\n+            regionScanner.close();\n+        }\n+    }\n+\n+    @Override\n+    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+        Scan s = new Scan();", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5MzgwMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459393800", "bodyText": "Thanks, done, now we're reading only STATE_QUALIFIER_BYTES column qualifier (all versions).\nhbaseScan.addColumn(V2TxnDecoder.FAMILY, V2TxnDecoder.STATE_QUALIFIER_BYTES)\n         .setReversed(reverse)\n         .readAllVersions()\n         .setFilter(new PrefixFilter(new byte[]{bucket})); // todo get one row only", "author": "hatyo", "createdAt": "2020-07-23T11:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3MDY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java\ndeleted file mode 100644\nindex 132739c8a2..0000000000\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/HBaseTxnFinder.java\n+++ /dev/null\n\n@@ -1,101 +0,0 @@\n-package com.splicemachine.si.impl.region;\n-\n-import com.splicemachine.hbase.CellUtils;\n-import com.splicemachine.si.impl.TxnUtils;\n-import com.splicemachine.utils.Pair;\n-import com.splicemachine.utils.Source;\n-import org.apache.hadoop.hbase.Cell;\n-import org.apache.hadoop.hbase.client.Scan;\n-import org.apache.hadoop.hbase.filter.PrefixFilter;\n-import org.apache.hadoop.hbase.regionserver.HRegion;\n-import org.apache.hadoop.hbase.regionserver.RegionScanner;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-\n-public class HBaseTxnFinder implements TxnFinder {\n-\n-    private HRegion region;\n-\n-    public HBaseTxnFinder(HRegion region) {\n-        this.region = region;\n-    }\n-\n-    private class ScanTimestampIterator implements Source<Pair<Long, Long>> {\n-        private final RegionScanner regionScanner;\n-        protected Pair<Long, Long> next;\n-        private List<Cell> currentResults;\n-\n-        protected Pair<Long, Long> decode(List<Cell> keyValues) throws IOException{\n-            if(keyValues.size()<=0) return null;\n-            Cell dataKv=null;\n-            long ts = 0;\n-\n-            for(Cell kv : keyValues){\n-                if(CellUtils.singleMatchingColumn(kv,V2TxnDecoder.FAMILY,V2TxnDecoder.DATA_QUALIFIER_BYTES)) {\n-                    dataKv=kv;\n-                }\n-                if(ts <  kv.getTimestamp()) {\n-                    ts = kv.getTimestamp(); // get last update\n-                }\n-            }\n-            if(dataKv==null) return null;\n-            long txnId= TxnUtils.txnIdFromRowKey(dataKv.getRowArray(),dataKv.getRowOffset(),dataKv.getRowLength());\n-            return new Pair<>(txnId, ts);\n-        }\n-\n-\n-        public ScanTimestampIterator(RegionScanner scanner){\n-            this.regionScanner=scanner;\n-        }\n-\n-        @Override\n-        public boolean hasNext() throws IOException{\n-            if(next!=null) return true;\n-            if(currentResults==null)\n-                currentResults=new ArrayList<>(10);\n-            boolean shouldContinue;\n-            do{\n-                shouldContinue=regionScanner.next(currentResults);\n-                if(currentResults.size()<=0) return false;\n-\n-                this.next = decode(currentResults);\n-                currentResults.clear();\n-            }while(next==null && shouldContinue);\n-\n-            return next!=null;\n-        }\n-\n-        @Override\n-        public Pair<Long, Long> next() throws IOException{\n-            if(!hasNext()) throw new NoSuchElementException();\n-            Pair<Long, Long> n=next;\n-            next=null;\n-            return n;\n-        }\n-\n-        @Override\n-        public void close() throws IOException{\n-            regionScanner.close();\n-        }\n-    }\n-\n-    @Override\n-    public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n-        Scan s = new Scan();\n-        byte[] arr = {bucket};\n-        s.setReversed(reverse).setFilter(new PrefixFilter(arr)); // todo get one row only\n-\n-        if(begin != null) {\n-            s.withStartRow(begin);\n-        }\n-        HBaseTxnFinder.ScanTimestampIterator si = new HBaseTxnFinder.ScanTimestampIterator(region.getScanner(s));\n-        if(si.hasNext()) {\n-            return si.next;\n-        } else {\n-            return null;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450775697", "bodyText": "Txn id 0 is used for the ROOT_TRANSACTION, which is a special transaction parent of all user level transactions. I don't think this is going to be problematic but I'd rather use a different transaction id other than 0, in case we think at some point this is actually the root transaction.", "author": "dgomezferro", "createdAt": "2020-07-07T10:49:31Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1MzA5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r459453095", "bodyText": "Done. I created a constant: public static final long OLDEST_TIME_TRAVEL_TX = TRASANCTION_INCREMENT; and I am using it here instead of simply using zero.", "author": "hatyo", "createdAt": "2020-07-23T13:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NTY5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\nindex a874ec3b0e..8286105f29 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\n\n@@ -189,35 +183,12 @@ public class TableScanOperation extends ScanOperation{\n         this.tableNameBytes=Bytes.toBytes(this.tableName);\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n+        this.pastTx = pastTx;\n         init();\n-        if(pastTxFunctor != null) {\n-            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n-            if(pastTx == -1) {\n-                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n-            }\n-        } else {\n-            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n-        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n-    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {\n-        if(dataValue instanceof SQLTimestamp) {\n-            Timestamp ts = ((SQLTimestamp)dataValue).getTimestamp(null);\n-            SpliceLogUtils.trace(LOG,\"time travel ts=%s\", ts.toString());\n-            try {\n-                return SIDriver.driver().getTxnStore().getTxnAt(ts.getTime());\n-            } catch (IOException e) {\n-                throw Exceptions.parseException(e);\n-            }\n-        }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n-            return dataValue.getLong();\n-        }else {\n-            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n-        }\n-    }\n-\n     /**\n      *\n      * Serialization/Deserialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776001", "bodyText": "Method names should start with lowercase", "author": "dgomezferro", "createdAt": "2020-07-07T10:50:05Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java", "diffHunk": "@@ -175,10 +190,34 @@ public TableScanOperation(long conglomId,\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n         init();\n+        if(pastTxFunctor != null) {\n+            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n+            if(pastTx == -1) {\n+                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n+            }\n+        } else {\n+            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n+        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n+    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDk5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456294990", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NjAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\nindex a874ec3b0e..8286105f29 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/TableScanOperation.java\n\n@@ -189,35 +183,12 @@ public class TableScanOperation extends ScanOperation{\n         this.tableNameBytes=Bytes.toBytes(this.tableName);\n         this.indexColItem=indexColItem;\n         this.indexName=indexName;\n+        this.pastTx = pastTx;\n         init();\n-        if(pastTxFunctor != null) {\n-            this.pastTx = MapToTxId((DataValueDescriptor)pastTxFunctor.invoke(activation));\n-            if(pastTx == -1) {\n-                pastTx = 0; // force going back to oldest transaction instead of ignoring it.\n-            }\n-        } else {\n-            this.pastTx = -1; // nothing is set, go ahead and use latest transaction.\n-        }\n         if(LOG.isTraceEnabled())\n             SpliceLogUtils.trace(LOG,\"isTopResultSet=%s,optimizerEstimatedCost=%f,optimizerEstimatedRowCount=%f\",isTopResultSet,optimizerEstimatedCost,optimizerEstimatedRowCount);\n     }\n \n-    private long MapToTxId(DataValueDescriptor dataValue) throws StandardException {\n-        if(dataValue instanceof SQLTimestamp) {\n-            Timestamp ts = ((SQLTimestamp)dataValue).getTimestamp(null);\n-            SpliceLogUtils.trace(LOG,\"time travel ts=%s\", ts.toString());\n-            try {\n-                return SIDriver.driver().getTxnStore().getTxnAt(ts.getTime());\n-            } catch (IOException e) {\n-                throw Exceptions.parseException(e);\n-            }\n-        }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n-            return dataValue.getLong();\n-        }else {\n-            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n-        }\n-    }\n-\n     /**\n      *\n      * Serialization/Deserialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776851", "bodyText": "Method names start lowercase", "author": "dgomezferro", "createdAt": "2020-07-07T10:51:40Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU5OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295598", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\nindex b11e4569c9..9040c24e21 100644\n--- a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n+++ b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n\n@@ -1,12 +1,15 @@\n package com.splicemachine.derby.impl.sql.execute.operations;\n \n-import com.splicemachine.derby.test.framework.*;\n-import org.junit.*;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n \n-import java.sql.*;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import static org.junit.Assert.fail;\n \n public class SelectTimeTravelIT {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450776968", "bodyText": "ditto", "author": "dgomezferro", "createdAt": "2020-07-07T10:51:53Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTY3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456295675", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3Njk2OA=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\nindex b11e4569c9..9040c24e21 100644\n--- a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n+++ b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n\n@@ -1,12 +1,15 @@\n package com.splicemachine.derby.impl.sql.execute.operations;\n \n-import com.splicemachine.derby.test.framework.*;\n-import org.junit.*;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n \n-import java.sql.*;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import static org.junit.Assert.fail;\n \n public class SelectTimeTravelIT {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r450777470", "bodyText": "Remove", "author": "dgomezferro", "createdAt": "2020-07-07T10:52:50Z", "path": "splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java", "diffHunk": "@@ -30,10 +30,23 @@ private TxnUtils(){}\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n+\t\trowKey[0] = (byte)(2);", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5ODQ0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456298449", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T08:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NzQ3MA=="}], "type": "inlineReview", "revised_code": {"commit": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "chunk": "diff --git a/splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java b/splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java\nindex dc94f9aae3..04a668cee9 100644\n--- a/splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java\n+++ b/splice_si_api/src/main/java/com/splicemachine/si/impl/TxnUtils.java\n\n@@ -30,23 +30,10 @@ public class TxnUtils {\n \t\tlong beginTS = txnId & SIConstants.TRANSANCTION_ID_MASK;\n \t\tbyte[] rowKey = new byte[9];\n \t\trowKey[0] = (byte)((beginTS / SIConstants.TRASANCTION_INCREMENT) & (TRANSACTION_TABLE_BUCKET_COUNT-1));\n-\t\trowKey[0] = (byte)(2);\n \t\tBytes.longToBytes(beginTS, rowKey, 1);\n \t\treturn rowKey;\n \t}\n \n-\tprivate static final char[] HEX_ARRAY = \"0123456789ABCDEF\".toCharArray();\n-\tpublic static String rowKeytoHbaseEscaped(byte[] rowKey) {\n-\t\tchar[] hexChars = new char[rowKey.length * 4];\n-\t\tfor (int j = 0; j < rowKey.length; j++) {\n-\t\t\tint v = rowKey[j] & 0xFF;\n-\t\t\thexChars[j * 4] = '\\\\';\n-\t\t\thexChars[j * 4 + 1] = 'x';\n-\t\t\thexChars[j * 4 + 2] = HEX_ARRAY[v >>> 4];\n-\t\t\thexChars[j * 4 + 3] = HEX_ARRAY[v & 0x0F];\n-\t\t}\n-\t\treturn new String(hexChars);\n-\t}\n \n \tpublic static long txnIdFromRowKey(byte[] buffer, int rowOffset, int rowLength) {\n \t\treturn Bytes.toLong(buffer, rowOffset + 1, rowLength - 1);\n"}}, {"oid": "16e8ee799170ab2ef72aba0f4c7084085e8514e2", "url": "https://github.com/splicemachine/spliceengine/commit/16e8ee799170ab2ef72aba0f4c7084085e8514e2", "message": "Fix SpotBug issues.", "committedDate": "2020-07-07T12:31:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451297626", "bodyText": "we don't really have a code convention, but i think this could use a bit more spaces, e.g.\n} catch(Throwable throwable) {\n(same for other lines)\nI don't really need the spaces after (, but like around operators e.g. if(keyValues.size()<=0) -> if(keyValues.size() <= 0).", "author": "martinrupp", "createdAt": "2020-07-08T05:48:50Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java", "diffHunk": "@@ -268,6 +268,17 @@ public int compare(TxnView o1,TxnView o2){\n         }\n     }\n \n+    @Override\n+    public long getTxnAt(long ts) throws IOException {\n+        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n+        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n+            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n+            return result.getTxnId();\n+        }catch(Throwable throwable){", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzk0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317949", "bodyText": "Done.", "author": "hatyo", "createdAt": "2020-07-17T09:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5NzYyNg=="}], "type": "inlineReview", "revised_code": {"commit": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java\nindex 70ae10c36e..06deb3798a 100644\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java\n+++ b/hbase_storage/src/main/java/com/splicemachine/si/impl/CoprocessorTxnStore.java\n\n@@ -268,17 +268,6 @@ public class CoprocessorTxnStore implements TxnStore {\n         }\n     }\n \n-    @Override\n-    public long getTxnAt(long ts) throws IOException {\n-        final TxnMessage.TxnAtRequest request=TxnMessage.TxnAtRequest.newBuilder().setTs(ts).build();\n-        try(TxnNetworkLayer table = tableFactory.accessTxnNetwork()){\n-            TxnMessage.TxnAtResponse result = table.getTxnAt(request);\n-            return result.getTxnId();\n-        }catch(Throwable throwable){\n-            throw new IOException(throwable);\n-        }\n-    }\n-\n     @Override\n     public TxnView getTransaction(long txnId) throws IOException{\n         return getTransaction(txnId,false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299344", "bodyText": "really LOG level, not TRACE? i'm not even sure we should have this here at all, even in trace level.", "author": "martinrupp", "createdAt": "2020-07-08T05:53:52Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzQzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456317434", "bodyText": "Yeah, I changed all of them back to DEBUG.", "author": "hatyo", "createdAt": "2020-07-17T09:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTM0NA=="}], "type": "inlineReview", "revised_code": {"commit": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java\ndeleted file mode 100644\nindex 86cfe283cc..0000000000\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java\n+++ /dev/null\n\n@@ -1,153 +0,0 @@\n-package com.splicemachine.si.impl.region;\n-\n-import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n-import com.splicemachine.si.constants.SIConstants;\n-import com.splicemachine.si.impl.TxnUtils;\n-import com.splicemachine.utils.Pair;\n-import com.splicemachine.utils.SpliceLogUtils;\n-import org.apache.log4j.Logger;\n-\n-import java.io.IOException;\n-import java.sql.Timestamp;\n-import java.util.Arrays;\n-\n-public class TxnTimeTraveler {\n-    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n-\n-    private TxnFinder txnFinder;\n-\n-    public TxnTimeTraveler(TxnFinder txnFinder) {\n-        this.txnFinder = txnFinder;\n-    }\n-\n-    /// @return Pair<closest tx id, closest tx's ts>\n-    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n-                                     byte[] end, long endTS) throws IOException {\n-        if(LOG.isTraceEnabled())\n-            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n-                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n-                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n-        byte[] left = begin, right = end, middle;\n-        long leftTS = beginTS, rightTS = endTS;\n-        boolean changed = true, reversed = false;\n-        while(changed) {\n-            if(Arrays.equals(left, right)) {\n-                if(leftTS < needleTS) {\n-                    return new Pair<>(txOf(left), leftTS);\n-                } else {\n-                    return null;\n-                }\n-            }\n-            changed = false;\n-            middle = middle(left, right);\n-            Pair<Long, Long> middleTx;\n-            middleTx = txnFinder.find(bucket, middle, reversed);\n-            reversed = false;\n-            if(LOG.isTraceEnabled())\n-                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n-                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n-                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n-                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n-            long middleTS = middleTx.getSecond();\n-            if(middleTS == needleTS) {\n-                return middleTx;\n-            } else if(needleTS < middleTS) {\n-                if(middleTS == rightTS)\n-                {\n-                    reversed = true;\n-                    changed = true;\n-                }\n-                else if(middleTS < rightTS)\n-                {\n-                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n-                    rightTS = middleTS;\n-                    changed = true;\n-                }\n-            } else if(leftTS < middleTS) {\n-                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n-                leftTS = middleTS;\n-                changed = true;\n-            }\n-        }\n-        return new Pair<>(txOf(left), leftTS);\n-    }\n-\n-    private long txOf(byte[] rowKey) {\n-        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n-    }\n-\n-    private byte[] middle(byte[] left, byte[] right) {\n-        assert(left.length == 9); assert(right.length == 9);\n-        byte lBucket = left[0], rBucket = right[0];\n-        assert(lBucket == rBucket);\n-        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n-        return toRowKeyWithBucket(middleTxnId, lBucket);\n-    }\n-\n-    private Pair<Long, Long> first(byte bucket) throws IOException {\n-        return txnFinder.find(bucket, null,false);\n-    }\n-\n-    private Pair<Long, Long> last(byte bucket) throws IOException {\n-        return txnFinder.find(bucket, null,true);\n-    }\n-\n-    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n-        byte[] result = TxnUtils.getRowKey(txId);\n-        assert result.length == 9 : \"unexpected rowKey format\";\n-        result[0] = bucket;\n-        return result;\n-    }\n-\n-    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n-    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n-    // transaction itself, we slide to the next tx.\n-    private long slideToNextTx(long tx) throws IOException {\n-        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n-            return -1;\n-        }\n-        return tx + SIConstants.TRASANCTION_INCREMENT;\n-    }\n-\n-    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n-        long closestTS = Long.MAX_VALUE, closestTx = -1;\n-        Pair<Long, Long> before, after;\n-        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n-            before = first(i);\n-            if(before == null /*|| before.getBeginTs() > ts*/) {\n-                continue; // region is empty, or the earliest tx in there happened after 'ts'\n-            }\n-            if(before.getSecond() > ts) {\n-                if(LOG.isTraceEnabled())\n-                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n-                            (int)i,\n-                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n-                            new Timestamp(before.getSecond()).toString(),\n-                            before.getFirst().toString(),\n-                            new Timestamp(ts).toString());\n-                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n-            }\n-            after = last(i);\n-            if(after.getSecond() < ts) {\n-                if(LOG.isTraceEnabled())\n-                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",\n-                            (int)i,\n-                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(after.getFirst(), i)),\n-                            new Timestamp(after.getSecond()).toString(),\n-                            after.getFirst().toString(),\n-                            new Timestamp(ts).toString());\n-                return new Pair<>(slideToNextTx(after.getFirst()), after.getSecond()); // after is the closest to our tx. [before ...... after] ........ <needle>\n-            }\n-            Pair<Long, Long> seachResults = bsearch(ts, i, toRowKeyWithBucket(before.getFirst(), i),\n-                    before.getSecond(), toRowKeyWithBucket(after.getFirst(), i), after.getSecond());\n-            if(seachResults == null) {\n-                continue;\n-            }\n-            if(Math.abs(seachResults.getSecond() - ts)< Math.abs(closestTS)) {\n-                closestTx = seachResults.getFirst();\n-                closestTS = seachResults.getSecond();\n-            }\n-        }\n-        return new Pair<>(slideToNextTx(closestTx), closestTS);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451299873", "bodyText": "TRACE or DEBUG?", "author": "martinrupp", "createdAt": "2020-07-08T05:55:22Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isTraceEnabled())\n+            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isTraceEnabled())\n+                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;\n+    }\n+\n+    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n+        long closestTS = Long.MAX_VALUE, closestTx = -1;\n+        Pair<Long, Long> before, after;\n+        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+            before = first(i);\n+            if(before == null /*|| before.getBeginTs() > ts*/) {\n+                continue; // region is empty, or the earliest tx in there happened after 'ts'\n+            }\n+            if(before.getSecond() > ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n+                            (int)i,\n+                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n+                            new Timestamp(before.getSecond()).toString(),\n+                            before.getFirst().toString(),\n+                            new Timestamp(ts).toString());\n+                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n+            }\n+            after = last(i);\n+            if(after.getSecond() < ts) {\n+                if(LOG.isTraceEnabled())\n+                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNjM3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456316370", "bodyText": "Right, I don't know why I chose TRACE and not DEBUG, I will change it on DEBUG level then.", "author": "hatyo", "createdAt": "2020-07-17T09:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5OTg3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java\ndeleted file mode 100644\nindex 86cfe283cc..0000000000\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java\n+++ /dev/null\n\n@@ -1,153 +0,0 @@\n-package com.splicemachine.si.impl.region;\n-\n-import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n-import com.splicemachine.si.constants.SIConstants;\n-import com.splicemachine.si.impl.TxnUtils;\n-import com.splicemachine.utils.Pair;\n-import com.splicemachine.utils.SpliceLogUtils;\n-import org.apache.log4j.Logger;\n-\n-import java.io.IOException;\n-import java.sql.Timestamp;\n-import java.util.Arrays;\n-\n-public class TxnTimeTraveler {\n-    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n-\n-    private TxnFinder txnFinder;\n-\n-    public TxnTimeTraveler(TxnFinder txnFinder) {\n-        this.txnFinder = txnFinder;\n-    }\n-\n-    /// @return Pair<closest tx id, closest tx's ts>\n-    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n-                                     byte[] end, long endTS) throws IOException {\n-        if(LOG.isTraceEnabled())\n-            SpliceLogUtils.trace(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n-                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n-                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n-        byte[] left = begin, right = end, middle;\n-        long leftTS = beginTS, rightTS = endTS;\n-        boolean changed = true, reversed = false;\n-        while(changed) {\n-            if(Arrays.equals(left, right)) {\n-                if(leftTS < needleTS) {\n-                    return new Pair<>(txOf(left), leftTS);\n-                } else {\n-                    return null;\n-                }\n-            }\n-            changed = false;\n-            middle = middle(left, right);\n-            Pair<Long, Long> middleTx;\n-            middleTx = txnFinder.find(bucket, middle, reversed);\n-            reversed = false;\n-            if(LOG.isTraceEnabled())\n-                SpliceLogUtils.trace(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n-                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n-                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n-                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n-            long middleTS = middleTx.getSecond();\n-            if(middleTS == needleTS) {\n-                return middleTx;\n-            } else if(needleTS < middleTS) {\n-                if(middleTS == rightTS)\n-                {\n-                    reversed = true;\n-                    changed = true;\n-                }\n-                else if(middleTS < rightTS)\n-                {\n-                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n-                    rightTS = middleTS;\n-                    changed = true;\n-                }\n-            } else if(leftTS < middleTS) {\n-                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n-                leftTS = middleTS;\n-                changed = true;\n-            }\n-        }\n-        return new Pair<>(txOf(left), leftTS);\n-    }\n-\n-    private long txOf(byte[] rowKey) {\n-        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n-    }\n-\n-    private byte[] middle(byte[] left, byte[] right) {\n-        assert(left.length == 9); assert(right.length == 9);\n-        byte lBucket = left[0], rBucket = right[0];\n-        assert(lBucket == rBucket);\n-        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n-        return toRowKeyWithBucket(middleTxnId, lBucket);\n-    }\n-\n-    private Pair<Long, Long> first(byte bucket) throws IOException {\n-        return txnFinder.find(bucket, null,false);\n-    }\n-\n-    private Pair<Long, Long> last(byte bucket) throws IOException {\n-        return txnFinder.find(bucket, null,true);\n-    }\n-\n-    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n-        byte[] result = TxnUtils.getRowKey(txId);\n-        assert result.length == 9 : \"unexpected rowKey format\";\n-        result[0] = bucket;\n-        return result;\n-    }\n-\n-    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n-    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n-    // transaction itself, we slide to the next tx.\n-    private long slideToNextTx(long tx) throws IOException {\n-        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n-            return -1;\n-        }\n-        return tx + SIConstants.TRASANCTION_INCREMENT;\n-    }\n-\n-    public Pair<Long, Long> getTxAt(long ts) throws IOException {\n-        long closestTS = Long.MAX_VALUE, closestTx = -1;\n-        Pair<Long, Long> before, after;\n-        for(byte i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n-            before = first(i);\n-            if(before == null /*|| before.getBeginTs() > ts*/) {\n-                continue; // region is empty, or the earliest tx in there happened after 'ts'\n-            }\n-            if(before.getSecond() > ts) {\n-                if(LOG.isTraceEnabled())\n-                    SpliceLogUtils.trace(LOG,\"in bucket %d the first txn [%s (TS: %s), id %s] happened after the needle (%s) exiting!\",\n-                            (int)i,\n-                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(before.getFirst(), i)),\n-                            new Timestamp(before.getSecond()).toString(),\n-                            before.getFirst().toString(),\n-                            new Timestamp(ts).toString());\n-                    return new Pair<>(slideToNextTx(closestTx), closestTS); // nothing, needle is too early: <needle> ....... [before ...... after]\n-            }\n-            after = last(i);\n-            if(after.getSecond() < ts) {\n-                if(LOG.isTraceEnabled())\n-                    SpliceLogUtils.trace(LOG,\"in bucket %d the last txn [%s (TS: %s), id %s] happened before the needle (%s) exiting!\",\n-                            (int)i,\n-                            TxnUtils.rowKeytoHbaseEscaped(toRowKeyWithBucket(after.getFirst(), i)),\n-                            new Timestamp(after.getSecond()).toString(),\n-                            after.getFirst().toString(),\n-                            new Timestamp(ts).toString());\n-                return new Pair<>(slideToNextTx(after.getFirst()), after.getSecond()); // after is the closest to our tx. [before ...... after] ........ <needle>\n-            }\n-            Pair<Long, Long> seachResults = bsearch(ts, i, toRowKeyWithBucket(before.getFirst(), i),\n-                    before.getSecond(), toRowKeyWithBucket(after.getFirst(), i), after.getSecond());\n-            if(seachResults == null) {\n-                continue;\n-            }\n-            if(Math.abs(seachResults.getSecond() - ts)< Math.abs(closestTS)) {\n-                closestTx = seachResults.getFirst();\n-                closestTS = seachResults.getSecond();\n-            }\n-        }\n-        return new Pair<>(slideToNextTx(closestTx), closestTS);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451303330", "bodyText": "SortedMap<Long, Long> m = txnTimeline.get(bucket); and if(m.size() == 0) { return null\ncan be done independent of if(begin == null) and if(reverse).\nI think you can add at the beginning of this function\nSortedMap<Long, Long> m = txnTimeline.get(bucket);\nif(m.size() == 0) {\n    return null;\n}\n\nand remove in other lines.", "author": "martinrupp", "createdAt": "2020-07-08T06:05:57Z", "path": "hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.splicemachine.si.impl;\n+\n+import com.splicemachine.primitives.Bytes;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.region.TxnFinder;\n+import com.splicemachine.si.impl.region.TxnTimeTraveler;\n+import com.splicemachine.utils.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+public class TimeTravelTest {\n+\n+    private static Long toTs(String s) throws ParseException {\n+        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n+        Date parsedDate = dateFormat.parse(s);\n+        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n+        return timestamp.getTime();\n+    }\n+\n+    class MockTxnFinder implements TxnFinder {\n+\n+\n+        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n+\n+        MockTxnFinder() {\n+            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n+                txnTimeline.add(new TreeMap<>());\n+            }\n+        }\n+\n+        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n+            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n+            txnTimeline.get(bucket).put(txnId, toTs(ts));\n+            return this;\n+        }\n+\n+        @Override\n+        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n+            if(begin == null) {", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNDYyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456314620", "bodyText": "You're absolutely right! Thank you \ud83d\udc4d I fixed it.", "author": "hatyo", "createdAt": "2020-07-17T08:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwMzMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "chunk": "diff --git a/hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java b/hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java\ndeleted file mode 100644\nindex 156562c911..0000000000\n--- a/hbase_storage/src/test/java/com/splicemachine/si/impl/TimeTravelTest.java\n+++ /dev/null\n\n@@ -1,137 +0,0 @@\n-package com.splicemachine.si.impl;\n-\n-import com.splicemachine.primitives.Bytes;\n-import com.splicemachine.si.constants.SIConstants;\n-import com.splicemachine.si.impl.region.TxnFinder;\n-import com.splicemachine.si.impl.region.TxnTimeTraveler;\n-import com.splicemachine.utils.Pair;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.sql.Timestamp;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.*;\n-\n-public class TimeTravelTest {\n-\n-    private static Long toTs(String s) throws ParseException {\n-        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss.SSS\");\n-        Date parsedDate = dateFormat.parse(s);\n-        Timestamp timestamp = new java.sql.Timestamp(parsedDate.getTime());\n-        return timestamp.getTime();\n-    }\n-\n-    class MockTxnFinder implements TxnFinder {\n-\n-\n-        List<SortedMap<Long, Long>> txnTimeline = new ArrayList<>();\n-\n-        MockTxnFinder() {\n-            for(int i = 0; i < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT; ++i) {\n-                txnTimeline.add(new TreeMap<>());\n-            }\n-        }\n-\n-        MockTxnFinder AddTxn(int bucket, long txnId, String ts) throws ParseException {\n-            assert bucket >= 0 && bucket < SIConstants.TRANSACTION_TABLE_BUCKET_COUNT;\n-            txnTimeline.get(bucket).put(txnId, toTs(ts));\n-            return this;\n-        }\n-\n-        @Override\n-        public Pair<Long, Long> find(byte bucket, byte[] begin, boolean reverse) throws IOException {\n-            if(begin == null) {\n-                SortedMap<Long, Long> m = txnTimeline.get(bucket);\n-                if(reverse) {\n-                    if(m.size() == 0) {\n-                        return null;\n-                    }\n-                    return new Pair<>(m.lastKey(), m.get(m.lastKey()));\n-                }\n-                else {\n-                    if(m.size() == 0) {\n-                        return null;\n-                    }\n-                    return new Pair<>(m.firstKey(), m.get(m.firstKey()));\n-                }\n-            } else {\n-                long txnId = Bytes.toLong(Bytes.slice(begin, 1, begin.length-1));\n-                SortedMap<Long, Long> m = txnTimeline.get(bucket);\n-                if(reverse) {\n-                    if(m.size() == 0) {\n-                        return null;\n-                    } else {\n-                        long prev = -1;\n-                        for(long k : m.keySet()) {\n-                            if(k <= txnId) {\n-                                prev = k;\n-                            } else {\n-                                return new Pair<>(prev, m.get(prev));\n-                            }\n-                        }\n-                    }\n-                }\n-                else {\n-                    if(m.size() == 0) {\n-                        return null;\n-                    } else {\n-                        for(long k : m.keySet()) {\n-                            if (k > txnId) {\n-                                return new Pair<>(k, m.get(k));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-    @Test\n-    public void testBinarySearch() throws Exception {\n-        MockTxnFinder txnFinder = new MockTxnFinder();\n-        txnFinder.AddTxn(0, 4999936, \"2020-07-03 21:15:16.123\")\n-                 .AddTxn(0, 5000960, \"2020-07-03 21:16:16.123\")\n-                 .AddTxn(0, 5001984, \"2020-07-03 21:17:16.123\")\n-                 .AddTxn(0, 5002752, \"2020-07-03 21:17:18.123\")\n-                 .AddTxn(0, 5003776, \"2020-07-03 21:19:18.123\")\n-                 .AddTxn(0, 5004800, \"2020-07-03 21:20:18.123\");\n-        TxnTimeTraveler timeTraveler = new TxnTimeTraveler(txnFinder);\n-        Assert.assertEquals(5002752, (long)timeTraveler.getTxAt(toTs(\"2020-07-03 21:17:30.123\")).getFirst() - SIConstants.TRASANCTION_INCREMENT);\n-    }\n-\n-    @Test\n-    public void testBinarySearchExtremeRanges() throws Exception {\n-        MockTxnFinder txnFinder = new MockTxnFinder();\n-        txnFinder.AddTxn(0, 4999936, \"2019-10-10 21:00:00.000\")\n-                 .AddTxn(0, 5000960, \"2020-07-03 21:16:16.123\")\n-                 .AddTxn(0, 5004800, \"2050-07-03 21:20:18.123\");\n-        TxnTimeTraveler timeTraveler = new TxnTimeTraveler(txnFinder);\n-        Assert.assertEquals(5000960, (long)timeTraveler.getTxAt(toTs(\"2020-07-03 21:17:30.123\")).getFirst() - SIConstants.TRASANCTION_INCREMENT);\n-    }\n-\n-    @Test\n-    public void testBinarySearchEmptyRange() throws Exception {\n-        MockTxnFinder txnFinder = new MockTxnFinder();\n-        txnFinder.AddTxn(0, 4999936, \"2019-10-10 21:00:00.000\")\n-                 .AddTxn(0, 5004800, \"2050-07-03 21:20:18.123\");\n-        TxnTimeTraveler timeTraveler = new TxnTimeTraveler(txnFinder);\n-        Assert.assertEquals(4999936, (long)timeTraveler.getTxAt(toTs(\"2020-07-03 21:17:30.123\")).getFirst() - SIConstants.TRASANCTION_INCREMENT);\n-    }\n-\n-    @Test\n-    public void testBinarySearchMultipleBuckets() throws Exception {\n-        MockTxnFinder txnFinder = new MockTxnFinder();\n-        txnFinder\n-                 .AddTxn(2, 4276480, \"2020-07-03 21:27:16.123\")\n-                 .AddTxn(2, 4276736, \"2020-07-03 21:28:16.123\")\n-                 .AddTxn(2, 4276992, \"2020-07-03 21:29:16.123\")\n-                 .AddTxn(2, 4277248, \"2020-07-03 21:30:18.123\")\n-                 .AddTxn(2, 4277504, \"2020-07-03 21:31:18.123\")\n-                 .AddTxn(2, 4277760, \"2020-07-03 21:32:18.123\");\n-        TxnTimeTraveler timeTraveler = new TxnTimeTraveler(txnFinder);\n-        Assert.assertEquals(4277504, (long)timeTraveler.getTxAt(toTs(\"2020-07-03 21:31:19.123\")).getFirst() - SIConstants.TRASANCTION_INCREMENT);\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r451306646", "bodyText": "do we really need this? maybe sth like \"testTimeTravelWorksT\" would be more intuitive? the SpliceWatcher will drop these tables automatically, so you can run the test multiple times.", "author": "martinrupp", "createdAt": "2020-07-08T06:15:45Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java", "diffHunk": "@@ -0,0 +1,253 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.*;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.*;\n+\n+public class SelectTimeTravelIT {\n+\n+    private static final String SCHEMA = SelectTimeTravelIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    private long GetTxId() throws SQLException {\n+        long result = -1;\n+        ResultSet rs =  watcher.executeQuery(\"CALL SYSCS_UTIL.SYSCS_GET_CURRENT_TRANSACTION()\");\n+        Assert.assertTrue(rs.next());\n+        result = rs.getLong(1);\n+        Assert.assertFalse(rs.next());\n+        return result;\n+    }\n+\n+    static int counter = 0;\n+    private static String GenerateTableName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    @Test\n+    public void testTimeTravelWorks() throws Exception {\n+        String tbl = GenerateTableName();", "originalCommit": "f4d1710199a53ee85c22658026d123bd83b3b88b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NzkxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r456297918", "bodyText": "I actually find this more elegant, I am already using a SpliceWatcher for the schema so I can repeat my tests since the schema (which is the same for all tests in this class) will be dropped and created again in the next run.\nI don't use a watcher for each table because it is just too cumbersome and unnecessary.", "author": "hatyo", "createdAt": "2020-07-17T08:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwNjY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "chunk": "diff --git a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\nindex b11e4569c9..9040c24e21 100644\n--- a/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n+++ b/splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SelectTimeTravelIT.java\n\n@@ -1,12 +1,15 @@\n package com.splicemachine.derby.impl.sql.execute.operations;\n \n-import com.splicemachine.derby.test.framework.*;\n-import org.junit.*;\n-import org.junit.rules.RuleChain;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n \n-import java.sql.*;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+import static org.junit.Assert.fail;\n \n public class SelectTimeTravelIT {\n \n"}}, {"oid": "20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "url": "https://github.com/splicemachine/spliceengine/commit/20abe7ca758cf03a863edc5c47ee7b9fe5c0bef6", "message": "Add upgrade script to invalidate stored statements.", "committedDate": "2020-07-10T15:07:15Z", "type": "commit"}, {"oid": "2f544c86289748608ac77934e5bc1250f7fdfbae", "url": "https://github.com/splicemachine/spliceengine/commit/2f544c86289748608ac77934e5bc1250f7fdfbae", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-10T15:12:03Z", "type": "commit"}, {"oid": "a84933d44be77758a4b1603cd9ce7b2e841f569c", "url": "https://github.com/splicemachine/spliceengine/commit/a84933d44be77758a4b1603cd9ce7b2e841f569c", "message": "Addressed further comments.", "committedDate": "2020-07-14T15:14:29Z", "type": "commit"}, {"oid": "2405dcb59774fecad245895185f80c6170108e7e", "url": "https://github.com/splicemachine/spliceengine/commit/2405dcb59774fecad245895185f80c6170108e7e", "message": "Merge remote-tracking branch 'origin/master' into DB-9714", "committedDate": "2020-07-14T15:15:31Z", "type": "commit"}, {"oid": "15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "url": "https://github.com/splicemachine/spliceengine/commit/15aac492587e0e6b8aae0d2339332dcb9dcc16dd", "message": "DB-9715 allow timestamp in AS OF clause.\n\n- accept a general expression which must evaluate to either\n  * numeric value that corresponds to txid\n  * timestamp value that corresponds to approximate time of\n    committing a transaction.\n- TODO: implement mapping function that maps timestamp to txid.", "committedDate": "2020-07-14T15:28:50Z", "type": "commit"}, {"oid": "361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "url": "https://github.com/splicemachine/spliceengine/commit/361a907cd1bc01f845619e3e4ac6b7f0f595ae1d", "message": "DB-9715 Implement algorithm to map timestamp to nearest transaction.\n\n- implement a special version of binary search that efficiently\n  scans a bucket of txn in SPLICE_TXN looking for the nearest\n  transaction to a given timestamp.\n- implement a new endpoint API call to retrieven nearest tx of\n  a given timestamp.\n- add tests.", "committedDate": "2020-07-14T15:28:50Z", "type": "commit"}, {"oid": "a028264376428e88eecb8ff963ff4f6dba222fd7", "url": "https://github.com/splicemachine/spliceengine/commit/a028264376428e88eecb8ff963ff4f6dba222fd7", "message": "DB-9715 Address comments", "committedDate": "2020-07-23T12:48:54Z", "type": "commit"}, {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "message": "Merge remote-tracking branch 'origin' into DB-9715", "committedDate": "2020-07-23T13:17:58Z", "type": "commit"}, {"oid": "1df95cc586347e02f45c22577b9c2a72e759ce38", "url": "https://github.com/splicemachine/spliceengine/commit/1df95cc586347e02f45c22577b9c2a72e759ce38", "message": "Merge remote-tracking branch 'origin' into DB-9715", "committedDate": "2020-07-23T13:17:58Z", "type": "forcePushed"}, {"oid": "2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "url": "https://github.com/splicemachine/spliceengine/commit/2716a5e98c6d1f16f3bfa68c6f2e6e91620712e8", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-07-24T17:00:12Z", "type": "commit"}, {"oid": "625377de5f60745e7f8697f90fba10017d287380", "url": "https://github.com/splicemachine/spliceengine/commit/625377de5f60745e7f8697f90fba10017d287380", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-08-04T14:45:09Z", "type": "commit"}, {"oid": "8070e6b063e11c0dfa62e0caf86365de8548d5cb", "url": "https://github.com/splicemachine/spliceengine/commit/8070e6b063e11c0dfa62e0caf86365de8548d5cb", "message": "DB-9715 address spotbugs issues.", "committedDate": "2020-08-04T15:03:13Z", "type": "commit"}, {"oid": "af035906997bb6ffdeec0468b1ba102d84741011", "url": "https://github.com/splicemachine/spliceengine/commit/af035906997bb6ffdeec0468b1ba102d84741011", "message": "Merge remote-tracking branch 'origin/master' into DB-9715", "committedDate": "2020-08-06T10:54:12Z", "type": "commit"}, {"oid": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "url": "https://github.com/splicemachine/spliceengine/commit/eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "message": "DB-9715 fix exception message.", "committedDate": "2020-08-06T10:54:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NTMwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3771#discussion_r466575301", "bodyText": "While  misspellings generally aren't noteworthy and this isn't a blocker for merging today, the literal here is spelled wrong. Could make searching for it harder in the future, so can we fix this in a future release?", "author": "carolp-503", "createdAt": "2020-08-06T17:33:24Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/region/TxnTimeTraveler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.splicemachine.si.impl.region;\n+\n+import com.splicemachine.si.api.txn.TxnTimeTravelResult;\n+import com.splicemachine.si.constants.SIConstants;\n+import com.splicemachine.si.impl.TxnUtils;\n+import com.splicemachine.utils.Pair;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Arrays;\n+\n+public class TxnTimeTraveler {\n+    private static final Logger LOG=Logger.getLogger(TxnTimeTraveler.class);\n+\n+    private TxnFinder txnFinder;\n+\n+    public TxnTimeTraveler(TxnFinder txnFinder) {\n+        this.txnFinder = txnFinder;\n+    }\n+\n+    /// @return Pair<closest tx id, closest tx's ts>\n+    private Pair<Long, Long> bsearch(long needleTS, byte bucket, byte[] begin, long beginTS,\n+                                     byte[] end, long endTS) throws IOException {\n+        if(LOG.isDebugEnabled())\n+            SpliceLogUtils.debug(LOG,\"enter bsearch in for range: [%s (TS: %s), %s (TS: %s)]\",\n+                    TxnUtils.rowKeytoHbaseEscaped(begin), new Timestamp(beginTS).toString(),\n+                    TxnUtils.rowKeytoHbaseEscaped(end), new Timestamp(endTS).toString());\n+        byte[] left = begin, right = end, middle;\n+        long leftTS = beginTS, rightTS = endTS;\n+        boolean changed = true, reversed = false;\n+        while(changed) {\n+            if(Arrays.equals(left, right)) {\n+                if(leftTS < needleTS) {\n+                    return new Pair<>(txOf(left), leftTS);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            changed = false;\n+            middle = middle(left, right);\n+            Pair<Long, Long> middleTx;\n+            middleTx = txnFinder.find(bucket, middle, reversed);\n+            reversed = false;\n+            if(LOG.isDebugEnabled())\n+                SpliceLogUtils.debug(LOG,\"middle of range: [%s (TS: %s) id %s, %s (TS: %s)] id %s is %s (TS: %s) id %s\",\n+                        TxnUtils.rowKeytoHbaseEscaped(left), new Timestamp(leftTS).toString(), txOf(left),\n+                        TxnUtils.rowKeytoHbaseEscaped(right), new Timestamp(rightTS).toString(), txOf(right),\n+                        TxnUtils.rowKeytoHbaseEscaped(middle), new Timestamp(middleTx.getSecond()).toString(), middleTx.getFirst().toString());\n+            long middleTS = middleTx.getSecond();\n+            if(middleTS == needleTS) {\n+                return middleTx;\n+            } else if(needleTS < middleTS) {\n+                if(middleTS == rightTS)\n+                {\n+                    reversed = true;\n+                    changed = true;\n+                }\n+                else if(middleTS < rightTS)\n+                {\n+                    right = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                    rightTS = middleTS;\n+                    changed = true;\n+                }\n+            } else if(leftTS < middleTS) {\n+                left = toRowKeyWithBucket(middleTx.getFirst(), bucket);\n+                leftTS = middleTS;\n+                changed = true;\n+            }\n+        }\n+        return new Pair<>(txOf(left), leftTS);\n+    }\n+\n+    private long txOf(byte[] rowKey) {\n+        return TxnUtils.txnIdFromRowKey(rowKey, 0, rowKey.length);\n+    }\n+\n+    private byte[] middle(byte[] left, byte[] right) {\n+        assert(left.length == 9); assert(right.length == 9);\n+        byte lBucket = left[0], rBucket = right[0];\n+        assert(lBucket == rBucket);\n+        long lTxnId = txOf(left), rTxnId = txOf(right), middleTxnId = (lTxnId + rTxnId) / 2;\n+        return toRowKeyWithBucket(middleTxnId, lBucket);\n+    }\n+\n+    private Pair<Long, Long> first(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,false);\n+    }\n+\n+    private Pair<Long, Long> last(byte bucket) throws IOException {\n+        return txnFinder.find(bucket, null,true);\n+    }\n+\n+    private byte[] toRowKeyWithBucket(long txId, byte bucket) {\n+        byte[] result = TxnUtils.getRowKey(txId);\n+        assert result.length == 9 : \"unexpected rowKey format\";\n+        result[0] = bucket;\n+        return result;\n+    }\n+\n+    // When we use a past transaction P whose timestamp is T, we can read data which is committed before T\n+    // i.e. all data with time < T will be visible, therefore, to be able to read the data of the past\n+    // transaction itself, we slide to the next tx.\n+    private long slideToNextTx(long tx) throws IOException {\n+        if(tx == -1) { // special case for timestamp that happened before the first transaction.\n+            return -1;\n+        }\n+        return tx + SIConstants.TRASANCTION_INCREMENT;", "originalCommit": "eb8b5ed9082f6d18a3865968cf5c63bac777c43a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}