{"pr_number": 4229, "pr_title": "DB-10253 Extend AS OF to all types of scan", "pr_createdAt": "2020-10-05T11:30:18Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4229", "timeline": [{"oid": "e399e44abdd0cf400127a707d333da76decfbcc4", "url": "https://github.com/splicemachine/spliceengine/commit/e399e44abdd0cf400127a707d333da76decfbcc4", "message": "DB-10253 Extend AS OF to all types of scan.", "committedDate": "2020-10-05T11:21:54Z", "type": "commit"}, {"oid": "8580e6761c715e87a4f137d45441e880b9fb8334", "url": "https://github.com/splicemachine/spliceengine/commit/8580e6761c715e87a4f137d45441e880b9fb8334", "message": "DB-10253 fix SpotBugs issues.", "committedDate": "2020-10-05T11:22:11Z", "type": "commit"}, {"oid": "3323e25407471c83337caa59887f632bd274a3cd", "url": "https://github.com/splicemachine/spliceengine/commit/3323e25407471c83337caa59887f632bd274a3cd", "message": "DB-10253 fix handling of null min. retention period.", "committedDate": "2020-10-05T11:22:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExMzQzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r500113439", "bodyText": "Given the code for SQLTimestamp above, it seems supporting SQLTime is trivial. Any reason to leave it for now?", "author": "ascend1", "createdAt": "2020-10-06T08:54:01Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java", "diffHunk": "@@ -450,4 +472,40 @@ public int getSplits() {\n     public FormatableBitSet getAccessedColumns() throws StandardException{\n         return scanInformation.getAccessedColumns();\n     }\n+\n+    private long mapToTxId(DataValueDescriptor dataValue) throws StandardException {\n+        if(dataValue instanceof SQLTimestamp) {\n+            Timestamp ts = ((SQLTimestamp)dataValue).getTimestamp(null);\n+            SpliceLogUtils.trace(LOG,\"time travel ts=%s\", ts.toString());\n+            try {\n+                return SIDriver.driver().getTxnStore().getTxnAt(ts.getTime());\n+            } catch (IOException e) {\n+                throw Exceptions.parseException(e);\n+            }\n+        }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n+            return dataValue.getLong();\n+        }else {\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.", "originalCommit": "3323e25407471c83337caa59887f632bd274a3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxODY2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r504518666", "bodyText": "It was not required so far and I am not exactly sure about its semantics since SQLTime is a time period ranging from 00:00:00.0000000 to 23:59:59.9999999 I think we need to map it to a point of time correctly (to act similar to Timestamp), i.e. let's say the current date is 01.01.2020 and given SQLTime is 01:02:03.456789, the resulting Timestamp would be 01.01.2020 01:02:03.456789. I think SQLTime#getTimestamp(Calendar) provides this functionality already.\nBut to answer your question, I will add support for this data type later since it wasn't required so far IIRC.", "author": "hatyo", "createdAt": "2020-10-14T09:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExMzQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1c611027cecc5fdd1df4b225b26fd99c1949a59b", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\nindex e4140e2ac0..aabcde69cd 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n\n@@ -485,7 +435,7 @@ public abstract class ScanOperation extends SpliceBaseOperation{\n         }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n             return dataValue.getLong();\n         }else {\n-            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED, dataValue.getClass().getSimpleName() + \" can not be used with time travel query\"); // fix me, we should read SqlTime as well.\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExNTc1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r500115754", "bodyText": "Is it sufficient to get one from activation.getLanguageConnectionContext().getContextManager()?", "author": "ascend1", "createdAt": "2020-10-06T08:57:35Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java", "diffHunk": "@@ -450,4 +472,40 @@ public int getSplits() {\n     public FormatableBitSet getAccessedColumns() throws StandardException{\n         return scanInformation.getAccessedColumns();\n     }\n+\n+    private long mapToTxId(DataValueDescriptor dataValue) throws StandardException {\n+        if(dataValue instanceof SQLTimestamp) {\n+            Timestamp ts = ((SQLTimestamp)dataValue).getTimestamp(null);\n+            SpliceLogUtils.trace(LOG,\"time travel ts=%s\", ts.toString());\n+            try {\n+                return SIDriver.driver().getTxnStore().getTxnAt(ts.getTime());\n+            } catch (IOException e) {\n+                throw Exceptions.parseException(e);\n+            }\n+        }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n+            return dataValue.getLong();\n+        }else {\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n+        }\n+    }\n+\n+    /**\n+     * @param pastTx The ID of the past transaction.\n+     * @return a view of a past transaction.\n+     */\n+    protected TxnView getPastTransaction(long pastTx) throws StandardException {\n+        TransactionController transactionExecute=activation.getLanguageConnectionContext().getTransactionExecute();\n+        ContextManager cm = ContextService.getFactory().newContextManager();", "originalCommit": "3323e25407471c83337caa59887f632bd274a3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyMDM0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r504520340", "bodyText": "I am not sure but I changed it as proposed to reuse existing  ContextManager instead of creating a new one.", "author": "hatyo", "createdAt": "2020-10-14T09:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExNTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyMjY0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r504522645", "bodyText": "With reusing the ContextManager many tests are failing in SelectTimeTravelIT, I think it has something to do with time travel (see the line below: TransactionController pastTC = transactionExecute.getAccessManager().getReadOnlyTransaction(cm, pastTx);).", "author": "hatyo", "createdAt": "2020-10-14T09:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExNTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "1c611027cecc5fdd1df4b225b26fd99c1949a59b", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\nindex e4140e2ac0..aabcde69cd 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n\n@@ -485,7 +435,7 @@ public abstract class ScanOperation extends SpliceBaseOperation{\n         }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n             return dataValue.getLong();\n         }else {\n-            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED, dataValue.getClass().getSimpleName() + \" can not be used with time travel query\"); // fix me, we should read SqlTime as well.\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNDIxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r500124218", "bodyText": "NOT_IMPLEMENTED is \"Feature not implemented: {0}.\", so requires a parameter.\ne.g.\nthrow StandardException.newException(SQLState.NOT_IMPLEMENTED, dataValue.getClass().getSimpleName() + \" can't be used in mapToTxId\" );", "author": "martinrupp", "createdAt": "2020-10-06T09:11:31Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java", "diffHunk": "@@ -450,4 +472,40 @@ public int getSplits() {\n     public FormatableBitSet getAccessedColumns() throws StandardException{\n         return scanInformation.getAccessedColumns();\n     }\n+\n+    private long mapToTxId(DataValueDescriptor dataValue) throws StandardException {\n+        if(dataValue instanceof SQLTimestamp) {\n+            Timestamp ts = ((SQLTimestamp)dataValue).getTimestamp(null);\n+            SpliceLogUtils.trace(LOG,\"time travel ts=%s\", ts.toString());\n+            try {\n+                return SIDriver.driver().getTxnStore().getTxnAt(ts.getTime());\n+            } catch (IOException e) {\n+                throw Exceptions.parseException(e);\n+            }\n+        }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n+            return dataValue.getLong();\n+        }else {\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.", "originalCommit": "e399e44abdd0cf400127a707d333da76decfbcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyNTI2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r504525263", "bodyText": "Thanks Martin for the nice catch!\nI changed it, and now we get a better error message:\nsplice> select * from t1 as of time('12:11:11');\nERROR 0A000: Feature not implemented: SQLTime can not be used with time travel query.\nsplice> select * from t1 as of 3.4;\nERROR 0A000: Feature not implemented: SQLDecimal can not be used with time travel query.", "author": "hatyo", "createdAt": "2020-10-14T09:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyODk5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4229#discussion_r504528991", "bodyText": "awesome!", "author": "martinrupp", "createdAt": "2020-10-14T09:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNDIxOA=="}], "type": "inlineReview", "revised_code": {"commit": "1c611027cecc5fdd1df4b225b26fd99c1949a59b", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\nindex e4140e2ac0..aabcde69cd 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/ScanOperation.java\n\n@@ -485,7 +435,7 @@ public abstract class ScanOperation extends SpliceBaseOperation{\n         }else if(dataValue instanceof SQLTinyint || dataValue instanceof SQLSmallint || dataValue instanceof SQLInteger || dataValue instanceof SQLLongint) {\n             return dataValue.getLong();\n         }else {\n-            throw StandardException.newException(SQLState.NOT_IMPLEMENTED); // fix me, we should read SqlTime as well.\n+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED, dataValue.getClass().getSimpleName() + \" can not be used with time travel query\"); // fix me, we should read SqlTime as well.\n         }\n     }\n \n"}}, {"oid": "66a11add3619fabf4bce5a96dc3937cbc74d2091", "url": "https://github.com/splicemachine/spliceengine/commit/66a11add3619fabf4bce5a96dc3937cbc74d2091", "message": "Merge remote-tracking branch 'origin/master' into DB-10253", "committedDate": "2020-10-14T08:38:36Z", "type": "commit"}, {"oid": "1c611027cecc5fdd1df4b225b26fd99c1949a59b", "url": "https://github.com/splicemachine/spliceengine/commit/1c611027cecc5fdd1df4b225b26fd99c1949a59b", "message": "DB-10253 address comments.", "committedDate": "2020-10-14T09:13:57Z", "type": "commit"}]}