{"pr_number": 3422, "pr_title": "DB-9369 Remove schema inference for Parquet tables", "pr_createdAt": "2020-04-13T10:36:16Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3422", "timeline": [{"oid": "d7c7bf326464101e354aed807ed9155112bdb84f", "url": "https://github.com/splicemachine/spliceengine/commit/d7c7bf326464101e354aed807ed9155112bdb84f", "message": "DB-9369 Remove schema inference for Parquet tables\n\nMake Decimal width computation consistent\nImplement extract weekday in native spark", "committedDate": "2020-04-13T10:34:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU5MzAzMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3422#discussion_r408593031", "bodyText": "There is an else path also with (rightType.isStringTypeId() && leftType.isNumericTypeId()), why not use computeMaxWidth() for that path also?", "author": "yxia92", "createdAt": "2020-04-15T05:41:40Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java", "diffHunk": "@@ -152,7 +153,7 @@ public ValueNode bindExpression( FromList\tfromList, SubqueryList subqueryList, L\n \t\t\t\tint charMaxWidth = leftDTS.getMaximumWidth();\n \t\t\t\tprecision += (2 * charMaxWidth);\t\t\t\t\t\t\t\t\n \t\t\t\tscale += charMaxWidth;\t\t\t\t\t\t\t\t\n-\t\t\t\tmaxWidth = precision + 3;\n+\t\t\t\tmaxWidth = DataTypeUtilities.computeMaxWidth(precision, scale);", "originalCommit": "d7c7bf326464101e354aed807ed9155112bdb84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMDQ3OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3422#discussion_r408720478", "bodyText": "Good catch, I missed that branch.", "author": "dgomezferro", "createdAt": "2020-04-15T09:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU5MzAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1c49f976cf4eedf1ab266fb66f5f1fc96b89f767", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java\nindex 195425aa47..306d107c55 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java\n\n@@ -55,162 +55,162 @@ import java.util.List;\n \n public final class BinaryArithmeticOperatorNode extends BinaryOperatorNode\n {\n-\t/**\n-\t * Initializer for a BinaryArithmeticOperatorNode\n-\t *\n-\t * @param leftOperand\tThe left operand\n-\t * @param rightOperand\tThe right operand\n-\t */\n-\n-\tpublic void init(\n-\t\t\t\t\tObject leftOperand,\n-\t\t\t\t\tObject rightOperand)\n-\t{\n-\t\tsuper.init(leftOperand, rightOperand,\n-\t\t\t\tClassName.NumberDataValue, ClassName.NumberDataValue);\n-\t}\n-\n-\tpublic void setNodeType(int nodeType)\n-\t{\n-\t\tString operator = null;\n-\t\tString methodName = null;\n-\n-\t\tswitch (nodeType)\n-\t\t{\n-\t\t\tcase C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE:\n-\t\t\t\toperator = TypeCompiler.DIVIDE_OP;\n-\t\t\t\tmethodName = \"divide\";\n-\t\t\t\tbreak;\n-\n-\t\t\tcase C_NodeTypes.BINARY_MINUS_OPERATOR_NODE:\n-\t\t\t\toperator = TypeCompiler.MINUS_OP;\n-\t\t\t\tmethodName = \"minus\";\n-\t\t\t\tbreak;\n-\n-\t\t\tcase C_NodeTypes.BINARY_PLUS_OPERATOR_NODE:\n-\t\t\t\toperator = TypeCompiler.PLUS_OP;\n-\t\t\t\tmethodName = \"plus\";\n-\t\t\t\tbreak;\n-\n-\t\t\tcase C_NodeTypes.BINARY_TIMES_OPERATOR_NODE:\n-\t\t\t\toperator = TypeCompiler.TIMES_OP;\n-\t\t\t\tmethodName = \"times\";\n-\t\t\t\tbreak;\n-\n-\t\t\tcase C_NodeTypes.MOD_OPERATOR_NODE:\n-\t\t\t\toperator = TypeCompiler.MOD_OP;\n-\t\t\t\tmethodName = \"mod\";\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\n-\t\t\t\t\t\t\"Unexpected nodeType = \" + nodeType);\n-\t\t\t\t}\n-\t\t}\n-\t\tsetOperator(operator);\n-\t\tsetMethodName(methodName);\n-\t\tsuper.setNodeType(nodeType);\n-\t}\n-\n-\t/**\n-\t * Bind this operator\n-\t *\n-\t * @param fromList\t\t\tThe query's FROM list\n-\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @return\tThe new top of the expression tree.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    /**\n+     * Initializer for a BinaryArithmeticOperatorNode\n+     *\n+     * @param leftOperand\tThe left operand\n+     * @param rightOperand\tThe right operand\n+     */\n+\n+    public void init(\n+            Object leftOperand,\n+            Object rightOperand)\n+    {\n+        super.init(leftOperand, rightOperand,\n+                ClassName.NumberDataValue, ClassName.NumberDataValue);\n+    }\n+\n+    public void setNodeType(int nodeType)\n+    {\n+        String operator = null;\n+        String methodName = null;\n+\n+        switch (nodeType)\n+        {\n+            case C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE:\n+                operator = TypeCompiler.DIVIDE_OP;\n+                methodName = \"divide\";\n+                break;\n+\n+            case C_NodeTypes.BINARY_MINUS_OPERATOR_NODE:\n+                operator = TypeCompiler.MINUS_OP;\n+                methodName = \"minus\";\n+                break;\n+\n+            case C_NodeTypes.BINARY_PLUS_OPERATOR_NODE:\n+                operator = TypeCompiler.PLUS_OP;\n+                methodName = \"plus\";\n+                break;\n+\n+            case C_NodeTypes.BINARY_TIMES_OPERATOR_NODE:\n+                operator = TypeCompiler.TIMES_OP;\n+                methodName = \"times\";\n+                break;\n+\n+            case C_NodeTypes.MOD_OPERATOR_NODE:\n+                operator = TypeCompiler.MOD_OP;\n+                methodName = \"mod\";\n+                break;\n+\n+            default:\n+                if (SanityManager.DEBUG)\n+                {\n+                    SanityManager.THROWASSERT(\n+                            \"Unexpected nodeType = \" + nodeType);\n+                }\n+        }\n+        setOperator(operator);\n+        setMethodName(methodName);\n+        super.setNodeType(nodeType);\n+    }\n+\n+    /**\n+     * Bind this operator\n+     *\n+     * @param fromList\t\t\tThe query's FROM list\n+     * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n+     *\n+     * @return\tThe new top of the expression tree.\n+     *\n+     * @exception StandardException\t\tThrown on error\n+     */\n     @Override\n-\tpublic ValueNode bindExpression( FromList\tfromList, SubqueryList subqueryList, List<AggregateNode> aggregateVector) throws StandardException {\n-\t\tsuper.bindExpression(fromList, subqueryList, aggregateVector);\n-\n-\t\tTypeId\tleftType = leftOperand.getTypeId();\n-\t\tTypeId\trightType = rightOperand.getTypeId();\n-\t\tDataTypeDescriptor\tleftDTS = leftOperand.getTypeServices();\n-\t\tDataTypeDescriptor\trightDTS = rightOperand.getTypeServices();\n-\n-\t\t/* Do any implicit conversions from (long) (var)char. */\n-\t\tif (leftType.isStringTypeId() && rightType.isNumericTypeId())\n-\t\t{\n-\t\t\tboolean nullableResult;\n-\t\t\tnullableResult = leftDTS.isNullable() ||\n-\t\t \t\t\t\t\t rightDTS.isNullable();\n-\t\t\t/* If other side is decimal/numeric, then we need to diddle\n-\t\t\t * with the precision, scale and max width in order to handle\n-\t\t\t * computations like:  1.1 + '0.111'\n-\t\t\t */\n-\t\t\tint precision = rightDTS.getPrecision();\n-\t\t\tint scale\t  = rightDTS.getScale();\n-\t\t\tint maxWidth  = rightDTS.getMaximumWidth();\n-\n-\t\t\tif (rightType.isDecimalTypeId())\n-\t\t\t{\n-\t\t\t\tint charMaxWidth = leftDTS.getMaximumWidth();\n-\t\t\t\tprecision += (2 * charMaxWidth);\t\t\t\t\t\t\t\t\n-\t\t\t\tscale += charMaxWidth;\t\t\t\t\t\t\t\t\n-\t\t\t\tmaxWidth = DataTypeUtilities.computeMaxWidth(precision, scale);\n-\t\t\t}\n-\n-\t\t\tleftOperand = (ValueNode)\n-\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\tleftOperand, \n-\t\t\t\t\t\tnew DataTypeDescriptor(rightType, precision,\n-\t\t\t\t\t\t\t\t\t\t\tscale, nullableResult, \n-\t\t\t\t\t\t\t\t\t\t\tmaxWidth),\n-\t\t\t\t\t\tgetContextManager());\n-\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t}\n-\t\telse if (rightType.isStringTypeId() && leftType.isNumericTypeId())\n-\t\t{\n-\t\t\tboolean nullableResult;\n-\t\t\tnullableResult = leftDTS.isNullable() ||\n-\t\t \t\t\t\t\t rightDTS.isNullable();\n-\t\t\t/* If other side is decimal/numeric, then we need to diddle\n-\t\t\t * with the precision, scale and max width in order to handle\n-\t\t\t * computations like:  1.1 + '0.111'\n-\t\t\t */\n-\t\t\tint precision = leftDTS.getPrecision();\n-\t\t\tint scale\t  = leftDTS.getScale();\n-\t\t\tint maxWidth  = leftDTS.getMaximumWidth();\n-\n-\t\t\tif (leftType.isDecimalTypeId())\n-\t\t\t{\n-\t\t\t\tint charMaxWidth = rightDTS.getMaximumWidth();\n-\t\t\t\tprecision += (2 * charMaxWidth);\t\t\t\t\t\t\t\t\n-\t\t\t\tscale += charMaxWidth;\t\t\t\t\t\t\t\t\n-\t\t\t\tmaxWidth = precision + 3;\n-\t\t\t}\n-\n-\t\t\trightOperand =  (ValueNode)\n-\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\trightOperand, \n-\t\t\t\t\t\tnew DataTypeDescriptor(leftType, precision,\n-\t\t\t\t\t\t\t\t\t\t\tscale, nullableResult, \n-\t\t\t\t\t\t\t\t\t\t\tmaxWidth),\n-\t\t\t\t\t\tgetContextManager());\n-\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t}\n-\n-\t\t/*\n-\t\t** Set the result type of this operator based on the operands.\n-\t\t** By convention, the left operand gets to decide the result type\n-\t\t** of a binary operator.\n-\t\t*/\n-\t\tsetType(leftOperand.getTypeCompiler().\n-\t\t\t\t\tresolveArithmeticOperation(\n-\t\t\t\t\t\tleftOperand.getTypeServices(),\n-\t\t\t\t\t\trightOperand.getTypeServices(),\n-\t\t\t\t\t\toperator\n-\t\t\t\t\t\t\t)\n-\t\t\t\t);\n-\n-\t\treturn this;\n-\t}\n+    public ValueNode bindExpression( FromList\tfromList, SubqueryList subqueryList, List<AggregateNode> aggregateVector) throws StandardException {\n+        super.bindExpression(fromList, subqueryList, aggregateVector);\n+\n+        TypeId\tleftType = leftOperand.getTypeId();\n+        TypeId\trightType = rightOperand.getTypeId();\n+        DataTypeDescriptor\tleftDTS = leftOperand.getTypeServices();\n+        DataTypeDescriptor\trightDTS = rightOperand.getTypeServices();\n+\n+        /* Do any implicit conversions from (long) (var)char. */\n+        if (leftType.isStringTypeId() && rightType.isNumericTypeId())\n+        {\n+            boolean nullableResult;\n+            nullableResult = leftDTS.isNullable() ||\n+                    rightDTS.isNullable();\n+            /* If other side is decimal/numeric, then we need to diddle\n+             * with the precision, scale and max width in order to handle\n+             * computations like:  1.1 + '0.111'\n+             */\n+            int precision = rightDTS.getPrecision();\n+            int scale\t  = rightDTS.getScale();\n+            int maxWidth  = rightDTS.getMaximumWidth();\n+\n+            if (rightType.isDecimalTypeId())\n+            {\n+                int charMaxWidth = leftDTS.getMaximumWidth();\n+                precision += (2 * charMaxWidth);\n+                scale += charMaxWidth;\n+                maxWidth = DataTypeUtilities.computeMaxWidth(precision, scale);\n+            }\n+\n+            leftOperand = (ValueNode)\n+                    getNodeFactory().getNode(\n+                            C_NodeTypes.CAST_NODE,\n+                            leftOperand,\n+                            new DataTypeDescriptor(rightType, precision,\n+                                    scale, nullableResult,\n+                                    maxWidth),\n+                            getContextManager());\n+            ((CastNode) leftOperand).bindCastNodeOnly();\n+        }\n+        else if (rightType.isStringTypeId() && leftType.isNumericTypeId())\n+        {\n+            boolean nullableResult;\n+            nullableResult = leftDTS.isNullable() ||\n+                    rightDTS.isNullable();\n+            /* If other side is decimal/numeric, then we need to diddle\n+             * with the precision, scale and max width in order to handle\n+             * computations like:  1.1 + '0.111'\n+             */\n+            int precision = leftDTS.getPrecision();\n+            int scale\t  = leftDTS.getScale();\n+            int maxWidth  = leftDTS.getMaximumWidth();\n+\n+            if (leftType.isDecimalTypeId())\n+            {\n+                int charMaxWidth = rightDTS.getMaximumWidth();\n+                precision += (2 * charMaxWidth);\n+                scale += charMaxWidth;\n+                maxWidth = DataTypeUtilities.computeMaxWidth(precision, scale);\n+            }\n+\n+            rightOperand =  (ValueNode)\n+                    getNodeFactory().getNode(\n+                            C_NodeTypes.CAST_NODE,\n+                            rightOperand,\n+                            new DataTypeDescriptor(leftType, precision,\n+                                    scale, nullableResult,\n+                                    maxWidth),\n+                            getContextManager());\n+            ((CastNode) rightOperand).bindCastNodeOnly();\n+        }\n+\n+        /*\n+         ** Set the result type of this operator based on the operands.\n+         ** By convention, the left operand gets to decide the result type\n+         ** of a binary operator.\n+         */\n+        setType(leftOperand.getTypeCompiler().\n+                resolveArithmeticOperation(\n+                        leftOperand.getTypeServices(),\n+                        rightOperand.getTypeServices(),\n+                        operator\n+                )\n+        );\n+\n+        return this;\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU5NDQ2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3422#discussion_r408594469", "bodyText": "Is a %s in the format string?", "author": "yxia92", "createdAt": "2020-04-15T05:46:12Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OperatorToString.java", "diffHunk": "@@ -317,11 +317,25 @@ else if (operand instanceof ExtractOperatorNode) {\n                     String functionName = eon.sparkFunctionName();\n \n                     // Splice extracts fractional seconds, but spark only extracts whole seconds.\n-                    if (functionName.equals(\"SECOND\") || functionName.equals(\"WEEK\") ||\n-                        functionName.equals(\"WEEKDAY\") || functionName.equals(\"WEEKDAYNAME\"))\n+                    if (functionName.equals(\"SECOND\")) {\n                         throwNotImplementedError();\n-                    else\n+                    } else if (functionName.equals(\"WEEK\") || functionName.equals(\"WEEKDAY\") || functionName.equals(\"WEEKDAYNAME\")) {\n+                        String parameter = \"\";\n+                        switch (functionName) {\n+                            case \"WEEK\":\n+                                parameter = \"W\";\n+                                break;\n+                            case \"WEEKDAY\":\n+                                parameter = \"u\";\n+                                break;\n+                            case \"WEEKDAYNAME\":\n+                                parameter = \"EEEE\";\n+                                break;\n+                        }\n+                        return format(\"date_format(%s, \\\"\\\") \", opToString2(uop.getOperand(), vars), parameter);", "originalCommit": "d7c7bf326464101e354aed807ed9155112bdb84f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMTU0OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3422#discussion_r408721548", "bodyText": "This was badly broken sorry, I'm not sure why I didn't catch while manually testing on the service.\nI've fixed it and added a test that uses parquet External tables to force this codepath.\nAgain, thanks for the catch!", "author": "dgomezferro", "createdAt": "2020-04-15T09:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU5NDQ2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "1c49f976cf4eedf1ab266fb66f5f1fc96b89f767", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OperatorToString.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OperatorToString.java\nindex 867f494531..48438a4974 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OperatorToString.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OperatorToString.java\n\n@@ -321,18 +321,25 @@ public class OperatorToString {\n                         throwNotImplementedError();\n                     } else if (functionName.equals(\"WEEK\") || functionName.equals(\"WEEKDAY\") || functionName.equals(\"WEEKDAYNAME\")) {\n                         String parameter = \"\";\n+                        boolean cast = false;\n                         switch (functionName) {\n                             case \"WEEK\":\n+                                cast = true;\n                                 parameter = \"W\";\n                                 break;\n                             case \"WEEKDAY\":\n+                                cast = true;\n                                 parameter = \"u\";\n                                 break;\n                             case \"WEEKDAYNAME\":\n                                 parameter = \"EEEE\";\n                                 break;\n                         }\n-                        return format(\"date_format(%s, \\\"\\\") \", opToString2(uop.getOperand(), vars), parameter);\n+                        if (cast) {\n+                            return format(\"cast(date_format(%s, \\\"%s\\\") as int) \", opToString2(uop.getOperand(), vars), parameter);\n+                        } else {\n+                            return format(\"date_format(%s, \\\"%s\\\") \", opToString2(uop.getOperand(), vars), parameter);\n+                        }\n                     } else {\n                         return format(\"%s(%s) \", functionName, opToString2(uop.getOperand(), vars));\n                     }\n"}}, {"oid": "1c49f976cf4eedf1ab266fb66f5f1fc96b89f767", "url": "https://github.com/splicemachine/spliceengine/commit/1c49f976cf4eedf1ab266fb66f5f1fc96b89f767", "message": "DB-9369 Address review", "committedDate": "2020-04-15T09:52:18Z", "type": "commit"}, {"oid": "06fe5f9bc3d725eb130f0f7dac58f6d0059fca57", "url": "https://github.com/splicemachine/spliceengine/commit/06fe5f9bc3d725eb130f0f7dac58f6d0059fca57", "message": "DB-9369 Remove superfluous changes", "committedDate": "2020-04-15T10:01:51Z", "type": "commit"}, {"oid": "16f877c3944a224ae92ad60668cbcd4d78630432", "url": "https://github.com/splicemachine/spliceengine/commit/16f877c3944a224ae92ad60668cbcd4d78630432", "message": "DB-9369 Disable \"extract week\" and update IT", "committedDate": "2020-04-15T11:02:48Z", "type": "commit"}, {"oid": "5ac229c50a33ca369386f8a4cc8b72ab6c5209f6", "url": "https://github.com/splicemachine/spliceengine/commit/5ac229c50a33ca369386f8a4cc8b72ab6c5209f6", "message": "Merge remote-tracking branch 'origin/master' into DB-9369", "committedDate": "2020-04-27T08:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NzUyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3422#discussion_r415777526", "bodyText": "i made some changes in #3486 to assure these temporary files are removed again. i'm waiting on this review, so if your change is in before mine i might have to adjust this as well. (this is more a note for myself to adjust this as well).\nfor now, tablePath.deleteOnExit(); should be sufficient", "author": "martinrupp", "createdAt": "2020-04-27T12:40:53Z", "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/ExternalTableIT.java", "diffHunk": "@@ -61,6 +63,45 @@ public static void cleanoutDirectory() {\n         SpliceUnitTest.clearDirectory( getExternalResourceDirectory() );\n     }\n \n+    @Test\n+    public void testNativeSparkExtractFunction() throws Exception {\n+        try {\n+            File tablePath = File.createTempFile(\"native-spark-table\", \".tmp\");", "originalCommit": "5ac229c50a33ca369386f8a4cc8b72ab6c5209f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61e7077b840ac0ce225d116aeab8b3cdf09fe68b", "chunk": "diff --git a/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/ExternalTableIT.java b/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/ExternalTableIT.java\nindex 6fa936bfe5..988a676a94 100644\n--- a/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/ExternalTableIT.java\n+++ b/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/ExternalTableIT.java\n\n@@ -56,13 +53,6 @@ public class ExternalTableIT extends SpliceUnitTest{\n     public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n             .around(spliceSchemaWatcher);\n \n-    // this will cleanup all files created in the dir getExternalResourceDirectory()\n-    // (if you insert into external tables, you create files)\n-    @BeforeClass\n-    public static void cleanoutDirectory() {\n-        SpliceUnitTest.clearDirectory( getExternalResourceDirectory() );\n-    }\n-\n     @Test\n     public void testNativeSparkExtractFunction() throws Exception {\n         try {\n"}}, {"oid": "61e7077b840ac0ce225d116aeab8b3cdf09fe68b", "url": "https://github.com/splicemachine/spliceengine/commit/61e7077b840ac0ce225d116aeab8b3cdf09fe68b", "message": "Merge remote-tracking branch 'origin/master' into DB-9369", "committedDate": "2020-04-29T18:48:09Z", "type": "commit"}]}