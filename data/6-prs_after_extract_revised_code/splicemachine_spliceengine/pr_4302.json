{"pr_number": 4302, "pr_title": "DB-10176 Support expression-based indexes in cost estimation", "pr_createdAt": "2020-10-15T12:33:58Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4302", "timeline": [{"oid": "5c7e264195c5cd1059332c52d5307791bf296e95", "url": "https://github.com/splicemachine/spliceengine/commit/5c7e264195c5cd1059332c52d5307791bf296e95", "message": "DB-10175 Expression-based index scan with relational operator preds", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "url": "https://github.com/splicemachine/spliceengine/commit/e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "message": "DB-10175 Expression-based index scan with in-list predicates", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "57ce9e16fc3de1c64638575483938d57d6795e42", "url": "https://github.com/splicemachine/spliceengine/commit/57ce9e16fc3de1c64638575483938d57d6795e42", "message": "DB-10175 Fix SpotBugs", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "message": "DB-10175 Address comments", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "b965fdf6ac44f431b541813d79344aec6776bde4", "url": "https://github.com/splicemachine/spliceengine/commit/b965fdf6ac44f431b541813d79344aec6776bde4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-15T11:22:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Mjc2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508342768", "bodyText": "afaik you can just do SpliceUnitTest.rowContainsQuery(levels, query, \"rows=10\",\"MergeJoin\"); which does the try/createStatement for you", "author": "martinrupp", "createdAt": "2020-10-20T09:18:36Z", "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java", "diffHunk": "@@ -51,6 +51,16 @@ public void innerJoin() throws Exception {\n                     \"explain select * from --splice-properties joinOrder=fixed\\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=MERGE\\n where ts_10_spk.c1 = ts_5_spk.c1\",\n                     \"rows=10\",\"MergeJoin\");\n         }\n+\n+        try(Statement s = methodWatcher.getOrCreateConnection().createStatement()){\n+            rowContainsQuery(s,\n+                    new int[]{1,3},\n+                    \"explain select upper(ts_10_spk.c2), upper(ts_5_spk.c2) from --splice-properties joinOrder=fixed\\n \" +\n+                            \"ts_10_spk --splice-properties index=ts_10_spk_expr_idx\\n, \" +\n+                            \"ts_5_spk --splice-properties index=ts_5_spk_expr_idx, joinStrategy=MERGE\\n \" +\n+                            \"where upper(ts_10_spk.c2) = upper(ts_5_spk.c2)\",\n+                    \"rows=10\",\"MergeJoin\");\n+        }", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNTQ5OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522215499", "bodyText": "That's right. Currently, xJoinSelectivityIT tests are derived from BaseJoinSelectivityIT but not from SpliceUnitTest. So we don't have the rowContainsQuery() here. The one we see in these tests are actually a method in BaseJoinSelectivityIT that does the same...\nAll these tests probably should be adapted to derive from SpliceUnitTest. But I guess I'll do this in the very end since they are just tests.", "author": "ascend1", "createdAt": "2020-11-12T15:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Mjc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java b/splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java\nindex e721b4b25d..e96daeb726 100644\n--- a/splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java\n+++ b/splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/MergeJoinSelectivityIT.java\n\n@@ -51,16 +51,6 @@ public class MergeJoinSelectivityIT extends BaseJoinSelectivityIT {\n                     \"explain select * from --splice-properties joinOrder=fixed\\n ts_10_spk, ts_5_spk --splice-properties joinStrategy=MERGE\\n where ts_10_spk.c1 = ts_5_spk.c1\",\n                     \"rows=10\",\"MergeJoin\");\n         }\n-\n-        try(Statement s = methodWatcher.getOrCreateConnection().createStatement()){\n-            rowContainsQuery(s,\n-                    new int[]{1,3},\n-                    \"explain select upper(ts_10_spk.c2), upper(ts_5_spk.c2) from --splice-properties joinOrder=fixed\\n \" +\n-                            \"ts_10_spk --splice-properties index=ts_10_spk_expr_idx\\n, \" +\n-                            \"ts_5_spk --splice-properties index=ts_5_spk_expr_idx, joinStrategy=MERGE\\n \" +\n-                            \"where upper(ts_10_spk.c2) = upper(ts_5_spk.c2)\",\n-                    \"rows=10\",\"MergeJoin\");\n-        }\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NTE2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508345162", "bodyText": "i would do a slightly reordering here:\nif (outerColumnInfo == null) continuel\n\nint outerTableNum = outerColumnInfo.getFirst();\nint outerColNum = outerColumnInfo.getSecond();\n\nthat way, there's no doubt outerTableNum and outerColNum are initialized.", "author": "martinrupp", "createdAt": "2020-10-20T09:22:09Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -277,29 +283,37 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                         \"Programmer error: RelationalOperator of type \"+ relop.getClass()+\" detected\";\n                 BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode)relop;\n                 if (bron.getOperator() == RelationalOperator.EQUALS_RELOP) {\n-                    ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n-                    ColumnReference outerColumn = getOuterColumn(bron, innerColumn);\n-                    if (innerColumn == null || outerColumn == null) continue;\n-                    int innerColumnNumber = innerColumn.getColumnNumber();\n+                    ColumnReference innerColumn = null;\n+                    int innerColumnNumber;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n+                    if (isIndexOnExpr) {\n+                        innerColumnNumber = pred.hasEqualOnIndexExpression(innerTable);\n+                    } else {\n+                        innerColumn = relop.getColumnOperand(innerTable);\n+                        if (innerColumn == null) {\n+                            continue;\n+                        }\n+                        innerColumnNumber = innerColumn.getColumnNumber();\n+                    }\n+\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, innerColumn);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDcxMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522550710", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-13T01:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NTE2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\nindex 6f4b1cbc8e..98c7ef6cbb 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\n\n@@ -283,37 +277,29 @@ public class MergeJoinStrategy extends HashableJoinStrategy{\n                         \"Programmer error: RelationalOperator of type \"+ relop.getClass()+\" detected\";\n                 BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode)relop;\n                 if (bron.getOperator() == RelationalOperator.EQUALS_RELOP) {\n-                    ColumnReference innerColumn = null;\n-                    int innerColumnNumber;\n-                    int outerTableNum;\n-                    int outerColNum;\n-\n-                    if (isIndexOnExpr) {\n-                        innerColumnNumber = pred.hasEqualOnIndexExpression(innerTable);\n-                    } else {\n-                        innerColumn = relop.getColumnOperand(innerTable);\n-                        if (innerColumn == null) {\n-                            continue;\n-                        }\n-                        innerColumnNumber = innerColumn.getColumnNumber();\n-                    }\n-\n-                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, innerColumn);\n-                    if (outerColumnInfo != null) {\n-                        outerTableNum = outerColumnInfo.getFirst();\n-                        outerColNum = outerColumnInfo.getSecond();\n-                    } else {\n-                        continue;\n-                    }\n+                    ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n+                    ColumnReference outerColumn = getOuterColumn(bron, innerColumn);\n+                    if (innerColumn == null || outerColumn == null) continue;\n+                    int innerColumnNumber = innerColumn.getColumnNumber();\n                     if (innerColumnNumber == innerColumnPosition) {\n                         innerColumns.set(i);\n-                        int rowOrdering = ascending ? RowOrdering.ASCENDING : RowOrdering.DESCENDING;\n-                        int outerPos = outerRowOrdering.orderedPositionForColumn(rowOrdering, outerTableNum, outerColNum);\n-                        if (outerPos >= 0) {\n-                            outerColumns.set(outerPos);\n-                            innerToOuterJoinColumnMap[i] = outerPos;\n-                        } else\n-                            return false;\n+                        int outerTableNum = outerColumn.getTableNumber();\n+                        int outerColNum = outerColumn.getColumnNumber();\n+                        if (ascending) {\n+                            int outerPos = outerRowOrdering.orderedPositionForColumn(RowOrdering.ASCENDING, outerTableNum, outerColNum);\n+                            if (outerPos >= 0) {\n+                                outerColumns.set(outerPos);\n+                                innerToOuterJoinColumnMap[i] = outerPos;\n+                            } else\n+                                return false;\n+                        } else {\n+                            int outerPos = outerRowOrdering.orderedPositionForColumn(RowOrdering.DESCENDING, outerTableNum, outerColNum);\n+                            if (outerPos >= 0) {\n+                                outerColumns.set(outerPos);\n+                                innerToOuterJoinColumnMap[i] = outerPos;\n+                            } else\n+                                return false;\n+                        }\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjI1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508346255", "bodyText": "reorder\nif (outerColumnInfo == null) continue;\nint outerTableNum = outerColumnInfo.getFirst();\nint outerColNum = outerColumnInfo.getSecond();\n\n(now clear everything is initialized)", "author": "martinrupp", "createdAt": "2020-10-20T09:23:44Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java", "diffHunk": "@@ -218,33 +219,38 @@ private boolean mergeable(RowOrdering outerRowOrdering,\n                                 IndexRowGenerator innerRowGenerator,\n                                 OptimizablePredicateList predList,\n                                 Optimizable innerTable) throws StandardException{\n-        int[] keyColumnPositionMap = innerRowGenerator.baseColumnPositions();\n+        boolean isIndexOnExpr = innerRowGenerator.isOnExpression();\n+        int[] keyColumnPositionMap = isIndexOnExpr ? null : innerRowGenerator.baseColumnPositions();\n         boolean[] keyAscending = innerRowGenerator.isAscending();\n \n-        BitSet innerColumns = new BitSet(keyColumnPositionMap.length);\n-        BitSet outerColumns = new BitSet(keyColumnPositionMap.length);\n+        BitSet innerColumns = new BitSet(keyAscending.length);\n+        BitSet outerColumns = new BitSet(keyAscending.length);\n         for(int p = 0;p<predList.size();p++){\n             Predicate pred = (Predicate)predList.getOptPredicate(p);\n             if(pred.isJoinPredicate()) continue; //we'll deal with these later\n             RelationalOperator relop=pred.getRelop();\n             if(!(relop instanceof BinaryRelationalOperatorNode)) continue;\n             if(relop.getOperator()==RelationalOperator.EQUALS_RELOP) {\n-                int innerEquals = pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n-                if (innerEquals >= 0) innerColumns.set(innerEquals);\n-                else {\n-\n+                int innerEquals = isIndexOnExpr ? pred.hasEqualOnIndexExpression(innerTable)\n+                                                : pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n+                if (innerEquals >= 0) {\n+                    innerColumns.set(innerEquals);\n+                } else {\n                     BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n-                    ValueNode vn = bron.getLeftOperand();\n-                    if (!(vn instanceof ColumnReference))\n-                        vn = bron.getRightOperand();\n-                    if (!(vn instanceof ColumnReference)) continue;\n-                    ColumnReference outerColumn = (ColumnReference) vn;\n+                    int outerTableNum;\n+                    int outerColNum;\n+\n                     /*\n                      * We are still sortable if we have constant predicates on the first N keys on the outer\n                      * side of the join, as long as we match the inner columns\n                      */\n-                    int outerTableNum = outerColumn.getTableNumber();\n-                    int outerColNum = outerColumn.getColumnNumber();\n+                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, null);\n+                    if (outerColumnInfo != null) {\n+                        outerTableNum = outerColumnInfo.getFirst();\n+                        outerColNum = outerColumnInfo.getSecond();\n+                    } else {\n+                        continue;\n+                    }", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDMzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522550339", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-13T01:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\nindex 6f4b1cbc8e..98c7ef6cbb 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/MergeJoinStrategy.java\n\n@@ -219,38 +218,33 @@ public class MergeJoinStrategy extends HashableJoinStrategy{\n                                 IndexRowGenerator innerRowGenerator,\n                                 OptimizablePredicateList predList,\n                                 Optimizable innerTable) throws StandardException{\n-        boolean isIndexOnExpr = innerRowGenerator.isOnExpression();\n-        int[] keyColumnPositionMap = isIndexOnExpr ? null : innerRowGenerator.baseColumnPositions();\n+        int[] keyColumnPositionMap = innerRowGenerator.baseColumnPositions();\n         boolean[] keyAscending = innerRowGenerator.isAscending();\n \n-        BitSet innerColumns = new BitSet(keyAscending.length);\n-        BitSet outerColumns = new BitSet(keyAscending.length);\n+        BitSet innerColumns = new BitSet(keyColumnPositionMap.length);\n+        BitSet outerColumns = new BitSet(keyColumnPositionMap.length);\n         for(int p = 0;p<predList.size();p++){\n             Predicate pred = (Predicate)predList.getOptPredicate(p);\n             if(pred.isJoinPredicate()) continue; //we'll deal with these later\n             RelationalOperator relop=pred.getRelop();\n             if(!(relop instanceof BinaryRelationalOperatorNode)) continue;\n             if(relop.getOperator()==RelationalOperator.EQUALS_RELOP) {\n-                int innerEquals = isIndexOnExpr ? pred.hasEqualOnIndexExpression(innerTable)\n-                                                : pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n-                if (innerEquals >= 0) {\n-                    innerColumns.set(innerEquals);\n-                } else {\n-                    BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n-                    int outerTableNum;\n-                    int outerColNum;\n+                int innerEquals = pred.hasEqualOnColumnList(keyColumnPositionMap, innerTable);\n+                if (innerEquals >= 0) innerColumns.set(innerEquals);\n+                else {\n \n+                    BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n+                    ValueNode vn = bron.getLeftOperand();\n+                    if (!(vn instanceof ColumnReference))\n+                        vn = bron.getRightOperand();\n+                    if (!(vn instanceof ColumnReference)) continue;\n+                    ColumnReference outerColumn = (ColumnReference) vn;\n                     /*\n                      * We are still sortable if we have constant predicates on the first N keys on the outer\n                      * side of the join, as long as we match the inner columns\n                      */\n-                    Pair<Integer, Integer> outerColumnInfo = getOuterColumnInfo(bron, innerTable, null);\n-                    if (outerColumnInfo != null) {\n-                        outerTableNum = outerColumnInfo.getFirst();\n-                        outerColNum = outerColumnInfo.getSecond();\n-                    } else {\n-                        continue;\n-                    }\n+                    int outerTableNum = outerColumn.getTableNumber();\n+                    int outerColNum = outerColumn.getColumnNumber();\n                     //we don't care what the sort order for this column is, since it's an equals predicate anyway\n                     int pos = outerRowOrdering.orderedPositionForColumn(RowOrdering.ASCENDING, outerTableNum, outerColNum);\n                     if (pos >= 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NzUzNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508347536", "bodyText": "(nitpic) 0.0f is float, you mean 0.0 (double)", "author": "martinrupp", "createdAt": "2020-10-20T09:25:35Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java", "diffHunk": "@@ -915,4 +915,10 @@ public boolean isConstantOrParameterTreeNode() {\n         // for count(*), operand is null\n         return operand != null && operand.isConstantOrParameterTreeNode();\n     }\n+\n+    public double getBaseOperationCost() throws StandardException { return getOperandCost(); }\n+\n+    protected double getOperandCost() throws StandardException {\n+        return operand == null ? 0.0f : operand.getBaseOperationCost();", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTAzNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522551036", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-13T01:27:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NzUzNg=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\nindex e793728343..524b9dc38d 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n\n@@ -912,13 +912,6 @@ public class UnaryOperatorNode extends OperatorNode\n \n     @Override\n     public boolean isConstantOrParameterTreeNode() {\n-        // for count(*), operand is null\n-        return operand != null && operand.isConstantOrParameterTreeNode();\n-    }\n-\n-    public double getBaseOperationCost() throws StandardException { return getOperandCost(); }\n-\n-    protected double getOperandCost() throws StandardException {\n-        return operand == null ? 0.0f : operand.getBaseOperationCost();\n+        return operand.isConstantOrParameterTreeNode();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODQwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508348402", "bodyText": "you have consts for everything but not for 1.0 and 2.0, and i'm not sure what they represent. Why is the cost twice if there's an operand?", "author": "martinrupp", "createdAt": "2020-10-20T09:26:52Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java", "diffHunk": "@@ -181,4 +183,12 @@ public void generateExpression(ExpressionClassBuilder acb,\n         mb.cast(ClassName.DataValueDescriptor);\n         mb.callMethod(VMOpcode.INVOKEINTERFACE,(String)null,methodName,getTypeCompiler().interfaceName(),1);\n     } // end of generateExpression\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double lowerCost = getOperandCost();\n+        double localCost = SIMPLE_OP_COST * (operand == null ? 1.0 : 2.0);", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDAwMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522554003", "bodyText": "It just indicates that if the function has an operand, probably it executes more instructions to finish. I didn't look into the code of date and timestamp. But the costing is also like a heuristic. No need to make the cost absolutely accurate because in the end, it's about comparing options, always relative.", "author": "ascend1", "createdAt": "2020-11-13T01:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODQwMg=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java\nindex 34309acd3c..e5db21b075 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java\n\n@@ -183,12 +181,4 @@ public class UnaryDateTimestampOperatorNode extends UnaryOperatorNode{\n         mb.cast(ClassName.DataValueDescriptor);\n         mb.callMethod(VMOpcode.INVOKEINTERFACE,(String)null,methodName,getTypeCompiler().interfaceName(),1);\n     } // end of generateExpression\n-\n-    @Override\n-    public double getBaseOperationCost() throws StandardException {\n-        double lowerCost = getOperandCost();\n-        double localCost = SIMPLE_OP_COST * (operand == null ? 1.0 : 2.0);\n-        double callCost = SIMPLE_OP_COST * FN_CALL_COST_FACTOR;\n-        return lowerCost + localCost + callCost;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODcyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508348724", "bodyText": "why 2", "author": "martinrupp", "createdAt": "2020-10-20T09:27:18Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java", "diffHunk": "@@ -162,4 +162,10 @@ public ValueNode getClone() throws StandardException {\n         return newTS;\n     }\n \n+\t@Override\n+\tpublic double getBaseOperationCost() throws StandardException {\n+\t\tdouble localCost = SIMPLE_OP_COST * 2.0;", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDc2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522554760", "bodyText": "Similar to the other place, no particular reason for having 2.0, but just to indicate that it should be at least more expensive than a simple addition, which has cost of SIMPLE_OP_COST. The operator may be much more expensive than two addition, but I'm worried that expression evaluation cost accumulates fast, don't want this part to dominate the cost. This could be a future work.", "author": "ascend1", "createdAt": "2020-11-13T01:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java\nindex 219aa8d3e6..6f0a357116 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TimestampOperatorNode.java\n\n@@ -162,10 +162,4 @@ public class TimestampOperatorNode extends BinaryOperatorNode\n         return newTS;\n     }\n \n-\t@Override\n-\tpublic double getBaseOperationCost() throws StandardException {\n-\t\tdouble localCost = SIMPLE_OP_COST * 2.0;\n-\t\tdouble callCost = SIMPLE_OP_COST * FN_CALL_COST_FACTOR;\n-\t\treturn localCost + callCost + getChildrenCost();\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODk4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508368980", "bodyText": "I wonder if rather than sprinkling boolean forExprIndex in many methods, would it make sense to have a StoreCostController implementation for index expressions? It could extend our current StoreCostControllerImpl and override only the desired methods. It might even be enough to modify the initialization.\nThis is just a suggestion, not sure if it would actually simplify things.", "author": "dgomezferro", "createdAt": "2020-10-20T09:57:47Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java", "diffHunk": "@@ -120,9 +123,10 @@\n      * @throws StandardException Standard exception policy.\n      * @see RowUtil\n      */\n-    void getFetchFromFullKeyCost(BitSet validColumns,\n+    void getFetchFromFullKeyCost(boolean forExprIndex,", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg4NDg4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522884882", "bodyText": "That's a good idea. I did it in the current way because when an index on expressions is not covering, we need both base table statistics and index on expressions statistics at the same time. That's why we have them together in StoreCostController and have this flag in methods. It's a quick step.\nIdeally we should be able to have multiple StoreCostControllers representing statistics on different conglomerates. A bit more refactoring is needed to achieve it, though. I think when we want to improve index statistics handling, this is a necessary prior step.", "author": "ascend1", "createdAt": "2020-11-13T11:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java b/db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java\nindex e179013814..43ba870c22 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/iapi/store/access/StoreCostController.java\n\n@@ -123,10 +120,9 @@ public interface StoreCostController extends RowCountable{\n      * @throws StandardException Standard exception policy.\n      * @see RowUtil\n      */\n-    void getFetchFromFullKeyCost(boolean forExprIndex,\n-                                 BitSet validColumns,\n+    void getFetchFromFullKeyCost(BitSet validColumns,\n                                  int access_type,\n-                                 CostEstimate cost);\n+                                 CostEstimate cost) throws StandardException;\n \n     /**\n      * Return an \"empty\" row location object of the correct type.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MjYyMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508382622", "bodyText": "This class is not used, it can be removed", "author": "dgomezferro", "createdAt": "2020-10-20T10:19:38Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java", "diffHunk": "@@ -144,29 +144,39 @@ public int maxCapacity(int userSpecifiedCapacity, int maxMemoryPerTable, double\n     private boolean mergeable(IndexRowGenerator innerRowGenerator,", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1Njc2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522556762", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-13T01:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MjYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java\nindex 532b33786a..f216834470 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/compile/HalfMergeSortJoinStrategy.java\n\n@@ -144,30 +144,21 @@ public class HalfMergeSortJoinStrategy extends HashableJoinStrategy {\n     private boolean mergeable(IndexRowGenerator innerRowGenerator,\n                               OptimizablePredicateList predList,\n                               Optimizable innerTable) throws StandardException {\n-        boolean isIndexOnExpr = innerRowGenerator.isOnExpression();\n-        int[] keyColumnPositionMap = isIndexOnExpr ? null : innerRowGenerator.baseColumnPositions();\n-        boolean[] keyAscending = innerRowGenerator.isAscending();\n+        int[] keyColumnPositionMap = innerRowGenerator.baseColumnPositions();\n \n-        BitSet innerColumns = new BitSet(keyAscending.length);\n+        BitSet innerColumns = new BitSet(keyColumnPositionMap.length);\n         for(int p=0;p<predList.size();p++) {\n             Predicate pred = (Predicate) predList.getOptPredicate(p);\n             RelationalOperator relop = pred.getRelop();\n             if (pred.isJoinPredicate()) {\n                 assert relop instanceof BinaryRelationalOperatorNode :\n                         \"Programmer error: RelationalOperator of type \" + relop.getClass() + \" detected\";\n-                int innerColumnNumber;\n-                if (isIndexOnExpr) {\n-                    innerColumnNumber = pred.hasEqualOnIndexExpression(innerTable);\n-                } else {\n-                    ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n-                    if (innerColumn == null) {\n-                        continue;\n-                    }\n-                    innerColumnNumber = innerColumn.getColumnNumber();\n-                }\n-                for (int i = 0; i < keyAscending.length; ++i) {\n-                    int keyColumnPosition = isIndexOnExpr ? i : keyColumnPositionMap[i];\n-                    if (innerColumnNumber == keyColumnPosition) {\n+                BinaryRelationalOperatorNode bron = (BinaryRelationalOperatorNode) relop;\n+                ColumnReference innerColumn = relop.getColumnOperand(innerTable);\n+                if (innerColumn == null) continue;\n+                int innerColumnNumber = innerColumn.getColumnNumber();\n+                for (int i = 0; i < keyColumnPositionMap.length; ++i) {\n+                    if (innerColumnNumber == keyColumnPositionMap[i]) {\n                         innerColumns.set(i);\n                     }\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4Mjk3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r508382970", "bodyText": "This test is ignored, and the class is unused, it can be removed.", "author": "dgomezferro", "createdAt": "2020-10-20T10:20:10Z", "path": "hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java", "diffHunk": "@@ -156,6 +151,7 @@ public void testHalfSortMergeAfterSplit() throws Throwable {\n             \"(c1 int, c2 int, c3 int, c4 int)\");\n \n     protected static SpliceIndexWatcher aIndex = new SpliceIndexWatcher(A, CLASS_NAME, A_IDX,CLASS_NAME,\"(c1 desc, c2 asc, c3 desc)\");", "originalCommit": "e583648cc30a7d7c79e19c5d7a8a3c21fb7aa676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NjgwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522556809", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-13T01:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4Mjk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "1516c436841f204c294d1ac4329eeea983ef3802", "chunk": "diff --git a/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java b/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java\nindex 3b46344b65..162c9cd7b0 100644\n--- a/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java\n+++ b/hbase_sql/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/HalfMergeSortSparkIT.java\n\n@@ -151,7 +156,6 @@ public class HalfMergeSortSparkIT {\n             \"(c1 int, c2 int, c3 int, c4 int)\");\n \n     protected static SpliceIndexWatcher aIndex = new SpliceIndexWatcher(A, CLASS_NAME, A_IDX,CLASS_NAME,\"(c1 desc, c2 asc, c3 desc)\");\n-    protected static SpliceIndexWatcher aExprIndex = new SpliceIndexWatcher(A, CLASS_NAME, A_EXPR_IDX, CLASS_NAME, \"(c1+1 desc, c2 asc, abs(c3) desc)\");\n \n     protected static SpliceTableWatcher bTable = new SpliceTableWatcher(B, CLASS_NAME,\n             \"(c1 int, c2 int, c3 int, primary key(c1, c2))\");\n"}}, {"oid": "1516c436841f204c294d1ac4329eeea983ef3802", "url": "https://github.com/splicemachine/spliceengine/commit/1516c436841f204c294d1ac4329eeea983ef3802", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-22T09:06:54Z", "type": "commit"}, {"oid": "c5d12ed61478bccf565395f8029144a5314879b4", "url": "https://github.com/splicemachine/spliceengine/commit/c5d12ed61478bccf565395f8029144a5314879b4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-23T12:46:54Z", "type": "commit"}, {"oid": "7331a098e8a4abcb90f2fbac1c570f5447be0f28", "url": "https://github.com/splicemachine/spliceengine/commit/7331a098e8a4abcb90f2fbac1c570f5447be0f28", "message": "DB-10176 Fix SpotBugs", "committedDate": "2020-10-23T12:49:13Z", "type": "forcePushed"}, {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45", "url": "https://github.com/splicemachine/spliceengine/commit/4c65948d27940e0e3567baa1adc0839afc56da45", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-26T08:16:31Z", "type": "commit"}, {"oid": "e06325c12c5c50abc3cc93e6c3b406ce657a5c77", "url": "https://github.com/splicemachine/spliceengine/commit/e06325c12c5c50abc3cc93e6c3b406ce657a5c77", "message": "DB-10236 Rewrite query for a covering expression-based index\n\nIn this change, rewriting happens in:\n\n- where clause\n- group by clause\n- order by clause\n- having clause, including aggregates\n- select list, including aggregates", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "7c1e30772a08c639076530ca35d0220475f6190b", "url": "https://github.com/splicemachine/spliceengine/commit/7c1e30772a08c639076530ca35d0220475f6190b", "message": "DB-10236 Make joins work correctly for covering expr index", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "7554fbf220cd6282423c68ce60e6ec3e5021056e", "url": "https://github.com/splicemachine/spliceengine/commit/7554fbf220cd6282423c68ce60e6ec3e5021056e", "message": "DB-10236 Fix SpotBugs", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "url": "https://github.com/splicemachine/spliceengine/commit/c136be91f09b0a1fa2c9b9786fb30c61fced173d", "message": "DB-10236 Fix TernaryOperator handling in index expression rewriting", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "420f279bee374ad844e7add536c34c328118191c", "url": "https://github.com/splicemachine/spliceengine/commit/420f279bee374ad844e7add536c34c328118191c", "message": "DB-10176 Support index on expressions in ScanCostFunction", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "33899b82e02f478b24e95bc7b2b1107f3974e6ca", "url": "https://github.com/splicemachine/spliceengine/commit/33899b82e02f478b24e95bc7b2b1107f3974e6ca", "message": "DB-10176 Fix a potential inconsistency in IndexDescriptorImpl", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "1034acbfb815c3318a0f50e20b79a36d0ddb8acb", "url": "https://github.com/splicemachine/spliceengine/commit/1034acbfb815c3318a0f50e20b79a36d0ddb8acb", "message": "DB-10176 Support expr index statistics in StoreCostController", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "70359659aed762cc96199285e2c4de9e42ef8f2d", "url": "https://github.com/splicemachine/spliceengine/commit/70359659aed762cc96199285e2c4de9e42ef8f2d", "message": "DB-10176 Push between predicates down when they use index expressions", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "8e8f2b60ef322303d66152a558b58c60b8ebde74", "url": "https://github.com/splicemachine/spliceengine/commit/8e8f2b60ef322303d66152a558b58c60b8ebde74", "message": "DB-10176 Refactor utilities of retieving known constants", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "cff5dea02a670968ba416ef93f1fc21cb130726d", "url": "https://github.com/splicemachine/spliceengine/commit/cff5dea02a670968ba416ef93f1fc21cb130726d", "message": "DB-10176 Fix pushing down qualifiers referencing index expressions", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "120d40805af4243d299968f14fd3a7417f1b8641", "url": "https://github.com/splicemachine/spliceengine/commit/120d40805af4243d299968f14fd3a7417f1b8641", "message": "DB-10176 Cost between predicate referencing index expression", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "3da4ba4396bd4d16bae9fb496ce413b686996d61", "url": "https://github.com/splicemachine/spliceengine/commit/3da4ba4396bd4d16bae9fb496ce413b686996d61", "message": "DB-10176 Add expression evaluation cost to scan cost estimation", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "7e15ec5b3304bb315229b0c8a77aef4cf1666e28", "url": "https://github.com/splicemachine/spliceengine/commit/7e15ec5b3304bb315229b0c8a77aef4cf1666e28", "message": "DB-10176 Make join selectivity estimation use index expression stats", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "46e4d96b154b378cbea777b06e2292bd5568be4e", "url": "https://github.com/splicemachine/spliceengine/commit/46e4d96b154b378cbea777b06e2292bd5568be4e", "message": "DB-10176 Make MergeJoin feasible for index expressions", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "5982fa36c9900e822250c4c5f5f88a77044602be", "url": "https://github.com/splicemachine/spliceengine/commit/5982fa36c9900e822250c4c5f5f88a77044602be", "message": "DB-10176 Support index expressions in HalfMergeSortJoin (currently disabled)", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "d802991e5d2ccb715d30a82d9c72f0eee5766ca7", "url": "https://github.com/splicemachine/spliceengine/commit/d802991e5d2ccb715d30a82d9c72f0eee5766ca7", "message": "DB-10176 Fix SpotBugs", "committedDate": "2020-10-26T08:18:33Z", "type": "commit"}, {"oid": "d802991e5d2ccb715d30a82d9c72f0eee5766ca7", "url": "https://github.com/splicemachine/spliceengine/commit/d802991e5d2ccb715d30a82d9c72f0eee5766ca7", "message": "DB-10176 Fix SpotBugs", "committedDate": "2020-10-26T08:18:33Z", "type": "forcePushed"}, {"oid": "d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "url": "https://github.com/splicemachine/spliceengine/commit/d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-27T15:47:00Z", "type": "commit"}, {"oid": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "url": "https://github.com/splicemachine/spliceengine/commit/bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "message": "DB-10175 Address comments", "committedDate": "2020-10-27T15:56:25Z", "type": "commit"}, {"oid": "4236cac5c473ac58a99061323b366d5edc70eda8", "url": "https://github.com/splicemachine/spliceengine/commit/4236cac5c473ac58a99061323b366d5edc70eda8", "message": "Merge branch 'master' into DB-10175\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "committedDate": "2020-10-28T14:38:13Z", "type": "commit"}, {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "url": "https://github.com/splicemachine/spliceengine/commit/2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "message": "DB-10175 Address comments / add semanticallyEquals()\n\nDB-10312 Cache index expression ASTs is partially applied here so that\nthe code binding index expressions is not duplicated everywhere.", "committedDate": "2020-10-29T20:24:59Z", "type": "commit"}, {"oid": "83a20d4c2342308c196697fa55929e49e997c901", "url": "https://github.com/splicemachine/spliceengine/commit/83a20d4c2342308c196697fa55929e49e997c901", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-29T20:26:10Z", "type": "commit"}, {"oid": "35654b5f5111273d24a3a795f0ab4adcca2f8f70", "url": "https://github.com/splicemachine/spliceengine/commit/35654b5f5111273d24a3a795f0ab4adcca2f8f70", "message": "DB-10175 Address comments / fix potential concurrent issue\n\nIndex expression ASTs should not be cached in IndexDescriptor because\nit is in turns cached in data dictionary cache, which is global to all\nqueries. For now, always return a copy of ASTs.", "committedDate": "2020-10-30T10:09:08Z", "type": "commit"}, {"oid": "e84193961ad090ee1047773f57b3d810224cdde1", "url": "https://github.com/splicemachine/spliceengine/commit/e84193961ad090ee1047773f57b3d810224cdde1", "message": "Merge branch 'DB-10175' into DB-10236\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TernaryOperatorNode.java\n\tsplice_machine/src/test/java/com/splicemachine/derby/impl/sql/actions/index/IndexIT.java", "committedDate": "2020-10-30T10:43:27Z", "type": "commit"}, {"oid": "e15d6ad1db16a17112f3cf80e4e2b87c46039d20", "url": "https://github.com/splicemachine/spliceengine/commit/e15d6ad1db16a17112f3cf80e4e2b87c46039d20", "message": "DB-10236 Adapt to the latest changes made in DB-10175\n\nNote: IndexIT.testCoveringExpressionBasedIndexSubquery fails in\ncurrent state because we cannot bind expressions after resultColumns\nare changed to index columns after changeAccessPath(). As a result,\nindex expressions containing JavaToSQLValueNode do not work.", "committedDate": "2020-10-30T14:49:11Z", "type": "commit"}, {"oid": "93d5dd9183c6871c1822362d45225f14e8734abf", "url": "https://github.com/splicemachine/spliceengine/commit/93d5dd9183c6871c1822362d45225f14e8734abf", "message": "DB-10236 Fix IndexIT.testCoveringExpressionBasedIndexSubquery\n\nThe fix is done by allowing binding base table columns even after\ntable's access path has been changed to index columns. This ability is\nlimited to index on expressions only.", "committedDate": "2020-10-30T17:50:59Z", "type": "commit"}, {"oid": "d1b3b65435c343fca40c91a1d99ae948a147461e", "url": "https://github.com/splicemachine/spliceengine/commit/d1b3b65435c343fca40c91a1d99ae948a147461e", "message": "DB-10312 Add hashCode() to ValueNode class hierarchy", "committedDate": "2020-11-02T08:52:12Z", "type": "commit"}, {"oid": "edd0881cf1a975079c18a51632f64ac0eb77a36b", "url": "https://github.com/splicemachine/spliceengine/commit/edd0881cf1a975079c18a51632f64ac0eb77a36b", "message": "DB-10236 Address comments / fix expr collecting and derived tables", "committedDate": "2020-11-02T15:29:40Z", "type": "commit"}, {"oid": "1f192d6f3a9ee4bf31a6f7120b5db18543bc380b", "url": "https://github.com/splicemachine/spliceengine/commit/1f192d6f3a9ee4bf31a6f7120b5db18543bc380b", "message": "DB-10236 Address comments / fix index expr in RHS of in-list", "committedDate": "2020-11-02T16:57:50Z", "type": "commit"}, {"oid": "dec647dfb3287c8ab6cc63e298cee3454ae3ba42", "url": "https://github.com/splicemachine/spliceengine/commit/dec647dfb3287c8ab6cc63e298cee3454ae3ba42", "message": "WIP: DB-10236 Address comments / fix count(*) and index expr in window", "committedDate": "2020-11-04T16:25:58Z", "type": "commit"}, {"oid": "6fbed9d56a55f3be3bd4f02f9b6af7eee168ff2e", "url": "https://github.com/splicemachine/spliceengine/commit/6fbed9d56a55f3be3bd4f02f9b6af7eee168ff2e", "message": "Merge branch 'master' into DB-10236\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ArrayConstantNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CastNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ConditionalNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/GenerationClauseNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/JavaToSQLValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/JavaValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/MethodCallNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SQLToJavaValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/StaticClassFieldReferenceNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TernaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueTupleNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VirtualColumnNode.java\n\tsplice_machine/src/test/java/com/splicemachine/derby/impl/sql/actions/index/IndexIT.java", "committedDate": "2020-11-04T23:19:18Z", "type": "commit"}, {"oid": "87fbb50fa6439543ca5a01ab2b4851000aba3662", "url": "https://github.com/splicemachine/spliceengine/commit/87fbb50fa6439543ca5a01ab2b4851000aba3662", "message": "Resolved missed conflicts", "committedDate": "2020-11-04T23:45:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2NTEyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r518465128", "bodyText": "Is the cost really multiplied by the length of the data type?  What if you have a really long string, is it really that expensive?", "author": "msirek", "createdAt": "2020-11-06T01:11:35Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java", "diffHunk": "@@ -194,5 +194,17 @@ private int getConstantNodeLength() throws StandardException\n         if( operand instanceof ConstantNode)\n             return ((ConstantNode) operand).getValue().getLength();\n         return -1;\n-    }        \n+    }\n+\n+    @Override\n+    public double getBaseOperationCost() throws StandardException {\n+        double cost = 0.0;\n+        if (operand != null) {\n+            if (getConstantLength() == -1) {\n+                cost += SIMPLE_OP_COST * operand.getTypeServices().getNull().getLength();", "originalCommit": "d802991e5d2ccb715d30a82d9c72f0eee5766ca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1OTU2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4302#discussion_r522559566", "bodyText": "I have the same concern here actually...I took a look at SQLChar.getLength() and it seems to have chance to calculate it in O(n). But then the expression evaluation cost could accumulate fast, soon dominating the plan cost. In the latest commit, I add an upper bound on this, hopefully better than linear.", "author": "ascend1", "createdAt": "2020-11-13T01:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2NTEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "713a0d727e775503dd2374aaba512d3794026d10", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java\nindex 14ea68e047..35325ebaba 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DB2LengthOperatorNode.java\n\n@@ -194,17 +194,5 @@ public final class DB2LengthOperatorNode extends UnaryOperatorNode\n         if( operand instanceof ConstantNode)\n             return ((ConstantNode) operand).getValue().getLength();\n         return -1;\n-    }\n-\n-    @Override\n-    public double getBaseOperationCost() throws StandardException {\n-        double cost = 0.0;\n-        if (operand != null) {\n-            if (getConstantLength() == -1) {\n-                cost += SIMPLE_OP_COST * operand.getTypeServices().getNull().getLength();\n-            }\n-            cost += SIMPLE_OP_COST * FN_CALL_COST_FACTOR;\n-        }\n-        return cost;\n-    }\n+    }        \n }\n"}}, {"oid": "713a0d727e775503dd2374aaba512d3794026d10", "url": "https://github.com/splicemachine/spliceengine/commit/713a0d727e775503dd2374aaba512d3794026d10", "message": "DB-10236 Column mapping manipulation for index on expressions", "committedDate": "2020-11-07T03:02:29Z", "type": "commit"}, {"oid": "d908f867665b138a317911e3caafb2ac6be60073", "url": "https://github.com/splicemachine/spliceengine/commit/d908f867665b138a317911e3caafb2ac6be60073", "message": "Merge branch 'master' into DB-10236", "committedDate": "2020-11-07T03:04:11Z", "type": "commit"}, {"oid": "50554af111bb803018025226236573fc4b3e8976", "url": "https://github.com/splicemachine/spliceengine/commit/50554af111bb803018025226236573fc4b3e8976", "message": "Merge branch 'master' into DB-10236", "committedDate": "2020-11-09T08:28:12Z", "type": "commit"}, {"oid": "6b6aef41c1efc752ed870edc5016410a283c57e7", "url": "https://github.com/splicemachine/spliceengine/commit/6b6aef41c1efc752ed870edc5016410a283c57e7", "message": "DB-10236 Fix outer join without correcting column references", "committedDate": "2020-11-09T10:57:04Z", "type": "commit"}, {"oid": "4dc00f89ca5d25c80a135036925b7298607d57ab", "url": "https://github.com/splicemachine/spliceengine/commit/4dc00f89ca5d25c80a135036925b7298607d57ab", "message": "DB-10236 Address comments / fix collecting expressions", "committedDate": "2020-11-12T04:10:57Z", "type": "commit"}, {"oid": "2208d1c4f7a8b2cb3b207e07d658704a5580eefd", "url": "https://github.com/splicemachine/spliceengine/commit/2208d1c4f7a8b2cb3b207e07d658704a5580eefd", "message": "DB-10236 Address comment / fix post join condition replacing", "committedDate": "2020-11-12T06:38:51Z", "type": "commit"}, {"oid": "012cfcfeb4bf8fbd28ceb8b39c5465fb803563ed", "url": "https://github.com/splicemachine/spliceengine/commit/012cfcfeb4bf8fbd28ceb8b39c5465fb803563ed", "message": "Merge branch 'DB-10236' into DB-10176\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryRelationalOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ColumnReference.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ResultColumn.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ScanCostFunction.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryComparisonOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryDateTimestampOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n\tsplice_machine/src/main/java/com/splicemachine/derby/impl/stats/StoreCostControllerImpl.java\n\tsplice_machine/src/main/java/com/splicemachine/derby/impl/store/access/SpliceTransactionManager.java", "committedDate": "2020-11-12T12:03:28Z", "type": "commit"}, {"oid": "2cb06b63e05fca90f6eab19508783dceb8d11e03", "url": "https://github.com/splicemachine/spliceengine/commit/2cb06b63e05fca90f6eab19508783dceb8d11e03", "message": "DB-10176 Fix faling tests", "committedDate": "2020-11-12T16:07:08Z", "type": "commit"}, {"oid": "9f4de2df9887b56ed0cea7e091a2a536c458361f", "url": "https://github.com/splicemachine/spliceengine/commit/9f4de2df9887b56ed0cea7e091a2a536c458361f", "message": "DB-10176 Add expression evaluation cost to GroupByNode", "committedDate": "2020-11-12T22:34:32Z", "type": "commit"}, {"oid": "3d947bb0afeb5a974e0284def9190d63ac34d3a9", "url": "https://github.com/splicemachine/spliceengine/commit/3d947bb0afeb5a974e0284def9190d63ac34d3a9", "message": "DB-10176 Fix sporadic tests temporarily", "committedDate": "2020-11-13T01:20:29Z", "type": "commit"}, {"oid": "3564c93ad724b40da5714f6110e588d890512c68", "url": "https://github.com/splicemachine/spliceengine/commit/3564c93ad724b40da5714f6110e588d890512c68", "message": "DB-10176 Address comments", "committedDate": "2020-11-13T08:59:48Z", "type": "commit"}, {"oid": "afbceae720671ef6afba980748c63693efb7e4fc", "url": "https://github.com/splicemachine/spliceengine/commit/afbceae720671ef6afba980748c63693efb7e4fc", "message": "Merge branch 'master' into DB-10176\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryArithmeticOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryLogicalOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ResultColumn.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TernaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueTupleNode.java\n\tsplice_machine/src/test/java/com/splicemachine/derby/impl/sql/actions/index/IndexIT.java", "committedDate": "2020-11-13T11:00:42Z", "type": "commit"}, {"oid": "25f669ca5fbf337e1ccce93d5cd0effa05223b69", "url": "https://github.com/splicemachine/spliceengine/commit/25f669ca5fbf337e1ccce93d5cd0effa05223b69", "message": "DB-10176 Fix failing test temporarily", "committedDate": "2020-11-13T13:00:08Z", "type": "commit"}]}