{"pr_number": 4007, "pr_title": "DB-10045 add MIN_RETAINED_VERSIONS column to SYSTABLES", "pr_createdAt": "2020-08-18T18:35:55Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4007", "timeline": [{"oid": "abe3e3f47f7fd60496b400308f9a2bcb44c21056", "url": "https://github.com/splicemachine/spliceengine/commit/abe3e3f47f7fd60496b400308f9a2bcb44c21056", "message": "DB-10045 refactor system tables row factory.", "committedDate": "2020-08-18T18:27:48Z", "type": "commit"}, {"oid": "08373b8a6984d961ee93889ecd94c8680fa5871b", "url": "https://github.com/splicemachine/spliceengine/commit/08373b8a6984d961ee93889ecd94c8680fa5871b", "message": "DB-10045 add MIN_RETAINED_VERSIONS column to SYSTABLES", "committedDate": "2020-08-18T18:28:01Z", "type": "commit"}, {"oid": "01a18f0a84f880b82e5cfcfdcb96e847291935b2", "url": "https://github.com/splicemachine/spliceengine/commit/01a18f0a84f880b82e5cfcfdcb96e847291935b2", "message": "DB-10045 fix spotbugs issue.", "committedDate": "2020-08-19T08:31:47Z", "type": "commit"}, {"oid": "e7cd2390342268607142d296e1c9bd95e26bd25d", "url": "https://github.com/splicemachine/spliceengine/commit/e7cd2390342268607142d296e1c9bd95e26bd25d", "message": "DB-10045 renamed field to minRetentionPeriod", "committedDate": "2020-08-21T15:52:13Z", "type": "commit"}, {"oid": "31f0415c89417a3fb8d1aebc534afcd4a2c7dfe0", "url": "https://github.com/splicemachine/spliceengine/commit/31f0415c89417a3fb8d1aebc534afcd4a2c7dfe0", "message": "Merge remote-tracking branch 'origin/master' into DB-10045", "committedDate": "2020-08-21T16:03:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MzUxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r477493519", "bodyText": "As @jyuanca mentioned, we need an upgrade script to add the new column to the table for existing system. The upgrade script should also cover the update of the view. Please refer to SpliceDataDictionary.updateColumnViewInSys() for the logic to update the sysvw.systablesview.", "author": "yxia92", "createdAt": "2020-08-26T18:12:06Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -52,661 +52,664 @@\n /**\n  * Factory for creating a SYSTABLES row.\n  *\n- *\n  * @version 0.1\n  */\n-\n-public class SYSTABLESRowFactory extends CatalogRowFactory\n-{\n-\tpublic static final String\t\tTABLENAME_STRING = \"SYSTABLES\";\n-\n-\tpublic static final int\t\tSYSTABLES_COLUMN_COUNT = 15;\n-\t/* Column #s for systables (1 based) */\n-\tpublic static final int\t\tSYSTABLES_TABLEID = 1;\n-\tpublic static final int\t\tSYSTABLES_TABLENAME = 2;\n-\tprotected static final int\t\tSYSTABLES_TABLETYPE = 3;\n-\tpublic static final int\t\tSYSTABLES_SCHEMAID = 4;\n-\tprotected static final int\t\tSYSTABLES_LOCKGRANULARITY = 5;\n-\tprotected static final int\t\tSYSTABLES_VERSION = 6;\n+public class SYSTABLESRowFactory extends CatalogRowFactory {\n+    public static final String TABLENAME_STRING = \"SYSTABLES\";\n+\n+    public static final int SYSTABLES_COLUMN_COUNT = 16;\n+\n+    /* Column #s for systables (1 based) */\n+    public    static final int SYSTABLES_TABLEID                = 1;\n+    public    static final int SYSTABLES_TABLENAME              = 2;\n+    protected static final int SYSTABLES_TABLETYPE              = 3;\n+    public    static final int SYSTABLES_SCHEMAID               = 4;\n+    protected static final int SYSTABLES_LOCKGRANULARITY        = 5;\n+    protected static final int SYSTABLES_VERSION                = 6;\n     /* Sequence for understanding coding/decoding with altering tables*/\n-    protected static final int\t\tSYSTABLES_COLUMN_SEQUENCE = 7;\n-\t/* External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_DELIMITED_BY = 8;\n-\tprotected static final int\t\tSYSTABLES_ESCAPED_BY = 9;\n-\tprotected static final int\t\tSYSTABLES_LINES_BY = 10;\n-\tprotected static final int\t\tSYSTABLES_STORED_AS = 11;\n-\tprotected static final int\t\tSYSTABLES_LOCATION = 12;\n-\tprotected static final int\t\tSYSTABLES_COMPRESSION = 13;\n-\t// SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n-\t@Deprecated\n-\tprotected static final int \t\tSYSTABLES_IS_PINNED = 14;\n-\tprotected static final int      SYSTABLES_PURGE_DELETED_ROWS = 15;\n-\t/* End External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_INDEX1_ID = 0;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_TABLENAME = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_SCHEMAID = 2;\n-\n-\tprotected static final int\t\tSYSTABLES_INDEX2_ID = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX2_TABLEID = 1;\n-\n-\n-    public static final String      PURGE_DELETED_ROWS = \"PURGE_DELETED_ROWS\";\n-\t/*\n-\t * The first version of any tables. Use this for System tables and\n-\t * any time that you don't know what the version is.\n-\t */\n-\tpublic static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n-\t//the current version for creating new tables with\n-\tpublic static final String CURRENT_TABLE_VERSION = \"4.0\";\n-\t\n-\t// all indexes are unique.\n-\n-\tprivate\tstatic\tfinal\tString[]\tuuids =\n-\t{\n-\t\t \"80000018-00d0-fd77-3ed8-000a0a0b1900\"\t// catalog UUID\n-\t\t,\"80000028-00d0-fd77-3ed8-000a0a0b1900\"\t// heap UUID\n-\t\t,\"8000001a-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX1\n-\t\t,\"8000001c-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX2\n-\t};\n-\n-\tprivate static final int[][] indexColumnPositions = \n-\t{ \n-\t\t{ SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n-\t\t{ SYSTABLES_TABLEID }\n-\t};\n-\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tCONSTRUCTORS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)\n-\t{\n-\t\tsuper(uuidf,ef,dvf);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\n-\tSYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n-\t{\n-\t\tsuper(uuidf,ef,dvf, dd);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tMETHODS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a SYSTABLES row\n-\t *\n-\t * @return\tRow suitable for inserting into SYSTABLES.\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\t@SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n-\tpublic ExecRow makeRow(boolean latestVersion, TupleDescriptor td,\n-\t\t\t\t\t\t   TupleDescriptor\tparent)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tUUID\t\t\t\t\t\toid;\n-\t\tString\t   \t\t\t\ttabSType = null;\n-\t\tint\t   \t\t\t\t\ttabIType;\n-\t\tExecRow        \t\t\trow;\n-\t\tString\t\t\t\t\tlockGranularity = null;\n-\t\tString\t\t\t\t\ttableID = null;\n-\t\tString\t\t\t\t\tschemaID = null;\n-\t\tString\t\t\t\t\ttableName = null;\n-        int                     columnSequence = 0;\n-\t\tString \t\t\t\t\tdelimited = null;\n-\t\tString \t\t\t\t\tescaped = null;\n-\t\tString \t\t\t\t\tlines = null;\n-\t\tString \t\t\t\t\tstoredAs = null;\n-\t\tString \t\t\t\t\tlocation = null;\n-\t\tString \t\t\t\t\tcompression = null;\n-\t\tSQLVarchar              tableVersion = null;\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tboolean \t\t\t\tisPinned = false;\n-\t\tboolean                 purgeDeletedRows = false;\n-\n-\t\tif (td != null)\n-\t\t{\n-\t\t\t/*\n-\t\t\t** We only allocate a new UUID if the descriptor doesn't already have one.\n-\t\t\t** For descriptors replicated from a Source system, we already have an UUID.\n-\t\t\t*/\n-\t\t\tif (!(td instanceof TableDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n-\t\t\tif (!(parent instanceof SchemaDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n-\t\t\tTableDescriptor descriptor = (TableDescriptor)td;\n-\t\t\tSchemaDescriptor schema = (SchemaDescriptor)parent;\n+    protected static final int SYSTABLES_COLUMN_SEQUENCE        = 7;\n+    /* External Tables Columns */\n+    protected static final int SYSTABLES_DELIMITED_BY           = 8;\n+    protected static final int SYSTABLES_ESCAPED_BY             = 9;\n+    protected static final int SYSTABLES_LINES_BY               = 10;\n+    protected static final int SYSTABLES_STORED_AS              = 11;\n+    protected static final int SYSTABLES_LOCATION               = 12;\n+    protected static final int SYSTABLES_COMPRESSION            = 13;\n+    // SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n+    @Deprecated\n+    protected static final int SYSTABLES_IS_PINNED              = 14;\n+    protected static final int SYSTABLES_PURGE_DELETED_ROWS     = 15;\n+    protected static final int SYSTABLES_MIN_RETENTION_PERIOD   = 16;\n+    /* End External Tables Columns */\n+\n+    protected static final int SYSTABLES_INDEX1_ID        = 0;\n+    protected static final int SYSTABLES_INDEX1_TABLENAME = 1;\n+    protected static final int SYSTABLES_INDEX1_SCHEMAID  = 2;\n+\n+    protected static final int SYSTABLES_INDEX2_ID        = 1;\n+    protected static final int SYSTABLES_INDEX2_TABLEID   = 1;\n+\n+    /* Column names */\n+    public static final String IS_PINNED            = \"IS_PINNED\";\n+    public static final String COMPRESSION          = \"COMPRESSION\";\n+    public static final String LOCATION             = \"LOCATION\";\n+    public static final String STORED               = \"STORED\";\n+    public static final String LINES                = \"LINES\";\n+    public static final String ESCAPED              = \"ESCAPED\";\n+    public static final String DELIMITED            = \"DELIMITED\";\n+    public static final String COLSEQUENCE          = \"COLSEQUENCE\";\n+    public static final String VERSION              = \"VERSION\";\n+    public static final String LOCKGRANULARITY      = \"LOCKGRANULARITY\";\n+    public static final String SCHEMAID             = \"SCHEMAID\";\n+    public static final String TABLETYPE            = \"TABLETYPE\";\n+    public static final String TABLENAME            = \"TABLENAME\";\n+    public static final String TABLEID              = \"TABLEID\";\n+    public static final String PURGE_DELETED_ROWS   = \"PURGE_DELETED_ROWS\";\n+    public static final String MIN_RETENTION_PERIOD = \"MIN_RETENTION_PERIOD\";\n+    /*\n+     * The first version of any tables. Use this for System tables and\n+     * any time that you don't know what the version is.\n+     */\n+    public static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n+    //the current version for creating new tables with\n+    public static final String CURRENT_TABLE_VERSION = \"4.0\";\n+\n+    // all indexes are unique.\n+\n+    private static final String[] uuids =\n+        {\n+            \"80000018-00d0-fd77-3ed8-000a0a0b1900\", // catalog UUID\n+            \"80000028-00d0-fd77-3ed8-000a0a0b1900\", // heap UUID\n+            \"8000001a-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX1\n+            \"8000001c-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX2\n+        };\n+\n+    private static final int[][] indexColumnPositions =\n+        {\n+            {SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n+            {SYSTABLES_TABLEID}\n+        };\n+\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tCONSTRUCTORS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf) {\n+        super(uuidf, ef, dvf);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n+    {\n+        super(uuidf,ef,dvf, dd);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tMETHODS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a SYSTABLES row\n+     *\n+     * @throws StandardException thrown on failure\n+     * @return Row suitable for inserting into SYSTABLES.\n+     */\n+    @SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n+    public ExecRow makeRow(boolean latestVersion,\n+                           TupleDescriptor td,\n+                           TupleDescriptor parent)\n+            throws StandardException {\n+        UUID oid;\n+        String tabSType = null;\n+        int tabIType;\n+        ExecRow row;\n+        String lockGranularity = null;\n+        String tableID = null;\n+        String schemaID = null;\n+        String tableName = null;\n+        int columnSequence = 0;\n+        String delimited = null;\n+        String escaped = null;\n+        String lines = null;\n+        String storedAs = null;\n+        String location = null;\n+        String compression = null;\n+        SQLVarchar tableVersion = null;\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        boolean isPinned = false;\n+        boolean purgeDeletedRows = false;\n+        long minRetentionPeriod = 0;\n+\n+        if (td != null) {\n+            /*\n+             ** We only allocate a new UUID if the descriptor doesn't already have one.\n+             ** For descriptors replicated from a Source system, we already have an UUID.\n+             */\n+            if (!(td instanceof TableDescriptor))\n+                throw new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n+            if (!(parent instanceof SchemaDescriptor))\n+                throw new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n+            TableDescriptor descriptor = (TableDescriptor) td;\n+            SchemaDescriptor schema = (SchemaDescriptor) parent;\n \n             columnSequence = descriptor.getColumnSequence();\n-\t\t\toid = descriptor.getUUID();\n-\t\t\tif ( oid == null )\n-\t\t    {\n-\t\t\t\toid = getUUIDFactory().createUUID();\n-\t\t\t\tdescriptor.setUUID(oid);\n-\t\t\t}\n-\t\t\ttableID = oid.toString();\n-\t\t\t\n-\t\t\tif (SanityManager.DEBUG)\n-\t\t\t{\n-\t\t\t\tSanityManager.ASSERT(schema != null, \n-\t\t\t\t\t\t\t\"Schema should not be null unless empty row is true\");\n-\t\t\t\tif (schema.getUUID() == null)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\n-\t\t\tschemaID = schema.getUUID().toString();\n-\n-\t\t\ttableName = descriptor.getName();\n-\n-\t\t\t/* RESOLVE - Table Type should really be a char in the descriptor\n-\t\t\t * T, S, V, S instead of 0, 1, 2, 3\n-\t\t\t */\n-\t\t\ttabIType = descriptor.getTableType();\n-\t\t\tswitch (tabIType)\n-\t\t\t{\n-\t\t\t    case TableDescriptor.BASE_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"T\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.SYSTEM_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"S\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.VIEW_TYPE:\n-\t\t\t\t\ttabSType = \"V\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"X\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.SYNONYM_TYPE:\n-\t\t\t\t\ttabSType = \"A\";\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase TableDescriptor.EXTERNAL_TYPE:\n-\t\t\t\t\ttabSType = \"E\";\n-\t\t\t\t\tbreak;\n-\n-\n-\t\t\t    default:\n-\t\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t\t\tSanityManager.THROWASSERT(\"invalid table type\");\n-\t\t\t}\n-\t\t\tchar[] lockGChar = new char[1];\n-\t\t\tlockGChar[0] = descriptor.getLockGranularity();\n-\t\t\tlockGranularity = new String(lockGChar);\n-\t\t\tdelimited = descriptor.getDelimited();\n-\t\t\tescaped = descriptor.getEscaped();\n-\t\t\tlines = descriptor.getLines();\n-\t\t\tstoredAs = descriptor.getStoredAs();\n-\t\t\tlocation = descriptor.getLocation();\n-\t\t\tcompression = descriptor.getCompression();\n-\t\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\t\tisPinned = descriptor.isPinned();\n+            oid = descriptor.getUUID();\n+            if (oid == null) {\n+                oid = getUUIDFactory().createUUID();\n+                descriptor.setUUID(oid);\n+            }\n+            tableID = oid.toString();\n+\n+            if (SanityManager.DEBUG) {\n+                SanityManager.ASSERT(schema != null,\n+                        \"Schema should not be null unless empty row is true\");\n+                if (schema.getUUID() == null) {\n+                    SanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n+                }\n+            }\n+\n+            schemaID = schema.getUUID().toString();\n+\n+            tableName = descriptor.getName();\n+\n+            /* RESOLVE - Table Type should really be a char in the descriptor\n+             * T, S, V, S instead of 0, 1, 2, 3\n+             */\n+            tabIType = descriptor.getTableType();\n+            switch (tabIType) {\n+                case TableDescriptor.BASE_TABLE_TYPE:\n+                    tabSType = \"T\";\n+                    break;\n+                case TableDescriptor.SYSTEM_TABLE_TYPE:\n+                    tabSType = \"S\";\n+                    break;\n+                case TableDescriptor.VIEW_TYPE:\n+                    tabSType = \"V\";\n+                    break;\n+\n+                case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n+                    tabSType = \"X\";\n+                    break;\n+\n+                case TableDescriptor.SYNONYM_TYPE:\n+                    tabSType = \"A\";\n+                    break;\n+                case TableDescriptor.EXTERNAL_TYPE:\n+                    tabSType = \"E\";\n+                    break;\n+\n+\n+                default:\n+                    if (SanityManager.DEBUG)\n+                        SanityManager.THROWASSERT(\"invalid table type\");\n+            }\n+            char[] lockGChar = new char[1];\n+            lockGChar[0] = descriptor.getLockGranularity();\n+            lockGranularity = new String(lockGChar);\n+            delimited = descriptor.getDelimited();\n+            escaped = descriptor.getEscaped();\n+            lines = descriptor.getLines();\n+            storedAs = descriptor.getStoredAs();\n+            location = descriptor.getLocation();\n+            compression = descriptor.getCompression();\n+            //NOT USED ANYMORE, for backward compatibility only\n+            isPinned = descriptor.isPinned();\n             purgeDeletedRows = descriptor.purgeDeletedRows();\n-\t\t\ttableVersion = descriptor.getVersion() == null ?\n-\t\t                 \tnew SQLVarchar(CURRENT_TABLE_VERSION) :\n-\t\t\t                new SQLVarchar(descriptor.getVersion());\n-\t\t}\n-\t\telse\n-\t\t\ttableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n-\n-\t\t/* Insert info into systables */\n-\n-\t\t/* RESOLVE - It would be nice to require less knowledge about systables\n-\t\t * and have this be more table driven.\n-\t\t */\n-\n-\t\t/* Build the row to insert  */\n-\t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n-\n-\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n-\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n-\t\treturn row;\n-\t}\n-\n-\tpublic static void setRowColumns(ExecRow row,\n-\t\t\t\t\t\t\t\t\t String tableID,\n-\t\t\t\t\t\t\t\t\t String tableName,\n-\t\t\t\t\t\t\t\t\t String tabSType,\n-\t\t\t\t\t\t\t\t\t String schemaID,\n-\t\t\t\t\t\t\t\t\t String lockGranularity,\n-\t\t\t\t\t\t\t\t\t SQLVarchar tableVersion,\n-\t\t\t\t\t\t\t\t\t int columnSequence,\n-\t\t\t\t\t\t\t\t\t String delimited,\n-\t\t\t\t\t\t\t\t\t String escaped,\n-\t\t\t\t\t\t\t\t\t String lines,\n-\t\t\t\t\t\t\t\t\t String storedAs,\n-\t\t\t\t\t\t\t\t\t String location,\n-\t\t\t\t\t\t\t\t\t String compression,\n-\t\t\t\t\t\t\t\t\t boolean isPinned,\n-\t\t\t\t\t\t\t\t\t boolean purgeDeletedRows) {\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n-\n-\t\t/* 2nd column is NAME (varchar(30)) */\n-\t\trow.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\trow.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n-\n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\trow.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n-\n-\t\t/* 6th column is VERSION (varchar(128)) */\n-\t\trow.setColumn(SYSTABLES_VERSION, tableVersion);\n-\n-\t\trow.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n-\n-\t\trow.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n-\t\trow.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n-\t\trow.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n-\t\trow.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n-\t\trow.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n-\t\trow.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n-\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\trow.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n-\t\trow.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n-\t}\n-\n-\t/**\n-\t * Builds an empty index row.\n-\t *\n-\t *\t@param\tindexNumber\tIndex to build empty row for.\n-\t *  @param  rowLocation\tRow location for last column of index row\n-\t *\n-\t * @return corresponding empty index row\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\t@SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n-\tExecIndexRow\tbuildEmptyIndexRow( int indexNumber,\n-\t\t\t\t\t\t\t\t\t\t\tRowLocation rowLocation)\n-\t\t\tthrows StandardException\n-\t{\n-\t\tint ncols = getIndexColumnCount(indexNumber);\n-\t\tExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n-\n-\t\trow.setColumn(ncols + 1, rowLocation);\n-\n-\t\tswitch( indexNumber )\n-\t\t{\n-\t\t    case SYSTABLES_INDEX1_ID:\n-\t\t\t\t/* 1st column is TABLENAME (varchar(128)) */\n-\t\t\t\trow.setColumn(1, new SQLVarchar());\n-\n-\t\t\t\t/* 2nd column is SCHEMAID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(2, new SQLChar());\n-\n-\t\t\t\tbreak;\n-\n-\t\t    case SYSTABLES_INDEX2_ID:\n-\t\t\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(1,new SQLChar());\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tthrow new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n-\t\t}\t// end switch\n-\n-\t\treturn\trow;\n-\t}\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t * @param isolationLevel use this explicit isolation level. Only\n-\t *                       ISOLATION_REPEATABLE_READ (normal usage)\n-\t *                       or ISOLATION_READ_UNCOMMITTED (corner\n-\t *                       cases) supported for now.\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tTupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(row,\n-\t\t\t\t\t\t\t\t   parentTupleDescriptor,\n-\t\t\t\t\t\t\t\t   dd,\n-\t\t\t\t\t\t\t\t   isolationLevel);\n-\t}\n-\n-\n-\t///////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n-\t//\n-\t///////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t *\n-\t * @return\ta table descriptor equivalent to a SYSTABLES row\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\tpublic TupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd )\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(\n-\t\t\trow,\n-\t\t\tparentTupleDescriptor,\n-\t\t\tdd,\n-\t\t\tTransactionController.ISOLATION_REPEATABLE_READ);\n-\t}\n-\n-\n-\tpublic TupleDescriptor buildDescriptorBody(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\tSanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n-\n-\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n-\n-\t\tString\ttableUUIDString; \n-\t\tString\tschemaUUIDString; \n-\t\tint\t\ttableTypeEnum;\n-\t\tString\tlockGranularity;\n-\t\tString\ttableName, tableType;\n-\t\tDataValueDescriptor\tcol;\n-\t\tUUID\t\ttableUUID;\n-\t\tUUID\t\tschemaUUID;\n-\t\tSchemaDescriptor\tschema;\n-\t\tTableDescriptor\t\ttabDesc;\n-\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLEID);\n-\t\ttableUUIDString = col.getString();\n-\t\ttableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n-\n-\n-\t\t/* 2nd column is TABLENAME (varchar(128)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\ttableName = col.getString();\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLETYPE);\n-\t\ttableType = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n-\t\t}\n-\t\tswitch (tableType.charAt(0))\n-\t\t{\n-\t\t\tcase 'T' : \n-\t\t\t\ttableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'S' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'V' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.VIEW_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'A' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'X' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'E' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\tSanityManager.THROWASSERT(\"Fourth column value invalid\");\n-\t\t\t\ttableTypeEnum = -1;\n-\t\t}\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_SCHEMAID);\n-\t\tschemaUUIDString = col.getString();\n-\t\tschemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n-\t\t\n-\t\tschema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n+            minRetentionPeriod = descriptor.getMinRetainedVersions();\n+            tableVersion = descriptor.getVersion() == null ?\n+                    new SQLVarchar(CURRENT_TABLE_VERSION) :\n+                    new SQLVarchar(descriptor.getVersion());\n+        } else\n+            tableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n+\n+        /* Insert info into systables */\n+\n+        /* RESOLVE - It would be nice to require less knowledge about systables\n+         * and have this be more table driven.\n+         */\n+\n+        /* Build the row to insert  */\n+        row = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n+\n+        setRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+                delimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows, minRetentionPeriod);\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row,\n+                                     String tableID,\n+                                     String tableName,\n+                                     String tabSType,\n+                                     String schemaID,\n+                                     String lockGranularity,\n+                                     SQLVarchar tableVersion,\n+                                     int columnSequence,\n+                                     String delimited,\n+                                     String escaped,\n+                                     String lines,\n+                                     String storedAs,\n+                                     String location,\n+                                     String compression,\n+                                     boolean isPinned,\n+                                     boolean purgeDeletedRows,\n+                                     long minRetentionPeriod) {\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n+\n+        /* 2nd column is NAME (varchar(30)) */\n+        row.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        row.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n+\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        row.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n+\n+        /* 6th column is VERSION (varchar(128)) */\n+        row.setColumn(SYSTABLES_VERSION, tableVersion);\n+\n+        row.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n+\n+        row.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n+        row.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n+        row.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n+        row.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n+        row.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n+        row.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n+        //NOT USED ANYMORE, for backward compatibility only\n+        row.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n+        row.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n+        row.setColumn(SYSTABLES_MIN_RETENTION_PERIOD, new SQLLongint(minRetentionPeriod));\n+    }\n+\n+    /**\n+     * Builds an empty index row.\n+     *\n+     * @param rowLocation Row location for last column of index row\n+     * @return corresponding empty index row\n+     * @throws StandardException thrown on failure\n+     * @param    indexNumber    Index to build empty row for.\n+     */\n+    @SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n+    ExecIndexRow buildEmptyIndexRow(int indexNumber,\n+                                    RowLocation rowLocation)\n+            throws StandardException {\n+        int ncols = getIndexColumnCount(indexNumber);\n+        ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n+\n+        row.setColumn(ncols + 1, rowLocation);\n+\n+        switch (indexNumber) {\n+            case SYSTABLES_INDEX1_ID:\n+                /* 1st column is TABLENAME (varchar(128)) */\n+                row.setColumn(1, new SQLVarchar());\n+\n+                /* 2nd column is SCHEMAID (UUID - char(36)) */\n+                row.setColumn(2, new SQLChar());\n+\n+                break;\n+\n+            case SYSTABLES_INDEX2_ID:\n+                /* 1st column is TABLEID (UUID - char(36)) */\n+                row.setColumn(1, new SQLChar());\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n+        }    // end switch\n+\n+        return row;\n+    }\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @param isolationLevel        use this explicit isolation level. Only\n+     *                              ISOLATION_REPEATABLE_READ (normal usage)\n+     *                              or ISOLATION_READ_UNCOMMITTED (corner\n+     *                              cases) supported for now.\n+     * @throws StandardException thrown on failure\n+     */\n+    TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        return buildDescriptorBody(row,\n+                parentTupleDescriptor,\n+                dd,\n+                isolationLevel);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n+    //\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @throws StandardException thrown on failure\n+     * @return a table descriptor equivalent to a SYSTABLES row\n+     */\n+\n+    public TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd)\n+            throws StandardException {\n+        return buildDescriptorBody(\n+                row,\n+                parentTupleDescriptor,\n+                dd,\n+                TransactionController.ISOLATION_REPEATABLE_READ);\n+    }\n+\n+\n+    public TupleDescriptor buildDescriptorBody(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        if (SanityManager.DEBUG)\n+            SanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n+\n+        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n+\n+        String tableUUIDString;\n+        String schemaUUIDString;\n+        int tableTypeEnum;\n+        String lockGranularity;\n+        String tableName, tableType;\n+        DataValueDescriptor col;\n+        UUID tableUUID;\n+        UUID schemaUUID;\n+        SchemaDescriptor schema;\n+        TableDescriptor tabDesc;\n+\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_TABLEID);\n+        tableUUIDString = col.getString();\n+        tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n+\n+\n+        /* 2nd column is TABLENAME (varchar(128)) */\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        tableName = col.getString();\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        col = row.getColumn(SYSTABLES_TABLETYPE);\n+        tableType = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n+        }\n+        switch (tableType.charAt(0)) {\n+            case 'T':\n+                tableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n+                break;\n+            case 'S':\n+                tableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n+                break;\n+            case 'V':\n+                tableTypeEnum = TableDescriptor.VIEW_TYPE;\n+                break;\n+            case 'A':\n+                tableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n+                break;\n+            case 'X':\n+                tableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n+                break;\n+            case 'E':\n+                tableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n+                break;\n+            default:\n+                if (SanityManager.DEBUG)\n+                    SanityManager.THROWASSERT(\"Fourth column value invalid\");\n+                tableTypeEnum = -1;\n+        }\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_SCHEMAID);\n+        schemaUUIDString = col.getString();\n+        schemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n+\n+        schema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n \n         // If table is temp table, (SESSION) schema will be null\n         if (schema == null && (tableTypeEnum == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)) {\n             schema = dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();\n         }\n \n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n-\t\tlockGranularity = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n-\t\t}\n-\n-\t\t//TODO -sf- place version into tuple descriptor\n-\t\tDataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n-\n-\t\tDataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n-\t\tDataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n-\t\tDataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n-\t\tDataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n-\t\tDataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n-\t\tDataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tDataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n-        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        col = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n+        lockGranularity = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n+        }\n \n-\t\t// RESOLVE - Deal with lock granularity\n-\t\ttabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n-\t\t\t\trow.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n-\t\t\t\tdelimitedDVD!=null?delimitedDVD.getString():null,\n-\t\t\t\tescapedDVD!=null?escapedDVD.getString():null,\n-\t\t\t\tlinesDVD!=null?linesDVD.getString():null,\n-\t\t\t\tstoredDVD!=null?storedDVD.getString():null,\n-\t\t\t\tlocationDVD!=null?locationDVD.getString():null,\n-\t\t\t\tcompressionDVD!=null?compressionDVD.getString():null,\n-\t\t\t\tisPinnedDVD.getBoolean(),\n-                purgeDeletedRowsDVD.getBoolean()\n-\t\t\t\t);\n-\t\ttabDesc.setUUID(tableUUID);\n-\n-\t\tif(versionDescriptor!=null){\n-\t\t\ttabDesc.setVersion(versionDescriptor.getString());\n-\t\t}else\n-\t\t\t\t\t\ttabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n-\t\treturn tabDesc;\n-\t}\n-\n-\t/**\n-\t *\tGet the table name out of this SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t *\n-\t * @return\tstring, the table name\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tprotected String getTableName(ExecRow\trow)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tDataValueDescriptor\tcol;\n-\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\treturn col.getString();\n-\t}\n-\n-\n-\t/**\n-\t * builds a list of columns suitable for creating this catalog.\n-\t *\n-\t *\n-\t * @return array of systemcolumn suitable for making this catalog.\n-\t */\n-\tpublic SystemColumn[]\tbuildColumnList()\n-        throws StandardException\n-\t{\n-        return new SystemColumn[] {\n-                SystemColumnImpl.getUUIDColumn(\"TABLEID\", false),\n-                SystemColumnImpl.getIdentifierColumn(\"TABLENAME\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"TABLETYPE\"),\n-                SystemColumnImpl.getUUIDColumn(\"SCHEMAID\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"LOCKGRANULARITY\"),\n-                SystemColumnImpl.getIdentifierColumn(\"VERSION\",true),\n-                SystemColumnImpl.getColumn(\"COLSEQUENCE\", Types.INTEGER, false),\n-                SystemColumnImpl.getColumn(\"DELIMITED\", Types.VARCHAR,  true),\n-                SystemColumnImpl.getColumn(\"ESCAPED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LINES\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"STORED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LOCATION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"COMPRESSION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"IS_PINNED\", Types.BOOLEAN, false),\n+        //TODO -sf- place version into tuple descriptor\n+        DataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n+\n+        DataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n+        DataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n+        DataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n+        DataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n+        DataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n+        DataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        DataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n+        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        DataValueDescriptor minRetentionPeriodDVD = row.getColumn(SYSTABLES_MIN_RETENTION_PERIOD);\n+\n+        // RESOLVE - Deal with lock granularity\n+        tabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n+                row.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n+                delimitedDVD != null ? delimitedDVD.getString() : null,\n+                escapedDVD != null ? escapedDVD.getString() : null,\n+                linesDVD != null ? linesDVD.getString() : null,\n+                storedDVD != null ? storedDVD.getString() : null,\n+                locationDVD != null ? locationDVD.getString() : null,\n+                compressionDVD != null ? compressionDVD.getString() : null,\n+                isPinnedDVD.getBoolean(),\n+                purgeDeletedRowsDVD.getBoolean(),\n+                minRetentionPeriodDVD.getLong()\n+        );\n+        tabDesc.setUUID(tableUUID);\n+\n+        if (versionDescriptor != null) {\n+            tabDesc.setVersion(versionDescriptor.getString());\n+        } else\n+            tabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n+        return tabDesc;\n+    }\n+\n+    /**\n+     * Get the table name out of this SYSTABLES row\n+     *\n+     * @param row a SYSTABLES row\n+     * @throws StandardException thrown on failure\n+     * @return string, the table name\n+     */\n+    protected String getTableName(ExecRow row)\n+            throws StandardException {\n+        DataValueDescriptor col;\n+\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        return col.getString();\n+    }\n+\n+\n+    /**\n+     * builds a list of columns suitable for creating this catalog.\n+     *\n+     * @return array of systemcolumn suitable for making this catalog.\n+     */\n+    public SystemColumn[] buildColumnList()\n+            throws StandardException {\n+        return new SystemColumn[]{\n+                SystemColumnImpl.getUUIDColumn(TABLEID, false),\n+                SystemColumnImpl.getIdentifierColumn(TABLENAME, false),\n+                SystemColumnImpl.getIndicatorColumn(TABLETYPE),\n+                SystemColumnImpl.getUUIDColumn(SCHEMAID, false),\n+                SystemColumnImpl.getIndicatorColumn(LOCKGRANULARITY),\n+                SystemColumnImpl.getIdentifierColumn(VERSION, true),\n+                SystemColumnImpl.getColumn(COLSEQUENCE, Types.INTEGER, false),\n+                SystemColumnImpl.getColumn(DELIMITED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(ESCAPED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LINES, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(STORED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LOCATION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(COMPRESSION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(IS_PINNED, Types.BOOLEAN, false),\n                 SystemColumnImpl.getColumn(PURGE_DELETED_ROWS, Types.BOOLEAN, false),\n+                SystemColumnImpl.getColumn(MIN_RETENTION_PERIOD, Types.BIGINT, false),\n         };\n-\t}\n-\n-\tpublic List<ColumnDescriptor[]> getViewColumns(TableDescriptor view, UUID viewId) throws StandardException {\n-\t\tList<ColumnDescriptor[]> cdsl = new ArrayList<>();\n-\t\tcdsl.add(\n-\t\t    new ColumnDescriptor[]{\n-\t\t\t\tnew ColumnDescriptor(\"TABLEID\",1,1,DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"TABLENAME\"               ,2,2,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"TABLETYPE\"               ,3,3,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"SCHEMAID\"               ,4,4,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LOCKGRANULARITY\"               ,5,5,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"VERSION\"               ,6,6,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"COLSEQUENCE\"               ,7,7,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"DELIMITED\"               ,8,8,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"ESCAPED\"               ,9,9,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LINES\"               ,10,10,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"STORED\"               ,11,11,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LOCATION\"               ,12,12,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"COMPRESSION\"               ,13,13,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"IS_PINNED\"               ,14,14,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"PURGE_DELETED_ROWS\"               ,15,15,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"SCHEMANAME\"               ,16,16,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0)\n-\t\t});\n-\n-\t\t// add columnlist for the systables view in sysibm schema\n-\t\tCollection<Object[]> colList = Lists.newArrayListWithCapacity(66);\n-\t\tcolList.add(new Object[]{\"NAME\", Types.VARCHAR, false, 128});\n-\t\tcolList.add(new Object[]{\"CREATOR\", Types.VARCHAR, false, 128});\n-\t\tcolList.add(new Object[]{\"TYPE\", Types.CHAR, false, 1});\n-       colList.add(new Object[]{\"COLCOUNT\", Types.SMALLINT, false, null});\n+    }\n+\n+    public List<ColumnDescriptor[]> getViewColumns(TableDescriptor view, UUID viewId) throws StandardException {\n+        List<ColumnDescriptor[]> cdsl = new ArrayList<>();\n+        cdsl.add(\n+                new ColumnDescriptor[]{\n+                        new ColumnDescriptor(TABLEID, 1, 1, DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(TABLENAME, 2, 2,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(TABLETYPE, 3, 3,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(SCHEMAID, 4, 4,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LOCKGRANULARITY, 5, 5,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(VERSION, 6, 6,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(COLSEQUENCE, 7, 7,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(DELIMITED, 8, 8,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(ESCAPED, 9, 9,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LINES, 10, 10,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(STORED, 11, 11,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LOCATION, 12, 12,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(COMPRESSION, 13, 13,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(IS_PINNED, 14, 14,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(PURGE_DELETED_ROWS, 15, 15,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(MIN_RETENTION_PERIOD, 16, 16,", "originalCommit": "31f0415c89417a3fb8d1aebc534afcd4a2c7dfe0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MTE4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r478441180", "bodyText": "Thanks, I addressed your comment, but not sure if it is exactly correctly.", "author": "hatyo", "createdAt": "2020-08-27T13:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5MzUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\nindex 8e38de6e33..9402577507 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n\n@@ -533,7 +533,7 @@ public class SYSTABLESRowFactory extends CatalogRowFactory {\n                 compressionDVD != null ? compressionDVD.getString() : null,\n                 isPinnedDVD.getBoolean(),\n                 purgeDeletedRowsDVD.getBoolean(),\n-                minRetentionPeriodDVD.getLong()\n+                minRetentionPeriodDVD != null ? minRetentionPeriodDVD.getLong() : null\n         );\n         tabDesc.setUUID(tableUUID);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NDEzMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r477494133", "bodyText": "We may need to define MIN_RETENTION_PERIOD as nullable, since the existing rows upgraded from lower versions won't have this field, so it's value is NULL.", "author": "yxia92", "createdAt": "2020-08-26T18:13:08Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -52,661 +52,664 @@\n /**\n  * Factory for creating a SYSTABLES row.\n  *\n- *\n  * @version 0.1\n  */\n-\n-public class SYSTABLESRowFactory extends CatalogRowFactory\n-{\n-\tpublic static final String\t\tTABLENAME_STRING = \"SYSTABLES\";\n-\n-\tpublic static final int\t\tSYSTABLES_COLUMN_COUNT = 15;\n-\t/* Column #s for systables (1 based) */\n-\tpublic static final int\t\tSYSTABLES_TABLEID = 1;\n-\tpublic static final int\t\tSYSTABLES_TABLENAME = 2;\n-\tprotected static final int\t\tSYSTABLES_TABLETYPE = 3;\n-\tpublic static final int\t\tSYSTABLES_SCHEMAID = 4;\n-\tprotected static final int\t\tSYSTABLES_LOCKGRANULARITY = 5;\n-\tprotected static final int\t\tSYSTABLES_VERSION = 6;\n+public class SYSTABLESRowFactory extends CatalogRowFactory {\n+    public static final String TABLENAME_STRING = \"SYSTABLES\";\n+\n+    public static final int SYSTABLES_COLUMN_COUNT = 16;\n+\n+    /* Column #s for systables (1 based) */\n+    public    static final int SYSTABLES_TABLEID                = 1;\n+    public    static final int SYSTABLES_TABLENAME              = 2;\n+    protected static final int SYSTABLES_TABLETYPE              = 3;\n+    public    static final int SYSTABLES_SCHEMAID               = 4;\n+    protected static final int SYSTABLES_LOCKGRANULARITY        = 5;\n+    protected static final int SYSTABLES_VERSION                = 6;\n     /* Sequence for understanding coding/decoding with altering tables*/\n-    protected static final int\t\tSYSTABLES_COLUMN_SEQUENCE = 7;\n-\t/* External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_DELIMITED_BY = 8;\n-\tprotected static final int\t\tSYSTABLES_ESCAPED_BY = 9;\n-\tprotected static final int\t\tSYSTABLES_LINES_BY = 10;\n-\tprotected static final int\t\tSYSTABLES_STORED_AS = 11;\n-\tprotected static final int\t\tSYSTABLES_LOCATION = 12;\n-\tprotected static final int\t\tSYSTABLES_COMPRESSION = 13;\n-\t// SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n-\t@Deprecated\n-\tprotected static final int \t\tSYSTABLES_IS_PINNED = 14;\n-\tprotected static final int      SYSTABLES_PURGE_DELETED_ROWS = 15;\n-\t/* End External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_INDEX1_ID = 0;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_TABLENAME = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_SCHEMAID = 2;\n-\n-\tprotected static final int\t\tSYSTABLES_INDEX2_ID = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX2_TABLEID = 1;\n-\n-\n-    public static final String      PURGE_DELETED_ROWS = \"PURGE_DELETED_ROWS\";\n-\t/*\n-\t * The first version of any tables. Use this for System tables and\n-\t * any time that you don't know what the version is.\n-\t */\n-\tpublic static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n-\t//the current version for creating new tables with\n-\tpublic static final String CURRENT_TABLE_VERSION = \"4.0\";\n-\t\n-\t// all indexes are unique.\n-\n-\tprivate\tstatic\tfinal\tString[]\tuuids =\n-\t{\n-\t\t \"80000018-00d0-fd77-3ed8-000a0a0b1900\"\t// catalog UUID\n-\t\t,\"80000028-00d0-fd77-3ed8-000a0a0b1900\"\t// heap UUID\n-\t\t,\"8000001a-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX1\n-\t\t,\"8000001c-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX2\n-\t};\n-\n-\tprivate static final int[][] indexColumnPositions = \n-\t{ \n-\t\t{ SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n-\t\t{ SYSTABLES_TABLEID }\n-\t};\n-\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tCONSTRUCTORS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)\n-\t{\n-\t\tsuper(uuidf,ef,dvf);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\n-\tSYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n-\t{\n-\t\tsuper(uuidf,ef,dvf, dd);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tMETHODS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a SYSTABLES row\n-\t *\n-\t * @return\tRow suitable for inserting into SYSTABLES.\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\t@SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n-\tpublic ExecRow makeRow(boolean latestVersion, TupleDescriptor td,\n-\t\t\t\t\t\t   TupleDescriptor\tparent)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tUUID\t\t\t\t\t\toid;\n-\t\tString\t   \t\t\t\ttabSType = null;\n-\t\tint\t   \t\t\t\t\ttabIType;\n-\t\tExecRow        \t\t\trow;\n-\t\tString\t\t\t\t\tlockGranularity = null;\n-\t\tString\t\t\t\t\ttableID = null;\n-\t\tString\t\t\t\t\tschemaID = null;\n-\t\tString\t\t\t\t\ttableName = null;\n-        int                     columnSequence = 0;\n-\t\tString \t\t\t\t\tdelimited = null;\n-\t\tString \t\t\t\t\tescaped = null;\n-\t\tString \t\t\t\t\tlines = null;\n-\t\tString \t\t\t\t\tstoredAs = null;\n-\t\tString \t\t\t\t\tlocation = null;\n-\t\tString \t\t\t\t\tcompression = null;\n-\t\tSQLVarchar              tableVersion = null;\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tboolean \t\t\t\tisPinned = false;\n-\t\tboolean                 purgeDeletedRows = false;\n-\n-\t\tif (td != null)\n-\t\t{\n-\t\t\t/*\n-\t\t\t** We only allocate a new UUID if the descriptor doesn't already have one.\n-\t\t\t** For descriptors replicated from a Source system, we already have an UUID.\n-\t\t\t*/\n-\t\t\tif (!(td instanceof TableDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n-\t\t\tif (!(parent instanceof SchemaDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n-\t\t\tTableDescriptor descriptor = (TableDescriptor)td;\n-\t\t\tSchemaDescriptor schema = (SchemaDescriptor)parent;\n+    protected static final int SYSTABLES_COLUMN_SEQUENCE        = 7;\n+    /* External Tables Columns */\n+    protected static final int SYSTABLES_DELIMITED_BY           = 8;\n+    protected static final int SYSTABLES_ESCAPED_BY             = 9;\n+    protected static final int SYSTABLES_LINES_BY               = 10;\n+    protected static final int SYSTABLES_STORED_AS              = 11;\n+    protected static final int SYSTABLES_LOCATION               = 12;\n+    protected static final int SYSTABLES_COMPRESSION            = 13;\n+    // SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n+    @Deprecated\n+    protected static final int SYSTABLES_IS_PINNED              = 14;\n+    protected static final int SYSTABLES_PURGE_DELETED_ROWS     = 15;\n+    protected static final int SYSTABLES_MIN_RETENTION_PERIOD   = 16;\n+    /* End External Tables Columns */\n+\n+    protected static final int SYSTABLES_INDEX1_ID        = 0;\n+    protected static final int SYSTABLES_INDEX1_TABLENAME = 1;\n+    protected static final int SYSTABLES_INDEX1_SCHEMAID  = 2;\n+\n+    protected static final int SYSTABLES_INDEX2_ID        = 1;\n+    protected static final int SYSTABLES_INDEX2_TABLEID   = 1;\n+\n+    /* Column names */\n+    public static final String IS_PINNED            = \"IS_PINNED\";\n+    public static final String COMPRESSION          = \"COMPRESSION\";\n+    public static final String LOCATION             = \"LOCATION\";\n+    public static final String STORED               = \"STORED\";\n+    public static final String LINES                = \"LINES\";\n+    public static final String ESCAPED              = \"ESCAPED\";\n+    public static final String DELIMITED            = \"DELIMITED\";\n+    public static final String COLSEQUENCE          = \"COLSEQUENCE\";\n+    public static final String VERSION              = \"VERSION\";\n+    public static final String LOCKGRANULARITY      = \"LOCKGRANULARITY\";\n+    public static final String SCHEMAID             = \"SCHEMAID\";\n+    public static final String TABLETYPE            = \"TABLETYPE\";\n+    public static final String TABLENAME            = \"TABLENAME\";\n+    public static final String TABLEID              = \"TABLEID\";\n+    public static final String PURGE_DELETED_ROWS   = \"PURGE_DELETED_ROWS\";\n+    public static final String MIN_RETENTION_PERIOD = \"MIN_RETENTION_PERIOD\";\n+    /*\n+     * The first version of any tables. Use this for System tables and\n+     * any time that you don't know what the version is.\n+     */\n+    public static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n+    //the current version for creating new tables with\n+    public static final String CURRENT_TABLE_VERSION = \"4.0\";\n+\n+    // all indexes are unique.\n+\n+    private static final String[] uuids =\n+        {\n+            \"80000018-00d0-fd77-3ed8-000a0a0b1900\", // catalog UUID\n+            \"80000028-00d0-fd77-3ed8-000a0a0b1900\", // heap UUID\n+            \"8000001a-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX1\n+            \"8000001c-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX2\n+        };\n+\n+    private static final int[][] indexColumnPositions =\n+        {\n+            {SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n+            {SYSTABLES_TABLEID}\n+        };\n+\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tCONSTRUCTORS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf) {\n+        super(uuidf, ef, dvf);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n+    {\n+        super(uuidf,ef,dvf, dd);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tMETHODS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a SYSTABLES row\n+     *\n+     * @throws StandardException thrown on failure\n+     * @return Row suitable for inserting into SYSTABLES.\n+     */\n+    @SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n+    public ExecRow makeRow(boolean latestVersion,\n+                           TupleDescriptor td,\n+                           TupleDescriptor parent)\n+            throws StandardException {\n+        UUID oid;\n+        String tabSType = null;\n+        int tabIType;\n+        ExecRow row;\n+        String lockGranularity = null;\n+        String tableID = null;\n+        String schemaID = null;\n+        String tableName = null;\n+        int columnSequence = 0;\n+        String delimited = null;\n+        String escaped = null;\n+        String lines = null;\n+        String storedAs = null;\n+        String location = null;\n+        String compression = null;\n+        SQLVarchar tableVersion = null;\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        boolean isPinned = false;\n+        boolean purgeDeletedRows = false;\n+        long minRetentionPeriod = 0;\n+\n+        if (td != null) {\n+            /*\n+             ** We only allocate a new UUID if the descriptor doesn't already have one.\n+             ** For descriptors replicated from a Source system, we already have an UUID.\n+             */\n+            if (!(td instanceof TableDescriptor))\n+                throw new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n+            if (!(parent instanceof SchemaDescriptor))\n+                throw new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n+            TableDescriptor descriptor = (TableDescriptor) td;\n+            SchemaDescriptor schema = (SchemaDescriptor) parent;\n \n             columnSequence = descriptor.getColumnSequence();\n-\t\t\toid = descriptor.getUUID();\n-\t\t\tif ( oid == null )\n-\t\t    {\n-\t\t\t\toid = getUUIDFactory().createUUID();\n-\t\t\t\tdescriptor.setUUID(oid);\n-\t\t\t}\n-\t\t\ttableID = oid.toString();\n-\t\t\t\n-\t\t\tif (SanityManager.DEBUG)\n-\t\t\t{\n-\t\t\t\tSanityManager.ASSERT(schema != null, \n-\t\t\t\t\t\t\t\"Schema should not be null unless empty row is true\");\n-\t\t\t\tif (schema.getUUID() == null)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\n-\t\t\tschemaID = schema.getUUID().toString();\n-\n-\t\t\ttableName = descriptor.getName();\n-\n-\t\t\t/* RESOLVE - Table Type should really be a char in the descriptor\n-\t\t\t * T, S, V, S instead of 0, 1, 2, 3\n-\t\t\t */\n-\t\t\ttabIType = descriptor.getTableType();\n-\t\t\tswitch (tabIType)\n-\t\t\t{\n-\t\t\t    case TableDescriptor.BASE_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"T\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.SYSTEM_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"S\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.VIEW_TYPE:\n-\t\t\t\t\ttabSType = \"V\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"X\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.SYNONYM_TYPE:\n-\t\t\t\t\ttabSType = \"A\";\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase TableDescriptor.EXTERNAL_TYPE:\n-\t\t\t\t\ttabSType = \"E\";\n-\t\t\t\t\tbreak;\n-\n-\n-\t\t\t    default:\n-\t\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t\t\tSanityManager.THROWASSERT(\"invalid table type\");\n-\t\t\t}\n-\t\t\tchar[] lockGChar = new char[1];\n-\t\t\tlockGChar[0] = descriptor.getLockGranularity();\n-\t\t\tlockGranularity = new String(lockGChar);\n-\t\t\tdelimited = descriptor.getDelimited();\n-\t\t\tescaped = descriptor.getEscaped();\n-\t\t\tlines = descriptor.getLines();\n-\t\t\tstoredAs = descriptor.getStoredAs();\n-\t\t\tlocation = descriptor.getLocation();\n-\t\t\tcompression = descriptor.getCompression();\n-\t\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\t\tisPinned = descriptor.isPinned();\n+            oid = descriptor.getUUID();\n+            if (oid == null) {\n+                oid = getUUIDFactory().createUUID();\n+                descriptor.setUUID(oid);\n+            }\n+            tableID = oid.toString();\n+\n+            if (SanityManager.DEBUG) {\n+                SanityManager.ASSERT(schema != null,\n+                        \"Schema should not be null unless empty row is true\");\n+                if (schema.getUUID() == null) {\n+                    SanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n+                }\n+            }\n+\n+            schemaID = schema.getUUID().toString();\n+\n+            tableName = descriptor.getName();\n+\n+            /* RESOLVE - Table Type should really be a char in the descriptor\n+             * T, S, V, S instead of 0, 1, 2, 3\n+             */\n+            tabIType = descriptor.getTableType();\n+            switch (tabIType) {\n+                case TableDescriptor.BASE_TABLE_TYPE:\n+                    tabSType = \"T\";\n+                    break;\n+                case TableDescriptor.SYSTEM_TABLE_TYPE:\n+                    tabSType = \"S\";\n+                    break;\n+                case TableDescriptor.VIEW_TYPE:\n+                    tabSType = \"V\";\n+                    break;\n+\n+                case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n+                    tabSType = \"X\";\n+                    break;\n+\n+                case TableDescriptor.SYNONYM_TYPE:\n+                    tabSType = \"A\";\n+                    break;\n+                case TableDescriptor.EXTERNAL_TYPE:\n+                    tabSType = \"E\";\n+                    break;\n+\n+\n+                default:\n+                    if (SanityManager.DEBUG)\n+                        SanityManager.THROWASSERT(\"invalid table type\");\n+            }\n+            char[] lockGChar = new char[1];\n+            lockGChar[0] = descriptor.getLockGranularity();\n+            lockGranularity = new String(lockGChar);\n+            delimited = descriptor.getDelimited();\n+            escaped = descriptor.getEscaped();\n+            lines = descriptor.getLines();\n+            storedAs = descriptor.getStoredAs();\n+            location = descriptor.getLocation();\n+            compression = descriptor.getCompression();\n+            //NOT USED ANYMORE, for backward compatibility only\n+            isPinned = descriptor.isPinned();\n             purgeDeletedRows = descriptor.purgeDeletedRows();\n-\t\t\ttableVersion = descriptor.getVersion() == null ?\n-\t\t                 \tnew SQLVarchar(CURRENT_TABLE_VERSION) :\n-\t\t\t                new SQLVarchar(descriptor.getVersion());\n-\t\t}\n-\t\telse\n-\t\t\ttableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n-\n-\t\t/* Insert info into systables */\n-\n-\t\t/* RESOLVE - It would be nice to require less knowledge about systables\n-\t\t * and have this be more table driven.\n-\t\t */\n-\n-\t\t/* Build the row to insert  */\n-\t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n-\n-\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n-\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n-\t\treturn row;\n-\t}\n-\n-\tpublic static void setRowColumns(ExecRow row,\n-\t\t\t\t\t\t\t\t\t String tableID,\n-\t\t\t\t\t\t\t\t\t String tableName,\n-\t\t\t\t\t\t\t\t\t String tabSType,\n-\t\t\t\t\t\t\t\t\t String schemaID,\n-\t\t\t\t\t\t\t\t\t String lockGranularity,\n-\t\t\t\t\t\t\t\t\t SQLVarchar tableVersion,\n-\t\t\t\t\t\t\t\t\t int columnSequence,\n-\t\t\t\t\t\t\t\t\t String delimited,\n-\t\t\t\t\t\t\t\t\t String escaped,\n-\t\t\t\t\t\t\t\t\t String lines,\n-\t\t\t\t\t\t\t\t\t String storedAs,\n-\t\t\t\t\t\t\t\t\t String location,\n-\t\t\t\t\t\t\t\t\t String compression,\n-\t\t\t\t\t\t\t\t\t boolean isPinned,\n-\t\t\t\t\t\t\t\t\t boolean purgeDeletedRows) {\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n-\n-\t\t/* 2nd column is NAME (varchar(30)) */\n-\t\trow.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\trow.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n-\n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\trow.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n-\n-\t\t/* 6th column is VERSION (varchar(128)) */\n-\t\trow.setColumn(SYSTABLES_VERSION, tableVersion);\n-\n-\t\trow.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n-\n-\t\trow.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n-\t\trow.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n-\t\trow.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n-\t\trow.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n-\t\trow.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n-\t\trow.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n-\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\trow.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n-\t\trow.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n-\t}\n-\n-\t/**\n-\t * Builds an empty index row.\n-\t *\n-\t *\t@param\tindexNumber\tIndex to build empty row for.\n-\t *  @param  rowLocation\tRow location for last column of index row\n-\t *\n-\t * @return corresponding empty index row\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\t@SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n-\tExecIndexRow\tbuildEmptyIndexRow( int indexNumber,\n-\t\t\t\t\t\t\t\t\t\t\tRowLocation rowLocation)\n-\t\t\tthrows StandardException\n-\t{\n-\t\tint ncols = getIndexColumnCount(indexNumber);\n-\t\tExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n-\n-\t\trow.setColumn(ncols + 1, rowLocation);\n-\n-\t\tswitch( indexNumber )\n-\t\t{\n-\t\t    case SYSTABLES_INDEX1_ID:\n-\t\t\t\t/* 1st column is TABLENAME (varchar(128)) */\n-\t\t\t\trow.setColumn(1, new SQLVarchar());\n-\n-\t\t\t\t/* 2nd column is SCHEMAID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(2, new SQLChar());\n-\n-\t\t\t\tbreak;\n-\n-\t\t    case SYSTABLES_INDEX2_ID:\n-\t\t\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(1,new SQLChar());\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tthrow new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n-\t\t}\t// end switch\n-\n-\t\treturn\trow;\n-\t}\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t * @param isolationLevel use this explicit isolation level. Only\n-\t *                       ISOLATION_REPEATABLE_READ (normal usage)\n-\t *                       or ISOLATION_READ_UNCOMMITTED (corner\n-\t *                       cases) supported for now.\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tTupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(row,\n-\t\t\t\t\t\t\t\t   parentTupleDescriptor,\n-\t\t\t\t\t\t\t\t   dd,\n-\t\t\t\t\t\t\t\t   isolationLevel);\n-\t}\n-\n-\n-\t///////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n-\t//\n-\t///////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t *\n-\t * @return\ta table descriptor equivalent to a SYSTABLES row\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\tpublic TupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd )\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(\n-\t\t\trow,\n-\t\t\tparentTupleDescriptor,\n-\t\t\tdd,\n-\t\t\tTransactionController.ISOLATION_REPEATABLE_READ);\n-\t}\n-\n-\n-\tpublic TupleDescriptor buildDescriptorBody(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\tSanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n-\n-\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n-\n-\t\tString\ttableUUIDString; \n-\t\tString\tschemaUUIDString; \n-\t\tint\t\ttableTypeEnum;\n-\t\tString\tlockGranularity;\n-\t\tString\ttableName, tableType;\n-\t\tDataValueDescriptor\tcol;\n-\t\tUUID\t\ttableUUID;\n-\t\tUUID\t\tschemaUUID;\n-\t\tSchemaDescriptor\tschema;\n-\t\tTableDescriptor\t\ttabDesc;\n-\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLEID);\n-\t\ttableUUIDString = col.getString();\n-\t\ttableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n-\n-\n-\t\t/* 2nd column is TABLENAME (varchar(128)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\ttableName = col.getString();\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLETYPE);\n-\t\ttableType = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n-\t\t}\n-\t\tswitch (tableType.charAt(0))\n-\t\t{\n-\t\t\tcase 'T' : \n-\t\t\t\ttableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'S' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'V' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.VIEW_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'A' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'X' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'E' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\tSanityManager.THROWASSERT(\"Fourth column value invalid\");\n-\t\t\t\ttableTypeEnum = -1;\n-\t\t}\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_SCHEMAID);\n-\t\tschemaUUIDString = col.getString();\n-\t\tschemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n-\t\t\n-\t\tschema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n+            minRetentionPeriod = descriptor.getMinRetainedVersions();\n+            tableVersion = descriptor.getVersion() == null ?\n+                    new SQLVarchar(CURRENT_TABLE_VERSION) :\n+                    new SQLVarchar(descriptor.getVersion());\n+        } else\n+            tableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n+\n+        /* Insert info into systables */\n+\n+        /* RESOLVE - It would be nice to require less knowledge about systables\n+         * and have this be more table driven.\n+         */\n+\n+        /* Build the row to insert  */\n+        row = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n+\n+        setRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+                delimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows, minRetentionPeriod);\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row,\n+                                     String tableID,\n+                                     String tableName,\n+                                     String tabSType,\n+                                     String schemaID,\n+                                     String lockGranularity,\n+                                     SQLVarchar tableVersion,\n+                                     int columnSequence,\n+                                     String delimited,\n+                                     String escaped,\n+                                     String lines,\n+                                     String storedAs,\n+                                     String location,\n+                                     String compression,\n+                                     boolean isPinned,\n+                                     boolean purgeDeletedRows,\n+                                     long minRetentionPeriod) {\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n+\n+        /* 2nd column is NAME (varchar(30)) */\n+        row.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        row.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n+\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        row.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n+\n+        /* 6th column is VERSION (varchar(128)) */\n+        row.setColumn(SYSTABLES_VERSION, tableVersion);\n+\n+        row.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n+\n+        row.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n+        row.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n+        row.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n+        row.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n+        row.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n+        row.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n+        //NOT USED ANYMORE, for backward compatibility only\n+        row.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n+        row.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n+        row.setColumn(SYSTABLES_MIN_RETENTION_PERIOD, new SQLLongint(minRetentionPeriod));\n+    }\n+\n+    /**\n+     * Builds an empty index row.\n+     *\n+     * @param rowLocation Row location for last column of index row\n+     * @return corresponding empty index row\n+     * @throws StandardException thrown on failure\n+     * @param    indexNumber    Index to build empty row for.\n+     */\n+    @SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n+    ExecIndexRow buildEmptyIndexRow(int indexNumber,\n+                                    RowLocation rowLocation)\n+            throws StandardException {\n+        int ncols = getIndexColumnCount(indexNumber);\n+        ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n+\n+        row.setColumn(ncols + 1, rowLocation);\n+\n+        switch (indexNumber) {\n+            case SYSTABLES_INDEX1_ID:\n+                /* 1st column is TABLENAME (varchar(128)) */\n+                row.setColumn(1, new SQLVarchar());\n+\n+                /* 2nd column is SCHEMAID (UUID - char(36)) */\n+                row.setColumn(2, new SQLChar());\n+\n+                break;\n+\n+            case SYSTABLES_INDEX2_ID:\n+                /* 1st column is TABLEID (UUID - char(36)) */\n+                row.setColumn(1, new SQLChar());\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n+        }    // end switch\n+\n+        return row;\n+    }\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @param isolationLevel        use this explicit isolation level. Only\n+     *                              ISOLATION_REPEATABLE_READ (normal usage)\n+     *                              or ISOLATION_READ_UNCOMMITTED (corner\n+     *                              cases) supported for now.\n+     * @throws StandardException thrown on failure\n+     */\n+    TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        return buildDescriptorBody(row,\n+                parentTupleDescriptor,\n+                dd,\n+                isolationLevel);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n+    //\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @throws StandardException thrown on failure\n+     * @return a table descriptor equivalent to a SYSTABLES row\n+     */\n+\n+    public TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd)\n+            throws StandardException {\n+        return buildDescriptorBody(\n+                row,\n+                parentTupleDescriptor,\n+                dd,\n+                TransactionController.ISOLATION_REPEATABLE_READ);\n+    }\n+\n+\n+    public TupleDescriptor buildDescriptorBody(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        if (SanityManager.DEBUG)\n+            SanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n+\n+        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n+\n+        String tableUUIDString;\n+        String schemaUUIDString;\n+        int tableTypeEnum;\n+        String lockGranularity;\n+        String tableName, tableType;\n+        DataValueDescriptor col;\n+        UUID tableUUID;\n+        UUID schemaUUID;\n+        SchemaDescriptor schema;\n+        TableDescriptor tabDesc;\n+\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_TABLEID);\n+        tableUUIDString = col.getString();\n+        tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n+\n+\n+        /* 2nd column is TABLENAME (varchar(128)) */\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        tableName = col.getString();\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        col = row.getColumn(SYSTABLES_TABLETYPE);\n+        tableType = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n+        }\n+        switch (tableType.charAt(0)) {\n+            case 'T':\n+                tableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n+                break;\n+            case 'S':\n+                tableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n+                break;\n+            case 'V':\n+                tableTypeEnum = TableDescriptor.VIEW_TYPE;\n+                break;\n+            case 'A':\n+                tableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n+                break;\n+            case 'X':\n+                tableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n+                break;\n+            case 'E':\n+                tableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n+                break;\n+            default:\n+                if (SanityManager.DEBUG)\n+                    SanityManager.THROWASSERT(\"Fourth column value invalid\");\n+                tableTypeEnum = -1;\n+        }\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_SCHEMAID);\n+        schemaUUIDString = col.getString();\n+        schemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n+\n+        schema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n \n         // If table is temp table, (SESSION) schema will be null\n         if (schema == null && (tableTypeEnum == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)) {\n             schema = dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();\n         }\n \n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n-\t\tlockGranularity = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n-\t\t}\n-\n-\t\t//TODO -sf- place version into tuple descriptor\n-\t\tDataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n-\n-\t\tDataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n-\t\tDataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n-\t\tDataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n-\t\tDataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n-\t\tDataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n-\t\tDataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tDataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n-        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        col = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n+        lockGranularity = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n+        }\n \n-\t\t// RESOLVE - Deal with lock granularity\n-\t\ttabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n-\t\t\t\trow.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n-\t\t\t\tdelimitedDVD!=null?delimitedDVD.getString():null,\n-\t\t\t\tescapedDVD!=null?escapedDVD.getString():null,\n-\t\t\t\tlinesDVD!=null?linesDVD.getString():null,\n-\t\t\t\tstoredDVD!=null?storedDVD.getString():null,\n-\t\t\t\tlocationDVD!=null?locationDVD.getString():null,\n-\t\t\t\tcompressionDVD!=null?compressionDVD.getString():null,\n-\t\t\t\tisPinnedDVD.getBoolean(),\n-                purgeDeletedRowsDVD.getBoolean()\n-\t\t\t\t);\n-\t\ttabDesc.setUUID(tableUUID);\n-\n-\t\tif(versionDescriptor!=null){\n-\t\t\ttabDesc.setVersion(versionDescriptor.getString());\n-\t\t}else\n-\t\t\t\t\t\ttabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n-\t\treturn tabDesc;\n-\t}\n-\n-\t/**\n-\t *\tGet the table name out of this SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t *\n-\t * @return\tstring, the table name\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tprotected String getTableName(ExecRow\trow)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tDataValueDescriptor\tcol;\n-\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\treturn col.getString();\n-\t}\n-\n-\n-\t/**\n-\t * builds a list of columns suitable for creating this catalog.\n-\t *\n-\t *\n-\t * @return array of systemcolumn suitable for making this catalog.\n-\t */\n-\tpublic SystemColumn[]\tbuildColumnList()\n-        throws StandardException\n-\t{\n-        return new SystemColumn[] {\n-                SystemColumnImpl.getUUIDColumn(\"TABLEID\", false),\n-                SystemColumnImpl.getIdentifierColumn(\"TABLENAME\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"TABLETYPE\"),\n-                SystemColumnImpl.getUUIDColumn(\"SCHEMAID\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"LOCKGRANULARITY\"),\n-                SystemColumnImpl.getIdentifierColumn(\"VERSION\",true),\n-                SystemColumnImpl.getColumn(\"COLSEQUENCE\", Types.INTEGER, false),\n-                SystemColumnImpl.getColumn(\"DELIMITED\", Types.VARCHAR,  true),\n-                SystemColumnImpl.getColumn(\"ESCAPED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LINES\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"STORED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LOCATION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"COMPRESSION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"IS_PINNED\", Types.BOOLEAN, false),\n+        //TODO -sf- place version into tuple descriptor\n+        DataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n+\n+        DataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n+        DataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n+        DataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n+        DataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n+        DataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n+        DataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        DataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n+        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        DataValueDescriptor minRetentionPeriodDVD = row.getColumn(SYSTABLES_MIN_RETENTION_PERIOD);\n+\n+        // RESOLVE - Deal with lock granularity\n+        tabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n+                row.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n+                delimitedDVD != null ? delimitedDVD.getString() : null,\n+                escapedDVD != null ? escapedDVD.getString() : null,\n+                linesDVD != null ? linesDVD.getString() : null,\n+                storedDVD != null ? storedDVD.getString() : null,\n+                locationDVD != null ? locationDVD.getString() : null,\n+                compressionDVD != null ? compressionDVD.getString() : null,\n+                isPinnedDVD.getBoolean(),\n+                purgeDeletedRowsDVD.getBoolean(),\n+                minRetentionPeriodDVD.getLong()\n+        );\n+        tabDesc.setUUID(tableUUID);\n+\n+        if (versionDescriptor != null) {\n+            tabDesc.setVersion(versionDescriptor.getString());\n+        } else\n+            tabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n+        return tabDesc;\n+    }\n+\n+    /**\n+     * Get the table name out of this SYSTABLES row\n+     *\n+     * @param row a SYSTABLES row\n+     * @throws StandardException thrown on failure\n+     * @return string, the table name\n+     */\n+    protected String getTableName(ExecRow row)\n+            throws StandardException {\n+        DataValueDescriptor col;\n+\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        return col.getString();\n+    }\n+\n+\n+    /**\n+     * builds a list of columns suitable for creating this catalog.\n+     *\n+     * @return array of systemcolumn suitable for making this catalog.\n+     */\n+    public SystemColumn[] buildColumnList()\n+            throws StandardException {\n+        return new SystemColumn[]{\n+                SystemColumnImpl.getUUIDColumn(TABLEID, false),\n+                SystemColumnImpl.getIdentifierColumn(TABLENAME, false),\n+                SystemColumnImpl.getIndicatorColumn(TABLETYPE),\n+                SystemColumnImpl.getUUIDColumn(SCHEMAID, false),\n+                SystemColumnImpl.getIndicatorColumn(LOCKGRANULARITY),\n+                SystemColumnImpl.getIdentifierColumn(VERSION, true),\n+                SystemColumnImpl.getColumn(COLSEQUENCE, Types.INTEGER, false),\n+                SystemColumnImpl.getColumn(DELIMITED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(ESCAPED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LINES, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(STORED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LOCATION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(COMPRESSION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(IS_PINNED, Types.BOOLEAN, false),\n                 SystemColumnImpl.getColumn(PURGE_DELETED_ROWS, Types.BOOLEAN, false),\n+                SystemColumnImpl.getColumn(MIN_RETENTION_PERIOD, Types.BIGINT, false),", "originalCommit": "31f0415c89417a3fb8d1aebc534afcd4a2c7dfe0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1OTAzMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r478259031", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-27T08:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NDEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\nindex 8e38de6e33..9402577507 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n\n@@ -533,7 +533,7 @@ public class SYSTABLESRowFactory extends CatalogRowFactory {\n                 compressionDVD != null ? compressionDVD.getString() : null,\n                 isPinnedDVD.getBoolean(),\n                 purgeDeletedRowsDVD.getBoolean(),\n-                minRetentionPeriodDVD.getLong()\n+                minRetentionPeriodDVD != null ? minRetentionPeriodDVD.getLong() : null\n         );\n         tabDesc.setUUID(tableUUID);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NTU5NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r477495594", "bodyText": "We may consider minRetentionPeriodDVD as NULL here for rows upgrade from lower versions.", "author": "yxia92", "createdAt": "2020-08-26T18:15:53Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -52,661 +52,664 @@\n /**\n  * Factory for creating a SYSTABLES row.\n  *\n- *\n  * @version 0.1\n  */\n-\n-public class SYSTABLESRowFactory extends CatalogRowFactory\n-{\n-\tpublic static final String\t\tTABLENAME_STRING = \"SYSTABLES\";\n-\n-\tpublic static final int\t\tSYSTABLES_COLUMN_COUNT = 15;\n-\t/* Column #s for systables (1 based) */\n-\tpublic static final int\t\tSYSTABLES_TABLEID = 1;\n-\tpublic static final int\t\tSYSTABLES_TABLENAME = 2;\n-\tprotected static final int\t\tSYSTABLES_TABLETYPE = 3;\n-\tpublic static final int\t\tSYSTABLES_SCHEMAID = 4;\n-\tprotected static final int\t\tSYSTABLES_LOCKGRANULARITY = 5;\n-\tprotected static final int\t\tSYSTABLES_VERSION = 6;\n+public class SYSTABLESRowFactory extends CatalogRowFactory {\n+    public static final String TABLENAME_STRING = \"SYSTABLES\";\n+\n+    public static final int SYSTABLES_COLUMN_COUNT = 16;\n+\n+    /* Column #s for systables (1 based) */\n+    public    static final int SYSTABLES_TABLEID                = 1;\n+    public    static final int SYSTABLES_TABLENAME              = 2;\n+    protected static final int SYSTABLES_TABLETYPE              = 3;\n+    public    static final int SYSTABLES_SCHEMAID               = 4;\n+    protected static final int SYSTABLES_LOCKGRANULARITY        = 5;\n+    protected static final int SYSTABLES_VERSION                = 6;\n     /* Sequence for understanding coding/decoding with altering tables*/\n-    protected static final int\t\tSYSTABLES_COLUMN_SEQUENCE = 7;\n-\t/* External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_DELIMITED_BY = 8;\n-\tprotected static final int\t\tSYSTABLES_ESCAPED_BY = 9;\n-\tprotected static final int\t\tSYSTABLES_LINES_BY = 10;\n-\tprotected static final int\t\tSYSTABLES_STORED_AS = 11;\n-\tprotected static final int\t\tSYSTABLES_LOCATION = 12;\n-\tprotected static final int\t\tSYSTABLES_COMPRESSION = 13;\n-\t// SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n-\t@Deprecated\n-\tprotected static final int \t\tSYSTABLES_IS_PINNED = 14;\n-\tprotected static final int      SYSTABLES_PURGE_DELETED_ROWS = 15;\n-\t/* End External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_INDEX1_ID = 0;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_TABLENAME = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_SCHEMAID = 2;\n-\n-\tprotected static final int\t\tSYSTABLES_INDEX2_ID = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX2_TABLEID = 1;\n-\n-\n-    public static final String      PURGE_DELETED_ROWS = \"PURGE_DELETED_ROWS\";\n-\t/*\n-\t * The first version of any tables. Use this for System tables and\n-\t * any time that you don't know what the version is.\n-\t */\n-\tpublic static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n-\t//the current version for creating new tables with\n-\tpublic static final String CURRENT_TABLE_VERSION = \"4.0\";\n-\t\n-\t// all indexes are unique.\n-\n-\tprivate\tstatic\tfinal\tString[]\tuuids =\n-\t{\n-\t\t \"80000018-00d0-fd77-3ed8-000a0a0b1900\"\t// catalog UUID\n-\t\t,\"80000028-00d0-fd77-3ed8-000a0a0b1900\"\t// heap UUID\n-\t\t,\"8000001a-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX1\n-\t\t,\"8000001c-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX2\n-\t};\n-\n-\tprivate static final int[][] indexColumnPositions = \n-\t{ \n-\t\t{ SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n-\t\t{ SYSTABLES_TABLEID }\n-\t};\n-\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tCONSTRUCTORS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)\n-\t{\n-\t\tsuper(uuidf,ef,dvf);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\n-\tSYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n-\t{\n-\t\tsuper(uuidf,ef,dvf, dd);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tMETHODS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a SYSTABLES row\n-\t *\n-\t * @return\tRow suitable for inserting into SYSTABLES.\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\t@SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n-\tpublic ExecRow makeRow(boolean latestVersion, TupleDescriptor td,\n-\t\t\t\t\t\t   TupleDescriptor\tparent)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tUUID\t\t\t\t\t\toid;\n-\t\tString\t   \t\t\t\ttabSType = null;\n-\t\tint\t   \t\t\t\t\ttabIType;\n-\t\tExecRow        \t\t\trow;\n-\t\tString\t\t\t\t\tlockGranularity = null;\n-\t\tString\t\t\t\t\ttableID = null;\n-\t\tString\t\t\t\t\tschemaID = null;\n-\t\tString\t\t\t\t\ttableName = null;\n-        int                     columnSequence = 0;\n-\t\tString \t\t\t\t\tdelimited = null;\n-\t\tString \t\t\t\t\tescaped = null;\n-\t\tString \t\t\t\t\tlines = null;\n-\t\tString \t\t\t\t\tstoredAs = null;\n-\t\tString \t\t\t\t\tlocation = null;\n-\t\tString \t\t\t\t\tcompression = null;\n-\t\tSQLVarchar              tableVersion = null;\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tboolean \t\t\t\tisPinned = false;\n-\t\tboolean                 purgeDeletedRows = false;\n-\n-\t\tif (td != null)\n-\t\t{\n-\t\t\t/*\n-\t\t\t** We only allocate a new UUID if the descriptor doesn't already have one.\n-\t\t\t** For descriptors replicated from a Source system, we already have an UUID.\n-\t\t\t*/\n-\t\t\tif (!(td instanceof TableDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n-\t\t\tif (!(parent instanceof SchemaDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n-\t\t\tTableDescriptor descriptor = (TableDescriptor)td;\n-\t\t\tSchemaDescriptor schema = (SchemaDescriptor)parent;\n+    protected static final int SYSTABLES_COLUMN_SEQUENCE        = 7;\n+    /* External Tables Columns */\n+    protected static final int SYSTABLES_DELIMITED_BY           = 8;\n+    protected static final int SYSTABLES_ESCAPED_BY             = 9;\n+    protected static final int SYSTABLES_LINES_BY               = 10;\n+    protected static final int SYSTABLES_STORED_AS              = 11;\n+    protected static final int SYSTABLES_LOCATION               = 12;\n+    protected static final int SYSTABLES_COMPRESSION            = 13;\n+    // SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n+    @Deprecated\n+    protected static final int SYSTABLES_IS_PINNED              = 14;\n+    protected static final int SYSTABLES_PURGE_DELETED_ROWS     = 15;\n+    protected static final int SYSTABLES_MIN_RETENTION_PERIOD   = 16;\n+    /* End External Tables Columns */\n+\n+    protected static final int SYSTABLES_INDEX1_ID        = 0;\n+    protected static final int SYSTABLES_INDEX1_TABLENAME = 1;\n+    protected static final int SYSTABLES_INDEX1_SCHEMAID  = 2;\n+\n+    protected static final int SYSTABLES_INDEX2_ID        = 1;\n+    protected static final int SYSTABLES_INDEX2_TABLEID   = 1;\n+\n+    /* Column names */\n+    public static final String IS_PINNED            = \"IS_PINNED\";\n+    public static final String COMPRESSION          = \"COMPRESSION\";\n+    public static final String LOCATION             = \"LOCATION\";\n+    public static final String STORED               = \"STORED\";\n+    public static final String LINES                = \"LINES\";\n+    public static final String ESCAPED              = \"ESCAPED\";\n+    public static final String DELIMITED            = \"DELIMITED\";\n+    public static final String COLSEQUENCE          = \"COLSEQUENCE\";\n+    public static final String VERSION              = \"VERSION\";\n+    public static final String LOCKGRANULARITY      = \"LOCKGRANULARITY\";\n+    public static final String SCHEMAID             = \"SCHEMAID\";\n+    public static final String TABLETYPE            = \"TABLETYPE\";\n+    public static final String TABLENAME            = \"TABLENAME\";\n+    public static final String TABLEID              = \"TABLEID\";\n+    public static final String PURGE_DELETED_ROWS   = \"PURGE_DELETED_ROWS\";\n+    public static final String MIN_RETENTION_PERIOD = \"MIN_RETENTION_PERIOD\";\n+    /*\n+     * The first version of any tables. Use this for System tables and\n+     * any time that you don't know what the version is.\n+     */\n+    public static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n+    //the current version for creating new tables with\n+    public static final String CURRENT_TABLE_VERSION = \"4.0\";\n+\n+    // all indexes are unique.\n+\n+    private static final String[] uuids =\n+        {\n+            \"80000018-00d0-fd77-3ed8-000a0a0b1900\", // catalog UUID\n+            \"80000028-00d0-fd77-3ed8-000a0a0b1900\", // heap UUID\n+            \"8000001a-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX1\n+            \"8000001c-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX2\n+        };\n+\n+    private static final int[][] indexColumnPositions =\n+        {\n+            {SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n+            {SYSTABLES_TABLEID}\n+        };\n+\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tCONSTRUCTORS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf) {\n+        super(uuidf, ef, dvf);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n+    {\n+        super(uuidf,ef,dvf, dd);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tMETHODS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a SYSTABLES row\n+     *\n+     * @throws StandardException thrown on failure\n+     * @return Row suitable for inserting into SYSTABLES.\n+     */\n+    @SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n+    public ExecRow makeRow(boolean latestVersion,\n+                           TupleDescriptor td,\n+                           TupleDescriptor parent)\n+            throws StandardException {\n+        UUID oid;\n+        String tabSType = null;\n+        int tabIType;\n+        ExecRow row;\n+        String lockGranularity = null;\n+        String tableID = null;\n+        String schemaID = null;\n+        String tableName = null;\n+        int columnSequence = 0;\n+        String delimited = null;\n+        String escaped = null;\n+        String lines = null;\n+        String storedAs = null;\n+        String location = null;\n+        String compression = null;\n+        SQLVarchar tableVersion = null;\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        boolean isPinned = false;\n+        boolean purgeDeletedRows = false;\n+        long minRetentionPeriod = 0;\n+\n+        if (td != null) {\n+            /*\n+             ** We only allocate a new UUID if the descriptor doesn't already have one.\n+             ** For descriptors replicated from a Source system, we already have an UUID.\n+             */\n+            if (!(td instanceof TableDescriptor))\n+                throw new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n+            if (!(parent instanceof SchemaDescriptor))\n+                throw new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n+            TableDescriptor descriptor = (TableDescriptor) td;\n+            SchemaDescriptor schema = (SchemaDescriptor) parent;\n \n             columnSequence = descriptor.getColumnSequence();\n-\t\t\toid = descriptor.getUUID();\n-\t\t\tif ( oid == null )\n-\t\t    {\n-\t\t\t\toid = getUUIDFactory().createUUID();\n-\t\t\t\tdescriptor.setUUID(oid);\n-\t\t\t}\n-\t\t\ttableID = oid.toString();\n-\t\t\t\n-\t\t\tif (SanityManager.DEBUG)\n-\t\t\t{\n-\t\t\t\tSanityManager.ASSERT(schema != null, \n-\t\t\t\t\t\t\t\"Schema should not be null unless empty row is true\");\n-\t\t\t\tif (schema.getUUID() == null)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\n-\t\t\tschemaID = schema.getUUID().toString();\n-\n-\t\t\ttableName = descriptor.getName();\n-\n-\t\t\t/* RESOLVE - Table Type should really be a char in the descriptor\n-\t\t\t * T, S, V, S instead of 0, 1, 2, 3\n-\t\t\t */\n-\t\t\ttabIType = descriptor.getTableType();\n-\t\t\tswitch (tabIType)\n-\t\t\t{\n-\t\t\t    case TableDescriptor.BASE_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"T\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.SYSTEM_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"S\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.VIEW_TYPE:\n-\t\t\t\t\ttabSType = \"V\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"X\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.SYNONYM_TYPE:\n-\t\t\t\t\ttabSType = \"A\";\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase TableDescriptor.EXTERNAL_TYPE:\n-\t\t\t\t\ttabSType = \"E\";\n-\t\t\t\t\tbreak;\n-\n-\n-\t\t\t    default:\n-\t\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t\t\tSanityManager.THROWASSERT(\"invalid table type\");\n-\t\t\t}\n-\t\t\tchar[] lockGChar = new char[1];\n-\t\t\tlockGChar[0] = descriptor.getLockGranularity();\n-\t\t\tlockGranularity = new String(lockGChar);\n-\t\t\tdelimited = descriptor.getDelimited();\n-\t\t\tescaped = descriptor.getEscaped();\n-\t\t\tlines = descriptor.getLines();\n-\t\t\tstoredAs = descriptor.getStoredAs();\n-\t\t\tlocation = descriptor.getLocation();\n-\t\t\tcompression = descriptor.getCompression();\n-\t\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\t\tisPinned = descriptor.isPinned();\n+            oid = descriptor.getUUID();\n+            if (oid == null) {\n+                oid = getUUIDFactory().createUUID();\n+                descriptor.setUUID(oid);\n+            }\n+            tableID = oid.toString();\n+\n+            if (SanityManager.DEBUG) {\n+                SanityManager.ASSERT(schema != null,\n+                        \"Schema should not be null unless empty row is true\");\n+                if (schema.getUUID() == null) {\n+                    SanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n+                }\n+            }\n+\n+            schemaID = schema.getUUID().toString();\n+\n+            tableName = descriptor.getName();\n+\n+            /* RESOLVE - Table Type should really be a char in the descriptor\n+             * T, S, V, S instead of 0, 1, 2, 3\n+             */\n+            tabIType = descriptor.getTableType();\n+            switch (tabIType) {\n+                case TableDescriptor.BASE_TABLE_TYPE:\n+                    tabSType = \"T\";\n+                    break;\n+                case TableDescriptor.SYSTEM_TABLE_TYPE:\n+                    tabSType = \"S\";\n+                    break;\n+                case TableDescriptor.VIEW_TYPE:\n+                    tabSType = \"V\";\n+                    break;\n+\n+                case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n+                    tabSType = \"X\";\n+                    break;\n+\n+                case TableDescriptor.SYNONYM_TYPE:\n+                    tabSType = \"A\";\n+                    break;\n+                case TableDescriptor.EXTERNAL_TYPE:\n+                    tabSType = \"E\";\n+                    break;\n+\n+\n+                default:\n+                    if (SanityManager.DEBUG)\n+                        SanityManager.THROWASSERT(\"invalid table type\");\n+            }\n+            char[] lockGChar = new char[1];\n+            lockGChar[0] = descriptor.getLockGranularity();\n+            lockGranularity = new String(lockGChar);\n+            delimited = descriptor.getDelimited();\n+            escaped = descriptor.getEscaped();\n+            lines = descriptor.getLines();\n+            storedAs = descriptor.getStoredAs();\n+            location = descriptor.getLocation();\n+            compression = descriptor.getCompression();\n+            //NOT USED ANYMORE, for backward compatibility only\n+            isPinned = descriptor.isPinned();\n             purgeDeletedRows = descriptor.purgeDeletedRows();\n-\t\t\ttableVersion = descriptor.getVersion() == null ?\n-\t\t                 \tnew SQLVarchar(CURRENT_TABLE_VERSION) :\n-\t\t\t                new SQLVarchar(descriptor.getVersion());\n-\t\t}\n-\t\telse\n-\t\t\ttableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n-\n-\t\t/* Insert info into systables */\n-\n-\t\t/* RESOLVE - It would be nice to require less knowledge about systables\n-\t\t * and have this be more table driven.\n-\t\t */\n-\n-\t\t/* Build the row to insert  */\n-\t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n-\n-\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n-\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n-\t\treturn row;\n-\t}\n-\n-\tpublic static void setRowColumns(ExecRow row,\n-\t\t\t\t\t\t\t\t\t String tableID,\n-\t\t\t\t\t\t\t\t\t String tableName,\n-\t\t\t\t\t\t\t\t\t String tabSType,\n-\t\t\t\t\t\t\t\t\t String schemaID,\n-\t\t\t\t\t\t\t\t\t String lockGranularity,\n-\t\t\t\t\t\t\t\t\t SQLVarchar tableVersion,\n-\t\t\t\t\t\t\t\t\t int columnSequence,\n-\t\t\t\t\t\t\t\t\t String delimited,\n-\t\t\t\t\t\t\t\t\t String escaped,\n-\t\t\t\t\t\t\t\t\t String lines,\n-\t\t\t\t\t\t\t\t\t String storedAs,\n-\t\t\t\t\t\t\t\t\t String location,\n-\t\t\t\t\t\t\t\t\t String compression,\n-\t\t\t\t\t\t\t\t\t boolean isPinned,\n-\t\t\t\t\t\t\t\t\t boolean purgeDeletedRows) {\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n-\n-\t\t/* 2nd column is NAME (varchar(30)) */\n-\t\trow.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\trow.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n-\n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\trow.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n-\n-\t\t/* 6th column is VERSION (varchar(128)) */\n-\t\trow.setColumn(SYSTABLES_VERSION, tableVersion);\n-\n-\t\trow.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n-\n-\t\trow.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n-\t\trow.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n-\t\trow.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n-\t\trow.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n-\t\trow.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n-\t\trow.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n-\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\trow.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n-\t\trow.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n-\t}\n-\n-\t/**\n-\t * Builds an empty index row.\n-\t *\n-\t *\t@param\tindexNumber\tIndex to build empty row for.\n-\t *  @param  rowLocation\tRow location for last column of index row\n-\t *\n-\t * @return corresponding empty index row\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\t@SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n-\tExecIndexRow\tbuildEmptyIndexRow( int indexNumber,\n-\t\t\t\t\t\t\t\t\t\t\tRowLocation rowLocation)\n-\t\t\tthrows StandardException\n-\t{\n-\t\tint ncols = getIndexColumnCount(indexNumber);\n-\t\tExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n-\n-\t\trow.setColumn(ncols + 1, rowLocation);\n-\n-\t\tswitch( indexNumber )\n-\t\t{\n-\t\t    case SYSTABLES_INDEX1_ID:\n-\t\t\t\t/* 1st column is TABLENAME (varchar(128)) */\n-\t\t\t\trow.setColumn(1, new SQLVarchar());\n-\n-\t\t\t\t/* 2nd column is SCHEMAID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(2, new SQLChar());\n-\n-\t\t\t\tbreak;\n-\n-\t\t    case SYSTABLES_INDEX2_ID:\n-\t\t\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(1,new SQLChar());\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tthrow new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n-\t\t}\t// end switch\n-\n-\t\treturn\trow;\n-\t}\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t * @param isolationLevel use this explicit isolation level. Only\n-\t *                       ISOLATION_REPEATABLE_READ (normal usage)\n-\t *                       or ISOLATION_READ_UNCOMMITTED (corner\n-\t *                       cases) supported for now.\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tTupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(row,\n-\t\t\t\t\t\t\t\t   parentTupleDescriptor,\n-\t\t\t\t\t\t\t\t   dd,\n-\t\t\t\t\t\t\t\t   isolationLevel);\n-\t}\n-\n-\n-\t///////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n-\t//\n-\t///////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t *\n-\t * @return\ta table descriptor equivalent to a SYSTABLES row\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\tpublic TupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd )\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(\n-\t\t\trow,\n-\t\t\tparentTupleDescriptor,\n-\t\t\tdd,\n-\t\t\tTransactionController.ISOLATION_REPEATABLE_READ);\n-\t}\n-\n-\n-\tpublic TupleDescriptor buildDescriptorBody(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\tSanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n-\n-\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n-\n-\t\tString\ttableUUIDString; \n-\t\tString\tschemaUUIDString; \n-\t\tint\t\ttableTypeEnum;\n-\t\tString\tlockGranularity;\n-\t\tString\ttableName, tableType;\n-\t\tDataValueDescriptor\tcol;\n-\t\tUUID\t\ttableUUID;\n-\t\tUUID\t\tschemaUUID;\n-\t\tSchemaDescriptor\tschema;\n-\t\tTableDescriptor\t\ttabDesc;\n-\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLEID);\n-\t\ttableUUIDString = col.getString();\n-\t\ttableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n-\n-\n-\t\t/* 2nd column is TABLENAME (varchar(128)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\ttableName = col.getString();\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLETYPE);\n-\t\ttableType = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n-\t\t}\n-\t\tswitch (tableType.charAt(0))\n-\t\t{\n-\t\t\tcase 'T' : \n-\t\t\t\ttableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'S' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'V' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.VIEW_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'A' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'X' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'E' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\tSanityManager.THROWASSERT(\"Fourth column value invalid\");\n-\t\t\t\ttableTypeEnum = -1;\n-\t\t}\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_SCHEMAID);\n-\t\tschemaUUIDString = col.getString();\n-\t\tschemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n-\t\t\n-\t\tschema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n+            minRetentionPeriod = descriptor.getMinRetainedVersions();\n+            tableVersion = descriptor.getVersion() == null ?\n+                    new SQLVarchar(CURRENT_TABLE_VERSION) :\n+                    new SQLVarchar(descriptor.getVersion());\n+        } else\n+            tableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n+\n+        /* Insert info into systables */\n+\n+        /* RESOLVE - It would be nice to require less knowledge about systables\n+         * and have this be more table driven.\n+         */\n+\n+        /* Build the row to insert  */\n+        row = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n+\n+        setRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+                delimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows, minRetentionPeriod);\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row,\n+                                     String tableID,\n+                                     String tableName,\n+                                     String tabSType,\n+                                     String schemaID,\n+                                     String lockGranularity,\n+                                     SQLVarchar tableVersion,\n+                                     int columnSequence,\n+                                     String delimited,\n+                                     String escaped,\n+                                     String lines,\n+                                     String storedAs,\n+                                     String location,\n+                                     String compression,\n+                                     boolean isPinned,\n+                                     boolean purgeDeletedRows,\n+                                     long minRetentionPeriod) {\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n+\n+        /* 2nd column is NAME (varchar(30)) */\n+        row.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        row.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n+\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        row.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n+\n+        /* 6th column is VERSION (varchar(128)) */\n+        row.setColumn(SYSTABLES_VERSION, tableVersion);\n+\n+        row.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n+\n+        row.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n+        row.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n+        row.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n+        row.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n+        row.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n+        row.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n+        //NOT USED ANYMORE, for backward compatibility only\n+        row.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n+        row.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n+        row.setColumn(SYSTABLES_MIN_RETENTION_PERIOD, new SQLLongint(minRetentionPeriod));\n+    }\n+\n+    /**\n+     * Builds an empty index row.\n+     *\n+     * @param rowLocation Row location for last column of index row\n+     * @return corresponding empty index row\n+     * @throws StandardException thrown on failure\n+     * @param    indexNumber    Index to build empty row for.\n+     */\n+    @SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n+    ExecIndexRow buildEmptyIndexRow(int indexNumber,\n+                                    RowLocation rowLocation)\n+            throws StandardException {\n+        int ncols = getIndexColumnCount(indexNumber);\n+        ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n+\n+        row.setColumn(ncols + 1, rowLocation);\n+\n+        switch (indexNumber) {\n+            case SYSTABLES_INDEX1_ID:\n+                /* 1st column is TABLENAME (varchar(128)) */\n+                row.setColumn(1, new SQLVarchar());\n+\n+                /* 2nd column is SCHEMAID (UUID - char(36)) */\n+                row.setColumn(2, new SQLChar());\n+\n+                break;\n+\n+            case SYSTABLES_INDEX2_ID:\n+                /* 1st column is TABLEID (UUID - char(36)) */\n+                row.setColumn(1, new SQLChar());\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n+        }    // end switch\n+\n+        return row;\n+    }\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @param isolationLevel        use this explicit isolation level. Only\n+     *                              ISOLATION_REPEATABLE_READ (normal usage)\n+     *                              or ISOLATION_READ_UNCOMMITTED (corner\n+     *                              cases) supported for now.\n+     * @throws StandardException thrown on failure\n+     */\n+    TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        return buildDescriptorBody(row,\n+                parentTupleDescriptor,\n+                dd,\n+                isolationLevel);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n+    //\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @throws StandardException thrown on failure\n+     * @return a table descriptor equivalent to a SYSTABLES row\n+     */\n+\n+    public TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd)\n+            throws StandardException {\n+        return buildDescriptorBody(\n+                row,\n+                parentTupleDescriptor,\n+                dd,\n+                TransactionController.ISOLATION_REPEATABLE_READ);\n+    }\n+\n+\n+    public TupleDescriptor buildDescriptorBody(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        if (SanityManager.DEBUG)\n+            SanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n+\n+        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n+\n+        String tableUUIDString;\n+        String schemaUUIDString;\n+        int tableTypeEnum;\n+        String lockGranularity;\n+        String tableName, tableType;\n+        DataValueDescriptor col;\n+        UUID tableUUID;\n+        UUID schemaUUID;\n+        SchemaDescriptor schema;\n+        TableDescriptor tabDesc;\n+\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_TABLEID);\n+        tableUUIDString = col.getString();\n+        tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n+\n+\n+        /* 2nd column is TABLENAME (varchar(128)) */\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        tableName = col.getString();\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        col = row.getColumn(SYSTABLES_TABLETYPE);\n+        tableType = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n+        }\n+        switch (tableType.charAt(0)) {\n+            case 'T':\n+                tableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n+                break;\n+            case 'S':\n+                tableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n+                break;\n+            case 'V':\n+                tableTypeEnum = TableDescriptor.VIEW_TYPE;\n+                break;\n+            case 'A':\n+                tableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n+                break;\n+            case 'X':\n+                tableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n+                break;\n+            case 'E':\n+                tableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n+                break;\n+            default:\n+                if (SanityManager.DEBUG)\n+                    SanityManager.THROWASSERT(\"Fourth column value invalid\");\n+                tableTypeEnum = -1;\n+        }\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_SCHEMAID);\n+        schemaUUIDString = col.getString();\n+        schemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n+\n+        schema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n \n         // If table is temp table, (SESSION) schema will be null\n         if (schema == null && (tableTypeEnum == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)) {\n             schema = dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();\n         }\n \n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n-\t\tlockGranularity = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n-\t\t}\n-\n-\t\t//TODO -sf- place version into tuple descriptor\n-\t\tDataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n-\n-\t\tDataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n-\t\tDataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n-\t\tDataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n-\t\tDataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n-\t\tDataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n-\t\tDataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tDataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n-        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        col = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n+        lockGranularity = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n+        }\n \n-\t\t// RESOLVE - Deal with lock granularity\n-\t\ttabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n-\t\t\t\trow.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n-\t\t\t\tdelimitedDVD!=null?delimitedDVD.getString():null,\n-\t\t\t\tescapedDVD!=null?escapedDVD.getString():null,\n-\t\t\t\tlinesDVD!=null?linesDVD.getString():null,\n-\t\t\t\tstoredDVD!=null?storedDVD.getString():null,\n-\t\t\t\tlocationDVD!=null?locationDVD.getString():null,\n-\t\t\t\tcompressionDVD!=null?compressionDVD.getString():null,\n-\t\t\t\tisPinnedDVD.getBoolean(),\n-                purgeDeletedRowsDVD.getBoolean()\n-\t\t\t\t);\n-\t\ttabDesc.setUUID(tableUUID);\n-\n-\t\tif(versionDescriptor!=null){\n-\t\t\ttabDesc.setVersion(versionDescriptor.getString());\n-\t\t}else\n-\t\t\t\t\t\ttabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n-\t\treturn tabDesc;\n-\t}\n-\n-\t/**\n-\t *\tGet the table name out of this SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t *\n-\t * @return\tstring, the table name\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tprotected String getTableName(ExecRow\trow)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tDataValueDescriptor\tcol;\n-\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\treturn col.getString();\n-\t}\n-\n-\n-\t/**\n-\t * builds a list of columns suitable for creating this catalog.\n-\t *\n-\t *\n-\t * @return array of systemcolumn suitable for making this catalog.\n-\t */\n-\tpublic SystemColumn[]\tbuildColumnList()\n-        throws StandardException\n-\t{\n-        return new SystemColumn[] {\n-                SystemColumnImpl.getUUIDColumn(\"TABLEID\", false),\n-                SystemColumnImpl.getIdentifierColumn(\"TABLENAME\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"TABLETYPE\"),\n-                SystemColumnImpl.getUUIDColumn(\"SCHEMAID\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"LOCKGRANULARITY\"),\n-                SystemColumnImpl.getIdentifierColumn(\"VERSION\",true),\n-                SystemColumnImpl.getColumn(\"COLSEQUENCE\", Types.INTEGER, false),\n-                SystemColumnImpl.getColumn(\"DELIMITED\", Types.VARCHAR,  true),\n-                SystemColumnImpl.getColumn(\"ESCAPED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LINES\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"STORED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LOCATION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"COMPRESSION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"IS_PINNED\", Types.BOOLEAN, false),\n+        //TODO -sf- place version into tuple descriptor\n+        DataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n+\n+        DataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n+        DataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n+        DataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n+        DataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n+        DataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n+        DataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        DataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n+        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        DataValueDescriptor minRetentionPeriodDVD = row.getColumn(SYSTABLES_MIN_RETENTION_PERIOD);\n+\n+        // RESOLVE - Deal with lock granularity\n+        tabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n+                row.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n+                delimitedDVD != null ? delimitedDVD.getString() : null,\n+                escapedDVD != null ? escapedDVD.getString() : null,\n+                linesDVD != null ? linesDVD.getString() : null,\n+                storedDVD != null ? storedDVD.getString() : null,\n+                locationDVD != null ? locationDVD.getString() : null,\n+                compressionDVD != null ? compressionDVD.getString() : null,\n+                isPinnedDVD.getBoolean(),\n+                purgeDeletedRowsDVD.getBoolean(),\n+                minRetentionPeriodDVD.getLong()", "originalCommit": "31f0415c89417a3fb8d1aebc534afcd4a2c7dfe0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MTg1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r478261854", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-27T08:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5NTU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\nindex 8e38de6e33..9402577507 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java\n\n@@ -533,7 +533,7 @@ public class SYSTABLESRowFactory extends CatalogRowFactory {\n                 compressionDVD != null ? compressionDVD.getString() : null,\n                 isPinnedDVD.getBoolean(),\n                 purgeDeletedRowsDVD.getBoolean(),\n-                minRetentionPeriodDVD.getLong()\n+                minRetentionPeriodDVD != null ? minRetentionPeriodDVD.getLong() : null\n         );\n         tabDesc.setUUID(tableUUID);\n \n"}}, {"oid": "90d68339c7383fb3bf57cbcf3857043bc8e0e28d", "url": "https://github.com/splicemachine/spliceengine/commit/90d68339c7383fb3bf57cbcf3857043bc8e0e28d", "message": "Merge remote-tracking branch 'origin/master' into DB-10045", "committedDate": "2020-08-27T08:30:20Z", "type": "commit"}, {"oid": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "url": "https://github.com/splicemachine/spliceengine/commit/a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "message": "DB-10045 Add upgrade script for minRetentionPeriod column.", "committedDate": "2020-08-27T14:12:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MDEyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r478640123", "bodyText": "We should not use the table's table descriptor td to get the view descriptor. The SYSTABLESVIEW is inside the schema sysvw. So we should use\n        SchemaDescriptor sysVWSchema=sysViewSchemaDesc;\n        TableDescriptor td1 = getTableDescriptor(\"SYSTABLESVIEW\", sysVWSchema, tc);\n        ViewDescriptor vd=getViewDescriptor(td1);", "author": "yxia92", "createdAt": "2020-08-27T19:16:44Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java", "diffHunk": "@@ -1645,4 +1645,47 @@ public void addCatalogVersion(TransactionController tc) throws StandardException\n \n         }\n     }\n+\n+    public void addMinRetentionPeriodColumn(TransactionController tc) throws StandardException {\n+        SchemaDescriptor sd = getSystemSchemaDescriptor();\n+        TableDescriptor td = getTableDescriptor(SYSTABLESRowFactory.TABLENAME_STRING, sd, tc);\n+        ColumnDescriptor cd = td.getColumnDescriptor(SYSTABLESRowFactory.MIN_RETENTION_PERIOD);\n+        if (cd == null) { // needs updating\n+            tc.elevate(\"dictionary\");\n+            dropTableDescriptor(td, sd, tc);\n+            td.setColumnSequence(td.getColumnSequence() + 1);\n+            // add the table descriptor with new name\n+            addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc, false);\n+\n+            ColumnDescriptor columnDescriptor;\n+            UUID uuid = getUUIDFactory().createUUID();\n+\n+            // Add the column MIN_RETENTION_PERIOD\n+            DataValueDescriptor storableDV = getDataValueFactory().getNullLong(null);\n+            int colNumber = td.getNumberOfColumns() + 1;\n+            DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT, 1);\n+            tc.addColumnToConglomerate(td.getHeapConglomerateId(), colNumber, storableDV, dtd.getCollationType());\n+\n+            columnDescriptor = new ColumnDescriptor(SYSTABLESRowFactory.MIN_RETENTION_PERIOD, colNumber,\n+                    colNumber, dtd, null, null, td, uuid, 0, 0, td.getColumnSequence());\n+\n+            addDescriptor(columnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc, false);\n+\n+            // now add the column to the table's column descriptor list.\n+            td.getColumnDescriptorList().add(columnDescriptor);\n+            updateSYSCOLPERMSforAddColumnToUserTable(td.getUUID(), tc);\n+\n+            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.TABLENAME_STRING,\n+                    SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n+\n+            // finally, update the SYSTABLESVIEW\n+            ViewDescriptor vd=getViewDescriptor(td);", "originalCommit": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwOTc2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r479209769", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-28T12:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MDEyMw=="}], "type": "inlineReview", "revised_code": {"commit": "3eed0230ad08bd8bebbb66ca900e95d97466a69e", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\nindex 2aad3adbb8..29253cfbaa 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\n\n@@ -1678,14 +1678,18 @@ public class SpliceDataDictionary extends DataDictionaryImpl{\n             SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.TABLENAME_STRING,\n                     SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n \n-            // finally, update the SYSTABLESVIEW\n-            ViewDescriptor vd=getViewDescriptor(td);\n-            dropViewDescriptor(vd, tc);\n-            DataDescriptorGenerator ddg=getDataDescriptorGenerator();\n-            vd=ddg.newViewDescriptor(td.getUUID(),SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, SYSTABLESRowFactory.SYSTABLE_VIEW_SQL,0,sd.getUUID());\n-            addDescriptor(vd,sd,DataDictionary.SYSVIEWS_CATALOG_NUM,true, tc,false);\n-            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: updated view %s with one more column: %s.\",\n-                    SYSTABLESRowFactory.TABLENAME_STRING, SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n+            // now upgrade the views if necessary\n+            TableDescriptor td1 = getTableDescriptor(SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, sysViewSchemaDesc, tc);\n+            if(td1 != null) {\n+                ViewDescriptor vd1 = getViewDescriptor(td1);\n+                dropAllColumnDescriptors(td1.getUUID(), tc);\n+                dropViewDescriptor(vd1, tc);\n+                dropTableDescriptor(td1, sysViewSchemaDesc, tc);\n+            }\n+            createOneSystemView(tc, SYSTABLES_CATALOG_NUM, SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, 0,\n+                    sysViewSchemaDesc, SYSTABLESRowFactory.SYSTABLE_VIEW_SQL);\n+            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.SYSTABLE_VIEW_NAME,\n+                    SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MzE4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r478643182", "bodyText": "Also since the new column you add to the view is not the last column in the view, it is better to drop all the columns in the view together with the view and re-create the view, similar to what we do in SpliceDataDictionary.updateColumnViewInSys().", "author": "yxia92", "createdAt": "2020-08-27T19:22:32Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java", "diffHunk": "@@ -1645,4 +1645,47 @@ public void addCatalogVersion(TransactionController tc) throws StandardException\n \n         }\n     }\n+\n+    public void addMinRetentionPeriodColumn(TransactionController tc) throws StandardException {\n+        SchemaDescriptor sd = getSystemSchemaDescriptor();\n+        TableDescriptor td = getTableDescriptor(SYSTABLESRowFactory.TABLENAME_STRING, sd, tc);\n+        ColumnDescriptor cd = td.getColumnDescriptor(SYSTABLESRowFactory.MIN_RETENTION_PERIOD);\n+        if (cd == null) { // needs updating\n+            tc.elevate(\"dictionary\");\n+            dropTableDescriptor(td, sd, tc);\n+            td.setColumnSequence(td.getColumnSequence() + 1);\n+            // add the table descriptor with new name\n+            addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc, false);\n+\n+            ColumnDescriptor columnDescriptor;\n+            UUID uuid = getUUIDFactory().createUUID();\n+\n+            // Add the column MIN_RETENTION_PERIOD\n+            DataValueDescriptor storableDV = getDataValueFactory().getNullLong(null);\n+            int colNumber = td.getNumberOfColumns() + 1;\n+            DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT, 1);\n+            tc.addColumnToConglomerate(td.getHeapConglomerateId(), colNumber, storableDV, dtd.getCollationType());\n+\n+            columnDescriptor = new ColumnDescriptor(SYSTABLESRowFactory.MIN_RETENTION_PERIOD, colNumber,\n+                    colNumber, dtd, null, null, td, uuid, 0, 0, td.getColumnSequence());\n+\n+            addDescriptor(columnDescriptor, td, DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc, false);\n+\n+            // now add the column to the table's column descriptor list.\n+            td.getColumnDescriptorList().add(columnDescriptor);\n+            updateSYSCOLPERMSforAddColumnToUserTable(td.getUUID(), tc);\n+\n+            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.TABLENAME_STRING,\n+                    SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n+\n+            // finally, update the SYSTABLESVIEW\n+            ViewDescriptor vd=getViewDescriptor(td);\n+            dropViewDescriptor(vd, tc);\n+            DataDescriptorGenerator ddg=getDataDescriptorGenerator();\n+            vd=ddg.newViewDescriptor(td.getUUID(),SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, SYSTABLESRowFactory.SYSTABLE_VIEW_SQL,0,sd.getUUID());\n+            addDescriptor(vd,sd,DataDictionary.SYSVIEWS_CATALOG_NUM,true, tc,false);", "originalCommit": "a20c124c194b24035c61fdc6b3a6a06f5c6ea830", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ0MTUwMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4007#discussion_r479441500", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-08-28T17:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MzE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3eed0230ad08bd8bebbb66ca900e95d97466a69e", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\nindex 2aad3adbb8..29253cfbaa 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java\n\n@@ -1678,14 +1678,18 @@ public class SpliceDataDictionary extends DataDictionaryImpl{\n             SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.TABLENAME_STRING,\n                     SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n \n-            // finally, update the SYSTABLESVIEW\n-            ViewDescriptor vd=getViewDescriptor(td);\n-            dropViewDescriptor(vd, tc);\n-            DataDescriptorGenerator ddg=getDataDescriptorGenerator();\n-            vd=ddg.newViewDescriptor(td.getUUID(),SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, SYSTABLESRowFactory.SYSTABLE_VIEW_SQL,0,sd.getUUID());\n-            addDescriptor(vd,sd,DataDictionary.SYSVIEWS_CATALOG_NUM,true, tc,false);\n-            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: updated view %s with one more column: %s.\",\n-                    SYSTABLESRowFactory.TABLENAME_STRING, SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n+            // now upgrade the views if necessary\n+            TableDescriptor td1 = getTableDescriptor(SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, sysViewSchemaDesc, tc);\n+            if(td1 != null) {\n+                ViewDescriptor vd1 = getViewDescriptor(td1);\n+                dropAllColumnDescriptors(td1.getUUID(), tc);\n+                dropViewDescriptor(vd1, tc);\n+                dropTableDescriptor(td1, sysViewSchemaDesc, tc);\n+            }\n+            createOneSystemView(tc, SYSTABLES_CATALOG_NUM, SYSTABLESRowFactory.SYSTABLE_VIEW_NAME, 0,\n+                    sysViewSchemaDesc, SYSTABLESRowFactory.SYSTABLE_VIEW_SQL);\n+            SpliceLogUtils.info(LOG, String.format(\"%s upgraded: added a column: %s.\", SYSTABLESRowFactory.SYSTABLE_VIEW_NAME,\n+                    SYSTABLESRowFactory.MIN_RETENTION_PERIOD));\n         }\n     }\n }\n"}}, {"oid": "3eed0230ad08bd8bebbb66ca900e95d97466a69e", "url": "https://github.com/splicemachine/spliceengine/commit/3eed0230ad08bd8bebbb66ca900e95d97466a69e", "message": "DB-10045 address comments.", "committedDate": "2020-08-28T17:17:08Z", "type": "commit"}, {"oid": "f42033bc14ffcec5900110b4eb293302435cab37", "url": "https://github.com/splicemachine/spliceengine/commit/f42033bc14ffcec5900110b4eb293302435cab37", "message": "DB-10045 Set upgrade version to 1974.", "committedDate": "2020-08-31T07:50:18Z", "type": "commit"}, {"oid": "15d8765e24bb16b43afb270d35c35108fc5bb9b0", "url": "https://github.com/splicemachine/spliceengine/commit/15d8765e24bb16b43afb270d35c35108fc5bb9b0", "message": "Merge remote-tracking branch 'origin/master' into DB-10045", "committedDate": "2020-08-31T08:37:41Z", "type": "commit"}, {"oid": "c2d34652296eff2a5fb37e2f24800bc2d308ca9f", "url": "https://github.com/splicemachine/spliceengine/commit/c2d34652296eff2a5fb37e2f24800bc2d308ca9f", "message": "DB-10045 fix test.", "committedDate": "2020-09-01T14:57:23Z", "type": "commit"}, {"oid": "a8e5e980b27fb03dfcec599c9a736f8c45a96a09", "url": "https://github.com/splicemachine/spliceengine/commit/a8e5e980b27fb03dfcec599c9a736f8c45a96a09", "message": "Merge remote-tracking branch 'origin/master' into DB-10045", "committedDate": "2020-09-09T08:57:40Z", "type": "commit"}]}