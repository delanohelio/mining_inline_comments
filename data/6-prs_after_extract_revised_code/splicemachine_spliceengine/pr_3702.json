{"pr_number": 3702, "pr_title": "DB-8781 Purge old updates", "pr_createdAt": "2020-06-19T12:28:53Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3702", "timeline": [{"oid": "4a5b3ad16b6b6522d4873ade28e6bc3d8651875e", "url": "https://github.com/splicemachine/spliceengine/commit/4a5b3ad16b6b6522d4873ade28e6bc3d8651875e", "message": "DB-8781 Purge old updates", "committedDate": "2020-06-19T12:33:50Z", "type": "commit"}, {"oid": "4a5b3ad16b6b6522d4873ade28e6bc3d8651875e", "url": "https://github.com/splicemachine/spliceengine/commit/4a5b3ad16b6b6522d4873ade28e6bc3d8651875e", "message": "DB-8781 Purge old updates", "committedDate": "2020-06-19T12:33:50Z", "type": "forcePushed"}, {"oid": "a0fa6eeb1448b78247ccd82cfebf18ddae1e2cf2", "url": "https://github.com/splicemachine/spliceengine/commit/a0fa6eeb1448b78247ccd82cfebf18ddae1e2cf2", "message": "Merge remote-tracking branch 'origin/master' into DB-8781", "committedDate": "2020-06-21T21:06:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU5NzM1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r443597354", "bodyText": "Here we are considering the begin timestamp of the transaction that wrote the data, but we need to consider the commit timestamp instead (there's the same problem with deletes too, https://splicemachine.atlassian.net/browse/DB-9640 )\nConsider the lowWaterMark is 1000 (and there is a transaction with timestamp 1000)\nIf we are processing an update with timestamp = 900 and commit timestamp 1200, we are adding it to the map. Then we remove the baseline insert @ ts 100.\nWhen the lowWatermark transaction @ 1000 goes to read, there's no baseline anymore and the row is gone.\nI think the race condition is pretty hard to hit but better to get it fixed.", "author": "dgomezferro", "createdAt": "2020-06-22T14:25:32Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -116,6 +120,27 @@ private void mutate(Cell element, TxnView txn) throws IOException {\n                     assert deleteRightAfterFirstWriteTimestamp == 0;\n                     deleteRightAfterFirstWriteTimestamp = element.getTimestamp();\n                     break;\n+                case USER_DATA: {\n+                    long t = element.getTimestamp();", "originalCommit": "a0fa6eeb1448b78247ccd82cfebf18ddae1e2cf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5MDg0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r444190842", "bodyText": "Very good point.\nI created separate PRs for DB-9640 against 2.8/3.0/master that address the deleted rows issue.\nI also updated this (DB-8781) to include the fix and extend it to updates.", "author": "arnaud-splice", "createdAt": "2020-06-23T12:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU5NzM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "2b341e2f19b78919324f0bbfb0ebef13df9b79a6", "chunk": "diff --git a/hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java b/hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java\nindex 3580041ad8..b32afb47be 100644\n--- a/hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java\n+++ b/hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java\n\n@@ -84,67 +109,70 @@ class SICompactionStateMutate {\n         final CellType cellType= CellUtils.getKeyValueType(element);\n         if (cellType == CellType.COMMIT_TIMESTAMP) {\n             assert txn == null;\n-            dataToReturn.add(element);\n+            long commitTimestamp = Bytes.toLong(element.getValueArray(), element.getValueOffset(), element.getValueLength());\n+            dataToReturn.add(new CellAndCommit(element, commitTimestamp));\n             return;\n         }\n         if (txn == null) {\n             // we don't have transactional information, just return the data as is\n-            dataToReturn.add(element);\n+            dataToReturn.add(new CellAndCommit(element, null));\n             return;\n         }\n         if (txn.getState() == Txn.State.ROLLEDBACK) {\n             // rolled back data, remove it from the compacted data\n             return;\n         }\n-        if (isCommitted(txn)) {\n-            /*\n-             * This element has been committed all the way to the user level, so a\n-             * commit timestamp can be placed on it.\n-             */\n-            long globalCommitTimestamp = txn.getEffectiveCommitTimestamp();\n-            dataToReturn.add(newTransactionTimeStampKeyValue(element, Bytes.toBytes(globalCommitTimestamp)));\n-            switch (cellType) {\n-                case TOMBSTONE: {\n-                    long t = element.getTimestamp();\n-                    if (t > maxTombstoneTimestamp &&\n-                            (!purgeConfig.shouldRespectActiveTransactions() || t < lowWatermarkTransaction)) {\n-                        maxTombstoneTimestamp = t;\n-                    }\n-                    break;\n+        if (!isCommitted(txn)) {\n+            dataToReturn.add(new CellAndCommit(element, null));\n+            return;\n+        }\n+\n+        /*\n+         * This element has been committed all the way to the user level, so a\n+         * commit timestamp can be placed on it.\n+         */\n+        long commitTimestamp = txn.getEffectiveCommitTimestamp();\n+        dataToReturn.add(new CellAndCommit(\n+                newTransactionTimeStampKeyValue(element, Bytes.toBytes(commitTimestamp)), commitTimestamp));\n+        switch (cellType) {\n+            case TOMBSTONE:\n+                if (commitTimestamp > maxTombstoneTimestamp &&\n+                        (!purgeConfig.shouldRespectActiveTransactions() || commitTimestamp < lowWatermarkTransaction)) {\n+                    maxTombstoneTimestamp = commitTimestamp;\n                 }\n-                case FIRST_WRITE_TOKEN:\n-                    assert !firstWriteToken;\n-                    firstWriteToken = true;\n-                    break;\n-                case DELETE_RIGHT_AFTER_FIRST_WRITE_TOKEN:\n-                    assert deleteRightAfterFirstWriteTimestamp == 0;\n-                    deleteRightAfterFirstWriteTimestamp = element.getTimestamp();\n-                    break;\n-                case USER_DATA: {\n-                    long t = element.getTimestamp();\n-                    if (purgeConfig.shouldPurgeUpdates() && t < lowWatermarkTransaction) {\n-                        EntryDecoder decoder = new EntryDecoder(element.getValueArray(), element.getValueOffset(), element.getValueLength());\n-                        BitIndex index = decoder.getCurrentIndex();\n-                        LOG.trace(\"BitIndex: \" + index + \" , length=\" + index.length());\n-                        boolean purge = true;\n-                        for (int col = index.nextSetBit(0); col >= 0; col = index.nextSetBit(col + 1)) {\n-                            if (!columnUpdateLatestTimestamp.containsKey(col)) {\n-                                columnUpdateLatestTimestamp.put(col, element.getTimestamp());\n-                                purge = false;\n-                                LOG.trace(\"Update cannot be purged: \" + element);\n-                            }\n-                        }\n-                        if (purge) {\n-                            boolean ret = updatesToPurgeTimestamps.add(element.getTimestamp());\n-                            assert ret;\n+                break;\n+            case FIRST_WRITE_TOKEN:\n+                assert !firstWriteToken;\n+                firstWriteToken = true;\n+                break;\n+            case DELETE_RIGHT_AFTER_FIRST_WRITE_TOKEN:\n+                assert deleteRightAfterFirstWriteTimestamp == 0;\n+                deleteRightAfterFirstWriteTimestamp = commitTimestamp;\n+                break;\n+            case USER_DATA: {\n+                if (purgeConfig.shouldPurgeUpdates() && commitTimestamp < lowWatermarkTransaction) {\n+                    EntryDecoder decoder = new EntryDecoder(element.getValueArray(), element.getValueOffset(), element.getValueLength());\n+                    BitIndex index = decoder.getCurrentIndex();\n+                    LOG.trace(\"BitIndex: \" + index + \" , length=\" + index.length());\n+                    boolean purge = true;\n+                    for (int col = index.nextSetBit(0); col >= 0; col = index.nextSetBit(col + 1)) {\n+                        if (!columnUpdateLatestTimestamp.containsKey(col)) {\n+                            columnUpdateLatestTimestamp.put(col, commitTimestamp);\n+                            purge = false;\n+                            LOG.trace(\"Update cannot be purged: \" + element);\n+                        } else {\n+                            assert commitTimestamp <= columnUpdateLatestTimestamp.get(col);\n                         }\n                     }\n-                    break;\n+                    if (purge) {\n+                        boolean ret = updatesToPurgeTimestamps.add(commitTimestamp);\n+                        assert ret;\n+                    }\n                 }\n+                break;\n             }\n         }\n-        // Committed or active, return the original data too\n-        dataToReturn.add(element);\n+        dataToReturn.add(new CellAndCommit(element, commitTimestamp));\n     }\n \n     private boolean shouldRemoveMostRecentTombstone() {\n"}}, {"oid": "2b341e2f19b78919324f0bbfb0ebef13df9b79a6", "url": "https://github.com/splicemachine/spliceengine/commit/2b341e2f19b78919324f0bbfb0ebef13df9b79a6", "message": "DB-9640 Purging: Compare watermark to commit timestamp instead of begin timestamp", "committedDate": "2020-06-23T12:15:20Z", "type": "commit"}, {"oid": "36d3210d863d69cc2147e9da6a9ed4ea7e6abe31", "url": "https://github.com/splicemachine/spliceengine/commit/36d3210d863d69cc2147e9da6a9ed4ea7e6abe31", "message": "DB-9640 Fix spotbugs", "committedDate": "2020-06-23T14:48:30Z", "type": "commit"}, {"oid": "36d3210d863d69cc2147e9da6a9ed4ea7e6abe31", "url": "https://github.com/splicemachine/spliceengine/commit/36d3210d863d69cc2147e9da6a9ed4ea7e6abe31", "message": "DB-9640 Fix spotbugs", "committedDate": "2020-06-23T14:48:30Z", "type": "forcePushed"}, {"oid": "8571a1972c12876ca5de67ce2c2291bc58bcef33", "url": "https://github.com/splicemachine/spliceengine/commit/8571a1972c12876ca5de67ce2c2291bc58bcef33", "message": "WIP More traces", "committedDate": "2020-06-24T09:46:10Z", "type": "forcePushed"}, {"oid": "4063777b486599a2135da10d5096fad5949082dc", "url": "https://github.com/splicemachine/spliceengine/commit/4063777b486599a2135da10d5096fad5949082dc", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-24T10:04:34Z", "type": "forcePushed"}, {"oid": "0cf9b0a59f7f0cbd7bd4e17a515505aecb7a2c8e", "url": "https://github.com/splicemachine/spliceengine/commit/0cf9b0a59f7f0cbd7bd4e17a515505aecb7a2c8e", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-24T10:06:34Z", "type": "forcePushed"}, {"oid": "7b46d649dc43a5561311b9791492ed8bd97b788e", "url": "https://github.com/splicemachine/spliceengine/commit/7b46d649dc43a5561311b9791492ed8bd97b788e", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-24T17:12:34Z", "type": "forcePushed"}, {"oid": "6a6c60f0d4193c9326a88143e105f1b2f639ee8b", "url": "https://github.com/splicemachine/spliceengine/commit/6a6c60f0d4193c9326a88143e105f1b2f639ee8b", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-25T00:17:24Z", "type": "forcePushed"}, {"oid": "c327ae2f936abfe918d2dadf9bb0d4419bf11252", "url": "https://github.com/splicemachine/spliceengine/commit/c327ae2f936abfe918d2dadf9bb0d4419bf11252", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-25T13:12:10Z", "type": "commit"}, {"oid": "c327ae2f936abfe918d2dadf9bb0d4419bf11252", "url": "https://github.com/splicemachine/spliceengine/commit/c327ae2f936abfe918d2dadf9bb0d4419bf11252", "message": "DB-9640 Ignore Delete Commits", "committedDate": "2020-06-25T13:12:10Z", "type": "forcePushed"}, {"oid": "a75510a01d47d18e1f66e14454d9bd9352823baf", "url": "https://github.com/splicemachine/spliceengine/commit/a75510a01d47d18e1f66e14454d9bd9352823baf", "message": "DB-9640 Use commit TS for watermark comp, begin TS for the rest", "committedDate": "2020-06-26T12:56:18Z", "type": "commit"}, {"oid": "eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "url": "https://github.com/splicemachine/spliceengine/commit/eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "message": "DB-8781 Properly handle updates with primary keys", "committedDate": "2020-06-26T12:57:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2ODQ4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449568486", "bodyText": "why is it not allowed to tolerate situations like:\nbuilder.purgeDeletes(true);\n... // oops business logic shows that we can't do that\nbuilder.purgeDeletes(false); // this will throw", "author": "hatyo", "createdAt": "2020-07-03T12:53:30Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/PurgeConfigBuilder.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.si.impl.server;\n+\n+public class PurgeConfigBuilder {\n+    private PurgeConfig.PurgeLatestTombstone purgeLatestTombstone = null;\n+    private Boolean respectActiveTransactions = null;\n+    private Boolean purgeDeletes = null;\n+    private Boolean purgeUpdates = null;\n+\n+    public PurgeConfigBuilder purgeDeletes(boolean b) {\n+        assert purgeDeletes == null;", "originalCommit": "eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNTk3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449605973", "bodyText": "At the moment, we set all of that in the same place, so I'd rather be defensive about it and force users to only call that function once.", "author": "arnaud-splice", "createdAt": "2020-07-03T14:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2ODQ4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2OTA5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449569093", "bodyText": "respectActiveTransactions I find the name a bit weird :) but it is ok", "author": "hatyo", "createdAt": "2020-07-03T12:54:52Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/PurgeConfig.java", "diffHunk": "@@ -23,34 +23,16 @@\n \n     private final PurgeLatestTombstone purgeLatestTombstone;\n     private final boolean respectActiveTransactions;\n-    private final boolean purge;\n+    private final boolean purgeDeletes;\n+    private final boolean purgeUpdates;\n \n-    public PurgeConfig(boolean purge, PurgeLatestTombstone purgeLatestTombstone, boolean respectActiveTransactions) {\n-        this.purge = purge;\n+    public PurgeConfig(boolean purgeDeletes, PurgeLatestTombstone purgeLatestTombstone, boolean purgeUpdates, boolean respectActiveTransactions) {", "originalCommit": "eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NTI3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449575276", "bodyText": "remove", "author": "hatyo", "createdAt": "2020-07-03T13:09:02Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -52,7 +56,7 @@ public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) t\n         assert dataToReturn.isEmpty();\n         assert results.isEmpty();\n         assert maxTombstoneTimestamp == 0;\n-        assert isSorted(rawList): \"CompactionStateMutate: rawList not sorted\";\n+        //assert isSorted(rawList): \"CompactionStateMutate: rawList not sorted\";", "originalCommit": "eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNDQ3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449604474", "bodyText": "I would rather leave them there as they are quite handy when debugging", "author": "arnaud-splice", "createdAt": "2020-07-03T14:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NTI3Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NTYzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449575637", "bodyText": "dito", "author": "hatyo", "createdAt": "2020-07-03T13:09:52Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/impl/server/SICompactionStateMutate.java", "diffHunk": "@@ -61,15 +65,17 @@ public void mutate(List<Cell> rawList, List<TxnView> txns, List<Cell> results) t\n                 TxnView txn = it.next();\n                 mutate(aRawList, txn);\n             }\n-            if (purgeConfig.shouldPurge() &&\n-                    (!purgeConfig.shouldRespectActiveTransactions() || maxTombstoneTimestamp > 0)) {\n-                removeDeletedRows();\n-            }\n-            results.addAll(dataToReturn);\n-            assert isSorted(results) : \"CompactionStateMutate: results not sorted\";\n+            Stream<Cell> stream = dataToReturn.stream();\n+            if (shouldPurgeDeletes())\n+                stream = stream.filter(not(this::purgeableDeletedRow));\n+            if (shouldPurgeUpdates())\n+                stream = stream.filter(not(this::purgeableOldUpdate));\n+            stream.forEachOrdered(results::add);\n+            //assert isSorted(results) : \"CompactionStateMutate: results not sorted\";", "originalCommit": "eb6c2fa16a04a0decf8c49bf7c1d9f6dc239f090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNDUyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3702#discussion_r449604526", "bodyText": "same", "author": "arnaud-splice", "createdAt": "2020-07-03T14:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NTYzNw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "98f2d86ef99fae2c0c2245aa5a7d606cbb9bd518", "url": "https://github.com/splicemachine/spliceengine/commit/98f2d86ef99fae2c0c2245aa5a7d606cbb9bd518", "message": "Merge remote-tracking branch 'origin/master' into DB-8781", "committedDate": "2020-07-09T08:58:57Z", "type": "commit"}]}