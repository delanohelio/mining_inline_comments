{"pr_number": 4853, "pr_title": "DB-11019 Use the selectivity of only one join predicate per column set.", "pr_createdAt": "2020-12-14T04:37:39Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4853", "timeline": [{"oid": "2e6b1d5bed2c893f4cdfbf27d8f0e74d1dc17033", "url": "https://github.com/splicemachine/spliceengine/commit/2e6b1d5bed2c893f4cdfbf27d8f0e74d1dc17033", "message": "DB-11019 Use the selectivity of only one join predicate per column set.", "committedDate": "2020-12-14T03:59:56Z", "type": "commit"}, {"oid": "e81d78e88b8a6127c0ad3749a325e9d42b04c02f", "url": "https://github.com/splicemachine/spliceengine/commit/e81d78e88b8a6127c0ad3749a325e9d42b04c02f", "message": "DB-11019 Fix Spotbugs.", "committedDate": "2020-12-14T05:10:29Z", "type": "commit"}, {"oid": "a5132bce5384d859a5265893143daea56c6bb062", "url": "https://github.com/splicemachine/spliceengine/commit/a5132bce5384d859a5265893143daea56c6bb062", "message": "DB-11019 Fix ITs.", "committedDate": "2020-12-14T06:33:02Z", "type": "commit"}, {"oid": "a22b4a7a471241c8effb13594e074947c9a75533", "url": "https://github.com/splicemachine/spliceengine/commit/a22b4a7a471241c8effb13594e074947c9a75533", "message": "DB-11019 Fix ITs, part 2.", "committedDate": "2020-12-14T14:09:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNjc4Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543216783", "bodyText": "very nice", "author": "martinrupp", "createdAt": "2020-12-15T10:16:59Z", "path": "db-engine/src/test/java/com/splicemachine/db/impl/sql/compile/ReferencedColumnsMapTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package com.splicemachine.db.iapi.types;\n+\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.*;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.impl.sql.compile.ReferencedColumnsMap;\n+import org.junit.Test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ *\n+ * Test Class for ReferencedColumnsMap\n+ *\n+ */\n+public class ReferencedColumnsMapTest {", "originalCommit": "a22b4a7a471241c8effb13594e074947c9a75533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2NzI2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543467260", "bodyText": "Thanks", "author": "msirek", "createdAt": "2020-12-15T15:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNjc4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDYxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543194619", "bodyText": "When would the case baseTable.getCurrentAccessPath() == null happen?", "author": "ascend1", "createdAt": "2020-12-15T09:46:21Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DefaultPredicateSelectivity.java", "diffHunk": "@@ -57,4 +57,14 @@ public double getSelectivity() throws StandardException {\n         }\n         return selectivity;\n     }\n+\n+    @Override\n+    public boolean shouldApplySelectivity() {\n+        return\n+            getNumReferencedTables() < 2             ||\n+            baseTable.getCurrentAccessPath() == null ||", "originalCommit": "a22b4a7a471241c8effb13594e074947c9a75533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2Njc3OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543466779", "bodyText": "I don't know, this is more like defensive programming so that no errors occur in any state of FromTable.  For example resetAccessPaths() can set currentAccessPath to null.  If currentAccessPath could never be set to null then this condition is not needed.  But if the method assumes currentAccessPath must be non-null, it places a precondition upon calling this method, which should be documented.  Adding the check just makes life easier because there is no precondition for calling this function.", "author": "msirek", "createdAt": "2020-12-15T15:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1NTc3OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543655779", "bodyText": "That makes sense. I debugged it a little bit and it seems getCurrentAccessPath() can indeed return null. Not sure if it can ever happen during cost estimation, but it seems when the best conglomerate is chosen, current is then set to null. Anyway, I agree that it safer. All good.", "author": "ascend1", "createdAt": "2020-12-15T20:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDYxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwODgzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543208834", "bodyText": "Maybe a pair of curly braces for the if block, since it contains multiple lines.", "author": "ascend1", "createdAt": "2020-12-15T10:05:35Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java", "diffHunk": "@@ -130,14 +132,73 @@ public static double estimateJoinSelectivity(Optimizable innerTable, Conglomerat\n             }\n         }\n         double selectivity = 1.d;\n+        List<JoinPredicateSelectivity> predSelectivities = new ArrayList<>();\n         if (predList != null) {\n             for (int i = 0; i < predList.size(); i++) {\n                 Predicate p = (Predicate) predList.getOptPredicate(i);\n                 if (!isTheRightJoinPredicate(p, predicateType))\n                     continue;\n \n-                selectivity *= p.joinSelectivity(innerTable, innerCD, innerRowCount, outerRowCount, selectivityJoinType);\n+                predSelectivities.add(new JoinPredicateSelectivity(p, innerTable, QualifierPhase.JOIN,\n+                                                           p.joinSelectivity(innerTable, innerCD, innerRowCount,\n+                                                                             outerRowCount, selectivityJoinType)));\n+            }\n+        }\n+        if (predSelectivities.size() == 1)\n+            selectivity = predSelectivities.get(0).getSelectivity();\n+        else {\n+            // Sort the selectivities and combine them using computeSqrtLevel\n+            // as is done in ScanCostFunction.\n+            Collections.sort(predSelectivities);\n+\n+            // Map from predicate number (in the order added to the map) to the\n+            // selectivity of the predicate.\n+            Map<Integer, JoinPredicateSelectivity> selectivityMap = new TreeMap<>();\n+\n+            // Map from column number to index into selectivityMap.\n+            // This double lookup is done so that the main data structure\n+            // holding selectivities has no duplicates.\n+            Map<Integer,Integer> selectivityIndexMap = new HashMap<>();\n+\n+            int index = 0;\n+            for (JoinPredicateSelectivity predicateSelectivity:predSelectivities) {\n+                Predicate p = predicateSelectivity.getPredicate();\n+                int tableNumber = innerTable.getTableNumber();\n+                Set<Integer> columnSet = p.getReferencedColumns().get(tableNumber);\n+                ReferencedColumnsMap referencedColumnsMap = p.getReferencedColumns();\n+\n+                Integer mapIndex = null;\n+                if (columnSet != null)\n+                    for (Integer I:columnSet) {\n+                        mapIndex = selectivityIndexMap.get(I);\n+                        if (mapIndex != null)\n+                            break;\n+                    }", "originalCommit": "a22b4a7a471241c8effb13594e074947c9a75533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MjIyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543462224", "bodyText": "Added braces.", "author": "msirek", "createdAt": "2020-12-15T15:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwODgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea99e299eeb65a021a091f5e57243b703dd39d1f", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java\nindex 944120d129..bc078f7231 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectivityUtil.java\n\n@@ -139,7 +139,7 @@ public class SelectivityUtil {\n                 if (!isTheRightJoinPredicate(p, predicateType))\n                     continue;\n \n-                predSelectivities.add(new JoinPredicateSelectivity(p, innerTable, QualifierPhase.JOIN,\n+                predSelectivities.add(new JoinPredicateSelectivity(p, innerTable, QualifierPhase.FILTER_BASE,\n                                                            p.joinSelectivity(innerTable, innerCD, innerRowCount,\n                                                                              outerRowCount, selectivityJoinType)));\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxODk0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543218940", "bodyText": "One thing that could lead to some confusion later is that the JOIN phase newly added here is not used in addPredicate() in ScanCostFunction, but only used in estimateJoinSelectivity() in SelectivityUtil. For this reason, I wonder if it's necessary to have this phase. In estimateJoinSelectivity(), there is only one phase involved, so practically, phase doesn't really matter.", "author": "ascend1", "createdAt": "2020-12-15T10:20:05Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java", "diffHunk": "@@ -38,8 +38,9 @@\n  * BASE - > Qualifier is going against a key value in a way where splice can perform partitioning.\n  * FILTER_BASE -> Qualifier for base table but does not restrict I/O from base scan.  This is evaluated prior to a possible lookup.\n  * FILTER_PROJECTION -> Qualifer applied after possible lookup in the projection node on top of the base conglomerate scan.\n+ * JOIN -> Join predicate used to adjust the join selectivity.\n  *\n  */\n public enum QualifierPhase {\n-    BASE,FILTER_BASE,FILTER_PROJECTION\n+    BASE,FILTER_BASE,FILTER_PROJECTION,JOIN", "originalCommit": "a22b4a7a471241c8effb13594e074947c9a75533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MTM0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4853#discussion_r543461346", "bodyText": "Good point.  I will remove it and just pass FILTER_BASE as the parameter value.", "author": "msirek", "createdAt": "2020-12-15T15:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxODk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea99e299eeb65a021a091f5e57243b703dd39d1f", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java\nindex 5055ed9cd2..7138842a26 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QualifierPhase.java\n\n@@ -38,9 +38,8 @@ package com.splicemachine.db.impl.sql.compile;\n  * BASE - > Qualifier is going against a key value in a way where splice can perform partitioning.\n  * FILTER_BASE -> Qualifier for base table but does not restrict I/O from base scan.  This is evaluated prior to a possible lookup.\n  * FILTER_PROJECTION -> Qualifer applied after possible lookup in the projection node on top of the base conglomerate scan.\n- * JOIN -> Join predicate used to adjust the join selectivity.\n  *\n  */\n public enum QualifierPhase {\n-    BASE,FILTER_BASE,FILTER_PROJECTION,JOIN\n+    BASE,FILTER_BASE,FILTER_PROJECTION\n }\n"}}, {"oid": "ea99e299eeb65a021a091f5e57243b703dd39d1f", "url": "https://github.com/splicemachine/spliceengine/commit/ea99e299eeb65a021a091f5e57243b703dd39d1f", "message": "DB-11019 Address review comments.", "committedDate": "2020-12-15T15:57:21Z", "type": "commit"}, {"oid": "51f3ef6e52e89948df7dea5518a0c0c535964b1f", "url": "https://github.com/splicemachine/spliceengine/commit/51f3ef6e52e89948df7dea5518a0c0c535964b1f", "message": "DB-11019 Remove dependency on cedarsoftware Deepequals.", "committedDate": "2020-12-16T00:45:54Z", "type": "commit"}, {"oid": "46bac5c50a5d52acdebabf7c1f8998d64f43e038", "url": "https://github.com/splicemachine/spliceengine/commit/46bac5c50a5d52acdebabf7c1f8998d64f43e038", "message": "DB-11019 Fix Spotbugs", "committedDate": "2020-12-16T05:27:33Z", "type": "commit"}]}