{"pr_number": 4880, "pr_title": "DB-10882 Support updatable cursors", "pr_createdAt": "2020-12-16T19:17:51Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4880", "timeline": [{"oid": "c1c4d206273ee8c9d94e0725488ee14fa9cf47d0", "url": "https://github.com/splicemachine/spliceengine/commit/c1c4d206273ee8c9d94e0725488ee14fa9cf47d0", "message": "DB-10882 WIP.", "committedDate": "2020-12-11T13:33:36Z", "type": "commit"}, {"oid": "556035ebfc19dc6aa05147d89dc459d9e01bd36a", "url": "https://github.com/splicemachine/spliceengine/commit/556035ebfc19dc6aa05147d89dc459d9e01bd36a", "message": "DB-10882 refactoring.", "committedDate": "2020-12-13T21:36:32Z", "type": "commit"}, {"oid": "13e80d97b3dcf9b2ad295698d0806a7d251eb962", "url": "https://github.com/splicemachine/spliceengine/commit/13e80d97b3dcf9b2ad295698d0806a7d251eb962", "message": "DB-10882 Adapt DeleteNode to expose CURRENT_ROW_LOCATION_NODE.\n\n- this is needed for the projection to generate the proper projection\n  expression (getRowLocation).", "committedDate": "2020-12-14T10:49:01Z", "type": "commit"}, {"oid": "c52a7c780f6196a31dd5a0d5418b8cd8b9c7cfa9", "url": "https://github.com/splicemachine/spliceengine/commit/c52a7c780f6196a31dd5a0d5418b8cd8b9c7cfa9", "message": "DB-10882 add tests.", "committedDate": "2020-12-14T12:16:11Z", "type": "commit"}, {"oid": "9fe58c3c3ae06bce90c28f7be6558151b7502b43", "url": "https://github.com/splicemachine/spliceengine/commit/9fe58c3c3ae06bce90c28f7be6558151b7502b43", "message": "DB-10882 fix decfloat bug.", "committedDate": "2020-12-15T13:45:00Z", "type": "commit"}, {"oid": "bc0f05ed9297f7ffa623db223091eaf9fbc4c692", "url": "https://github.com/splicemachine/spliceengine/commit/bc0f05ed9297f7ffa623db223091eaf9fbc4c692", "message": "Merge remote-tracking branch 'origin/master' into DB-10882", "committedDate": "2020-12-15T13:53:06Z", "type": "commit"}, {"oid": "97b39d0fcb49ae5405542db6ad301e90f994a121", "url": "https://github.com/splicemachine/spliceengine/commit/97b39d0fcb49ae5405542db6ad301e90f994a121", "message": "DB-10882 distributed cursor now works.", "committedDate": "2020-12-16T12:41:49Z", "type": "commit"}, {"oid": "50e7d2e9056d7ad4d3ad407a953163c3e7538ac4", "url": "https://github.com/splicemachine/spliceengine/commit/50e7d2e9056d7ad4d3ad407a953163c3e7538ac4", "message": "DB-10882 index scans support updatable result sets.", "committedDate": "2020-12-16T15:23:07Z", "type": "commit"}, {"oid": "3c391ebe00788b3c9c0a8654ee14bda281c36521", "url": "https://github.com/splicemachine/spliceengine/commit/3c391ebe00788b3c9c0a8654ee14bda281c36521", "message": "DB-10882 serialize rowId from distributed cursor only with updatable result sets.", "committedDate": "2020-12-16T17:17:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4NDY2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r544984667", "bodyText": "@dgomezferro this prevents serializing rowId. Should we added to other functions that could be pushed down to Spark executors and used by the ResultStreamer?", "author": "hatyo", "createdAt": "2020-12-17T10:37:23Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/ScrollInsensitiveFunction.java", "diffHunk": "@@ -41,6 +41,9 @@ public ExecRow call(ExecRow execRow) throws Exception {\n             this.operationContext.recordRead();\n             op.setCurrentRow(execRow);\n             this.operationContext.recordProduced();\n+            if(!op.isForUpdate()) {", "originalCommit": "3c391ebe00788b3c9c0a8654ee14bda281c36521", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNjI5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r545006293", "bodyText": "I think this is the only case, at least for now", "author": "dgomezferro", "createdAt": "2020-12-17T11:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4NDY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyMTk5NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r546021994", "bodyText": "ok", "author": "hatyo", "createdAt": "2020-12-18T18:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk4NDY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a4dacaa044e70803990f026dfc408ccd739bc383", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/ScrollInsensitiveFunction.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/ScrollInsensitiveFunction.java\nindex 7aaf1d15f8..038b3375bb 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/ScrollInsensitiveFunction.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/ScrollInsensitiveFunction.java\n\n@@ -35,11 +36,12 @@ public class ScrollInsensitiveFunction extends SpliceFunction<SpliceOperation, E\n         @Override\n         public ExecRow call(ExecRow execRow) throws Exception {\n             if (!initialized) {\n-                op = (SpliceOperation) getOperation();\n+                op = getOperation();\n                 initialized = true;\n             }\n             this.operationContext.recordRead();\n             op.setCurrentRow(execRow);\n+            op.setCurrentRowLocation(execRow == null ? null : new HBaseRowLocation(execRow.getKey()));\n             this.operationContext.recordProduced();\n             if(!op.isForUpdate()) {\n                 execRow.setKey(null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNDA0MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r545004041", "bodyText": "Why is this change needed? @ascend1 @msirek can you comment on whether this could cause issues?", "author": "dgomezferro", "createdAt": "2020-12-17T11:07:05Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/DeleteNode.java", "diffHunk": "@@ -325,19 +325,11 @@ else if (cursorTargetTableName != null)\n                     rowIdColumn.setName(COLUMNNAME);\n                 }\n \n-                ColumnReference columnReference = (ColumnReference) getNodeFactory().getNode(\n-                        C_NodeTypes.COLUMN_REFERENCE,\n-                        rowIdColumn.getName(),\n-                        null,\n-                        getContextManager());\n-                columnReference.setSource(rowIdColumn);\n-                columnReference.setNestingLevel(targetTable.getLevel());\n-                columnReference.setSourceLevel(targetTable.getLevel());\n                 rowLocationColumn =\n                         (ResultColumn) getNodeFactory().getNode(\n                                 C_NodeTypes.RESULT_COLUMN,\n                                 COLUMNNAME,\n-                                columnReference,\n+                                rowIdColumn,\n                                 getContextManager());", "originalCommit": "3c391ebe00788b3c9c0a8654ee14bda281c36521", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyMTYyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r546021623", "bodyText": "If we don't expose the CURRENT_ROW_LOCATION_NODE in the RCL for update/delete nodes we will not generate the corresponding getRowLocation in the projection expression, which means we will not be able to retrieve the rowId from the projection node.\nFor more information please have a look at com.splicemachine.db.impl.sql.compile.ResultColumnList#generateEvaluatedRow", "author": "hatyo", "createdAt": "2020-12-18T18:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg1NTY3Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547855677", "bodyText": "That makes sense, thanks!", "author": "dgomezferro", "createdAt": "2020-12-23T09:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNDA0MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwODU5NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r545008594", "bodyText": "Nitpick, a getter for this would be better", "author": "dgomezferro", "createdAt": "2020-12-17T11:14:13Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceIndexWatcher.java", "diffHunk": "@@ -31,7 +31,7 @@\n     protected String tableName;\n     protected String tableSchemaName;\n     protected String createString;\n-    protected String indexName;\n+    public final String indexName;", "originalCommit": "3c391ebe00788b3c9c0a8654ee14bda281c36521", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyMTc5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r546021793", "bodyText": "fixed it.", "author": "hatyo", "createdAt": "2020-12-18T18:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwODU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "a4dacaa044e70803990f026dfc408ccd739bc383", "chunk": "diff --git a/splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceIndexWatcher.java b/splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceIndexWatcher.java\nindex d4766e0065..263e79f608 100644\n--- a/splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceIndexWatcher.java\n+++ b/splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceIndexWatcher.java\n\n@@ -31,7 +31,7 @@ public class SpliceIndexWatcher extends TestWatcher {\n     protected String tableName;\n     protected String tableSchemaName;\n     protected String createString;\n-    public final String indexName;\n+    protected String indexName;\n     protected String indexSchemaName;\n     protected String create = \"create\";\n     protected boolean excludeNulls;\n"}}, {"oid": "a4dacaa044e70803990f026dfc408ccd739bc383", "url": "https://github.com/splicemachine/spliceengine/commit/a4dacaa044e70803990f026dfc408ccd739bc383", "message": "DB-10882 address comments.", "committedDate": "2020-12-18T16:11:07Z", "type": "commit"}, {"oid": "68bac0f1d1b165a645790250fe64e4b39c55dd7c", "url": "https://github.com/splicemachine/spliceengine/commit/68bac0f1d1b165a645790250fe64e4b39c55dd7c", "message": "DB-10882 add tests for triggers and concurrent transactions.", "committedDate": "2020-12-18T18:48:33Z", "type": "commit"}, {"oid": "6aff83db02c6c7f62348f5af965502673cfe6f35", "url": "https://github.com/splicemachine/spliceengine/commit/6aff83db02c6c7f62348f5af965502673cfe6f35", "message": "Merge remote-tracking branch 'origin/master' into DB-10882", "committedDate": "2020-12-18T18:50:46Z", "type": "commit"}, {"oid": "ded03dda64adcade38c59791440911ccc0398c31", "url": "https://github.com/splicemachine/spliceengine/commit/ded03dda64adcade38c59791440911ccc0398c31", "message": "DB-10882 small cleanup.", "committedDate": "2020-12-18T18:58:05Z", "type": "commit"}, {"oid": "6d6eebd05223d649fa3ebac6a7de035444978e76", "url": "https://github.com/splicemachine/spliceengine/commit/6d6eebd05223d649fa3ebac6a7de035444978e76", "message": "DB-10882 remove LoopingAlphabetStream from tests.", "committedDate": "2020-12-18T19:53:46Z", "type": "commit"}, {"oid": "7b8c438b7ad364c9b4be6271b5883c862a7b60ef", "url": "https://github.com/splicemachine/spliceengine/commit/7b8c438b7ad364c9b4be6271b5883c862a7b60ef", "message": "DB-10882 fix SpotBugs issues.", "committedDate": "2020-12-19T10:40:50Z", "type": "commit"}, {"oid": "76010a3390f9fa3114ae7527d8e1108d96843268", "url": "https://github.com/splicemachine/spliceengine/commit/76010a3390f9fa3114ae7527d8e1108d96843268", "message": "DB-10882 support partial projections.", "committedDate": "2020-12-21T20:25:27Z", "type": "commit"}, {"oid": "6a737df155108bdd6f7d82d4418a484d6b03e1dc", "url": "https://github.com/splicemachine/spliceengine/commit/6a737df155108bdd6f7d82d4418a484d6b03e1dc", "message": "Merge remote-tracking branch 'origin/master' into DB-10882", "committedDate": "2020-12-21T20:28:47Z", "type": "commit"}, {"oid": "af7aafbe8d9c79e50f2590291be6f646be1efc0c", "url": "https://github.com/splicemachine/spliceengine/commit/af7aafbe8d9c79e50f2590291be6f646be1efc0c", "message": "DB-10882 address SpotBugs issues.", "committedDate": "2020-12-22T11:42:37Z", "type": "commit"}, {"oid": "e41f8e246028a5bd0b76ac405ceab75baee7e8fd", "url": "https://github.com/splicemachine/spliceengine/commit/e41f8e246028a5bd0b76ac405ceab75baee7e8fd", "message": "Merge remote-tracking branch 'origin/master' into DB-10882", "committedDate": "2020-12-22T18:04:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyODU0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547428542", "bodyText": "Remove extra spacing", "author": "dgomezferro", "createdAt": "2020-12-22T18:16:24Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/IndexValueRow.java", "diffHunk": "@@ -54,7 +54,7 @@\n  */\n public class IndexValueRow implements ExecIndexRow, Serializable {\n \n-\tprivate ExecRow valueRow;\n+\tprivate ExecRow                                     valueRow;", "originalCommit": "76010a3390f9fa3114ae7527d8e1108d96843268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ1NTYzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547455639", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-12-22T19:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyODU0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d3592e08ee2426ffb06628a8ca8db68a3bbe6675", "chunk": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/IndexValueRow.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/IndexValueRow.java\nindex 84d6199bf0..aa33cebee9 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/IndexValueRow.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/IndexValueRow.java\n\n@@ -49,225 +49,225 @@ import java.util.BitSet;\n import java.util.List;\n \n /**\n-\tMapper of ValueRow into ExecIndexRow. \n+    Mapper of ValueRow into ExecIndexRow.\n \n  */\n public class IndexValueRow implements ExecIndexRow, Serializable {\n \n-\tprivate ExecRow                                     valueRow;\n-\n-\tpublic IndexValueRow(ExecRow valueRow) {\n-\t\t this.valueRow = valueRow;\n-\t}\n-\n-\t@Override\n-\tpublic int size() {\n-\t\treturn valueRow.size();\n-\t}\n-\n-\t@Override\n-\tpublic int length() {\n-\t\treturn valueRow.length();\n-\t}\n-\n-\t@Override\n-\tpublic StructType schema() {\n-\t\treturn valueRow.schema();\n-\t}\n-\n-\t@Override\n-\tpublic Object apply(int i) {\n-\t\treturn valueRow.apply(i);\n-\t}\n-\n-\t@Override\n-\tpublic Object get(int i) {\n-\t\treturn valueRow.get(i);\n-\t}\n-\n-\t@Override\n-\tpublic boolean isNullAt(int i) {\n-\t\treturn valueRow.isNullAt(i);\n-\t}\n-\n-\t@Override\n-\tpublic boolean getBoolean(int i) {\n-\t\treturn valueRow.getBoolean(i);\n-\t}\n-\n-\t@Override\n-\tpublic byte getByte(int i) {\n-\t\treturn valueRow.getByte(i);\n-\t}\n-\n-\t@Override\n-\tpublic short getShort(int i) {\n-\t\treturn valueRow.getShort(i);\n-\t}\n-\n-\t@Override\n-\tpublic int getInt(int i) {\n-\t\treturn valueRow.getInt(i);\n-\t}\n-\n-\t@Override\n-\tpublic long getLong(int i) {\n-\t\treturn valueRow.getLong(i);\n-\t}\n-\n-\t@Override\n-\tpublic float getFloat(int i) {\n-\t\treturn valueRow.getFloat(i);\n-\t}\n-\n-\t@Override\n-\tpublic double getDouble(int i) {\n-\t\treturn valueRow.getDouble(i);\n-\t}\n-\n-\t@Override\n-\tpublic String getString(int i) {\n-\t\treturn valueRow.getString(i);\n-\t}\n-\n-\t@Override\n-\tpublic BigDecimal getDecimal(int i) {\n-\t\treturn valueRow.getDecimal(i);\n-\t}\n-\n-\t@Override\n-\tpublic Date getDate(int i) {\n-\t\treturn valueRow.getDate(i);\n-\t}\n-\n-\t@Override\n-\tpublic Timestamp getTimestamp(int i) {\n-\t\treturn valueRow.getTimestamp(i);\n-\t}\n-\n-\t@Override\n-\tpublic <T> Seq<T> getSeq(int i) {\n-\t\treturn valueRow.getSeq(i);\n-\t}\n-\n-\t@Override\n-\tpublic <T> List<T> getList(int i) {\n-\t\treturn valueRow.getList(i);\n-\t}\n-\n-\t@Override\n-\tpublic <K, V> Map<K, V> getMap(int i) {\n-\t\treturn valueRow.getMap(i);\n-\t}\n-\n-\t@Override\n-\tpublic <K, V> java.util.Map<K, V> getJavaMap(int i) {\n-\t\treturn valueRow.getJavaMap(i);\n-\t}\n-\n-\t@Override\n-\tpublic Row getStruct(int i) {\n-\t\treturn valueRow.getStruct(i);\n-\t}\n-\n-\t@Override\n-\tpublic <T> T getAs(int i) {\n-\t\treturn valueRow.getAs(i);\n-\t}\n-\n-\t@Override\n-\tpublic <T> T getAs(String s) {\n-\t\treturn valueRow.getAs(s);\n-\t}\n-\n-\t@Override\n-\tpublic int fieldIndex(String s) {\n-\t\treturn valueRow.fieldIndex(s);\n-\t}\n-\n-\t@Override\n-\tpublic <T> scala.collection.immutable.Map<String, T> getValuesMap(Seq<String> seq) {\n-\t\treturn valueRow.getValuesMap(seq);\n-\t}\n-\n-\t/*\n+    private ExecRow valueRow;\n+\n+    public IndexValueRow(ExecRow valueRow) {\n+         this.valueRow = valueRow;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return valueRow.size();\n+    }\n+\n+    @Override\n+    public int length() {\n+        return valueRow.length();\n+    }\n+\n+    @Override\n+    public StructType schema() {\n+        return valueRow.schema();\n+    }\n+\n+    @Override\n+    public Object apply(int i) {\n+        return valueRow.apply(i);\n+    }\n+\n+    @Override\n+    public Object get(int i) {\n+        return valueRow.get(i);\n+    }\n+\n+    @Override\n+    public boolean isNullAt(int i) {\n+        return valueRow.isNullAt(i);\n+    }\n+\n+    @Override\n+    public boolean getBoolean(int i) {\n+        return valueRow.getBoolean(i);\n+    }\n+\n+    @Override\n+    public byte getByte(int i) {\n+        return valueRow.getByte(i);\n+    }\n+\n+    @Override\n+    public short getShort(int i) {\n+        return valueRow.getShort(i);\n+    }\n+\n+    @Override\n+    public int getInt(int i) {\n+        return valueRow.getInt(i);\n+    }\n+\n+    @Override\n+    public long getLong(int i) {\n+        return valueRow.getLong(i);\n+    }\n+\n+    @Override\n+    public float getFloat(int i) {\n+        return valueRow.getFloat(i);\n+    }\n+\n+    @Override\n+    public double getDouble(int i) {\n+        return valueRow.getDouble(i);\n+    }\n+\n+    @Override\n+    public String getString(int i) {\n+        return valueRow.getString(i);\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimal(int i) {\n+        return valueRow.getDecimal(i);\n+    }\n+\n+    @Override\n+    public Date getDate(int i) {\n+        return valueRow.getDate(i);\n+    }\n+\n+    @Override\n+    public Timestamp getTimestamp(int i) {\n+        return valueRow.getTimestamp(i);\n+    }\n+\n+    @Override\n+    public <T> Seq<T> getSeq(int i) {\n+        return valueRow.getSeq(i);\n+    }\n+\n+    @Override\n+    public <T> List<T> getList(int i) {\n+        return valueRow.getList(i);\n+    }\n+\n+    @Override\n+    public <K, V> Map<K, V> getMap(int i) {\n+        return valueRow.getMap(i);\n+    }\n+\n+    @Override\n+    public <K, V> java.util.Map<K, V> getJavaMap(int i) {\n+        return valueRow.getJavaMap(i);\n+    }\n+\n+    @Override\n+    public Row getStruct(int i) {\n+        return valueRow.getStruct(i);\n+    }\n+\n+    @Override\n+    public <T> T getAs(int i) {\n+        return valueRow.getAs(i);\n+    }\n+\n+    @Override\n+    public <T> T getAs(String s) {\n+        return valueRow.getAs(s);\n+    }\n+\n+    @Override\n+    public int fieldIndex(String s) {\n+        return valueRow.fieldIndex(s);\n+    }\n+\n+    @Override\n+    public <T> scala.collection.immutable.Map<String, T> getValuesMap(Seq<String> seq) {\n+        return valueRow.getValuesMap(seq);\n+    }\n+\n+    /*\n          * class interface\n          */\n-\tpublic String toString() {\n-\t\treturn valueRow.toString();\n-\t}\n-\n-\t@Override\n-\tpublic Row copy() {\n-\t\treturn null;\n-\t}\n-\n-\t@Override\n-\tpublic boolean anyNull() {\n-\t\treturn false;\n-\t}\n-\n-\n-\t/**\n-\t\tGet the array form of the row that Access expects.\n-\n-\t\t@see ExecRow#getRowArray\n-\t*/\n-\tpublic DataValueDescriptor[] getRowArray() {\n-\t\treturn valueRow.getRowArray();\n-\t}\n-\n-\t/**\t@see ExecRow#getRowArray */\n-\tpublic void setRowArray(DataValueDescriptor[] value) \n-\t{\n-\t\tvalueRow.setRowArray(value);\n-\t}\n-\n-\t/**\n-\t\tGet a clone of the array form of the row that Access expects.\n-\n-\t\t@see ExecRow#getRowArray\n-\t*/\n-\tpublic DataValueDescriptor[] getRowArrayClone() \n-\t{\n-\t\treturn valueRow.getRowArrayClone();\n-\t}\n-\n-\t// this is the actual current # of columns\n-\tpublic int nColumns() {\n-\t\treturn valueRow.nColumns();\n-\t}\n-\n-\t/*\n-\t * Row interface\n-\t */\n-\t// position is 1-based\n-\tpublic DataValueDescriptor\tgetColumn (int position) throws StandardException {\n-\t\treturn valueRow.getColumn(position);\n-\t}\n-\n-\t// position is 1-based.\n-\tpublic void setColumn(int position, DataValueDescriptor col) {\n-\t\tvalueRow.setColumn(position, col);\n-\t}\n-\n-\t// position is 1-based.\n-\tpublic void setColumnValue(int position, DataValueDescriptor col) throws StandardException {\n-\t\tvalueRow.setColumnValue(position, col);\n-\t}\n-\n-\t// position is 1-based\n-\tpublic ExecRow getClone() {\n-\t\treturn new IndexValueRow(valueRow.getClone());\n-\t}\n-\n-\tpublic ExecRow getClone(FormatableBitSet clonedCols) {\n-\t\treturn new IndexValueRow(valueRow.getClone(clonedCols));\n-\t}\n-\n-\tpublic ExecRow getNewNullRow() {\n-\t\treturn new IndexValueRow(valueRow.getNewNullRow());\n-\t}\n+    public String toString() {\n+        return valueRow.toString();\n+    }\n+\n+    @Override\n+    public Row copy() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean anyNull() {\n+        return false;\n+    }\n+\n+\n+    /**\n+        Get the array form of the row that Access expects.\n+\n+        @see ExecRow#getRowArray\n+    */\n+    public DataValueDescriptor[] getRowArray() {\n+        return valueRow.getRowArray();\n+    }\n+\n+    /**\t@see ExecRow#getRowArray */\n+    public void setRowArray(DataValueDescriptor[] value)\n+    {\n+        valueRow.setRowArray(value);\n+    }\n+\n+    /**\n+        Get a clone of the array form of the row that Access expects.\n+\n+        @see ExecRow#getRowArray\n+    */\n+    public DataValueDescriptor[] getRowArrayClone()\n+    {\n+        return valueRow.getRowArrayClone();\n+    }\n+\n+    // this is the actual current # of columns\n+    public int nColumns() {\n+        return valueRow.nColumns();\n+    }\n+\n+    /*\n+     * Row interface\n+     */\n+    // position is 1-based\n+    public DataValueDescriptor\tgetColumn (int position) throws StandardException {\n+        return valueRow.getColumn(position);\n+    }\n+\n+    // position is 1-based.\n+    public void setColumn(int position, DataValueDescriptor col) {\n+        valueRow.setColumn(position, col);\n+    }\n+\n+    // position is 1-based.\n+    public void setColumnValue(int position, DataValueDescriptor col) throws StandardException {\n+        valueRow.setColumnValue(position, col);\n+    }\n+\n+    // position is 1-based\n+    public ExecRow getClone() {\n+        return new IndexValueRow(valueRow.getClone());\n+    }\n+\n+    public ExecRow getClone(FormatableBitSet clonedCols) {\n+        return new IndexValueRow(valueRow.getClone(clonedCols));\n+    }\n+\n+    public ExecRow getNewNullRow() {\n+        return new IndexValueRow(valueRow.getNewNullRow());\n+    }\n \n     /**\n      * Reset all columns in the row array to null values.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNDM0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547434342", "bodyText": "We are setting this unconditionally, not just for \"FOR UPDATE\" statements. Is it possible to restrict it?", "author": "dgomezferro", "createdAt": "2020-12-22T18:24:45Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/SetCurrentLocatedRowAndRowKeyFunction.java", "diffHunk": "@@ -17,27 +17,31 @@\n import com.splicemachine.db.iapi.sql.execute.ExecRow;\n import com.splicemachine.db.iapi.types.HBaseRowLocation;\n import com.splicemachine.derby.iapi.sql.execute.SpliceOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.ProjectRestrictOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.ScrollInsensitiveOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.TableScanOperation;\n import com.splicemachine.derby.stream.iapi.OperationContext;\n import com.splicemachine.derby.stream.utils.StreamLogUtils;\n \n-/**\n- *\n- *\n- */\n public class SetCurrentLocatedRowAndRowKeyFunction<Op extends SpliceOperation> extends SpliceFunction<Op,ExecRow,ExecRow> {\n \n+    private BaseRowLocatorFunction<Op> locatorFunction;\n+\n     public SetCurrentLocatedRowAndRowKeyFunction() {\n         super();\n+        locatorFunction = new BaseRowLocatorFunction<>();\n     }\n \n     public SetCurrentLocatedRowAndRowKeyFunction(OperationContext operationContext) {\n         super(operationContext);\n+        locatorFunction = new BaseRowLocatorFunction<>();\n     }\n \n     @Override\n     public ExecRow call(ExecRow locatedRow) throws Exception {\n         getOperation().setCurrentRow(locatedRow);\n         getOperation().setCurrentRowLocation(new HBaseRowLocation(locatedRow.getKey()));\n+        getOperation().setCurrentBaseRowLocation(locatorFunction.call(operationContext));", "originalCommit": "76010a3390f9fa3114ae7527d8e1108d96843268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ1NjQ1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547456453", "bodyText": "You're right, I restrict it now for for-update plans.", "author": "hatyo", "createdAt": "2020-12-22T19:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNDM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d3592e08ee2426ffb06628a8ca8db68a3bbe6675", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/SetCurrentLocatedRowAndRowKeyFunction.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/SetCurrentLocatedRowAndRowKeyFunction.java\nindex 9214377a97..cfac2a910a 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/SetCurrentLocatedRowAndRowKeyFunction.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/SetCurrentLocatedRowAndRowKeyFunction.java\n\n@@ -41,7 +41,9 @@ public class SetCurrentLocatedRowAndRowKeyFunction<Op extends SpliceOperation> e\n     public ExecRow call(ExecRow locatedRow) throws Exception {\n         getOperation().setCurrentRow(locatedRow);\n         getOperation().setCurrentRowLocation(new HBaseRowLocation(locatedRow.getKey()));\n-        getOperation().setCurrentBaseRowLocation(locatorFunction.call(operationContext));\n+        if(getOperation().isForUpdate()) {\n+            getOperation().setCurrentBaseRowLocation(locatorFunction.apply(operationContext));\n+        }\n         StreamLogUtils.logOperationRecord(locatedRow, operationContext);\n         return locatedRow;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNDc0OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547434748", "bodyText": "I don't think this needs to be a SpliceFunction, the logic could even be a static function. I'm ok with it being a functional object, but no need to extend SpliceFunction, implement hasNativeSparkImplementation etc.", "author": "dgomezferro", "createdAt": "2020-12-22T18:25:32Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/function/BaseRowLocatorFunction.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.stream.function;\n+\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.derby.iapi.sql.execute.SpliceOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.IndexRowToBaseRowOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.ProjectRestrictOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.ScrollInsensitiveOperation;\n+import com.splicemachine.derby.impl.sql.execute.operations.TableScanOperation;\n+import com.splicemachine.derby.stream.iapi.OperationContext;\n+\n+public class BaseRowLocatorFunction <Op extends SpliceOperation> extends SpliceFunction<Op, OperationContext<Op>,ExecRow> {", "originalCommit": "76010a3390f9fa3114ae7527d8e1108d96843268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ1NzMwNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4880#discussion_r547457307", "bodyText": "You're right, I wanted initially to make it a full-fledged SpliceFunction that I inject in the plan execution, but along the way I reduced it to a normal static function. I will refactor it accordingly.", "author": "hatyo", "createdAt": "2020-12-22T19:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNDc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "d3592e08ee2426ffb06628a8ca8db68a3bbe6675", "chunk": "diff --git a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/BaseRowLocatorFunction.java b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/BaseRowLocatorFunction.java\nindex 8a1f891e91..9ecbd3e9af 100644\n--- a/splice_machine/src/main/java/com/splicemachine/derby/stream/function/BaseRowLocatorFunction.java\n+++ b/splice_machine/src/main/java/com/splicemachine/derby/stream/function/BaseRowLocatorFunction.java\n\n@@ -13,6 +13,7 @@\n \n package com.splicemachine.derby.stream.function;\n \n+import com.splicemachine.db.iapi.error.StandardException;\n import com.splicemachine.db.iapi.sql.execute.ExecRow;\n import com.splicemachine.derby.iapi.sql.execute.SpliceOperation;\n import com.splicemachine.derby.impl.sql.execute.operations.IndexRowToBaseRowOperation;\n"}}, {"oid": "d3592e08ee2426ffb06628a8ca8db68a3bbe6675", "url": "https://github.com/splicemachine/spliceengine/commit/d3592e08ee2426ffb06628a8ca8db68a3bbe6675", "message": "DB-10882 address comments.", "committedDate": "2020-12-22T19:32:02Z", "type": "commit"}]}