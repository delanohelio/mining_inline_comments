{"pr_number": 561, "pr_title": "analysis/_running-time", "pr_createdAt": "2020-01-06T21:22:10Z", "pr_url": "https://github.com/phac-nml/irida/pull/561", "timeline": [{"oid": "3784f31cb5b7466caf53531b67f120dff5506d0d", "url": "https://github.com/phac-nml/irida/commit/3784f31cb5b7466caf53531b67f120dff5506d0d", "message": "Correct running time is displayed for analyses in any state rather than just completed", "committedDate": "2020-01-06T21:20:41Z", "type": "commit"}, {"oid": "fea97518cbd6374235b8ace2996fa3aac321e5ae", "url": "https://github.com/phac-nml/irida/commit/fea97518cbd6374235b8ace2996fa3aac321e5ae", "message": "Updated analyses table to use AnalysisAuditing to display the correct duration for all states", "committedDate": "2020-01-06T22:08:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1NTM1NQ==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363755355", "bodyText": "Why not make the AnalysisAuditing a component and have the EntityManagerFactory autowired into it?", "author": "joshsadam", "createdAt": "2020-01-07T13:50:06Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/AnalysesAjaxController.java", "diffHunk": "@@ -204,11 +208,9 @@ private AnalysisModel createAnalysisModel(AnalysisSubmission submission, Locale\n \t\tString stateString = messageSource.getMessage(\"analysis.state.\" + analysisState.toString(), null, locale);\n \t\tAnalysisStateModel state = new AnalysisStateModel(stateString, analysisState.toString());\n \t\tString workflow = messageSource.getMessage(\"workflow.\" + workflowType + \".title\", null, workflowType, locale);\n-\t\tLong duration = 0L;\n-\t\tif (analysisState.equals(AnalysisState.COMPLETED)) {\n-\t\t\tduration = DateUtilities.getDurationInMilliseconds(submission.getCreatedDate(), submission.getAnalysis()\n-\t\t\t\t\t.getCreatedDate());\n-\t\t}\n+\n+\t\tAnalysisAuditing analysisAudit = new AnalysisAuditing(entityManagerFactory);", "originalCommit": "fea97518cbd6374235b8ace2996fa3aac321e5ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwODg2NA==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363808864", "bodyText": "Removed Entity Manager/Audit Reader and annotated the class as a component in 6766c8e", "author": "deepsidhu85", "createdAt": "2020-01-07T15:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1NTM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "chunk": "diff --git a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/AnalysesAjaxController.java b/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/AnalysesAjaxController.java\nindex 14b1b192a1..87b884ae5b 100644\n--- a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/AnalysesAjaxController.java\n+++ b/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/AnalysesAjaxController.java\n\n@@ -209,7 +207,6 @@ public class AnalysesAjaxController {\n \t\tAnalysisStateModel state = new AnalysisStateModel(stateString, analysisState.toString());\n \t\tString workflow = messageSource.getMessage(\"workflow.\" + workflowType + \".title\", null, workflowType, locale);\n \n-\t\tAnalysisAuditing analysisAudit = new AnalysisAuditing(entityManagerFactory);\n \t\tLong duration = analysisAudit.getAnalysisRunningTime(submission);\n \n \t\t/*\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc1NjAwOA==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363756008", "bodyText": "@tom114 can you take a look at this class and add your review to it please?", "author": "joshsadam", "createdAt": "2020-01-07T13:51:33Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n+\n+/*\n+ * This class is used for auditing analysis submissions using\n+ * AuditReader and EntityManagerFactory.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+\n+import org.hibernate.envers.AuditReader;\n+import org.hibernate.envers.AuditReaderFactory;\n+import org.hibernate.envers.query.AuditEntity;\n+\n+import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n+import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n+import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n+\n+public class AnalysisAuditing {\n+\tprivate EntityManagerFactory entityManagerFactory;\n+\n+\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n+\t\tthis.entityManagerFactory=entityManagerFactory;\n+\t}\n+\n+\t/**\n+\t * Gets the running time of an analysis\n+\t *\n+\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n+\t * @return {@link Long} Running time of the analysis\n+\t */\n+\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n+\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();", "originalCommit": "fea97518cbd6374235b8ace2996fa3aac321e5ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "chunk": "diff --git a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java b/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\ndeleted file mode 100644\nindex caeec5694d..0000000000\n--- a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n-\n-/*\n- * This class is used for auditing analysis submissions using\n- * AuditReader and EntityManagerFactory.\n- */\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityManagerFactory;\n-\n-import org.hibernate.envers.AuditReader;\n-import org.hibernate.envers.AuditReaderFactory;\n-import org.hibernate.envers.query.AuditEntity;\n-\n-import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n-import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n-import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n-\n-public class AnalysisAuditing {\n-\tprivate EntityManagerFactory entityManagerFactory;\n-\n-\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n-\t\tthis.entityManagerFactory=entityManagerFactory;\n-\t}\n-\n-\t/**\n-\t * Gets the running time of an analysis\n-\t *\n-\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n-\t * @return {@link Long} Running time of the analysis\n-\t */\n-\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tArrayList<AnalysisSubmission> uniqueAuditedSubmissions = new ArrayList<>();\n-\t\tif (audit != null ) {\n-\t\t\t// Gets a list of the analysis submission revisions for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submission.getId()))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\tArrayList<String> auditedStates = new ArrayList<>();\n-\n-\t\t\t// Get a unique list of the audited submissions based on the state\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && !auditedStates.contains(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t.toString())) {\n-\t\t\t\t\tauditedStates.add(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t\t.toString());\n-\t\t\t\t\tuniqueAuditedSubmissions.add(auditedSubmission);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// Get the run time of the analysis from creation till completion/error\n-\t\t\treturn DateUtilities.getDurationInMilliseconds(submission.getCreatedDate(),\n-\t\t\t\t\tuniqueAuditedSubmissions.get(uniqueAuditedSubmissions.size() - 1)\n-\t\t\t\t\t\t\t.getModifiedDate());\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\t\treturn 0L;\n-\t}\n-\n-\t/**\n-\t * Gets the state of analysis prior to error\n-\t *\n-\t * @param submissionId {@link Long} identifier for an {@link AnalysisSubmission}\n-\t * @return {@link String} State of analysis prior to error\n-\t */\n-\tpublic AnalysisState getPreviousStateBeforeError(Long submissionId) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tAnalysisSubmission previousRevision = null;\n-\n-\t\tif (audit != null) {\n-\t\t\t// Get revisions from the analysis submission audit table for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submissionId))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\t// Go through the revisions and find the first one with an error. The revision\n-\t\t\t// prior is set to the previousRevision\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && auditedSubmission.getAnalysisState() == AnalysisState.ERROR) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tpreviousRevision = auditedSubmission;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\n-\t\tif (previousRevision == null) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn previousRevision.getAnalysisState();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc3ODc5NA==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363778794", "bodyText": "Rather than deal with all this AuditReader stuff you should be able to get everything from the AnalysisSubmissionRepository.  It extends RevisionRepository which should have the methods you need to get the history you're grabbing below.  See docs at https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/history/RevisionRepository.html?is-external=true", "author": "tom114", "createdAt": "2020-01-07T14:41:45Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n+\n+/*\n+ * This class is used for auditing analysis submissions using\n+ * AuditReader and EntityManagerFactory.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+\n+import org.hibernate.envers.AuditReader;\n+import org.hibernate.envers.AuditReaderFactory;\n+import org.hibernate.envers.query.AuditEntity;\n+\n+import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n+import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n+import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n+\n+public class AnalysisAuditing {\n+\tprivate EntityManagerFactory entityManagerFactory;\n+\n+\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n+\t\tthis.entityManagerFactory=entityManagerFactory;\n+\t}\n+\n+\t/**\n+\t * Gets the running time of an analysis\n+\t *\n+\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n+\t * @return {@link Long} Running time of the analysis\n+\t */\n+\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n+\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n+\t\tAuditReader audit = AuditReaderFactory.get(entityManager);", "originalCommit": "fea97518cbd6374235b8ace2996fa3aac321e5ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwOTAzOA==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363809038", "bodyText": "Thanks Tom! Updated in 6766c8e", "author": "deepsidhu85", "createdAt": "2020-01-07T15:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc3ODc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "chunk": "diff --git a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java b/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\ndeleted file mode 100644\nindex caeec5694d..0000000000\n--- a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n-\n-/*\n- * This class is used for auditing analysis submissions using\n- * AuditReader and EntityManagerFactory.\n- */\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityManagerFactory;\n-\n-import org.hibernate.envers.AuditReader;\n-import org.hibernate.envers.AuditReaderFactory;\n-import org.hibernate.envers.query.AuditEntity;\n-\n-import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n-import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n-import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n-\n-public class AnalysisAuditing {\n-\tprivate EntityManagerFactory entityManagerFactory;\n-\n-\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n-\t\tthis.entityManagerFactory=entityManagerFactory;\n-\t}\n-\n-\t/**\n-\t * Gets the running time of an analysis\n-\t *\n-\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n-\t * @return {@link Long} Running time of the analysis\n-\t */\n-\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tArrayList<AnalysisSubmission> uniqueAuditedSubmissions = new ArrayList<>();\n-\t\tif (audit != null ) {\n-\t\t\t// Gets a list of the analysis submission revisions for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submission.getId()))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\tArrayList<String> auditedStates = new ArrayList<>();\n-\n-\t\t\t// Get a unique list of the audited submissions based on the state\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && !auditedStates.contains(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t.toString())) {\n-\t\t\t\t\tauditedStates.add(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t\t.toString());\n-\t\t\t\t\tuniqueAuditedSubmissions.add(auditedSubmission);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// Get the run time of the analysis from creation till completion/error\n-\t\t\treturn DateUtilities.getDurationInMilliseconds(submission.getCreatedDate(),\n-\t\t\t\t\tuniqueAuditedSubmissions.get(uniqueAuditedSubmissions.size() - 1)\n-\t\t\t\t\t\t\t.getModifiedDate());\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\t\treturn 0L;\n-\t}\n-\n-\t/**\n-\t * Gets the state of analysis prior to error\n-\t *\n-\t * @param submissionId {@link Long} identifier for an {@link AnalysisSubmission}\n-\t * @return {@link String} State of analysis prior to error\n-\t */\n-\tpublic AnalysisState getPreviousStateBeforeError(Long submissionId) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tAnalysisSubmission previousRevision = null;\n-\n-\t\tif (audit != null) {\n-\t\t\t// Get revisions from the analysis submission audit table for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submissionId))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\t// Go through the revisions and find the first one with an error. The revision\n-\t\t\t// prior is set to the previousRevision\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && auditedSubmission.getAnalysisState() == AnalysisState.ERROR) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tpreviousRevision = auditedSubmission;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\n-\t\tif (previousRevision == null) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn previousRevision.getAnalysisState();\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc3OTA3NA==", "url": "https://github.com/phac-nml/irida/pull/561#discussion_r363779074", "bodyText": "Yeah definitely try to use the AnalysisSubmissionRepository/RevisionRepository.  It'll avoid so much of this stuff.", "author": "tom114", "createdAt": "2020-01-07T14:42:21Z", "path": "src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n+\n+/*\n+ * This class is used for auditing analysis submissions using\n+ * AuditReader and EntityManagerFactory.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+\n+import org.hibernate.envers.AuditReader;\n+import org.hibernate.envers.AuditReaderFactory;\n+import org.hibernate.envers.query.AuditEntity;\n+\n+import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n+import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n+import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n+\n+public class AnalysisAuditing {\n+\tprivate EntityManagerFactory entityManagerFactory;\n+\n+\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n+\t\tthis.entityManagerFactory=entityManagerFactory;\n+\t}\n+\n+\t/**\n+\t * Gets the running time of an analysis\n+\t *\n+\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n+\t * @return {@link Long} Running time of the analysis\n+\t */\n+\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n+\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n+\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n+\t\tArrayList<AnalysisSubmission> uniqueAuditedSubmissions = new ArrayList<>();\n+\t\tif (audit != null ) {\n+\t\t\t// Gets a list of the analysis submission revisions for the submission\n+\t\t\tList<?> auditResultSet = audit.createQuery()\n+\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n+\t\t\t\t\t.add(AuditEntity.id()\n+\t\t\t\t\t\t\t.eq(submission.getId()))\n+\t\t\t\t\t.getResultList();\n+\t\t\t// release the db connection\n+\t\t\tentityManager.close();\n+\t\t\tArrayList<String> auditedStates = new ArrayList<>();\n+\n+\t\t\t// Get a unique list of the audited submissions based on the state\n+\t\t\tfor (Object auditResult : auditResultSet) {\n+\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n+\t\t\t\tif (auditedSubmission != null && !auditedStates.contains(auditedSubmission.getAnalysisState()\n+\t\t\t\t\t\t.toString())) {\n+\t\t\t\t\tauditedStates.add(auditedSubmission.getAnalysisState()\n+\t\t\t\t\t\t\t.toString());\n+\t\t\t\t\tuniqueAuditedSubmissions.add(auditedSubmission);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// Get the run time of the analysis from creation till completion/error\n+\t\t\treturn DateUtilities.getDurationInMilliseconds(submission.getCreatedDate(),\n+\t\t\t\t\tuniqueAuditedSubmissions.get(uniqueAuditedSubmissions.size() - 1)\n+\t\t\t\t\t\t\t.getModifiedDate());\n+\t\t}\n+\n+\t\t// Before returning we double check to make sure\n+\t\t// the connection to the db has been released\n+\t\tif(entityManager.isOpen()) {\n+\t\t\tentityManager.close();", "originalCommit": "fea97518cbd6374235b8ace2996fa3aac321e5ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "chunk": "diff --git a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java b/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\ndeleted file mode 100644\nindex caeec5694d..0000000000\n--- a/src/main/java/ca/corefacility/bioinformatics/irida/ria/web/analysis/auditing/AnalysisAuditing.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-package ca.corefacility.bioinformatics.irida.ria.web.analysis.auditing;\n-\n-/*\n- * This class is used for auditing analysis submissions using\n- * AuditReader and EntityManagerFactory.\n- */\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityManagerFactory;\n-\n-import org.hibernate.envers.AuditReader;\n-import org.hibernate.envers.AuditReaderFactory;\n-import org.hibernate.envers.query.AuditEntity;\n-\n-import ca.corefacility.bioinformatics.irida.model.enums.AnalysisState;\n-import ca.corefacility.bioinformatics.irida.model.workflow.submission.AnalysisSubmission;\n-import ca.corefacility.bioinformatics.irida.ria.web.utilities.DateUtilities;\n-\n-public class AnalysisAuditing {\n-\tprivate EntityManagerFactory entityManagerFactory;\n-\n-\tpublic AnalysisAuditing(EntityManagerFactory entityManagerFactory) {\n-\t\tthis.entityManagerFactory=entityManagerFactory;\n-\t}\n-\n-\t/**\n-\t * Gets the running time of an analysis\n-\t *\n-\t * @param submission {@link AnalysisSubmission} The submission {@link AnalysisSubmission}\n-\t * @return {@link Long} Running time of the analysis\n-\t */\n-\tpublic Long getAnalysisRunningTime(AnalysisSubmission submission) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tArrayList<AnalysisSubmission> uniqueAuditedSubmissions = new ArrayList<>();\n-\t\tif (audit != null ) {\n-\t\t\t// Gets a list of the analysis submission revisions for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submission.getId()))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\tArrayList<String> auditedStates = new ArrayList<>();\n-\n-\t\t\t// Get a unique list of the audited submissions based on the state\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && !auditedStates.contains(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t.toString())) {\n-\t\t\t\t\tauditedStates.add(auditedSubmission.getAnalysisState()\n-\t\t\t\t\t\t\t.toString());\n-\t\t\t\t\tuniqueAuditedSubmissions.add(auditedSubmission);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// Get the run time of the analysis from creation till completion/error\n-\t\t\treturn DateUtilities.getDurationInMilliseconds(submission.getCreatedDate(),\n-\t\t\t\t\tuniqueAuditedSubmissions.get(uniqueAuditedSubmissions.size() - 1)\n-\t\t\t\t\t\t\t.getModifiedDate());\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\t\treturn 0L;\n-\t}\n-\n-\t/**\n-\t * Gets the state of analysis prior to error\n-\t *\n-\t * @param submissionId {@link Long} identifier for an {@link AnalysisSubmission}\n-\t * @return {@link String} State of analysis prior to error\n-\t */\n-\tpublic AnalysisState getPreviousStateBeforeError(Long submissionId) {\n-\t\tEntityManager entityManager = entityManagerFactory.createEntityManager();\n-\t\tAuditReader audit = AuditReaderFactory.get(entityManager);\n-\t\tAnalysisSubmission previousRevision = null;\n-\n-\t\tif (audit != null) {\n-\t\t\t// Get revisions from the analysis submission audit table for the submission\n-\t\t\tList<?> auditResultSet = audit.createQuery()\n-\t\t\t\t\t.forRevisionsOfEntity(AnalysisSubmission.class, true, false)\n-\t\t\t\t\t.add(AuditEntity.id()\n-\t\t\t\t\t\t\t.eq(submissionId))\n-\t\t\t\t\t.getResultList();\n-\t\t\t// release the db connection\n-\t\t\tentityManager.close();\n-\t\t\t// Go through the revisions and find the first one with an error. The revision\n-\t\t\t// prior is set to the previousRevision\n-\t\t\tfor (Object auditResult : auditResultSet) {\n-\t\t\t\tAnalysisSubmission auditedSubmission = (AnalysisSubmission) auditResult;\n-\t\t\t\tif (auditedSubmission != null && auditedSubmission.getAnalysisState() == AnalysisState.ERROR) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tpreviousRevision = auditedSubmission;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Before returning we double check to make sure\n-\t\t// the connection to the db has been released\n-\t\tif(entityManager.isOpen()) {\n-\t\t\tentityManager.close();\n-\t\t}\n-\n-\t\tif (previousRevision == null) {\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn previousRevision.getAnalysisState();\n-\t}\n-}\n"}}, {"oid": "6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "url": "https://github.com/phac-nml/irida/commit/6766c8ecf35d0d185900b8e1958aca1fa9d2d409", "message": "Removed audit reader and entity manager and made use of analysisSubmissionRepository revisions extension", "committedDate": "2020-01-07T15:39:01Z", "type": "commit"}, {"oid": "9f8ca01216438d8e96e3060286681374e07294d0", "url": "https://github.com/phac-nml/irida/commit/9f8ca01216438d8e96e3060286681374e07294d0", "message": "Formatted code and added javadoc comment", "committedDate": "2020-01-07T15:53:39Z", "type": "commit"}, {"oid": "4153a2d27c9ce6ec56127cc2f79e66900c07722a", "url": "https://github.com/phac-nml/irida/commit/4153a2d27c9ce6ec56127cc2f79e66900c07722a", "message": "Changed auditedStates to use a set rather than an arraylist", "committedDate": "2020-01-07T16:47:49Z", "type": "commit"}, {"oid": "bf9702896523a3c8c0c02f057ac2b8e6972c3c66", "url": "https://github.com/phac-nml/irida/commit/bf9702896523a3c8c0c02f057ac2b8e6972c3c66", "message": "Merge branch 'analysis/_base_results' into analysis/_running-time", "committedDate": "2020-01-07T17:10:45Z", "type": "commit"}, {"oid": "03c8363d1ae37e2b3c2178eaeefa40fa215842e3", "url": "https://github.com/phac-nml/irida/commit/03c8363d1ae37e2b3c2178eaeefa40fa215842e3", "message": "Updated method to check if there are uniqueAuditedSubmissions before returning a duration", "committedDate": "2020-01-07T21:37:53Z", "type": "commit"}, {"oid": "55bb6a2f85767dd40b223cf06930d12b4bfc7dfe", "url": "https://github.com/phac-nml/irida/commit/55bb6a2f85767dd40b223cf06930d12b4bfc7dfe", "message": "Removed unused import", "committedDate": "2020-01-08T17:01:42Z", "type": "commit"}, {"oid": "d79bd9e34397dd9751f6a05054ca0d7a87fea550", "url": "https://github.com/phac-nml/irida/commit/d79bd9e34397dd9751f6a05054ca0d7a87fea550", "message": "Added comments", "committedDate": "2020-01-08T18:11:20Z", "type": "commit"}]}