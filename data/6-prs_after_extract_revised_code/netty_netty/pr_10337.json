{"pr_number": 10337, "pr_title": "Fix possible StackOverflowError when try to resolve authorative names\u2026", "pr_createdAt": "2020-06-02T13:13:38Z", "pr_url": "https://github.com/netty/netty/pull/10337", "timeline": [{"oid": "3a59f507f325c3a27fdbffd8a4aca1293d1ae648", "url": "https://github.com/netty/netty/commit/3a59f507f325c3a27fdbffd8a4aca1293d1ae648", "message": "Fix possible StackOverflowError when try to resolve authorative nameservers\n\nMotivation:\n\nThere is a possibility to end up with a StackOverflowError when trying to resolve authorative nameservers because of incorrect wrapping the AuthoritativeDnsServerCache.\n\nModifications:\n\nEnsure we don't end up with an overflow due wrapping\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10246", "committedDate": "2020-06-02T14:09:45Z", "type": "commit"}, {"oid": "3a59f507f325c3a27fdbffd8a4aca1293d1ae648", "url": "https://github.com/netty/netty/commit/3a59f507f325c3a27fdbffd8a4aca1293d1ae648", "message": "Fix possible StackOverflowError when try to resolve authorative nameservers\n\nMotivation:\n\nThere is a possibility to end up with a StackOverflowError when trying to resolve authorative nameservers because of incorrect wrapping the AuthoritativeDnsServerCache.\n\nModifications:\n\nEnsure we don't end up with an overflow due wrapping\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10246", "committedDate": "2020-06-02T14:09:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MzY5MA==", "url": "https://github.com/netty/netty/pull/10337#discussion_r434043690", "bodyText": "Consider the opposite approach: write a utility method that will wrap only if it's not an instance of RedirectAuthoritativeDnsServerCache. That will help to avoid allocation of a new object when it's already wrapped.", "author": "idelpivnitskiy", "createdAt": "2020-06-02T17:19:42Z", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -498,34 +498,49 @@ public void operationComplete(final Future<List<InetAddress>> future) {\n                 }\n             }\n         });\n-        if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache(),\n+        DnsCache resolveCache = resolveCache();\n+        if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache,\n                 parent.resolvedInternetProtocolFamiliesUnsafe())) {\n-            final AuthoritativeDnsServerCache authoritativeDnsServerCache = authoritativeDnsServerCache();\n             new DnsAddressResolveContext(parent, originalPromise, nameServerName, additionals,\n-                                         parent.newNameServerAddressStream(nameServerName),\n-                                         resolveCache(), new AuthoritativeDnsServerCache() {\n-                @Override\n-                public DnsServerAddressStream get(String hostname) {\n-                    // To not risk falling into any loop, we will not use the cache while following redirects but only\n-                    // on the initial query.\n-                    return null;\n-                }\n+                                         parent.newNameServerAddressStream(nameServerName), resolveCache,\n+                                         new RedirectAuthoritativeDnsServerCache(authoritativeDnsServerCache()), false)\n+                    .resolve(resolverPromise);\n+        }\n+    }\n \n-                @Override\n-                public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\n-                    authoritativeDnsServerCache.cache(hostname, address, originalTtl, loop);\n-                }\n+    private static final class RedirectAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\n+        private final AuthoritativeDnsServerCache wrapped;\n \n-                @Override\n-                public void clear() {\n-                    authoritativeDnsServerCache.clear();\n-                }\n+        RedirectAuthoritativeDnsServerCache(AuthoritativeDnsServerCache authoritativeDnsServerCache) {\n+            // Unwrap to prevent the possibility of an StackOverflowError when wrapping another\n+            // RedirectAuthoritativeDnsServerCache.\n+            if (authoritativeDnsServerCache instanceof RedirectAuthoritativeDnsServerCache) {\n+                this.wrapped = ((RedirectAuthoritativeDnsServerCache) authoritativeDnsServerCache).wrapped;\n+            } else {\n+                this.wrapped = authoritativeDnsServerCache;", "originalCommit": "3a59f507f325c3a27fdbffd8a4aca1293d1ae648", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cc3192eda047ae78d674e17b845cf940ba32ebc9", "chunk": "diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java\nindex 728f68687d..78c9514ced 100644\n--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java\n+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java\n\n@@ -503,22 +503,26 @@ abstract class DnsResolveContext<T> {\n                 parent.resolvedInternetProtocolFamiliesUnsafe())) {\n             new DnsAddressResolveContext(parent, originalPromise, nameServerName, additionals,\n                                          parent.newNameServerAddressStream(nameServerName), resolveCache,\n-                                         new RedirectAuthoritativeDnsServerCache(authoritativeDnsServerCache()), false)\n+                                         redirectAuthoritativeDnsServerCache(authoritativeDnsServerCache()), false)\n                     .resolve(resolverPromise);\n         }\n     }\n \n+    private static AuthoritativeDnsServerCache redirectAuthoritativeDnsServerCache(\n+            AuthoritativeDnsServerCache authoritativeDnsServerCache) {\n+        // Don't wrap again to prevent the possibility of an StackOverflowError when wrapping another\n+        // RedirectAuthoritativeDnsServerCache.\n+        if (authoritativeDnsServerCache instanceof RedirectAuthoritativeDnsServerCache) {\n+            return authoritativeDnsServerCache;\n+        }\n+        return new RedirectAuthoritativeDnsServerCache(authoritativeDnsServerCache);\n+    }\n+\n     private static final class RedirectAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\n         private final AuthoritativeDnsServerCache wrapped;\n \n         RedirectAuthoritativeDnsServerCache(AuthoritativeDnsServerCache authoritativeDnsServerCache) {\n-            // Unwrap to prevent the possibility of an StackOverflowError when wrapping another\n-            // RedirectAuthoritativeDnsServerCache.\n-            if (authoritativeDnsServerCache instanceof RedirectAuthoritativeDnsServerCache) {\n-                this.wrapped = ((RedirectAuthoritativeDnsServerCache) authoritativeDnsServerCache).wrapped;\n-            } else {\n-                this.wrapped = authoritativeDnsServerCache;\n-            }\n+            this.wrapped = authoritativeDnsServerCache;\n         }\n \n         @Override\n"}}, {"oid": "cc3192eda047ae78d674e17b845cf940ba32ebc9", "url": "https://github.com/netty/netty/commit/cc3192eda047ae78d674e17b845cf940ba32ebc9", "message": "Address review", "committedDate": "2020-06-03T06:31:31Z", "type": "commit"}]}