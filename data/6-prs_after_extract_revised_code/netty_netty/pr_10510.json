{"pr_number": 10510, "pr_title": "Clear scheduled timeout if channel is closed with incomplete WebSocket handshake", "pr_createdAt": "2020-08-28T02:32:22Z", "pr_url": "https://github.com/netty/netty/pull/10510", "timeline": [{"oid": "668626675009be4c7793a2a4df498c58c2b71b2e", "url": "https://github.com/netty/netty/commit/668626675009be4c7793a2a4df498c58c2b71b2e", "message": "Clear scheduled timeout if channel is closed without completing WebSocket handshake\n\nMotivation:\n\nConsider a scenario when the client iniitiates a WebSocket handshake but before the handshake is complete,\nthe channel is closed due to some reason. In such scenario, the handshake timeout scheduled on the executor\nis not cleared. The reason it is not cleared is because in such cases the handshakePromise is not completed.\n\nModifications:\n\nThis change completes the handshakePromise exceptinoally on channelInactive callback, if it has not been\ncompleted so far. This triggers the callback on completion of the promise which clears the timeout scheduled\non the executor.\n\nThis PR also adds a test case which reproduces the scenario described above. The test case fails before the\nfix is added and succeeds when the fix is applied.\n\nResult:\n\nAfter this change, the timeout scheduled on the executor will be cleared, thus freeing up thread resources.", "committedDate": "2020-08-28T02:29:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg0Nzk5MQ==", "url": "https://github.com/netty/netty/pull/10510#discussion_r478847991", "bodyText": "Lets first check if it\u2019s done yet and only if this is not true try to fail it. This will reduce the overhead in most cases as we will not create the extra exception", "author": "normanmaurer", "createdAt": "2020-08-28T06:00:53Z", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java", "diffHunk": "@@ -70,6 +70,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         applyHandshakeTimeout();\n     }\n \n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        handshakePromise.tryFailure(new WebSocketHandshakeException(\"channel closed with handshake in progress\"));", "originalCommit": "668626675009be4c7793a2a4df498c58c2b71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2ODkyMw==", "url": "https://github.com/netty/netty/pull/10510#discussion_r479468923", "bodyText": "Done.", "author": "divijvaidya", "createdAt": "2020-08-28T18:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg0Nzk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1d0bef774c4efa2e41e54f630ef20e5756590fca", "chunk": "diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java\nindex 9e38e24c9c..c8e96eb700 100644\n--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java\n+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java\n\n@@ -72,7 +72,10 @@ class WebSocketClientProtocolHandshakeHandler extends ChannelInboundHandlerAdapt\n \n     @Override\n     public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        handshakePromise.tryFailure(new WebSocketHandshakeException(\"channel closed with handshake in progress\"));\n+        if (!handshakePromise.isDone()) {\n+            handshakePromise.tryFailure(new WebSocketHandshakeException(\"channel closed with handshake in progress\"));\n+        }\n+\n         super.channelInactive(ctx);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNDk0Ng==", "url": "https://github.com/netty/netty/pull/10510#discussion_r479334946", "bodyText": "Sorry maybe I miss something, how server can send close websocket frame if handshake is not complete yet.", "author": "amizurov", "createdAt": "2020-08-28T14:17:03Z", "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. This close could be initiated by the server by\n+        // sending the CloseWebSocket frame. To reproduce the test scenario for this test case,", "originalCommit": "668626675009be4c7793a2a4df498c58c2b71b2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2OTcwMA==", "url": "https://github.com/netty/netty/pull/10510#discussion_r479469700", "bodyText": "You are right. This is a bad example of a scenario for a channel close. I have changed the comment to remove this description. However, apart from this incorrect example, there can be number of cases when the channel might be closed before the handshake is complete. I have provide an example where SSL handshake fails below in the other comment.", "author": "divijvaidya", "createdAt": "2020-08-28T18:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNDk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "1d0bef774c4efa2e41e54f630ef20e5756590fca", "chunk": "diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\nindex 44969c228b..33ceb0d404 100644\n--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\n+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\n\n@@ -203,8 +203,8 @@ public class WebSocketHandshakeHandOverTest {\n \n         final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n \n-        // Close the channel while the handshake is in progress. This close could be initiated by the server by\n-        // sending the CloseWebSocket frame. To reproduce the test scenario for this test case,\n+        // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n+        // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n         // we would manually close the channel.\n         clientWsHandler.close(ctx, ctx.newPromise());\n \n"}}, {"oid": "1d0bef774c4efa2e41e54f630ef20e5756590fca", "url": "https://github.com/netty/netty/commit/1d0bef774c4efa2e41e54f630ef20e5756590fca", "message": "Check from completion of promise before failing it", "committedDate": "2020-08-28T18:26:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1OTcxMA==", "url": "https://github.com/netty/netty/pull/10510#discussion_r487559710", "bodyText": "Also call clientChannel.finishAndReleaseAll() and serverChannel.finishAndReleaseAll() otherwise we have leaks", "author": "normanmaurer", "createdAt": "2020-09-13T18:13:34Z", "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n+        // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n+        // we would manually close the channel.\n+        clientWsHandler.close(ctx, ctx.newPromise());\n+\n+        // At this stage handshake is incomplete but the handshake future should be completed exceptionally since\n+        // channel is closed.\n+        assertTrue(clientWsHandshakeHandler.getHandshakeFuture().isDone());", "originalCommit": "1d0bef774c4efa2e41e54f630ef20e5756590fca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0OTIxNg==", "url": "https://github.com/netty/netty/pull/10510#discussion_r488349216", "bodyText": "updated", "author": "divijvaidya", "createdAt": "2020-09-15T02:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1OTcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "67c21c5ded2571280c6b13e3c5e87e6d2893e4d8", "chunk": "diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\nindex 33ceb0d404..41d4578d32 100644\n--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\n+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java\n\n@@ -193,24 +193,29 @@ public class WebSocketHandshakeHandOverTest {\n         EmbeddedChannel clientChannel = createClientChannel(null);\n         EmbeddedChannel serverChannel = createServerChannel(null);\n \n-        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n-        transferAllDataWithMerge(clientChannel, serverChannel);\n+        try {\n+            // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+            transferAllDataWithMerge(clientChannel, serverChannel);\n \n-        final WebSocketClientProtocolHandler clientWsHandler =\n-                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n-        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n-                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+            final WebSocketClientProtocolHandler clientWsHandler =\n+                    clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+            final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                    clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n \n-        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+            final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n \n-        // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n-        // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n-        // we would manually close the channel.\n-        clientWsHandler.close(ctx, ctx.newPromise());\n+            // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n+            // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n+            // we would manually close the channel.\n+            clientWsHandler.close(ctx, ctx.newPromise());\n \n-        // At this stage handshake is incomplete but the handshake future should be completed exceptionally since\n-        // channel is closed.\n-        assertTrue(clientWsHandshakeHandler.getHandshakeFuture().isDone());\n+            // At this stage handshake is incomplete but the handshake future should be completed exceptionally since\n+            // channel is closed.\n+            assertTrue(clientWsHandshakeHandler.getHandshakeFuture().isDone());\n+        } finally {\n+            serverChannel.finishAndReleaseAll();\n+            clientChannel.finishAndReleaseAll();\n+        }\n     }\n \n     @Test(timeout = 10000)\n"}}, {"oid": "67c21c5ded2571280c6b13e3c5e87e6d2893e4d8", "url": "https://github.com/netty/netty/commit/67c21c5ded2571280c6b13e3c5e87e6d2893e4d8", "message": "Clean up resources after test is complete", "committedDate": "2020-09-15T02:38:31Z", "type": "commit"}]}