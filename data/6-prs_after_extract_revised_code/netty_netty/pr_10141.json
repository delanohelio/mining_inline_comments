{"pr_number": 10141, "pr_title": "Replace usage() with freeBytes() in thresholds within hot paths of PoolChunkList", "pr_createdAt": "2020-03-27T20:20:38Z", "pr_url": "https://github.com/netty/netty/pull/10141", "timeline": [{"oid": "35338adc66d2b7833c58746b7cdc9e107ad6d2f3", "url": "https://github.com/netty/netty/commit/35338adc66d2b7833c58746b7cdc9e107ad6d2f3", "message": "Replace usage() with freeBytes() in thresholds within hot paths of PoolChunkList\n\nMotivation:\nPoolChunk.usage() method has non-trivial computations. It is used currently in hot path methods invoked when an allocation and de-allocation are happened.\nThe idea is to replace usage() output comparison against percent thresholds by Chunk.freeBytes plain comparison against absolute thresholds. In such way the majority of computations from the threshold conditions are moved to init logic.\n\nModifications:\nReplace PoolChunk.usage() conditions in PoolChunkList with equivalent conditions for PoolChunk.freeBytes()\n\nResult:\nImprove performance of allocation and de-allocation of ByteBuf from normal size cache pool", "committedDate": "2020-03-27T19:38:24Z", "type": "commit"}, {"oid": "dc46a664c00b8618639b345bbfed39668375ef7f", "url": "https://github.com/netty/netty/commit/dc46a664c00b8618639b345bbfed39668375ef7f", "message": "Use direct access to freeBytes in PoolChunk for allocation/de-allocation logic without extra sync block", "committedDate": "2020-03-28T15:36:09Z", "type": "commit"}, {"oid": "7802e9039ae7173513cef4c10d8d3ca0dbafd883", "url": "https://github.com/netty/netty/commit/7802e9039ae7173513cef4c10d8d3ca0dbafd883", "message": "Add simple benchmark for PooledByteBufAllocator\nAdd -XX:BiasedLockingStartupDelay=0 to JMH benchmarks to correctly evaluate synchronization cost", "committedDate": "2020-03-28T18:40:19Z", "type": "commit"}, {"oid": "e92a206a989efa2b317175f72b47209d1819383b", "url": "https://github.com/netty/netty/commit/e92a206a989efa2b317175f72b47209d1819383b", "message": "Add consumeCPU to SimpleByteBufPooledAllocatorBenchmark to amortize heavyweight (for the CPU cache) atomic operations using by acquire/release on pool, based on review comments", "committedDate": "2020-03-29T13:15:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MjIxNQ==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400042215", "bodyText": "@netudima nit: can you add a comment to explain the \"formula\" you used to calculate both ?", "author": "normanmaurer", "createdAt": "2020-03-30T09:16:29Z", "path": "buffer/src/main/java/io/netty/buffer/PoolChunkList.java", "diffHunk": "@@ -49,6 +51,8 @@\n         this.minUsage = minUsage;\n         this.maxUsage = maxUsage;\n         maxCapacity = calculateMaxCapacity(minUsage, chunkSize);\n+        freeMinThreshold = (maxUsage == 100) ? 0 : (int) (chunkSize * (100L - maxUsage + 1) / 100L);\n+        freeMaxThreshold = (minUsage == 100) ? 0 : (int) (chunkSize * (100L - minUsage + 1) / 100L - 1);", "originalCommit": "e92a206a989efa2b317175f72b47209d1819383b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwODY0Nw==", "url": "https://github.com/netty/netty/pull/10141#discussion_r401108647", "bodyText": "Added a comment + updated the logic a bit to fully align old usage() based logic and the new one. How it has been verified:  https://gist.github.com/netudima/454ba97d8154109a50ae831bafc8e151", "author": "netudima", "createdAt": "2020-03-31T18:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MjIxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9ad322e837b69a1215099c7db07dce4d9e4cb809", "chunk": "diff --git a/buffer/src/main/java/io/netty/buffer/PoolChunkList.java b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java\nindex aa7a9d43b1..bbdc65590d 100644\n--- a/buffer/src/main/java/io/netty/buffer/PoolChunkList.java\n+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java\n\n@@ -51,8 +51,24 @@ final class PoolChunkList<T> implements PoolChunkListMetric {\n         this.minUsage = minUsage;\n         this.maxUsage = maxUsage;\n         maxCapacity = calculateMaxCapacity(minUsage, chunkSize);\n-        freeMinThreshold = (maxUsage == 100) ? 0 : (int) (chunkSize * (100L - maxUsage + 1) / 100L);\n-        freeMaxThreshold = (minUsage == 100) ? 0 : (int) (chunkSize * (100L - minUsage + 1) / 100L - 1);\n+\n+        // the thresholds are aligned with PoolChunk.usage() logic:\n+        // 1) basic logic: usage() = 100 - freeBytes * 100L / chunkSize\n+        //    so, for example: (usage() >= maxUsage) condition can be transformed in the following way:\n+        //      100 - freeBytes * 100L / chunkSize >= maxUsage\n+        //      freeBytes <= chunkSize * (100 - maxUsage) / 100\n+        //      let freeMinThreshold = chunkSize * (100 - maxUsage) / 100, then freeBytes <= freeMinThreshold\n+        //\n+        //  2) usage() returns an int value and has a floor rounding during a calculation,\n+        //     to be aligned absolute thresholds should be shifted for \"the rounding step\":\n+        //       freeBytes * 100 / chunkSize < 1\n+        //       the condition can be converted to: freeBytes < 1 * chunkSize / 100\n+        //     this is why we have + 0.99999999 shifts. A example why just +1 shift cannot be used:\n+        //       freeBytes = 16777216 == freeMaxThreshold: 16777216, usage = 0 < minUsage: 1, chunkSize: 16777216\n+        //     At the same time we want to have zero thresholds in case of (maxUsage == 100) and (minUsage == 100).\n+        //\n+        freeMinThreshold = (maxUsage == 100) ? 0 : (int) (chunkSize * (100.0 - maxUsage + 0.99999999) / 100L);\n+        freeMaxThreshold = (minUsage == 100) ? 0 : (int) (chunkSize * (100.0 - minUsage + 0.99999999) / 100L);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400043663", "bodyText": "@netudima can you create a new PooledByteBufAllocator instance in a @Setup method and use it ? Otherwise it may not produce fair results as it may have already stuff cached from before etc. You may even want to disable ThreadLocal caches all together when doing so to ensure you really hit the PoolArena. WDYT ?", "author": "normanmaurer", "createdAt": "2020-03-30T09:18:45Z", "path": "microbench/src/main/java/io/netty/microbench/buffer/SimpleByteBufPooledAllocatorBenchmark.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.buffer;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Benchmark)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+public class SimpleByteBufPooledAllocatorBenchmark extends AbstractMicrobenchmark {\n+\n+    public SimpleByteBufPooledAllocatorBenchmark() {\n+        super(true, false);\n+    }\n+\n+    @Param({\"123\", \"1234\", \"12345\", \"123456\", \"1234567\"})\n+    public int size;\n+\n+    @Param({\"0\", \"5\", \"10\", \"100\"})\n+    public long tokens;\n+\n+    @Benchmark\n+    public boolean getAndRelease() {\n+        ByteBufAllocator alloc = PooledByteBufAllocator.DEFAULT;", "originalCommit": "e92a206a989efa2b317175f72b47209d1819383b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0NjM5NA==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400046394", "bodyText": "@franz1981 WDYT ?", "author": "normanmaurer", "createdAt": "2020-03-30T09:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA2NTg5NQ==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400065895", "bodyText": "I missed that :O ,that's a good point :+1", "author": "franz1981", "createdAt": "2020-03-30T09:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3NDA2MA==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400674060", "bodyText": "@netudima please address and let me know once done... after all my comments are addressed I will merge this. Good job.", "author": "normanmaurer", "createdAt": "2020-03-31T06:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY3NTgyNA==", "url": "https://github.com/netty/netty/pull/10141#discussion_r400675824", "bodyText": "Thank you for the review, working on the changes.", "author": "netudima", "createdAt": "2020-03-31T06:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwOTE4Nw==", "url": "https://github.com/netty/netty/pull/10141#discussion_r401109187", "bodyText": "Added\n@Param({\"false\", \"true\"})\n    public boolean useThreadCache;\n\nto control thread cache usage in the bench", "author": "netudima", "createdAt": "2020-03-31T18:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9ad322e837b69a1215099c7db07dce4d9e4cb809", "chunk": "diff --git a/microbench/src/main/java/io/netty/microbench/buffer/SimpleByteBufPooledAllocatorBenchmark.java b/microbench/src/main/java/io/netty/microbench/buffer/SimpleByteBufPooledAllocatorBenchmark.java\nindex feebb554e1..fec3fa9516 100644\n--- a/microbench/src/main/java/io/netty/microbench/buffer/SimpleByteBufPooledAllocatorBenchmark.java\n+++ b/microbench/src/main/java/io/netty/microbench/buffer/SimpleByteBufPooledAllocatorBenchmark.java\n\n@@ -21,10 +21,12 @@ import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.microbench.util.AbstractMicrobenchmark;\n import org.openjdk.jmh.annotations.Benchmark;\n import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Level;\n import org.openjdk.jmh.annotations.Mode;\n import org.openjdk.jmh.annotations.OutputTimeUnit;\n import org.openjdk.jmh.annotations.Param;\n import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n import org.openjdk.jmh.annotations.State;\n import org.openjdk.jmh.infra.Blackhole;\n \n"}}, {"oid": "9ad322e837b69a1215099c7db07dce4d9e4cb809", "url": "https://github.com/netty/netty/commit/9ad322e837b69a1215099c7db07dce4d9e4cb809", "message": "Adjust calculation of freeMinThreshold/freeMaxThreshold to be fully aligned with old usage()-based thresholds, add an explanation for freeMinThreshold/freeMaxThreshold formulas.\nAdd enabled and disabled thread pool cache options in SimpleByteBufPooledAllocatorBenchmark.", "committedDate": "2020-03-31T17:59:25Z", "type": "commit"}]}