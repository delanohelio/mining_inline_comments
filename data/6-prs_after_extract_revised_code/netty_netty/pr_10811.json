{"pr_number": 10811, "pr_title": "Allow blocking calls inside SingleThreadEventExecutor.addTask", "pr_createdAt": "2020-11-21T15:28:17Z", "pr_url": "https://github.com/netty/netty/pull/10811", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng==", "url": "https://github.com/netty/netty/pull/10811#discussion_r528608786", "bodyText": "using reflection will not really work with Java9+. So I think we need to come up with something different here.", "author": "normanmaurer", "createdAt": "2020-11-23T10:39:07Z", "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "originalCommit": "df3a1e0727989df4be9f777394232a2a10128982", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0NDA5OQ==", "url": "https://github.com/netty/netty/pull/10811#discussion_r528644099", "bodyText": "That might be impossible I'm afraid, but I'll investigate. I think that's why 09d38c8 did not introduce any test for this.", "author": "adutra", "createdAt": "2020-11-23T11:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0NjIxMg==", "url": "https://github.com/netty/netty/pull/10811#discussion_r528646212", "bodyText": "If thats the case then we may need to bite the bullet and just remove the test.", "author": "normanmaurer", "createdAt": "2020-11-23T11:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwOTA4MA==", "url": "https://github.com/netty/netty/pull/10811#discussion_r528709080", "bodyText": "I came up with a little something that works for SingleThreadEventExecutor, but not for GlobalEventExecutor. So I suggest that we leave GlobalEventExecutor untested. Let me know if it's looking better this way.", "author": "adutra", "createdAt": "2020-11-23T13:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c7934f46a35f2f3a37068c42af481737b7ed4118", "chunk": "diff --git a/transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java b/transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java\nindex 758f2a6f2d..68858b127d 100644\n--- a/transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java\n+++ b/transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java\n\n@@ -130,15 +132,16 @@ public class NettyBlockHoundIntegrationTest {\n         latch.await();\n     }\n \n-    @Test(timeout = 5000L)\n-    public void testGlobalEventExecutorAddTask() throws Exception {\n-        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n-    }\n-\n     @Test(timeout = 5000L)\n     public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        TestLinkedBlockingQueue<Runnable> taskQueue = new TestLinkedBlockingQueue<>();\n         SingleThreadEventExecutor executor =\n                 new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {\n+                        return taskQueue;\n+                    }\n+\n                     @Override\n                     protected void run() {\n                         while (!confirmShutdown()) {\n"}}, {"oid": "c7934f46a35f2f3a37068c42af481737b7ed4118", "url": "https://github.com/netty/netty/commit/c7934f46a35f2f3a37068c42af481737b7ed4118", "message": "Allow blocking calls inside SingleThreadEventExecutor.addTask\n\nMotivation:\n\nGlobalEventExecutor.addTask was rightfully allowed to block by commit\n09d38c8. However the same should have been done for\nSingleThreadEventExecutor.addTask.\n\nBlockHound is currently intercepting that call, and as a consequence,\nit prevents SingleThreadEventExecutor from working properly, if addTask is\ncalled from a thread that cannot block.\n\nThe interception is due to LinkedBlockingQueue.offer implementation,\nwhich uses a ReentrantLock internally.\n\nModifications:\n\n* Added one BlockHound exception to\nio.netty.util.internal.Hidden.NettyBlockHoundIntegration for\nSingleThreadEventExecutor.addTask.\n* Also added unit tests for both SingleThreadEventExecutor.addTask\nand GlobalEventExecutor.addTask.\n\nResult:\n\nSingleThreadEventExecutor.addTask can now be invoked from any thread\nwhen BlockHound is activated.", "committedDate": "2020-11-23T17:03:49Z", "type": "commit"}, {"oid": "c7934f46a35f2f3a37068c42af481737b7ed4118", "url": "https://github.com/netty/netty/commit/c7934f46a35f2f3a37068c42af481737b7ed4118", "message": "Allow blocking calls inside SingleThreadEventExecutor.addTask\n\nMotivation:\n\nGlobalEventExecutor.addTask was rightfully allowed to block by commit\n09d38c8. However the same should have been done for\nSingleThreadEventExecutor.addTask.\n\nBlockHound is currently intercepting that call, and as a consequence,\nit prevents SingleThreadEventExecutor from working properly, if addTask is\ncalled from a thread that cannot block.\n\nThe interception is due to LinkedBlockingQueue.offer implementation,\nwhich uses a ReentrantLock internally.\n\nModifications:\n\n* Added one BlockHound exception to\nio.netty.util.internal.Hidden.NettyBlockHoundIntegration for\nSingleThreadEventExecutor.addTask.\n* Also added unit tests for both SingleThreadEventExecutor.addTask\nand GlobalEventExecutor.addTask.\n\nResult:\n\nSingleThreadEventExecutor.addTask can now be invoked from any thread\nwhen BlockHound is activated.", "committedDate": "2020-11-23T17:03:49Z", "type": "forcePushed"}]}