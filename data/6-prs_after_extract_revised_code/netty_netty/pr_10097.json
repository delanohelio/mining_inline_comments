{"pr_number": 10097, "pr_title": "Replace reflection usage with MethodHandles when performance matters", "pr_createdAt": "2020-03-10T13:03:54Z", "pr_url": "https://github.com/netty/netty/pull/10097", "timeline": [{"oid": "79e7fa00eb73735d6de8a751ef7bb92e79dfbfa8", "url": "https://github.com/netty/netty/commit/79e7fa00eb73735d6de8a751ef7bb92e79dfbfa8", "message": "Replace reflection usage with MethodHandles when performance matters\n\nMotivation:\n\nAs we have java8 as a minimum target we can use MethodHandles. We should do so when we expect to have a method called multiple times.\n\nModifications:\n\n- Replace usage of reflection with MethodHandles where it makes sense\n- Remove some code which was there to support java < 8\n\nResult:\n\nFaster code", "committedDate": "2020-03-10T13:01:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjEyNg==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390606126", "bodyText": "MethodType.methodType(void.class, ByteBuffer.class)\n?", "author": "carl-mastrangelo", "createdAt": "2020-03-10T20:57:09Z", "path": "common/src/main/java/io/netty/util/internal/CleanerJava9.java", "diffHunk": "@@ -30,46 +32,53 @@\n final class CleanerJava9 implements Cleaner {\n     private static final InternalLogger logger = InternalLoggerFactory.getInstance(CleanerJava9.class);\n \n-    private static final Method INVOKE_CLEANER;\n+    private static final MethodHandle INVOKE_CLEANER_HANDLE;\n \n     static {\n-        final Method method;\n+        final MethodHandle invokeCleanerHandle;\n         final Throwable error;\n         if (PlatformDependent0.hasUnsafe()) {\n             final ByteBuffer buffer = ByteBuffer.allocateDirect(1);\n-            Object maybeInvokeMethod = AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n+            Object maybeInvokeMethodHandle = AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                 try {\n+                    MethodHandles.Lookup lookup = MethodHandles.lookup();\n                     // See https://bugs.openjdk.java.net/browse/JDK-8171377\n-                    Method m = PlatformDependent0.UNSAFE.getClass().getDeclaredMethod(\n-                            \"invokeCleaner\", ByteBuffer.class);\n-                    m.invoke(PlatformDependent0.UNSAFE, buffer);\n+                    MethodHandle m = lookup.findVirtual(\n+                            PlatformDependent0.UNSAFE.getClass(),\n+                            \"invokeCleaner\",\n+                            MethodType.methodType(void.class).appendParameterTypes(ByteBuffer.class)).", "originalCommit": "79e7fa00eb73735d6de8a751ef7bb92e79dfbfa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4NDIwNA==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390784204", "bodyText": "yes... was not aware there is such an overload :D", "author": "normanmaurer", "createdAt": "2020-03-11T07:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjEyNg=="}], "type": "inlineReview", "revised_code": {"commit": "79e386250eeb80af484b44f13d892d3d883c3ffd", "chunk": "diff --git a/common/src/main/java/io/netty/util/internal/CleanerJava9.java b/common/src/main/java/io/netty/util/internal/CleanerJava9.java\nindex 5d648e478e..96e04cf2d9 100644\n--- a/common/src/main/java/io/netty/util/internal/CleanerJava9.java\n+++ b/common/src/main/java/io/netty/util/internal/CleanerJava9.java\n\n@@ -46,8 +46,7 @@ final class CleanerJava9 implements Cleaner {\n                     MethodHandle m = lookup.findVirtual(\n                             PlatformDependent0.UNSAFE.getClass(),\n                             \"invokeCleaner\",\n-                            MethodType.methodType(void.class).appendParameterTypes(ByteBuffer.class)).\n-                            bindTo(PlatformDependent0.UNSAFE);\n+                            MethodType.methodType(void.class, ByteBuffer.class)).bindTo(PlatformDependent0.UNSAFE);\n                     m.invokeExact(buffer);\n                     return m;\n                 } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNzkxNw==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390607917", "bodyText": "In the past I have had pain using invokeExact (if the types aren't exactly right, normal covariance doesn't work, or something like that).\nConsider using plain invoke.   I'm moderately confident the \"exact\" overload doesn't have any performance benefit.", "author": "carl-mastrangelo", "createdAt": "2020-03-10T21:00:25Z", "path": "common/src/main/java/io/netty/util/internal/CleanerJava9.java", "diffHunk": "@@ -78,7 +87,7 @@ public void freeDirectBuffer(ByteBuffer buffer) {\n         // See https://bugs.openjdk.java.net/browse/JDK-8191053.\n         if (System.getSecurityManager() == null) {\n             try {\n-                INVOKE_CLEANER.invoke(PlatformDependent0.UNSAFE, buffer);\n+                INVOKE_CLEANER_HANDLE.invokeExact(buffer);", "originalCommit": "79e7fa00eb73735d6de8a751ef7bb92e79dfbfa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxMDkwNg==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390610906", "bodyText": "Tomorrow I will give a better look (still recovering from a fever today), but I have experienced the opposite ie invokeExact to get a huge benefit in perf if compared with just invoke. I need to re-check, but that was my past experience with it.\nRe the pain, I totally understand it, same experience here...", "author": "franz1981", "createdAt": "2020-03-10T21:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNzkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4NDEwOQ==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390784109", "bodyText": "@carl-mastrangelo I tested this one and it works... I would prefer to use invokeExact if possible.", "author": "normanmaurer", "createdAt": "2020-03-11T07:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNzkxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwOTIzMQ==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390609231", "bodyText": "Similar comment, just use the vararg form?", "author": "carl-mastrangelo", "createdAt": "2020-03-10T21:01:50Z", "path": "handler/src/main/java/io/netty/handler/ssl/Conscrypt.java", "diffHunk": "@@ -16,23 +16,27 @@\n package io.netty.handler.ssl;\n \n import javax.net.ssl.SSLEngine;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n \n /**\n  * Contains methods that can be used to detect if conscrypt is usable.\n  */\n final class Conscrypt {\n     // This class exists to avoid loading other conscrypt related classes using features only available in JDK8+,\n     // because we need to maintain JDK6+ runtime compatibility.\n-    private static final Method IS_CONSCRYPT_SSLENGINE = loadIsConscryptEngine();\n+    private static final MethodHandle IS_CONSCRYPT_SSLENGINE = loadIsConscryptEngine();\n     private static final boolean CAN_INSTANCE_PROVIDER = canInstanceProvider();\n \n-    private static Method loadIsConscryptEngine() {\n+    private static MethodHandle loadIsConscryptEngine() {\n         try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n             Class<?> conscryptClass = Class.forName(\"org.conscrypt.Conscrypt\", true,\n                     ConscryptAlpnSslEngine.class.getClassLoader());\n-            return conscryptClass.getMethod(\"isConscrypt\", SSLEngine.class);\n+            return lookup.findStatic(conscryptClass, \"isConscrypt\", MethodType.methodType(boolean.class)\n+                    .appendParameterTypes(SSLEngine.class));", "originalCommit": "79e7fa00eb73735d6de8a751ef7bb92e79dfbfa8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79e386250eeb80af484b44f13d892d3d883c3ffd", "chunk": "diff --git a/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java b/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java\nindex 3d2993fd2b..a6ac56237f 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java\n\n@@ -35,8 +35,8 @@ final class Conscrypt {\n \n             Class<?> conscryptClass = Class.forName(\"org.conscrypt.Conscrypt\", true,\n                     ConscryptAlpnSslEngine.class.getClassLoader());\n-            return lookup.findStatic(conscryptClass, \"isConscrypt\", MethodType.methodType(boolean.class)\n-                    .appendParameterTypes(SSLEngine.class));\n+            return lookup.findStatic(conscryptClass, \"isConscrypt\",\n+                    MethodType.methodType(boolean.class, SSLEngine.class));\n         } catch (Throwable ignore) {\n             // Conscrypt was not loaded.\n             return null;\n"}}, {"oid": "79e386250eeb80af484b44f13d892d3d883c3ffd", "url": "https://github.com/netty/netty/commit/79e386250eeb80af484b44f13d892d3d883c3ffd", "message": "cleanup", "committedDate": "2020-03-11T09:32:23Z", "type": "commit"}, {"oid": "afb8636285f9f6c7d343c3d69a3a4d31756b6c8b", "url": "https://github.com/netty/netty/commit/afb8636285f9f6c7d343c3d69a3a4d31756b6c8b", "message": "cleanup", "committedDate": "2020-03-11T10:03:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2NjcwMQ==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390866701", "bodyText": "I would create a  CRC32 castedChecksum = (CRC32) checksum to be captured&used on\n                @Override\n                public void update(ByteBuffer b) {\n                    castedChecksum.update(b);\n                }", "author": "franz1981", "createdAt": "2020-03-11T10:13:37Z", "path": "codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java", "diffHunk": "@@ -33,43 +32,34 @@\n  * byte array ({@link ByteBuf#hasArray()} is {@code true}) or not.\n  */\n abstract class ByteBufChecksum implements Checksum {\n-    private static final Method ADLER32_UPDATE_METHOD;\n-    private static final Method CRC32_UPDATE_METHOD;\n-\n-    static {\n-        // See if we can use fast-path when using ByteBuf that is not heap based as Adler32 and CRC32 added support\n-        // for update(ByteBuffer) in JDK8.\n-        ADLER32_UPDATE_METHOD = updateByteBuffer(new Adler32());\n-        CRC32_UPDATE_METHOD = updateByteBuffer(new CRC32());\n-    }\n \n     private final ByteProcessor updateProcessor = value -> {\n         update(value);\n         return true;\n     };\n \n-    private static Method updateByteBuffer(Checksum checksum) {\n-        try {\n-            Method method = checksum.getClass().getDeclaredMethod(\"update\", ByteBuffer.class);\n-            method.invoke(checksum, ByteBuffer.allocate(1));\n-            return method;\n-        } catch (Throwable ignore) {\n-            return null;\n-        }\n-    }\n-\n     static ByteBufChecksum wrapChecksum(Checksum checksum) {\n         requireNonNull(checksum, \"checksum\");\n         if (checksum instanceof ByteBufChecksum) {\n             return (ByteBufChecksum) checksum;\n         }\n-        if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {\n-            return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);\n+        if (checksum instanceof Adler32) {\n+            return new OptimizedByteBufChecksum<Adler32>((Adler32) checksum) {\n+                @Override\n+                public void update(ByteBuffer b) {\n+                    checksum.update(b);\n+                }\n+            };\n         }\n-        if (checksum instanceof CRC32 && CRC32_UPDATE_METHOD != null) {\n-            return new ReflectiveByteBufChecksum(checksum, CRC32_UPDATE_METHOD);\n+        if (checksum instanceof CRC32) {\n+            return new OptimizedByteBufChecksum<CRC32>((CRC32) checksum) {", "originalCommit": "afb8636285f9f6c7d343c3d69a3a4d31756b6c8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2NzkwMg==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390867902", "bodyText": "Same for Adler32.\nIIRC captured final are true finals 4 the JVM, so I would expect checksum.update(b); to be monomorphic, but to reduce the chance that the JVM won't be able to do that, this change would help...", "author": "franz1981", "createdAt": "2020-03-11T10:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2NjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg4ODU1OA==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390888558", "bodyText": "I would prefer to keep it as it is as its cleaner imho and I am not convinced it matters.", "author": "normanmaurer", "createdAt": "2020-03-11T10:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2NjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg5MzQwMA==", "url": "https://github.com/netty/netty/pull/10097#discussion_r390893400", "bodyText": "Yep,. probably it won't worth doing it", "author": "franz1981", "createdAt": "2020-03-11T11:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2NjcwMQ=="}], "type": "inlineReview", "revised_code": null}]}