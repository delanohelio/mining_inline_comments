{"pr_number": 10069, "pr_title": "Preserve order when using alternate event loops", "pr_createdAt": "2020-02-29T06:34:18Z", "pr_url": "https://github.com/netty/netty/pull/10069", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA4MjU4Nw==", "url": "https://github.com/netty/netty/pull/10069#discussion_r386082587", "bodyText": "this is not correct (and also not the one above) as you will cause a ClassCastException later on if the ChannelHandlerContext does not wrap an ChannelOutboundHandler.", "author": "normanmaurer", "createdAt": "2020-03-01T06:56:34Z", "path": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java", "diffHunk": "@@ -906,17 +906,21 @@ private boolean isNotValidPromise(ChannelPromise promise, boolean allowVoidPromi\n \n     private AbstractChannelHandlerContext findContextInbound(int mask) {\n         AbstractChannelHandlerContext ctx = this;\n+        EventExecutor currentExecutor = executor();\n         do {\n             ctx = ctx.next;\n-        } while ((ctx.executionMask & mask) == 0);\n+        } while (!ChannelHandlerMask.isInbound(ctx.executionMask)\n+            || (ctx.executionMask & mask) == 0 && ctx.executor() == currentExecutor);\n         return ctx;\n     }\n \n     private AbstractChannelHandlerContext findContextOutbound(int mask) {\n         AbstractChannelHandlerContext ctx = this;\n+        EventExecutor currentExecutor = executor();\n         do {\n             ctx = ctx.prev;\n-        } while ((ctx.executionMask & mask) == 0);\n+        } while (!ChannelHandlerMask.isOutbound(ctx.executionMask)\n+            || (ctx.executionMask & mask) == 0 && ctx.executor() == currentExecutor);", "originalCommit": "e8dd352c8d17943df310ba1371329c0990e5bbb9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a4fa90032d86c2b1c47039aeb8a3b88ae03cffd", "chunk": "diff --git a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\nindex 7b07a163eb..9ba91f97ac 100644\n--- a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\n+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\n\n@@ -909,8 +911,7 @@ abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, R\n         EventExecutor currentExecutor = executor();\n         do {\n             ctx = ctx.next;\n-        } while (!ChannelHandlerMask.isInbound(ctx.executionMask)\n-            || (ctx.executionMask & mask) == 0 && ctx.executor() == currentExecutor);\n+        } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));\n         return ctx;\n     }\n \n"}}, {"oid": "9a4fa90032d86c2b1c47039aeb8a3b88ae03cffd", "url": "https://github.com/netty/netty/commit/9a4fa90032d86c2b1c47039aeb8a3b88ae03cffd", "message": "Fix context selection", "committedDate": "2020-03-02T09:27:00Z", "type": "forcePushed"}, {"oid": "b3725abd87b66a56ab389397d82a98d84b45745c", "url": "https://github.com/netty/netty/commit/b3725abd87b66a56ab389397d82a98d84b45745c", "message": "Preserve order when using alternate event loops\n\nWhen the HttpContentCompressor is put on an alternate EventExecutor, the order of events should be\npreserved so that the compressed content is correctly created. This is done by checking that\nthe executor in the ChannelHandlerContext is the same executor as the current executor when\nevaluating if the handler should be skipped.", "committedDate": "2020-03-02T21:50:24Z", "type": "forcePushed"}, {"oid": "d43c4870de2663d7f78863d5476ae6ffd7640094", "url": "https://github.com/netty/netty/commit/d43c4870de2663d7f78863d5476ae6ffd7640094", "message": "Fix buffer leaks and cleanup", "committedDate": "2020-03-02T13:36:30Z", "type": "forcePushed"}, {"oid": "e921df1574d8eb6ea34cddd122821142f7adc27e", "url": "https://github.com/netty/netty/commit/e921df1574d8eb6ea34cddd122821142f7adc27e", "message": "Preserve order when using alternate event loops\n\nMotivation:\n\nWhen the HttpContentCompressor is put on an alternate EventExecutor, the order of events should be\npreserved so that the compressed content is correctly created.\n\nModifications:\n- checking that the executor in the ChannelHandlerContext is the same executor as the current executor when evaluating if the handler should be skipped.\n- Add unit test\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10067\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-03-03T08:03:50Z", "type": "commit"}, {"oid": "e921df1574d8eb6ea34cddd122821142f7adc27e", "url": "https://github.com/netty/netty/commit/e921df1574d8eb6ea34cddd122821142f7adc27e", "message": "Preserve order when using alternate event loops\n\nMotivation:\n\nWhen the HttpContentCompressor is put on an alternate EventExecutor, the order of events should be\npreserved so that the compressed content is correctly created.\n\nModifications:\n- checking that the executor in the ChannelHandlerContext is the same executor as the current executor when evaluating if the handler should be skipped.\n- Add unit test\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10067\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-03-03T08:03:50Z", "type": "forcePushed"}]}