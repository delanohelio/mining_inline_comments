{"pr_number": 9955, "pr_title": "Efficient BytBuf search algorithms (#9914)", "pr_createdAt": "2020-01-15T21:25:53Z", "pr_url": "https://github.com/netty/netty/pull/9955", "timeline": [{"oid": "ee5bf845fb5d41e93aa8e490312674772ae4f08c", "url": "https://github.com/netty/netty/commit/ee5bf845fb5d41e93aa8e490312674772ae4f08c", "message": "Efficient BytBuf search algorithms (#9914)\n\nMotivation:\n\nWe have found out that ByteBufUtil.indexOf can be inefficient for substring search on\nByteBuf, both in terms of algorithm complexity (worst case O(needle.readableBytes *\nhaystack.readableBytes)), and in constant factor (esp. on Composite buffers).\nWith implementation of more performant search algorithms we have seen improvements on\nthe order of magnitude.\n\nModifications:\n\nThis change introduces three search algorithms:\n1. Knuth Morris Pratt - classical textbook algorithm, a good default choice.\n2. Bit mask based algorithm - stable performance on any input, but limited to maximum\nsearch substring (the needle) length of 64 bytes.\n3. Aho\u2013Corasick - worse performance and higher memory consumption than [1] and [2], but\nit supports multiple substring (the needles) search simultaneously, by inspecting every\nbyte of the haystack only once.\n\nEach algorithm processes every byte of underlying buffer only once, they are implemented\nas ByteProcessor.\n\nResult:\n\nEfficient search algorithms with linear time complexity available in Netty (I will share\nbenchmark results in a comment on a PR).", "committedDate": "2020-01-15T21:19:48Z", "type": "commit"}, {"oid": "894cb3ccb91c7b578f11228974a488d8d9fca9a3", "url": "https://github.com/netty/netty/commit/894cb3ccb91c7b578f11228974a488d8d9fca9a3", "message": "Improved benchmarks", "committedDate": "2020-01-18T05:22:19Z", "type": "commit"}, {"oid": "fdf1f3be4106c10a6afe20e620e81bc8147be7ef", "url": "https://github.com/netty/netty/commit/fdf1f3be4106c10a6afe20e620e81bc8147be7ef", "message": "Added PREDICTABLE and UNPREDICTABLE benchmark inputs", "committedDate": "2020-01-20T08:08:34Z", "type": "commit"}, {"oid": "3849c0c3966f1a87a83b0eb3fe26c7a481e81cb7", "url": "https://github.com/netty/netty/commit/3849c0c3966f1a87a83b0eb3fe26c7a481e81cb7", "message": "Adjusted some benchmark inputs", "committedDate": "2020-01-22T07:07:57Z", "type": "commit"}, {"oid": "acbee05bfb6c00d560d7ac2ef85f2df6a7d34ea2", "url": "https://github.com/netty/netty/commit/acbee05bfb6c00d560d7ac2ef85f2df6a7d34ea2", "message": "Minor polishing", "committedDate": "2020-01-23T11:13:10Z", "type": "commit"}, {"oid": "057676d519c6e438ec17fa3ec6dbc30f84ab659e", "url": "https://github.com/netty/netty/commit/057676d519c6e438ec17fa3ec6dbc30f84ab659e", "message": "Rename next to jumpTable in KMP", "committedDate": "2020-01-24T11:54:35Z", "type": "commit"}, {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1", "url": "https://github.com/netty/netty/commit/200b9aea18d7ec4684b6af7af41c18c85024e0c1", "message": "Cleaner AhoCorasic (no change in benchmarks)", "committedDate": "2020-02-04T07:00:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ==", "url": "https://github.com/netty/netty/pull/9955#discussion_r374613345", "bodyText": "have you tried inspecting ASM here? Look if there is any PlatformDependent method that can save bound checks there.", "author": "franz1981", "createdAt": "2020-02-04T11:19:51Z", "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "originalCommit": "200b9aea18d7ec4684b6af7af41c18c85024e0c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MTM5OA==", "url": "https://github.com/netty/netty/pull/9955#discussion_r374641398", "bodyText": "@franz1981 I've checked the assembly, also tried Byte.toUnsignedInt (which I think intrinsics to movzbl), nothing has helped to eliminate the bounds check. JDK 8 / 11 / 13 / GraalVM.\nLooks like PlatformDependent.getLong is something worth trying, thanks for the tip - will update later.", "author": "linasm", "createdAt": "2020-02-04T12:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MzQ0Ng==", "url": "https://github.com/netty/netty/pull/9955#discussion_r375193446", "bodyText": "So, adding this to PlatformDependent0:\n    static long getLong(long[] data, int index) {\n        return UNSAFE.getLong(data, LONG_ARRAY_BASE_OFFSET + LONG_ARRAY_INDEX_SCALE * index);\n    }\nand using it in ShiftingBitMaskSearchProcessor gives 2-8% improvement.\nAssembly with Array (process method is inlined and 4x loop-unrolled, so I'm only pasting one unroll piece here):\n  2.36%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c791e: movzx  r9d,BYTE PTR [rbx+rcx*1+0x12]\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ;*iand\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@17 (line 37)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.70%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7924: mov    rax,rdx\n  2.69%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7927: shl    rax,1\n  0.78%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c792a: mov    r8d,r10d\n  1.85%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c792d: add    r8d,0x2            ;*iinc\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@21 (line 1335)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.91%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7931: or     rax,0x1            ;*lor  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@8 (line 37)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  2.84%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7935: cmp    r9d,esi\n         \u2502  \u2502 \u2502\u2502\u256d \u2502      0x000000010a0c7938: jae    0x000000010a0c79ef  ;*laload\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@18 (line 37)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.53%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c793e: and    rax,QWORD PTR [rbp+r9*8+0x10]\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ;*land\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@19 (line 37)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  2.55%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7943: mov    r9,rax\n  0.81%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7946: and    r9,r13             ;*land\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@31 (line 38)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  3.31%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7949: test   r9,r9\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c794c: jne    0x000000010a0c7a43  ;*ifne\n\n(bound check is cmp r9d,esi; jae)\nAssembly with Unsafe (again, 1/4 piece of loop unroll):\n  6.95%  \u2502     \u2502    0x000000010c2cc973: shl    rbx,1\n  0.33%  \u2502     \u2502    0x000000010c2cc976: movsxd rax,r10d\n  0.26%  \u2502     \u2502    0x000000010c2cc979: movzx  esi,BYTE PTR [rdi+rax*1+0x11]\n         \u2502     \u2502                                                  ;*iand\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@17 (line 36)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.11%  \u2502     \u2502    0x000000010c2cc97e: or     rbx,0x1\n  6.88%  \u2502     \u2502    0x000000010c2cc982: and    rbx,QWORD PTR [rdx+rsi*8+0x10]\n         \u2502     \u2502                                                  ;*land\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@21 (line 36)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  1.56%  \u2502     \u2502    0x000000010c2cc987: mov    rsi,rbx\n  0.42%  \u2502     \u2502    0x000000010c2cc98a: and    rsi,r8             ;*land\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@33 (line 38)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  6.74%  \u2502     \u2502    0x000000010c2cc98d: test   rsi,rsi\n         \u2502   \u256d \u2502    0x000000010c2cc990: jne    0x000000010c2cca19  ;*ifne\n\n(which looks really good to me, except for maybe some instruction ordering)\nOf course, same change could be done for KMP and Aho-Corasic (requiring to add getInt and getObject to PlatformDependent).", "author": "linasm", "createdAt": "2020-02-05T11:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NDk5NA==", "url": "https://github.com/netty/netty/pull/9955#discussion_r377284994", "bodyText": "Tried PlatformDependent with all algos. Up to 8% improvement for Shifting bit mask, up to +21% for KMP, no measurable change for Aho-Corasic. Looks like Aho-Corasic is hitting some hard CPU pipeline limit, caused by tight traversal of this 2 level cyclic memory access indirection (object -> array -> object). Currently trying to resolve this issue, with promising results. Once done, will update with full table of results (want to avoid excess noise here).", "author": "linasm", "createdAt": "2020-02-10T19:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "316415241a7e179555c2f5467c4b280385d4a11d", "chunk": "diff --git a/buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java b/buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java\nindex fdaa3b7d1e..ff0bcc0f29 100644\n--- a/buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java\n+++ b/buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java\n\n@@ -12,7 +12,9 @@\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n  */\n- package io.netty.buffer.search;\n+package io.netty.buffer.search;\n+\n+import io.netty.util.internal.PlatformDependent;\n \n /**\n  * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n"}}, {"oid": "9880833965621b2be1ecc1a2b73cd9547205d3c0", "url": "https://github.com/netty/netty/commit/9880833965621b2be1ecc1a2b73cd9547205d3c0", "message": "PlatformDependent same type array based getInt and getLong", "committedDate": "2020-02-06T19:36:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ==", "url": "https://github.com/netty/netty/pull/9955#discussion_r377211991", "bodyText": "It cannot be made less GC hungry by caching the search processor?\neach benchmarked method could include the jump table initialization and needle clone too (thinking of kmp here)\nEscape analysis probably won't even kick-in due to the size of needle array", "author": "franz1981", "createdAt": "2020-02-10T17:37:03Z", "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.search;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.SearchProcessorFactory;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.CompilerControl.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class SearchBenchmark extends AbstractMicrobenchmark {\n+\n+    private static final long SEED = 123;\n+\n+    public enum ByteBufType {\n+        HEAP {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.wrappedBuffer(bytes, 0, bytes.length);\n+            }\n+        },\n+        COMPOSITE {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                CompositeByteBuf buf = Unpooled.compositeBuffer();\n+                int length = bytes.length;\n+                int offset = 0;\n+                int capacity = length / 8; // 8 buffers per composite\n+\n+                while (length > 0) {\n+                    buf.addComponent(true, Unpooled.wrappedBuffer(bytes, offset, Math.min(length, capacity)));\n+                    length -= capacity;\n+                    offset += capacity;\n+                }\n+                return buf;\n+            }\n+        },\n+        DIRECT {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.directBuffer(bytes.length).writeBytes(bytes);\n+            }\n+        };\n+        abstract ByteBuf newBuffer(byte[] bytes);\n+    }\n+\n+    public enum Input {\n+        RANDOM_256B {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 256, ' ', 127);\n+            }\n+        },\n+        RANDOM_2KB {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, ' ', 127);\n+            }\n+        },\n+        PREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // all 0s\n+                return new byte[64];\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // no 0s except in the very end\n+                byte[] bytes = randomBytes(rnd, 2048, 1, 255);\n+                Arrays.fill(bytes, bytes.length - 64, bytes.length, (byte) 0);\n+                return bytes;\n+            }\n+        },\n+        UNPREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return randomBytes(rnd, 64, 0, 1);\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, 0, 1);\n+            }\n+        },\n+        WORST_CASE { // ShiftingBitMask will fail on it because the needle is >64 bytes long\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // aa(...)aab\n+                byte[] needle = new byte[1024];\n+                Arrays.fill(needle, (byte) 'a');\n+                needle[needle.length - 1] = 'b';\n+                return needle;\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // aa(...)aaa\n+                byte[] haystack = new byte[2048];\n+                Arrays.fill(haystack, (byte) 'a');\n+                return haystack;\n+            }\n+        };\n+\n+        abstract byte[] getNeedle(Random rnd);\n+        abstract byte[] getHaystack(Random rnd);\n+    }\n+\n+    @Param\n+    public Input input;\n+\n+    @Param\n+    public ByteBufType bufferType;\n+\n+    private Random rnd;\n+    private ByteBuf needle, haystack;\n+    private byte[] needleBytes, haystackBytes;\n+    private SearchProcessorFactory kmpFactory, shiftingBitMaskFactory, ahoCorasicFactory;\n+\n+    @Setup\n+    public void setup() {\n+        rnd = new Random(SEED);\n+\n+        needleBytes = input.getNeedle(rnd);\n+        haystackBytes = input.getHaystack(rnd);\n+\n+        needle = Unpooled.wrappedBuffer(needleBytes);\n+        haystack = bufferType.newBuffer(haystackBytes);\n+\n+        kmpFactory = SearchProcessorFactory.newKmpSearchProcessorFactory(needleBytes);\n+        ahoCorasicFactory = MultiSearchProcessorFactory.newAhoCorasicSearchProcessorFactory(needleBytes);\n+\n+        if (needleBytes.length <= 64) {\n+            shiftingBitMaskFactory = SearchProcessorFactory.newShiftingBitMaskSearchProcessorFactory(needleBytes);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        needle.release();\n+        haystack.release();\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int indexOf() {\n+        return ByteBufUtil.indexOf(needle, haystack);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int kmp() {\n+        return haystack.forEachByte(kmpFactory.newSearchProcessor());", "originalCommit": "200b9aea18d7ec4684b6af7af41c18c85024e0c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NzIyOQ==", "url": "https://github.com/netty/netty/pull/9955#discussion_r377287229", "bodyText": "Sure, I can make the runs allocation free by reusing the search processor (resetting its state is trivial for all algos). Or is it something else that you had in mind?", "author": "linasm", "createdAt": "2020-02-10T20:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMjkzNA==", "url": "https://github.com/netty/netty/pull/9955#discussion_r379612934", "bodyText": "My new benchmark suite will reuse (reset) the SearchProcessor so each invocation will be allocation free.", "author": "linasm", "createdAt": "2020-02-14T19:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "32fff4f707a277aa9ba2187acd5b42255ca2720e", "chunk": "diff --git a/microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java b/microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java\nindex f2ed4aa185..ec82ad8081 100644\n--- a/microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java\n+++ b/microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java\n\n@@ -17,9 +17,9 @@ package io.netty.microbench.search;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufUtil;\n-import io.netty.buffer.CompositeByteBuf;\n import io.netty.buffer.Unpooled;\n-import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.AbstractMultiSearchProcessorFactory;\n+import io.netty.buffer.search.AbstractSearchProcessorFactory;\n import io.netty.buffer.search.SearchProcessorFactory;\n import io.netty.microbench.util.AbstractMicrobenchmark;\n import org.openjdk.jmh.annotations.Benchmark;\n"}}, {"oid": "316415241a7e179555c2f5467c4b280385d4a11d", "url": "https://github.com/netty/netty/commit/316415241a7e179555c2f5467c4b280385d4a11d", "message": "ShiftingBitMask and KMP using PlatformDependent instead of array", "committedDate": "2020-02-11T19:08:32Z", "type": "commit"}, {"oid": "8182d78887e1f07b09772caebe4c2499b5e3c106", "url": "https://github.com/netty/netty/commit/8182d78887e1f07b09772caebe4c2499b5e3c106", "message": "Rewrite Aho-Corasic for better performance", "committedDate": "2020-02-11T21:18:50Z", "type": "commit"}, {"oid": "ba3242bd9e7982994f395de5046925749e3f773c", "url": "https://github.com/netty/netty/commit/ba3242bd9e7982994f395de5046925749e3f773c", "message": "SearchProcessor.reset method", "committedDate": "2020-02-12T12:18:45Z", "type": "commit"}, {"oid": "2a0b6998612bf9c36094ee1fdc89d19424cf3b28", "url": "https://github.com/netty/netty/commit/2a0b6998612bf9c36094ee1fdc89d19424cf3b28", "message": "Missed one array access in KMP - replace with PlatformDependent.getByte", "committedDate": "2020-02-13T08:38:51Z", "type": "commit"}, {"oid": "e6e85d895cbe5a98172a94aa2117888ccbf75f8b", "url": "https://github.com/netty/netty/commit/e6e85d895cbe5a98172a94aa2117888ccbf75f8b", "message": "Use PlatformDependent.getXX with long index in all string search algos", "committedDate": "2020-02-13T19:26:31Z", "type": "commit"}, {"oid": "3b0a8d041c2239924cfeb91a8591efe7fb6151ce", "url": "https://github.com/netty/netty/commit/3b0a8d041c2239924cfeb91a8591efe7fb6151ce", "message": "Expand byte to long instead of int in AhoCorasic", "committedDate": "2020-02-13T20:24:03Z", "type": "commit"}, {"oid": "32fff4f707a277aa9ba2187acd5b42255ca2720e", "url": "https://github.com/netty/netty/commit/32fff4f707a277aa9ba2187acd5b42255ca2720e", "message": "A new benchmark suite - SearchRealDataBenchmark", "committedDate": "2020-02-15T09:34:25Z", "type": "commit"}, {"oid": "31d573d116a6d7ef8148ab83a621b159d3fa6edf", "url": "https://github.com/netty/netty/commit/31d573d116a6d7ef8148ab83a621b159d3fa6edf", "message": "Do not reuse SearchProcessor in SearchRealDataBenchmark", "committedDate": "2020-02-15T10:59:23Z", "type": "commit"}, {"oid": "dde7c44856c2b0fe1cd2306ae52f891dfa2b71a1", "url": "https://github.com/netty/netty/commit/dde7c44856c2b0fe1cd2306ae52f891dfa2b71a1", "message": "Fix typo", "committedDate": "2020-02-28T09:58:09Z", "type": "commit"}, {"oid": "6db9de31ba4543afc0424a3bf8f2124617877b5b", "url": "https://github.com/netty/netty/commit/6db9de31ba4543afc0424a3bf8f2124617877b5b", "message": "Rename ShiftingBitMask to Bitap (as known in the industry)", "committedDate": "2020-03-01T20:35:45Z", "type": "commit"}, {"oid": "8972d65c8fc3473f3bc372185d8d3ef66340ff20", "url": "https://github.com/netty/netty/commit/8972d65c8fc3473f3bc372185d8d3ef66340ff20", "message": "Nest SearchProcessor classes in their Factories for a more compact code", "committedDate": "2020-03-02T06:52:09Z", "type": "commit"}, {"oid": "8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e", "url": "https://github.com/netty/netty/commit/8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e", "message": "Additional test cases", "committedDate": "2020-03-28T20:33:07Z", "type": "commit"}]}