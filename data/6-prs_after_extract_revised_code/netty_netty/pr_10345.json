{"pr_number": 10345, "pr_title": "Add example code for smtp client", "pr_createdAt": "2020-06-10T16:07:59Z", "pr_url": "https://github.com/netty/netty/pull/10345", "timeline": [{"oid": "36f4a51d2992aa3cf567e50e3de3ce21ffd684a4", "url": "https://github.com/netty/netty/commit/36f4a51d2992aa3cf567e50e3de3ce21ffd684a4", "message": "Add example code for smtp client\n\nMotivation:\n\nWe don't have example code for smtp.\n\nModifications:\n\nAdd SmtpClient and SmtpClientHandler.\n\nResult:\n\nProvide an example for developers who want to write a smtp client.", "committedDate": "2020-06-10T15:58:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE1NTY3NQ==", "url": "https://github.com/netty/netty/pull/10345#discussion_r450155675", "bodyText": "@yuanrw I think it would be better to just expose CompletionStage in general. WDYT ?", "author": "normanmaurer", "createdAt": "2020-07-06T11:23:55Z", "path": "example/src/main/java/io/netty/example/smtp/SmtpClientHandler.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package io.netty.example.smtp;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.smtp.DefaultLastSmtpContent;\n+import io.netty.handler.codec.smtp.SmtpRequest;\n+import io.netty.handler.codec.smtp.SmtpResponse;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.FutureCompletionStage;\n+import io.netty.util.concurrent.Promise;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An example smtp client handler\n+ */\n+public class SmtpClientHandler extends SimpleChannelInboundHandler<SmtpResponse> {\n+\n+    private ChannelHandlerContext ctx;\n+    private final AtomicReference<Promise<SmtpResponse>> responseFuture = new AtomicReference<>();\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    protected void messageReceived(ChannelHandlerContext ctx, SmtpResponse response) throws Exception {\n+        Promise<SmtpResponse> promise = responseFuture.get();\n+        if (promise == null) {\n+            throw new RuntimeException(\"Unexpected response received: \" + response);\n+        } else {\n+            if (response.code() >= 500) {\n+                throw new RuntimeException(\"receive an error: \" + response);\n+            }\n+            printResponse(response);\n+            promise.setSuccess(response);\n+            responseFuture.set(null);\n+        }\n+    }\n+\n+    private static void printResponse(SmtpResponse response) {\n+        System.out.println(response);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        cause.printStackTrace();\n+        responseFuture.get().setFailure(cause);\n+        ctx.close();\n+    }\n+\n+    public FutureCompletionStage<SmtpResponse> send(SmtpRequest request) {", "originalCommit": "36f4a51d2992aa3cf567e50e3de3ce21ffd684a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMDk5Mg==", "url": "https://github.com/netty/netty/pull/10345#discussion_r450630992", "bodyText": "@normanmaurer Sometimes we may want to block on the result. So I need to get the underlying Future.\nhandler.send(req(EHLO, \"localhost\"))\n        .thenCompose(r -> handler.send(req(AUTH, \"login\")))\n        .future().await();", "author": "yuanrw", "createdAt": "2020-07-07T06:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE1NTY3NQ=="}], "type": "inlineReview", "revised_code": null}]}