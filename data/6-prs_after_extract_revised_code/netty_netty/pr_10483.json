{"pr_number": 10483, "pr_title": "MQTT5 support for netty-codec-mqtt", "pr_createdAt": "2020-08-14T14:32:35Z", "pr_url": "https://github.com/netty/netty/pull/10483", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0Mzk5Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r470843992", "bodyText": "I believe it should be 0x81, 0x82 etc \ud83d\ude00", "author": "kachayev", "createdAt": "2020-08-14T20:11:27Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java", "diffHunk": "@@ -25,11 +25,34 @@\n  */\n public enum MqttConnectReturnCode {\n     CONNECTION_ACCEPTED((byte) 0x00),\n+    //MQTT 3 codes\n     CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION((byte) 0X01),\n     CONNECTION_REFUSED_IDENTIFIER_REJECTED((byte) 0x02),\n     CONNECTION_REFUSED_SERVER_UNAVAILABLE((byte) 0x03),\n     CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD((byte) 0x04),\n-    CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05);\n+    CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05),\n+    //MQTT 5 codes\n+    CONNECTION_REFUSED_UNSPECIFIED_ERROR((byte) 0x80),\n+    CONNECTION_REFUSED_MALFORMED_PACKET((byte) 0x80),", "originalCommit": "675d0ee3ef75bb4c6a204cc7a7cfe7d2f172f596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNzQ5MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r470937491", "bodyText": "Nice catch. Fixed that.", "author": "paul-lysak", "createdAt": "2020-08-15T04:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0Mzk5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "fc5dd1b3c9a8b35bd1b6c3945210d90c52fd985c", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java\nindex 8ecf476f12..be5a091a77 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java\n\n@@ -33,26 +33,26 @@ public enum MqttConnectReturnCode {\n     CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05),\n     //MQTT 5 codes\n     CONNECTION_REFUSED_UNSPECIFIED_ERROR((byte) 0x80),\n-    CONNECTION_REFUSED_MALFORMED_PACKET((byte) 0x80),\n-    CONNECTION_REFUSED_PROTOCOL_ERROR((byte) 0x80),\n-    CONNECTION_REFUSED_IMPLEMENTATION_SPECIFIC((byte) 0x80),\n-    CONNECTION_REFUSED_UNSUPPORTED_PROTOCOL_VERSION((byte) 0x80),\n-    CONNECTION_REFUSED_CLIENT_IDENTIFIER_NOT_VALID((byte) 0x80),\n-    CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD((byte) 0x80),\n-    CONNECTION_REFUSED_NOT_AUTHORIZED_5((byte) 0x80),\n-    CONNECTION_REFUSED_SERVER_UNAVAILABLE_5((byte) 0x80),\n-    CONNECTION_REFUSED_SERVER_BUSY((byte) 0x80),\n-    CONNECTION_REFUSED_BANNED((byte) 0x80),\n-    CONNECTION_REFUSED_BAD_AUTHENTICATION_METHOD((byte) 0x80),\n-    CONNECTION_REFUSED_TOPIC_NAME_INVALID((byte) 0x80),\n-    CONNECTION_REFUSED_PACKET_TOO_LARGE((byte) 0x80),\n-    CONNECTION_REFUSED_QUOTA_EXCEEDED((byte) 0x80),\n-    CONNECTION_REFUSED_PAYLOAD_FORMAT_INVALID((byte) 0x80),\n-    CONNECTION_REFUSED_RETAIN_NOT_SUPPORTED((byte) 0x80),\n-    CONNECTION_REFUSED_QOS_NOT_SUPPORTED((byte) 0x80),\n-    CONNECTION_REFUSED_USE_ANOTHER_SERVER((byte) 0x80),\n-    CONNECTION_REFUSED_SERVER_MOVED((byte) 0x80),\n-    CONNECTION_REFUSED_CONNECTION_RATE_EXCEEDED((byte) 0x80);\n+    CONNECTION_REFUSED_MALFORMED_PACKET((byte) 0x81),\n+    CONNECTION_REFUSED_PROTOCOL_ERROR((byte) 0x82),\n+    CONNECTION_REFUSED_IMPLEMENTATION_SPECIFIC((byte) 0x83),\n+    CONNECTION_REFUSED_UNSUPPORTED_PROTOCOL_VERSION((byte) 0x84),\n+    CONNECTION_REFUSED_CLIENT_IDENTIFIER_NOT_VALID((byte) 0x85),\n+    CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD((byte) 0x86),\n+    CONNECTION_REFUSED_NOT_AUTHORIZED_5((byte) 0x87),\n+    CONNECTION_REFUSED_SERVER_UNAVAILABLE_5((byte) 0x88),\n+    CONNECTION_REFUSED_SERVER_BUSY((byte) 0x89),\n+    CONNECTION_REFUSED_BANNED((byte) 0x8A),\n+    CONNECTION_REFUSED_BAD_AUTHENTICATION_METHOD((byte) 0x8C),\n+    CONNECTION_REFUSED_TOPIC_NAME_INVALID((byte) 0x90),\n+    CONNECTION_REFUSED_PACKET_TOO_LARGE((byte) 0x95),\n+    CONNECTION_REFUSED_QUOTA_EXCEEDED((byte) 0x97),\n+    CONNECTION_REFUSED_PAYLOAD_FORMAT_INVALID((byte) 0x99),\n+    CONNECTION_REFUSED_RETAIN_NOT_SUPPORTED((byte) 0x9A),\n+    CONNECTION_REFUSED_QOS_NOT_SUPPORTED((byte) 0x9B),\n+    CONNECTION_REFUSED_USE_ANOTHER_SERVER((byte) 0x9C),\n+    CONNECTION_REFUSED_SERVER_MOVED((byte) 0x9D),\n+    CONNECTION_REFUSED_CONNECTION_RATE_EXCEEDED((byte) 0x9F);\n \n     private static final Map<Byte, MqttConnectReturnCode> VALUE_TO_CODE_MAP;\n \n"}}, {"oid": "fc5dd1b3c9a8b35bd1b6c3945210d90c52fd985c", "url": "https://github.com/netty/netty/commit/fc5dd1b3c9a8b35bd1b6c3945210d90c52fd985c", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-15T04:44:09Z", "type": "forcePushed"}, {"oid": "714d09e2c80834289418d19cb97e658fc4477401", "url": "https://github.com/netty/netty/commit/714d09e2c80834289418d19cb97e658fc4477401", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-15T07:03:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066322", "bodyText": "Did you check for API breakage?", "author": "hyperxpro", "createdAt": "2020-08-16T05:08:15Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +43,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s\n             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.\n             return clientId != null;\n         }\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader) {\n+    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjYwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232603", "bodyText": "This method has package visibility and not intended to be called by classes outside of MQTT coded. MqttDecoder.decodeFixedHeader is the only place where it's called. Therefore, changing the API shouldn't be an issue here.", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI1OTg2OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471259869", "bodyText": "AS @paul-lysak noted... this is fine", "author": "normanmaurer", "createdAt": "2020-08-17T06:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\nindex bb3f765c68..6615b06e2a 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n\n@@ -51,7 +71,7 @@ final class MqttCodecUtil {\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {\n+    static MqttFixedHeader validateFixedHeader(ChannelHandlerContext ctx, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case PUBREL:\n             case SUBSCRIBE:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066418", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:09:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjYzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232639", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java\nindex 37e456a2d6..d1589571cf 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066467", "bodyText": "Can be final", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public class MqttProperties {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\nindex a9c839e361..9b2c40bc04 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ3NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066475", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:14Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\nindex 6f3a584975..b7fdf757ac 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066498", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:26Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\nindex bc0eba9b62..f9f419a920 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjU0MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066540", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\nindex 3b4521a8d3..2ad2ce26bc 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjU2MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066560", "bodyText": "Can be final.", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:04Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+/**\n+ * Model the SubscriptionOption used in Subscribe MQTT v5 packet\n+ */\n+public class MqttSubscriptionOption {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\nindex 3b4521a8d3..2ad2ce26bc 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjYyMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066620", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:39Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjcwNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232707", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\nindex 2c3712ca69..abc4546004 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY1Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066653", "bodyText": "Can be final.", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public class MqttUnsubAckPayload {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\nindex 2c3712ca69..abc4546004 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2014 The Netty Project\n+ * Copyright 2020 The Netty Project\n  *\n  * The Netty Project licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066679", "bodyText": "Wildcard * not allowed. Use FQCN.", "author": "hyperxpro", "createdAt": "2020-08-16T05:12:29Z", "path": "example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java", "diffHunk": "@@ -17,13 +17,7 @@\n \n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.handler.codec.mqtt.MqttConnectMessage;\n-import io.netty.handler.codec.mqtt.MqttConnectPayload;\n-import io.netty.handler.codec.mqtt.MqttConnectVariableHeader;\n-import io.netty.handler.codec.mqtt.MqttFixedHeader;\n-import io.netty.handler.codec.mqtt.MqttMessage;\n-import io.netty.handler.codec.mqtt.MqttMessageType;\n-import io.netty.handler.codec.mqtt.MqttQoS;\n+import io.netty.handler.codec.mqtt.*;", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjc1MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232751", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "chunk": "diff --git a/example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java b/example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java\nindex 6251596540..36268c7e8f 100644\n--- a/example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java\n+++ b/example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java\n\n@@ -17,7 +17,14 @@ package io.netty.example.mqtt.heartBeat;\n \n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.handler.codec.mqtt.*;\n+import io.netty.handler.codec.mqtt.MqttConnectMessage;\n+import io.netty.handler.codec.mqtt.MqttConnectPayload;\n+import io.netty.handler.codec.mqtt.MqttConnectVariableHeader;\n+import io.netty.handler.codec.mqtt.MqttFixedHeader;\n+import io.netty.handler.codec.mqtt.MqttMessage;\n+import io.netty.handler.codec.mqtt.MqttMessageType;\n+import io.netty.handler.codec.mqtt.MqttQoS;\n+import io.netty.handler.codec.mqtt.MqttProperties;\n import io.netty.handler.timeout.IdleStateEvent;\n import io.netty.util.ReferenceCountUtil;\n \n"}}, {"oid": "70fd242a06c005a1143442b4c8e258baef94c2a9", "url": "https://github.com/netty/netty/commit/70fd242a06c005a1143442b4c8e258baef94c2a9", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-17T04:59:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDExMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260113", "bodyText": "So we only use this for the decoder and not the encoder right ? If we also use it for he Encoder we may want to use CodecException", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:06Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +43,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s\n             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.\n             return clientId != null;\n         }\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader) {\n+    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {\n         switch (mqttFixedHeader.messageType()) {\n             case PUBREL:\n             case SUBSCRIBE:\n             case UNSUBSCRIBE:\n                 if (mqttFixedHeader.qosLevel() != MqttQoS.AT_LEAST_ONCE) {\n                     throw new DecoderException(mqttFixedHeader.messageType().name() + \" message must have QoS 1\");\n                 }\n+                return mqttFixedHeader;\n+            case AUTH:\n+                if (mqttVersion != MqttVersion.MQTT_5) {\n+                    throw new DecoderException(\"AUTH message requires at least MQTT 5\");", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4MTEyOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471981129", "bodyText": "Right, the only place where this method is used is MqttDecoder.decodeFixedHeader.", "author": "paul-lysak", "createdAt": "2020-08-18T07:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDExMw=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\nindex bb3f765c68..6615b06e2a 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n\n@@ -51,7 +71,7 @@ final class MqttCodecUtil {\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {\n+    static MqttFixedHeader validateFixedHeader(ChannelHandlerContext ctx, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case PUBREL:\n             case SUBSCRIBE:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDIyNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260224", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java", "diffHunk": "@@ -27,9 +27,17 @@\n \n     private final boolean sessionPresent;\n \n+    private MqttProperties properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNDYxMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472104611", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-18T11:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDIyNA=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\nindex e4fc94b576..c6ef2a1c70 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\n\n@@ -27,7 +27,7 @@ public final class MqttConnAckVariableHeader {\n \n     private final boolean sessionPresent;\n \n-    private MqttProperties properties;\n+    private final MqttProperties properties;\n \n     public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {\n         this(connectReturnCode, sessionPresent, MqttProperties.NO_PROPERTIES);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDI5Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260296", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:37Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -27,13 +27,15 @@\n public final class MqttConnectPayload {\n \n     private final String clientIdentifier;\n+    private MqttProperties willProperties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\nindex 04ff487bc8..7623dd4f1f 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n\n@@ -27,7 +27,7 @@ import io.netty.util.internal.StringUtil;\n public final class MqttConnectPayload {\n \n     private final String clientIdentifier;\n-    private MqttProperties willProperties;\n+    private final MqttProperties willProperties;\n     private final String willTopic;\n     private final byte[] willMessage;\n     private final String userName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDM2Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260363", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:49Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -32,6 +32,7 @@\n     private final boolean isWillFlag;\n     private final boolean isCleanSession;\n     private final int keepAliveTimeSeconds;\n+    private MqttProperties properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\nindex 807584676b..ad9a83de3d 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n\n@@ -32,7 +32,7 @@ public final class MqttConnectVariableHeader {\n     private final boolean isWillFlag;\n     private final boolean isCleanSession;\n     private final int keepAliveTimeSeconds;\n-    private MqttProperties properties;\n+    private final MqttProperties properties;\n \n     public MqttConnectVariableHeader(\n             String name,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260656", "bodyText": "can you please explain why we need an AtomicReference here ?", "author": "normanmaurer", "createdAt": "2020-08-17T06:41:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4MzY2Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471983662", "bodyText": "Encoder and decoder take protocol version from the CONNECT message and this message goes only through one of them -i.e. for the client it goes through Encoder, but not though Decoder. For the server - vice versa: it goes through Decoder, but not though Encoder. All subsequent messages should follow the protocol version as there are some subtle differences in MQTT 5 which require encoding/decoding in a different way to stay compatible.\nTherefore, there should be some way for Encoder and Decoder to share information about the MQTT version. AtomicReference seemed the simplest solution for that, without reinventing the wheel. Do you have better suggestions for that?", "author": "paul-lysak", "createdAt": "2020-08-18T07:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjAwMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471986002", "bodyText": "I think a better way would be to use AttributeKey with Channel.attr(...)", "author": "normanmaurer", "createdAt": "2020-08-18T07:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNDk3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472104979", "bodyText": "Changed to use AttributeKey", "author": "paul-lysak", "createdAt": "2020-08-18T11:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex a4b8c00eff..f6f198fd53 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -59,90 +59,69 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n-    private AtomicReference<MqttVersion> mqttVersionRef;\n-\n-    private MqttVersion mqttVersion() {\n-        if (mqttVersionRef == null) {\n-            return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return mqttVersionRef.get();\n-        }\n-    }\n-\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n-        this(maxBytesInMessage, null);\n-    }\n-\n-    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n-    }\n-\n-    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n-        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER:\n-                try {\n-                    mqttFixedHeader = decodeFixedHeader(buffer);\n-                    bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n-                    checkpoint(DecoderState.READ_VARIABLE_HEADER);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n-                }\n+            case READ_FIXED_HEADER: try {\n+                mqttFixedHeader = decodeFixedHeader(ctx, buffer);\n+                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n+                checkpoint(DecoderState.READ_VARIABLE_HEADER);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_VARIABLE_HEADER:\n-                try {\n-                    final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n-                    variableHeader = decodedVariableHeader.value;\n-                    if (bytesRemainingInVariablePart > maxBytesInMessage) {\n-                        throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n-                    }\n-                    bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n-                    checkpoint(DecoderState.READ_PAYLOAD);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_VARIABLE_HEADER:  try {\n+                final Result<?> decodedVariableHeader = decodeVariableHeader(ctx, buffer, mqttFixedHeader);\n+                variableHeader = decodedVariableHeader.value;\n+                if (bytesRemainingInVariablePart > maxBytesInMessage) {\n+                    throw new TooLongFrameException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n                 }\n+                bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n+                checkpoint(DecoderState.READ_PAYLOAD);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_PAYLOAD:\n-                try {\n-                    final Result<?> decodedPayload =\n-                            decodePayload(\n-                                    buffer,\n-                                    mqttFixedHeader.messageType(),\n-                                    bytesRemainingInVariablePart,\n-                                    variableHeader);\n-                    bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n-                    if (bytesRemainingInVariablePart != 0) {\n-                        throw new DecoderException(\n-                                \"non-zero remaining payload bytes: \" +\n-                                        bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n-                    }\n-                    checkpoint(DecoderState.READ_FIXED_HEADER);\n-                    MqttMessage message = MqttMessageFactory.newMessage(\n-                            mqttFixedHeader, variableHeader, decodedPayload.value);\n-                    mqttFixedHeader = null;\n-                    variableHeader = null;\n-                    out.add(message);\n-                    break;\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_PAYLOAD: try {\n+                final Result<?> decodedPayload =\n+                        decodePayload(\n+                                ctx,\n+                                buffer,\n+                                mqttFixedHeader.messageType(),\n+                                bytesRemainingInVariablePart,\n+                                variableHeader);\n+                bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n+                if (bytesRemainingInVariablePart != 0) {\n+                    throw new DecoderException(\n+                            \"non-zero remaining payload bytes: \" +\n+                                    bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n                 }\n+                checkpoint(DecoderState.READ_FIXED_HEADER);\n+                MqttMessage message = MqttMessageFactory.newMessage(\n+                        mqttFixedHeader, variableHeader, decodedPayload.value);\n+                mqttFixedHeader = null;\n+                variableHeader = null;\n+                out.add(message);\n+                break;\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n             case BAD_MESSAGE:\n                 // Keep discarding until disconnection.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTcyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471969723", "bodyText": "It would be nice if you could revert the formatting changes to make this easier to review", "author": "normanmaurer", "createdAt": "2020-08-18T07:26:22Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;\n+\n+    private MqttVersion mqttVersion() {\n+        if (mqttVersionRef == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {\n+            return mqttVersionRef.get();\n+        }\n+    }\n+\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n+        this(maxBytesInMessage, null);\n+    }\n+\n+    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n+    }\n+\n+    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n+        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER: try {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNTM5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472105390", "bodyText": "done wherever possible", "author": "paul-lysak", "createdAt": "2020-08-18T11:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTcyMw=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex a4b8c00eff..f6f198fd53 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -59,90 +59,69 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n-    private AtomicReference<MqttVersion> mqttVersionRef;\n-\n-    private MqttVersion mqttVersion() {\n-        if (mqttVersionRef == null) {\n-            return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return mqttVersionRef.get();\n-        }\n-    }\n-\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n-        this(maxBytesInMessage, null);\n-    }\n-\n-    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n-    }\n-\n-    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n-        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER:\n-                try {\n-                    mqttFixedHeader = decodeFixedHeader(buffer);\n-                    bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n-                    checkpoint(DecoderState.READ_VARIABLE_HEADER);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n-                }\n+            case READ_FIXED_HEADER: try {\n+                mqttFixedHeader = decodeFixedHeader(ctx, buffer);\n+                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n+                checkpoint(DecoderState.READ_VARIABLE_HEADER);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_VARIABLE_HEADER:\n-                try {\n-                    final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n-                    variableHeader = decodedVariableHeader.value;\n-                    if (bytesRemainingInVariablePart > maxBytesInMessage) {\n-                        throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n-                    }\n-                    bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n-                    checkpoint(DecoderState.READ_PAYLOAD);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_VARIABLE_HEADER:  try {\n+                final Result<?> decodedVariableHeader = decodeVariableHeader(ctx, buffer, mqttFixedHeader);\n+                variableHeader = decodedVariableHeader.value;\n+                if (bytesRemainingInVariablePart > maxBytesInMessage) {\n+                    throw new TooLongFrameException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n                 }\n+                bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n+                checkpoint(DecoderState.READ_PAYLOAD);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_PAYLOAD:\n-                try {\n-                    final Result<?> decodedPayload =\n-                            decodePayload(\n-                                    buffer,\n-                                    mqttFixedHeader.messageType(),\n-                                    bytesRemainingInVariablePart,\n-                                    variableHeader);\n-                    bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n-                    if (bytesRemainingInVariablePart != 0) {\n-                        throw new DecoderException(\n-                                \"non-zero remaining payload bytes: \" +\n-                                        bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n-                    }\n-                    checkpoint(DecoderState.READ_FIXED_HEADER);\n-                    MqttMessage message = MqttMessageFactory.newMessage(\n-                            mqttFixedHeader, variableHeader, decodedPayload.value);\n-                    mqttFixedHeader = null;\n-                    variableHeader = null;\n-                    out.add(message);\n-                    break;\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_PAYLOAD: try {\n+                final Result<?> decodedPayload =\n+                        decodePayload(\n+                                ctx,\n+                                buffer,\n+                                mqttFixedHeader.messageType(),\n+                                bytesRemainingInVariablePart,\n+                                variableHeader);\n+                bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n+                if (bytesRemainingInVariablePart != 0) {\n+                    throw new DecoderException(\n+                            \"non-zero remaining payload bytes: \" +\n+                                    bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n                 }\n+                checkpoint(DecoderState.READ_FIXED_HEADER);\n+                MqttMessage message = MqttMessageFactory.newMessage(\n+                        mqttFixedHeader, variableHeader, decodedPayload.value);\n+                mqttFixedHeader = null;\n+                variableHeader = null;\n+                out.add(message);\n+                break;\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n             case BAD_MESSAGE:\n                 // Keep discarding until disconnection.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTk4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471969982", "bodyText": "Use TooLongFrameException", "author": "normanmaurer", "createdAt": "2020-08-18T07:26:47Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;\n+\n+    private MqttVersion mqttVersion() {\n+        if (mqttVersionRef == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {\n+            return mqttVersionRef.get();\n+        }\n+    }\n+\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n+        this(maxBytesInMessage, null);\n+    }\n+\n+    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n+    }\n+\n+    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n+        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER: try {\n-                mqttFixedHeader = decodeFixedHeader(buffer);\n-                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n-                checkpoint(DecoderState.READ_VARIABLE_HEADER);\n-                // fall through\n-            } catch (Exception cause) {\n-                out.add(invalidMessage(cause));\n-                return;\n-            }\n+            case READ_FIXED_HEADER:\n+                try {\n+                    mqttFixedHeader = decodeFixedHeader(buffer);\n+                    bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n+                    checkpoint(DecoderState.READ_VARIABLE_HEADER);\n+                    // fall through\n+                } catch (Exception cause) {\n+                    out.add(invalidMessage(cause));\n+                    return;\n+                }\n \n-            case READ_VARIABLE_HEADER:  try {\n-                final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n-                variableHeader = decodedVariableHeader.value;\n-                if (bytesRemainingInVariablePart > maxBytesInMessage) {\n-                    throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n+            case READ_VARIABLE_HEADER:\n+                try {\n+                    final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n+                    variableHeader = decodedVariableHeader.value;\n+                    if (bytesRemainingInVariablePart > maxBytesInMessage) {\n+                        throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex a4b8c00eff..f6f198fd53 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -59,90 +59,69 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n-    private AtomicReference<MqttVersion> mqttVersionRef;\n-\n-    private MqttVersion mqttVersion() {\n-        if (mqttVersionRef == null) {\n-            return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return mqttVersionRef.get();\n-        }\n-    }\n-\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n-        this(maxBytesInMessage, null);\n-    }\n-\n-    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n-        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n-    }\n-\n-    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n-        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER:\n-                try {\n-                    mqttFixedHeader = decodeFixedHeader(buffer);\n-                    bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n-                    checkpoint(DecoderState.READ_VARIABLE_HEADER);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n-                }\n+            case READ_FIXED_HEADER: try {\n+                mqttFixedHeader = decodeFixedHeader(ctx, buffer);\n+                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n+                checkpoint(DecoderState.READ_VARIABLE_HEADER);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_VARIABLE_HEADER:\n-                try {\n-                    final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n-                    variableHeader = decodedVariableHeader.value;\n-                    if (bytesRemainingInVariablePart > maxBytesInMessage) {\n-                        throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n-                    }\n-                    bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n-                    checkpoint(DecoderState.READ_PAYLOAD);\n-                    // fall through\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_VARIABLE_HEADER:  try {\n+                final Result<?> decodedVariableHeader = decodeVariableHeader(ctx, buffer, mqttFixedHeader);\n+                variableHeader = decodedVariableHeader.value;\n+                if (bytesRemainingInVariablePart > maxBytesInMessage) {\n+                    throw new TooLongFrameException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n                 }\n+                bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;\n+                checkpoint(DecoderState.READ_PAYLOAD);\n+                // fall through\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n-            case READ_PAYLOAD:\n-                try {\n-                    final Result<?> decodedPayload =\n-                            decodePayload(\n-                                    buffer,\n-                                    mqttFixedHeader.messageType(),\n-                                    bytesRemainingInVariablePart,\n-                                    variableHeader);\n-                    bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n-                    if (bytesRemainingInVariablePart != 0) {\n-                        throw new DecoderException(\n-                                \"non-zero remaining payload bytes: \" +\n-                                        bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n-                    }\n-                    checkpoint(DecoderState.READ_FIXED_HEADER);\n-                    MqttMessage message = MqttMessageFactory.newMessage(\n-                            mqttFixedHeader, variableHeader, decodedPayload.value);\n-                    mqttFixedHeader = null;\n-                    variableHeader = null;\n-                    out.add(message);\n-                    break;\n-                } catch (Exception cause) {\n-                    out.add(invalidMessage(cause));\n-                    return;\n+            case READ_PAYLOAD: try {\n+                final Result<?> decodedPayload =\n+                        decodePayload(\n+                                ctx,\n+                                buffer,\n+                                mqttFixedHeader.messageType(),\n+                                bytesRemainingInVariablePart,\n+                                variableHeader);\n+                bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;\n+                if (bytesRemainingInVariablePart != 0) {\n+                    throw new DecoderException(\n+                            \"non-zero remaining payload bytes: \" +\n+                                    bytesRemainingInVariablePart + \" (\" + mqttFixedHeader.messageType() + ')');\n                 }\n+                checkpoint(DecoderState.READ_FIXED_HEADER);\n+                MqttMessage message = MqttMessageFactory.newMessage(\n+                        mqttFixedHeader, variableHeader, decodedPayload.value);\n+                mqttFixedHeader = null;\n+                variableHeader = null;\n+                out.add(message);\n+                break;\n+            } catch (Exception cause) {\n+                out.add(invalidMessage(cause));\n+                return;\n+            }\n \n             case BAD_MESSAGE:\n                 // Keep discarding until disconnection.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjA2MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471972061", "bodyText": "This will not work as MqttEncoder is marked as @Sharable and so may be shared between different Channel\ufffd instances.", "author": "normanmaurer", "createdAt": "2020-08-18T07:30:01Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -36,9 +39,24 @@\n @ChannelHandler.Sharable\n public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n-    public static final MqttEncoder INSTANCE = new MqttEncoder();\n+    public static final MqttEncoder INSTANCE = new MqttEncoder(null);\n \n-    private MqttEncoder() { }\n+    private AtomicReference<MqttVersion> mqttVersionRef;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNTcxOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472105719", "bodyText": "Changed version handling approach, removed atomic references.", "author": "paul-lysak", "createdAt": "2020-08-18T11:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex b87bee78b1..59efe0de01 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -39,28 +37,13 @@ import static io.netty.handler.codec.mqtt.MqttCodecUtil.*;\n @ChannelHandler.Sharable\n public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n-    public static final MqttEncoder INSTANCE = new MqttEncoder(null);\n+    public static final MqttEncoder INSTANCE = new MqttEncoder();\n \n-    private AtomicReference<MqttVersion> mqttVersionRef;\n-\n-    private MqttVersion mqttVersion() {\n-        if (mqttVersionRef == null) {\n-            return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return mqttVersionRef.get();\n-        }\n-    }\n-\n-    /**\n-     * @param mqttVersionRef - version reference to be shared between encoder and decoder. If null - assumes MQTT 3\n-     */\n-    public MqttEncoder(AtomicReference<MqttVersion> mqttVersionRef) {\n-        this.mqttVersionRef = mqttVersionRef;\n-    }\n+    private MqttEncoder() { }\n \n     @Override\n     protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> out) throws Exception {\n-        out.add(doEncode(ctx.alloc(), msg));\n+        out.add(doEncode(ctx, ctx.alloc(), msg));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjQ2OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471972468", "bodyText": "nit: you can merge the above two lines", "author": "normanmaurer", "createdAt": "2020-08-18T07:30:39Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -234,23 +276,35 @@ private static ByteBuf encodeSubscribeMessage(\n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n \n         // Payload\n         for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            writeUTF8String(buf, topic.topicName());\n+            final MqttSubscriptionOption option = topic.option();\n+\n+            int optionEncoded = 0;\n+            optionEncoded |= option.retainHandling().value() << 4;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex b87bee78b1..59efe0de01 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -299,10 +297,14 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         return buf;\n     }\n \n-    private ByteBuf encodeUnsubscribeMessage(\n+    private static ByteBuf encodeUnsubscribeMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttUnsubscribeMessage message) {\n-        ByteBuf propertiesBuf = encodePropertiesIfNeeded(byteBufAllocator, message.variableHeader().properties());\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.variableHeader().properties());\n \n         final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzEwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973108", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:31:41Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- *     MQTTV3.1/unsubscribe</a>\n+ * MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n     public MqttUnsubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttUnsubscribePayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttUnsubscribeMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttUnsubscribePayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\nindex 066011af73..67d45cadd8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\n\n@@ -18,7 +18,7 @@ package io.netty.handler.codec.mqtt;\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- * MQTTV3.1/unsubscribe</a>\n+ *     MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzIxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973213", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:31:49Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- *     MQTTV3.1/unsubscribe</a>\n+ * MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n     public MqttUnsubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\nindex 066011af73..67d45cadd8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java\n\n@@ -18,7 +18,7 @@ package io.netty.handler.codec.mqtt;\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- * MQTTV3.1/unsubscribe</a>\n+ *     MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzM0NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973345", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:02Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,35 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {\n-        super(mqttFixedHeader, variableHeader, null);\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdAndPropertiesVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        super(mqttFixedHeader, variableHeader, payload);\n+    }\n+\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n+    }\n+\n+    private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n+            MqttMessageIdVariableHeader variableHeader) {\n+        if (variableHeader instanceof MqttMessageIdAndPropertiesVariableHeader) {\n+            return (MqttMessageIdAndPropertiesVariableHeader) variableHeader;\n+        } else {\n+            return new MqttMessageIdAndPropertiesVariableHeader(variableHeader.messageId(),\n+                    MqttProperties.NO_PROPERTIES);\n+        }\n+    }\n+\n+    @Override\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {\n+        return (MqttMessageIdAndPropertiesVariableHeader) super.variableHeader();\n     }\n \n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttUnsubAckPayload payload() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\nindex 2017c7f3a3..3f50e4a9ad 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n\n@@ -32,6 +32,10 @@ public final class MqttUnsubAckMessage extends MqttMessage {\n                                MqttUnsubAckPayload payload) {\n         this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n     }\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader) {\n+        this(mqttFixedHeader, variableHeader, null);\n+    }\n \n     private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n             MqttMessageIdVariableHeader variableHeader) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzQ0MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973440", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:11Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,35 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\nindex 2017c7f3a3..3f50e4a9ad 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n\n@@ -32,6 +32,10 @@ public final class MqttUnsubAckMessage extends MqttMessage {\n                                MqttUnsubAckPayload payload) {\n         this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n     }\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader) {\n+        this(mqttFixedHeader, variableHeader, null);\n+    }\n \n     private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n             MqttMessageIdVariableHeader variableHeader) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzYxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973618", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- *     MQTTV3.1/subscribe</a>\n+ * MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n     public MqttSubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttSubscribePayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttSubscribeMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttSubscribePayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\nindex f2a52e8a74..8db27877d8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\n\n@@ -18,7 +18,7 @@ package io.netty.handler.codec.mqtt;\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- * MQTTV3.1/subscribe</a>\n+ *     MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzY1MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973650", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:29Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- *     MQTTV3.1/subscribe</a>\n+ * MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n     public MqttSubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\nindex f2a52e8a74..8db27877d8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java\n\n@@ -18,7 +18,7 @@ package io.netty.handler.codec.mqtt;\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- * MQTTV3.1/subscribe</a>\n+ *     MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973703", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java", "diffHunk": "@@ -23,14 +23,21 @@\n \n     public MqttSubAckMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttSubAckPayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttSubAckMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttSubAckPayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4ODgzMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471988831", "bodyText": "MqttMessageIdAndPropertiesVariableHeader is a subclass of MqttMessageIdVariableHeader - the value returned from variableHeader here will match the expectations of the users of the coded.", "author": "paul-lysak", "createdAt": "2020-08-18T07:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4OTU2NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471989564", "bodyText": "Unfortunally this will still not work as it will break binary compat as far as I know", "author": "normanmaurer", "createdAt": "2020-08-18T07:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MDY5NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471990694", "bodyText": "if you run mvn clean package it should check for these kind of things and fail the build", "author": "normanmaurer", "createdAt": "2020-08-18T08:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4NzE4OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472287188", "bodyText": "Unfortunately, wasn't able to run this check today due to #10114 - the full build of the fresh Netty code from branch 4.1 (without my changes) didn't complete. Tomorrow I'll try to skip epoll transport build and see if it goes forward.", "author": "paul-lysak", "createdAt": "2020-08-18T15:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MDQ3Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472740472", "bodyText": "Verified in coded-mqtt folder with mvn clean verify. You were right about the return types: https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.15.\nFixed this and other compatibility issues detected by japicmp.", "author": "paul-lysak", "createdAt": "2020-08-19T06:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}], "type": "inlineReview", "revised_code": {"commit": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\nindex 07fdd875eb..f0c7719306 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\n\n@@ -36,7 +36,11 @@ public final class MqttSubAckMessage extends MqttMessage {\n     }\n \n     @Override\n-    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {\n+    public MqttMessageIdVariableHeader variableHeader() {\n+        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    }\n+\n+    public MqttMessageIdAndPropertiesVariableHeader idAndPropertiesVariableHeader() {\n         return (MqttMessageIdAndPropertiesVariableHeader) super.variableHeader();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzc0OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973748", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java", "diffHunk": "@@ -23,14 +23,21 @@\n \n     public MqttSubAckMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4OTcxMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471989711", "bodyText": "There's a constructor with the old signature besides this one - the code that uses the old API will use the old version, while the code that uses MQTT 5 features will use the new one.", "author": "paul-lysak", "createdAt": "2020-08-18T07:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\nindex 07fdd875eb..f0c7719306 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java\n\n@@ -36,7 +36,11 @@ public final class MqttSubAckMessage extends MqttMessage {\n     }\n \n     @Override\n-    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {\n+    public MqttMessageIdVariableHeader variableHeader() {\n+        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    }\n+\n+    public MqttMessageIdAndPropertiesVariableHeader idAndPropertiesVariableHeader() {\n         return (MqttMessageIdAndPropertiesVariableHeader) super.variableHeader();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzkyMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973920", "bodyText": "missing null checks", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:54Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * Variable Header for AUTH and DISCONNECT messages represented by {@link MqttMessage}\n+ */\n+public final class MqttReasonCodeAndPropertiesVariableHeader {\n+\n+    private final byte reasonCode;\n+    private final MqttProperties properties;\n+\n+    public static final byte REASON_CODE_OK = 0;\n+\n+    public MqttReasonCodeAndPropertiesVariableHeader(byte reasonCode,\n+                                                     MqttProperties properties) {\n+        this.reasonCode = reasonCode;\n+        this.properties = properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\nindex f9f419a920..24d959331f 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java\n\n@@ -31,7 +31,11 @@ public final class MqttReasonCodeAndPropertiesVariableHeader {\n     public MqttReasonCodeAndPropertiesVariableHeader(byte reasonCode,\n                                                      MqttProperties properties) {\n         this.reasonCode = reasonCode;\n-        this.properties = properties;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.properties = properties;\n+        }\n     }\n \n     public byte reasonCode() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzk4MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973981", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:33:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java", "diffHunk": "@@ -25,10 +25,12 @@\n \n     private final String topicName;\n     private final int packetId;\n+    private final MqttProperties mqttProperties;\n \n-    public MqttPublishVariableHeader(String topicName, int packetId) {\n+    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\nindex 378b35b386..83958ef687 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\n\n@@ -27,6 +27,10 @@ public final class MqttPublishVariableHeader {\n     private final int packetId;\n     private final MqttProperties mqttProperties;\n \n+    public MqttPublishVariableHeader(String topicName, int packetId) {\n+        this(topicName, packetId, MqttProperties.NO_PROPERTIES);\n+    }\n+\n     public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {\n         this.topicName = topicName;\n         this.packetId = packetId;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NDA4Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471974086", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:33:13Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java", "diffHunk": "@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2014 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package io.netty.handler.codec.mqtt;\n-\n-/**\n- * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#puback\">MQTTV3.1/puback</a>\n- */\n-public final class MqttPubAckMessage extends MqttMessage {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwODkyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472108923", "bodyText": "Restored MqttPubAckMessage and its encoding/decoding. It makes little sense, however - PUBACK, PUBREC, PUBREL and PUBCOMP can be handled as MqttMessage (which is superclass of MqttPubAckMessage), just with a custom variable header class. Does it make sense to mark MqttPubAckMessage as deprecated?", "author": "paul-lysak", "createdAt": "2020-08-18T11:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NDA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java\nnew file mode 100644\nindex 0000000000..d878f1508c\n--- /dev/null\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java\n\n@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.mqtt;\n+\n+/**\n+ * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#puback\">MQTTV3.1/puback</a>\n+ */\n+public final class MqttPubAckMessage extends MqttMessage {\n+\n+    public MqttPubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {\n+        super(mqttFixedHeader, variableHeader);\n+    }\n+\n+    @Override\n+    public MqttMessageIdVariableHeader variableHeader() {\n+        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    }\n+}\n"}}, {"oid": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "url": "https://github.com/netty/netty/commit/9786339412a2f1b31d2a8dbfc6c07f9120842091", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-18T11:16:27Z", "type": "forcePushed"}, {"oid": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "url": "https://github.com/netty/netty/commit/a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T06:04:02Z", "type": "forcePushed"}, {"oid": "95eb759b41c870c90d0165d2d6b323d2457ed143", "url": "https://github.com/netty/netty/commit/95eb759b41c870c90d0165d2d6b323d2457ed143", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T06:10:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NTUwNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472875505", "bodyText": "nit: you can remove the else as you return in the if anyway", "author": "normanmaurer", "createdAt": "2020-08-19T09:00:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -16,14 +16,34 @@\n \n package io.netty.handler.codec.mqtt;\n \n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.DecoderException;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n \n final class MqttCodecUtil {\n \n     private static final char[] TOPIC_WILDCARDS = {'#', '+'};\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");\n+\n+    static MqttVersion getMqttVersion(ChannelHandlerContext ctx) {\n+        Attribute<MqttVersion> attr = ctx.channel().attr(MQTT_VERSION_KEY);\n+        MqttVersion version = attr.get();\n+        if (version == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\nindex 6615b06e2a..f3552a2e27 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n\n@@ -27,16 +27,15 @@ final class MqttCodecUtil {\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n-    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");\n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"NETTY_CODEC_MQTT_VERSION\");\n \n     static MqttVersion getMqttVersion(ChannelHandlerContext ctx) {\n         Attribute<MqttVersion> attr = ctx.channel().attr(MQTT_VERSION_KEY);\n         MqttVersion version = attr.get();\n         if (version == null) {\n             return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return version;\n         }\n+        return version;\n     }\n \n     static void setMqttVersion(ChannelHandlerContext ctx, MqttVersion version) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NTk1MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472875951", "bodyText": "I would use a \"more unique\" name so we not clash with something the user may have defined already", "author": "normanmaurer", "createdAt": "2020-08-19T09:01:19Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -16,14 +16,34 @@\n \n package io.netty.handler.codec.mqtt;\n \n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.DecoderException;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n \n final class MqttCodecUtil {\n \n     private static final char[] TOPIC_WILDCARDS = {'#', '+'};\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\nindex 6615b06e2a..f3552a2e27 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n\n@@ -27,16 +27,15 @@ final class MqttCodecUtil {\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n-    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");\n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"NETTY_CODEC_MQTT_VERSION\");\n \n     static MqttVersion getMqttVersion(ChannelHandlerContext ctx) {\n         Attribute<MqttVersion> attr = ctx.channel().attr(MQTT_VERSION_KEY);\n         MqttVersion version = attr.get();\n         if (version == null) {\n             return MqttVersion.MQTT_3_1_1;\n-        } else {\n-            return version;\n         }\n+        return version;\n     }\n \n     static void setMqttVersion(ChannelHandlerContext ctx, MqttVersion version) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjI5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472876290", "bodyText": "nit: update comment to reflect that this is also true for version 5 ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:01:52Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +63,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\nindex 6615b06e2a..f3552a2e27 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java\n\n@@ -64,7 +63,7 @@ final class MqttCodecUtil {\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n         if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n-            // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s\n+            // In 3.1.3.1 Client Identifier of MQTT 3.1.1 and 5.0 specifications, The Server MAY allow ClientId\u2019s\n             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.\n             return clientId != null;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzMzNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877334", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -52,6 +76,7 @@ public MqttConnectVariableHeader(\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\nindex 506d7d904c..87c0934020 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n\n@@ -76,7 +76,11 @@ public final class MqttConnectVariableHeader {\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n-        this.properties = properties;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.properties = properties;\n+        }\n     }\n \n     public String name() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzQxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877413", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:50Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -56,7 +59,23 @@ public MqttConnectPayload(\n             byte[] willMessage,\n             String userName,\n             byte[] password) {\n+        this(clientIdentifier,\n+                MqttProperties.NO_PROPERTIES,\n+                willTopic,\n+                willMessage,\n+                userName,\n+                password);\n+    }\n+\n+    public MqttConnectPayload(\n+            String clientIdentifier,\n+            MqttProperties willProperties,\n+            String willTopic,\n+            byte[] willMessage,\n+            String userName,\n+            byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n+        this.willProperties = willProperties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\nindex a051f9e43f..7169e4900c 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n\n@@ -75,7 +75,11 @@ public final class MqttConnectPayload {\n             String userName,\n             byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n-        this.willProperties = willProperties;\n+        if (willProperties == null) {\n+            this.willProperties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.willProperties = willProperties;\n+        }\n         this.willTopic = willTopic;\n         this.willMessage = willMessage;\n         this.userName = userName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzQ2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877467", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java", "diffHunk": "@@ -27,9 +27,17 @@\n \n     private final boolean sessionPresent;\n \n+    private final MqttProperties properties;\n+\n     public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {\n+        this(connectReturnCode, sessionPresent, MqttProperties.NO_PROPERTIES);\n+    }\n+\n+    public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent,\n+                                     MqttProperties properties) {\n         this.connectReturnCode = connectReturnCode;\n         this.sessionPresent = sessionPresent;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\nindex c6ef2a1c70..b4fa704ee8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java\n\n@@ -37,7 +37,11 @@ public final class MqttConnAckVariableHeader {\n                                      MqttProperties properties) {\n         this.connectReturnCode = connectReturnCode;\n         this.sessionPresent = sessionPresent;\n-        this.properties = properties;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.properties = properties;\n+        }\n     }\n \n     public MqttConnectReturnCode connectReturnCode() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3ODAzMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472878032", "bodyText": "can't this be static now ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:04:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,52 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMDg0OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472920849", "bodyText": "Unfortunately no - decodePubReplyMessage, decodePublishVariableHeader and decodeReasonCodeAndPropertiesVariableHeader rely on bytesRemainingInVariablePart, because reason code and properties may be skipped in case of successful message.", "author": "paul-lysak", "createdAt": "2020-08-19T10:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3ODAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -210,8 +210,10 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n             case PINGRESP:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);\n+            default:\n+                //shouldn't reach here\n+                return new Result<Object>(null, 0);\n         }\n-        return new Result<Object>(null, 0); //should never reach here\n     }\n \n     private static Result<MqttConnectVariableHeader> decodeConnectionVariableHeader(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3OTU5Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472879593", "bodyText": "Isn't that the same as calling buffer.readInt(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:07:37Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +634,36 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n+        int remainingLength = 0;\n+        int multiplier = 1;\n+        short digit;\n+        int loops = 0;\n+        do {\n+            digit = buffer.readUnsignedByte();\n+            remainingLength += (digit & 127) * multiplier;\n+            multiplier *= 128;\n+            loops++;\n+        } while ((digit & 128) != 0 && loops < 4);\n+\n+        // MQTT protocol limits Remaining Length to 4 bytes\n+        if (loops == 4 && (digit & 128) != 0) {\n+            return null;\n+        }\n+        return new Result<Integer>(remainingLength, loops);\n+    }\n+\n+    private static Result<Integer> decode4bytesInteger(ByteBuf buffer) {\n+        short msb = buffer.readUnsignedByte();\n+        short secondByte = buffer.readUnsignedByte();\n+        short thirdByte = buffer.readUnsignedByte();\n+        short lsbSize = buffer.readUnsignedByte();\n+        final int numberOfBytesConsumed = 4;\n+        int result = msb << 24 | secondByte << 16 | thirdByte << 8 | lsbSize;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MzIyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472963226", "bodyText": "Right, removed the duplicate code", "author": "paul-lysak", "createdAt": "2020-08-19T11:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3OTU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -634,6 +637,12 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    /**\n+     * See 1.5.5 Variable Byte Integer section of MQTT 5.0 specification for encoding/decoding rules\n+     *\n+     * @param buffer\n+     * @return\n+     */\n     private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n         int remainingLength = 0;\n         int multiplier = 1;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MDM0NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472880344", "bodyText": "would be nice if you can link to the spec so its clearer what you are doing here in terms of masking etc", "author": "normanmaurer", "createdAt": "2020-08-19T09:08:53Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -379,9 +519,20 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         while (numberOfBytesConsumed < bytesRemainingInVariablePart) {\n             final Result<String> decodedTopicName = decodeString(buffer);\n             numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;\n-            int qos = buffer.readUnsignedByte() & 0x03;\n+            final short optionByte = buffer.readUnsignedByte();\n+\n+            MqttQoS qos = MqttQoS.valueOf(optionByte & 0x03);", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -519,6 +521,7 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n         while (numberOfBytesConsumed < bytesRemainingInVariablePart) {\n             final Result<String> decodedTopicName = decodeString(buffer);\n             numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;\n+            //See 3.8.3.1 Subscription Options of MQTT 5.0 specification for optionByte details\n             final short optionByte = buffer.readUnsignedByte();\n \n             MqttQoS qos = MqttQoS.valueOf(optionByte & 0x03);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MDcwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472880708", "bodyText": "please add a default: as well", "author": "normanmaurer", "createdAt": "2020-08-19T09:09:28Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -474,4 +674,78 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n             this.numberOfBytesConsumed = numberOfBytesConsumed;\n         }\n     }\n+\n+    private static Result<MqttProperties> decodeProperties(ByteBuf buffer) {\n+        final Result<Integer> propertiesLength = decodeVariableByteInteger(buffer);\n+        int totalPropertiesLength = propertiesLength.value;\n+        int numberOfBytesConsumed = propertiesLength.numberOfBytesConsumed;\n+\n+        MqttProperties decodedProperties = new MqttProperties();\n+        while (numberOfBytesConsumed < totalPropertiesLength) {\n+            Result<Integer> propertyId = decodeVariableByteInteger(buffer);\n+            numberOfBytesConsumed += propertyId.numberOfBytesConsumed;\n+\n+            switch (MqttProperties.MqttPropertyType.valueOf(propertyId.value)) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    final int b1 = buffer.readUnsignedByte();\n+                    numberOfBytesConsumed++;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, b1));\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    final Result<Integer> int2BytesResult = decodeMsbLsb(buffer);\n+                    numberOfBytesConsumed += int2BytesResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, int2BytesResult.value));\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    final Result<Integer> int4BytesResult = decode4bytesInteger(buffer);\n+                    numberOfBytesConsumed += int4BytesResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, int4BytesResult.value));\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    Result<Integer> vbIntegerResult = decodeVariableByteInteger(buffer);\n+                    numberOfBytesConsumed += vbIntegerResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, vbIntegerResult.value));\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    final Result<String> stringResult = decodeString(buffer);\n+                    numberOfBytesConsumed += stringResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.StringProperty(propertyId.value, stringResult.value));\n+                    break;\n+                case USER_PROPERTY:\n+                    final Result<String> keyResult = decodeString(buffer);\n+                    final Result<String> valueResult = decodeString(buffer);\n+                    numberOfBytesConsumed += keyResult.numberOfBytesConsumed;\n+                    numberOfBytesConsumed += valueResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.UserProperty(keyResult.value, valueResult.value));\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    final Result<byte[]> binaryDataResult = decodeByteArray(buffer);\n+                    numberOfBytesConsumed += binaryDataResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.BinaryProperty(propertyId.value, binaryDataResult.value));\n+                    break;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -685,7 +683,8 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n             Result<Integer> propertyId = decodeVariableByteInteger(buffer);\n             numberOfBytesConsumed += propertyId.numberOfBytesConsumed;\n \n-            switch (MqttProperties.MqttPropertyType.valueOf(propertyId.value)) {\n+            MqttProperties.MqttPropertyType propertyType = MqttProperties.MqttPropertyType.valueOf(propertyId.value);\n+            switch (propertyType) {\n                 case PAYLOAD_FORMAT_INDICATOR:\n                 case REQUEST_PROBLEM_INFORMATION:\n                 case REQUEST_RESPONSE_INFORMATION:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTA1OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881058", "bodyText": "nit: I know this is pre-existing but can you add a default: ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:10:05Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,52 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);\n \n             case PINGREQ:\n             case PINGRESP:\n-            case DISCONNECT:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -210,8 +210,10 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n             case PINGRESP:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);\n+            default:\n+                //shouldn't reach here\n+                return new Result<Object>(null, 0);\n         }\n-        return new Result<Object>(null, 0); //should never reach here\n     }\n \n     private static Result<MqttConnectVariableHeader> decodeConnectionVariableHeader(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTQzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881439", "bodyText": "can you link to the spec ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:10:43Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +634,36 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n+        int remainingLength = 0;\n+        int multiplier = 1;\n+        short digit;\n+        int loops = 0;\n+        do {\n+            digit = buffer.readUnsignedByte();\n+            remainingLength += (digit & 127) * multiplier;\n+            multiplier *= 128;\n+            loops++;\n+        } while ((digit & 128) != 0 && loops < 4);\n+\n+        // MQTT protocol limits Remaining Length to 4 bytes", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex f6f198fd53..9da87156b7 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -634,6 +637,12 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    /**\n+     * See 1.5.5 Variable Byte Integer section of MQTT 5.0 specification for encoding/decoding rules\n+     *\n+     * @param buffer\n+     * @return\n+     */\n     private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n         int remainingLength = 0;\n         int multiplier = 1;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTk4NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881984", "bodyText": "don't use this one directly but use Unpooled.EMPTY_BUFFER", "author": "normanmaurer", "createdAt": "2020-08-19T09:11:36Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -18,9 +18,10 @@\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.EmptyByteBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -18,7 +18,7 @@ package io.netty.handler.codec.mqtt;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufAllocator;\n-import io.netty.buffer.EmptyByteBuf;\n+import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandler;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.EncoderException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjI3MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882270", "bodyText": "consider removing this argument as you can get the instance from ctx.alloc()", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:06Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -53,37 +54,48 @@ protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> o\n      * @param message MQTT message to encode\n      * @return ByteBuf with encoded bytes\n      */\n-    static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message) {\n+    static ByteBuf doEncode(ChannelHandlerContext ctx,\n+                     ByteBufAllocator byteBufAllocator,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -55,48 +55,47 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n      * @return ByteBuf with encoded bytes\n      */\n     static ByteBuf doEncode(ChannelHandlerContext ctx,\n-                     ByteBufAllocator byteBufAllocator,\n                      MqttMessage message) {\n \n         switch (message.fixedHeader().messageType()) {\n             case CONNECT:\n-                return encodeConnectMessage(ctx, byteBufAllocator, (MqttConnectMessage) message);\n+                return encodeConnectMessage(ctx, (MqttConnectMessage) message);\n \n             case CONNACK:\n-                return encodeConnAckMessage(ctx, byteBufAllocator, (MqttConnAckMessage) message);\n+                return encodeConnAckMessage(ctx, (MqttConnAckMessage) message);\n \n             case PUBLISH:\n-                return encodePublishMessage(ctx, byteBufAllocator, (MqttPublishMessage) message);\n+                return encodePublishMessage(ctx, (MqttPublishMessage) message);\n \n             case SUBSCRIBE:\n-                return encodeSubscribeMessage(ctx, byteBufAllocator, (MqttSubscribeMessage) message);\n+                return encodeSubscribeMessage(ctx, (MqttSubscribeMessage) message);\n \n             case UNSUBSCRIBE:\n-                return encodeUnsubscribeMessage(ctx, byteBufAllocator, (MqttUnsubscribeMessage) message);\n+                return encodeUnsubscribeMessage(ctx,  (MqttUnsubscribeMessage) message);\n \n             case SUBACK:\n-                return encodeSubAckMessage(ctx, byteBufAllocator, (MqttSubAckMessage) message);\n+                return encodeSubAckMessage(ctx, (MqttSubAckMessage) message);\n \n             case UNSUBACK:\n                 if (message instanceof MqttUnsubAckMessage) {\n-                    return encodeUnsubAckMessage(ctx, byteBufAllocator, (MqttUnsubAckMessage) message);\n+                    return encodeUnsubAckMessage(ctx, (MqttUnsubAckMessage) message);\n                 } else {\n-                    return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(byteBufAllocator, message);\n+                    return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n                 }\n \n             case PUBACK:\n             case PUBREC:\n             case PUBREL:\n             case PUBCOMP:\n-                return encodePubReplyMessage(ctx, byteBufAllocator, message);\n+                return encodePubReplyMessage(ctx, message);\n \n             case DISCONNECT:\n             case AUTH:\n-                return encodeReasonCodePlusPropertiesMessage(ctx, byteBufAllocator, message);\n+                return encodeReasonCodePlusPropertiesMessage(ctx, message);\n \n             case PINGREQ:\n             case PINGRESP:\n-                return encodeMessageWithOnlySingleByteFixedHeader(byteBufAllocator, message);\n+                return encodeMessageWithOnlySingleByteFixedHeader(ctx.alloc(), message);\n \n             default:\n                 throw new IllegalArgumentException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882403", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:20Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -53,37 +54,48 @@ protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> o\n      * @param message MQTT message to encode\n      * @return ByteBuf with encoded bytes\n      */\n-    static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message) {\n+    static ByteBuf doEncode(ChannelHandlerContext ctx,\n+                     ByteBufAllocator byteBufAllocator,\n+                     MqttMessage message) {\n \n         switch (message.fixedHeader().messageType()) {\n             case CONNECT:\n-                return encodeConnectMessage(byteBufAllocator, (MqttConnectMessage) message);\n+                return encodeConnectMessage(ctx, byteBufAllocator, (MqttConnectMessage) message);\n \n             case CONNACK:\n-                return encodeConnAckMessage(byteBufAllocator, (MqttConnAckMessage) message);\n+                return encodeConnAckMessage(ctx, byteBufAllocator, (MqttConnAckMessage) message);\n \n             case PUBLISH:\n-                return encodePublishMessage(byteBufAllocator, (MqttPublishMessage) message);\n+                return encodePublishMessage(ctx, byteBufAllocator, (MqttPublishMessage) message);\n \n             case SUBSCRIBE:\n-                return encodeSubscribeMessage(byteBufAllocator, (MqttSubscribeMessage) message);\n+                return encodeSubscribeMessage(ctx, byteBufAllocator, (MqttSubscribeMessage) message);\n \n             case UNSUBSCRIBE:\n-                return encodeUnsubscribeMessage(byteBufAllocator, (MqttUnsubscribeMessage) message);\n+                return encodeUnsubscribeMessage(ctx, byteBufAllocator, (MqttUnsubscribeMessage) message);\n \n             case SUBACK:\n-                return encodeSubAckMessage(byteBufAllocator, (MqttSubAckMessage) message);\n+                return encodeSubAckMessage(ctx, byteBufAllocator, (MqttSubAckMessage) message);\n \n             case UNSUBACK:\n+                if (message instanceof MqttUnsubAckMessage) {\n+                    return encodeUnsubAckMessage(ctx, byteBufAllocator, (MqttUnsubAckMessage) message);\n+                } else {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0NjYwMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472946601", "bodyText": "Prior version calls encodeMessageWithOnlySingleByteFixedHeaderAndMessageId here and doesn't assume the type of message to be MqttUnsubAckMessage, therefore some client code may fail if we don't do the check here - the same way as MqttCodecTest.testUnsubAckMessage fails if I remove this conditional", "author": "paul-lysak", "createdAt": "2020-08-19T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MjYzMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473092631", "bodyText": "Thats not what I meant... I was basically saying you can refactor it to be:\nif (....) {\n    return ...\n}\nreturn ...", "author": "normanmaurer", "createdAt": "2020-08-19T14:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -55,48 +55,47 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n      * @return ByteBuf with encoded bytes\n      */\n     static ByteBuf doEncode(ChannelHandlerContext ctx,\n-                     ByteBufAllocator byteBufAllocator,\n                      MqttMessage message) {\n \n         switch (message.fixedHeader().messageType()) {\n             case CONNECT:\n-                return encodeConnectMessage(ctx, byteBufAllocator, (MqttConnectMessage) message);\n+                return encodeConnectMessage(ctx, (MqttConnectMessage) message);\n \n             case CONNACK:\n-                return encodeConnAckMessage(ctx, byteBufAllocator, (MqttConnAckMessage) message);\n+                return encodeConnAckMessage(ctx, (MqttConnAckMessage) message);\n \n             case PUBLISH:\n-                return encodePublishMessage(ctx, byteBufAllocator, (MqttPublishMessage) message);\n+                return encodePublishMessage(ctx, (MqttPublishMessage) message);\n \n             case SUBSCRIBE:\n-                return encodeSubscribeMessage(ctx, byteBufAllocator, (MqttSubscribeMessage) message);\n+                return encodeSubscribeMessage(ctx, (MqttSubscribeMessage) message);\n \n             case UNSUBSCRIBE:\n-                return encodeUnsubscribeMessage(ctx, byteBufAllocator, (MqttUnsubscribeMessage) message);\n+                return encodeUnsubscribeMessage(ctx,  (MqttUnsubscribeMessage) message);\n \n             case SUBACK:\n-                return encodeSubAckMessage(ctx, byteBufAllocator, (MqttSubAckMessage) message);\n+                return encodeSubAckMessage(ctx, (MqttSubAckMessage) message);\n \n             case UNSUBACK:\n                 if (message instanceof MqttUnsubAckMessage) {\n-                    return encodeUnsubAckMessage(ctx, byteBufAllocator, (MqttUnsubAckMessage) message);\n+                    return encodeUnsubAckMessage(ctx, (MqttUnsubAckMessage) message);\n                 } else {\n-                    return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(byteBufAllocator, message);\n+                    return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n                 }\n \n             case PUBACK:\n             case PUBREC:\n             case PUBREL:\n             case PUBCOMP:\n-                return encodePubReplyMessage(ctx, byteBufAllocator, message);\n+                return encodePubReplyMessage(ctx, message);\n \n             case DISCONNECT:\n             case AUTH:\n-                return encodeReasonCodePlusPropertiesMessage(ctx, byteBufAllocator, message);\n+                return encodeReasonCodePlusPropertiesMessage(ctx, message);\n \n             case PINGREQ:\n             case PINGRESP:\n-                return encodeMessageWithOnlySingleByteFixedHeader(byteBufAllocator, message);\n+                return encodeMessageWithOnlySingleByteFixedHeader(ctx.alloc(), message);\n \n             default:\n                 throw new IllegalArgumentException(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjY1NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882654", "bodyText": "nit consider removing  the allocator as you can get it via ctx.alloc()", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:48Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -93,6 +105,7 @@ static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message)\n     }\n \n     private static ByteBuf encodeConnectMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -106,7 +105,6 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeConnectMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttConnectMessage message) {\n         int payloadBufferSize = 0;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Mjc4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882782", "bodyText": "good catch!", "author": "normanmaurer", "createdAt": "2020-08-19T09:13:02Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -102,10 +115,11 @@ private static ByteBuf encodeConnectMessage(\n         MqttConnectPayload payload = message.payload();\n         MqttVersion mqttVersion = MqttVersion.fromProtocolNameAndLevel(variableHeader.name(),\n                 (byte) variableHeader.version());\n+        MqttCodecUtil.setMqttVersion(ctx, mqttVersion);\n \n         // as MQTT 3.1 & 3.1.1 spec, If the User Name Flag is set to 0, the Password Flag MUST be set to 0\n         if (!variableHeader.hasUserName() && variableHeader.hasPassword()) {\n-            throw new DecoderException(\"Without a username, the password MUST be not set\");\n+            throw new EncoderException(\"Without a username, the password MUST be not set\");", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDU3Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472894576", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:05Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -138,9 +152,20 @@ private static ByteBuf encodeConnectMessage(\n             payloadBufferSize += 2 + passwordBytes.length;\n         }\n \n-        // Fixed header\n+        // Fixed and variable header\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4;\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -156,19 +154,19 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(\n                 mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.variableHeader().properties());\n         int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n         final ByteBuf willPropertiesBuf;\n         if (variableHeader.isWillFlag()) {\n-            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, byteBufAllocator, payload.willProperties());\n+            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n             payloadBufferSize += willPropertiesBuf.readableBytes();\n         } else {\n-            willPropertiesBuf = new EmptyByteBuf(byteBufAllocator);\n+            willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n         }\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDg5Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472894897", "bodyText": "you will need to call willPropertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -138,9 +152,20 @@ private static ByteBuf encodeConnectMessage(\n             payloadBufferSize += 2 + passwordBytes.length;\n         }\n \n-        // Fixed header\n+        // Fixed and variable header\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4;\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(\n+                mqttVersion,\n+                byteBufAllocator,\n+                message.variableHeader().properties());\n+        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n+        final ByteBuf willPropertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -156,19 +154,19 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(\n                 mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.variableHeader().properties());\n         int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n         final ByteBuf willPropertiesBuf;\n         if (variableHeader.isWillFlag()) {\n-            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, byteBufAllocator, payload.willProperties());\n+            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n             payloadBufferSize += willPropertiesBuf.readableBytes();\n         } else {\n-            willPropertiesBuf = new EmptyByteBuf(byteBufAllocator);\n+            willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n         }\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTEyOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895128", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:54Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +223,34 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -224,30 +224,29 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeConnAckMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n         final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.variableHeader().properties());\n \n-        ByteBuf buf = byteBufAllocator.buffer(4 + propertiesBuf.readableBytes());\n+        ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n         buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n \n         return buf;\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttSubscribeMessage message) {\n         MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n         final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTIxNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895216", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:04Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +223,34 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.variableHeader().properties());\n+\n+        ByteBuf buf = byteBufAllocator.buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n+        writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+        buf.writeBytes(propertiesBuf);\n \n         return buf;\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -224,30 +224,29 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeConnAckMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n         final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.variableHeader().properties());\n \n-        ByteBuf buf = byteBufAllocator.buffer(4 + propertiesBuf.readableBytes());\n+        ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n         buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n \n         return buf;\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttSubscribeMessage message) {\n         MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n         final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTM0Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895346", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -234,23 +274,38 @@ private static ByteBuf encodeSubscribeMessage(\n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n \n         // Payload\n         for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            writeUTF8String(buf, topic.topicName());\n+            final MqttSubscriptionOption option = topic.option();\n+\n+            int optionEncoded =  option.retainHandling().value() << 4;\n+            if (option.isRetainAsPublished()) {\n+                optionEncoded |= 0x08;\n+            }\n+            if (option.isNoLocal()) {\n+                optionEncoded |= 0x04;\n+            }\n+            optionEncoded |= option.qos().value();\n+\n+            buf.writeByte(optionEncoded);\n         }\n \n         return buf;\n     }\n \n     private static ByteBuf encodeUnsubscribeMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttUnsubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -267,7 +266,7 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTQ0Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895446", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,35 +340,72 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -341,21 +341,21 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeSubAckMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n         MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n         int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n         buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTU2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895567", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:36Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,35 +340,72 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n         ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            ByteBufAllocator byteBufAllocator,\n+            MqttUnsubAckMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+        int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+        writeVariableLengthInt(buf, variablePartSize);\n+        buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+\n+        for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+            buf.writeByte(reasonCode);\n+        }\n+\n+        return buf;\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -341,21 +341,21 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeSubAckMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n         MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n-                byteBufAllocator,\n+                ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n         int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n         buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTgwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895808", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -325,11 +418,53 @@ private static ByteBuf encodePublishMessage(\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n         buf.writeBytes(payload);\n \n         return buf;\n     }\n \n+    private static ByteBuf encodePubReplyMessage(ChannelHandlerContext ctx,\n+                                          ByteBufAllocator byteBufAllocator,\n+                                          MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttPubReplyMessageVariableHeader) {\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttPubReplyMessageVariableHeader variableHeader =\n+                    (MqttPubReplyMessageVariableHeader) message.variableHeader();\n+            int msgId = variableHeader.messageId();\n+\n+            final ByteBuf propertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -410,7 +413,7 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(topicNameBytes.length);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTg5MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895891", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -347,6 +482,46 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(\n         return buf;\n     }\n \n+    private static ByteBuf encodeReasonCodePlusPropertiesMessage(\n+            ChannelHandlerContext ctx,\n+            ByteBufAllocator byteBufAllocator,\n+            MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttReasonCodeAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttReasonCodeAndPropertiesVariableHeader variableHeader =\n+                    (MqttReasonCodeAndPropertiesVariableHeader) message.variableHeader();\n+\n+            final ByteBuf propertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -484,7 +488,6 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n     private static ByteBuf encodeReasonCodePlusPropertiesMessage(\n             ChannelHandlerContext ctx,\n-            ByteBufAllocator byteBufAllocator,\n             MqttMessage message) {\n         if (message.variableHeader() instanceof MqttReasonCodeAndPropertiesVariableHeader) {\n             MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NjExNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472896116", "bodyText": "please add default:", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:30Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +533,89 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {\n+            return new EmptyByteBuf(byteBufAllocator);\n+        }\n+    }\n+\n+    private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n+                                            MqttProperties mqttProperties) {\n+        ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n+        // encode also the Properties part\n+        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+            switch (MqttProperties.MqttPropertyType.valueOf(property.propertyId)) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                    propertiesBuf.writeByte(bytePropValue);\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                    propertiesBuf.writeShort(twoBytesInPropValue);\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                    propertiesBuf.writeInt(fourBytesIntPropValue);\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                    writeVariableLengthInt(propertiesBuf, vbi);\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                    break;\n+                case USER_PROPERTY:\n+                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n+                    for (MqttProperties.StringPair pair: pairs) {\n+                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                        writeUTF8String(propertiesBuf, pair.key);\n+                        writeUTF8String(propertiesBuf, pair.value);\n+                    }\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                    propertiesBuf.writeShort(binaryPropValue.length);\n+                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                    break;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 2a48dcd83d..5fc4d8d888 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -539,7 +543,7 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n         if (mqttVersion == MqttVersion.MQTT_5) {\n             return encodeProperties(byteBufAllocator, mqttProperties);\n         } else {\n-            return new EmptyByteBuf(byteBufAllocator);\n+            return Unpooled.EMPTY_BUFFER;\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzA2MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897060", "bodyText": "protected as the class is abstract", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public abstract static class MqttProperty<T> {\n+        final T value;\n+        final int propertyId;\n+\n+        public MqttProperty(int propertyId, T value) {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\nindex 9b2c40bc04..152616755a 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n\n@@ -92,7 +92,7 @@ public final class MqttProperties {\n         final T value;\n         final int propertyId;\n \n-        public MqttProperty(int propertyId, T value) {\n+        protected MqttProperty(int propertyId, T value) {\n             this.propertyId = propertyId;\n             this.value = value;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897387", "bodyText": "not need to call this()", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public abstract static class MqttProperty<T> {\n+        final T value;\n+        final int propertyId;\n+\n+        public MqttProperty(int propertyId, T value) {\n+            this.propertyId = propertyId;\n+            this.value = value;\n+        }\n+    }\n+\n+    public static final class IntegerProperty extends MqttProperty<Integer> {\n+\n+        public IntegerProperty(int propertyId, Integer value) {\n+            super(propertyId, value);\n+        }\n+    }\n+\n+    public static final class StringProperty extends MqttProperty<String> {\n+\n+        public StringProperty(int propertyId, String value) {\n+            super(propertyId, value);\n+        }\n+    }\n+\n+    public static final class StringPair {\n+        public final String key;\n+        public final String value;\n+\n+        public StringPair(String key, String value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() + 31 * value.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            StringPair that = (StringPair) obj;\n+\n+            return that.key.equals(this.key) && that.value.equals(this.value);\n+        }\n+    }\n+\n+    //User properties are the only properties that may be included multiple times and\n+    //are the only properties where ordering is required. Therefore, they need a special handling\n+    public static final class UserProperties extends MqttProperty<List<StringPair>> {\n+        public UserProperties() {\n+            super(MqttPropertyType.USER_PROPERTY.value, new ArrayList<StringPair>());\n+        }\n+\n+        public UserProperties(List<StringPair> values) {\n+            this();", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk1NjY2NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472956665", "bodyText": "If I remove this() then it tries to call superclass default construction which doesn't exist, so compilation fails.", "author": "paul-lysak", "createdAt": "2020-08-19T11:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MjMyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475362323", "bodyText": "ah I see...  Plese also make it clear via java docs that the given values are copied and so the List reference is not stored. You may even use Collection<StringPair> or Iterable<StringPair>", "author": "normanmaurer", "createdAt": "2020-08-24T06:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\nindex 9b2c40bc04..152616755a 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n\n@@ -92,7 +92,7 @@ public final class MqttProperties {\n         final T value;\n         final int propertyId;\n \n-        public MqttProperty(int propertyId, T value) {\n+        protected MqttProperty(int propertyId, T value) {\n             this.propertyId = propertyId;\n             this.value = value;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzYzOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897638", "bodyText": "null check ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:57Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * Variable Header containing Packet Id, reason code and Properties as in MQTT v5 spec.\n+ */\n+public final class MqttPubReplyMessageVariableHeader extends MqttMessageIdVariableHeader {\n+\n+    private final byte reasonCode;\n+    private final MqttProperties properties;\n+\n+    public static final byte REASON_CODE_OK = 0;\n+\n+    public MqttPubReplyMessageVariableHeader(int messageId, byte reasonCode, MqttProperties properties) {\n+        super(messageId);\n+        if (messageId < 1 || messageId > 0xffff) {\n+            throw new IllegalArgumentException(\"messageId: \" + messageId + \" (expected: 1 ~ 65535)\");\n+        }\n+        this.reasonCode = reasonCode;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\nindex b7fdf757ac..ea7dd60306 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java\n\n@@ -34,7 +34,11 @@ public final class MqttPubReplyMessageVariableHeader extends MqttMessageIdVariab\n             throw new IllegalArgumentException(\"messageId: \" + messageId + \" (expected: 1 ~ 65535)\");\n         }\n         this.reasonCode = reasonCode;\n-        this.properties = properties;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.properties = properties;\n+        }\n     }\n \n     public byte reasonCode() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5Nzc2NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897765", "bodyText": "null check ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:36:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java", "diffHunk": "@@ -25,10 +25,16 @@\n \n     private final String topicName;\n     private final int packetId;\n+    private final MqttProperties mqttProperties;\n \n     public MqttPublishVariableHeader(String topicName, int packetId) {\n+        this(topicName, packetId, MqttProperties.NO_PROPERTIES);\n+    }\n+\n+    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {\n         this.topicName = topicName;\n         this.packetId = packetId;\n+        this.mqttProperties = mqttProperties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\nindex 83958ef687..0b86c2416f 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java\n\n@@ -25,16 +25,20 @@ public final class MqttPublishVariableHeader {\n \n     private final String topicName;\n     private final int packetId;\n-    private final MqttProperties mqttProperties;\n+    private final MqttProperties properties;\n \n     public MqttPublishVariableHeader(String topicName, int packetId) {\n         this(topicName, packetId, MqttProperties.NO_PROPERTIES);\n     }\n \n-    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {\n+    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties properties) {\n         this.topicName = topicName;\n         this.packetId = packetId;\n-        this.mqttProperties = mqttProperties;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.properties = properties;\n+        }\n     }\n \n     public String topicName() {\n"}}, {"oid": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "url": "https://github.com/netty/netty/commit/7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T11:34:15Z", "type": "forcePushed"}, {"oid": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "url": "https://github.com/netty/netty/commit/4df4ec779ac51eca89b92a2305eeac0f410c29e2", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T11:41:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDI5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473090290", "bodyText": "this pattern seems to be used a lot... consider extracting it to a static method and use it everywhere...", "author": "normanmaurer", "createdAt": "2020-08-19T14:51:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -52,6 +76,11 @@ public MqttConnectVariableHeader(\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\nindex 87c0934020..0ebbc855f8 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java\n\n@@ -76,11 +76,7 @@ public final class MqttConnectVariableHeader {\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n-        if (properties == null) {\n-            this.properties = MqttProperties.NO_PROPERTIES;\n-        } else {\n-            this.properties = properties;\n-        }\n+        this.properties = MqttProperties.notNull(properties);\n     }\n \n     public String name() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDYwMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473090600", "bodyText": "if this is the case we should throw ....", "author": "normanmaurer", "createdAt": "2020-08-19T14:51:57Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,54 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);\n \n             case PINGREQ:\n             case PINGRESP:\n-            case DISCONNECT:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);\n+            default:\n+                //shouldn't reach here\n+                return new Result<Object>(null, 0);", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex 9da87156b7..7ea215392b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -212,7 +212,7 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n                 return new Result<Object>(null, 0);\n             default:\n                 //shouldn't reach here\n-                return new Result<Object>(null, 0);\n+                throw new DecoderException(\"Unknown message type: \" + mqttFixedHeader.messageType());\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MTE3NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473091174", "bodyText": "either fill both or remove", "author": "normanmaurer", "createdAt": "2020-08-19T14:52:43Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +637,31 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    /**\n+     * See 1.5.5 Variable Byte Integer section of MQTT 5.0 specification for encoding/decoding rules\n+     *\n+     * @param buffer\n+     * @return", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex 9da87156b7..7ea215392b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -640,8 +640,8 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n     /**\n      * See 1.5.5 Variable Byte Integer section of MQTT 5.0 specification for encoding/decoding rules\n      *\n-     * @param buffer\n-     * @return\n+     * @param buffer the buffer to decode from\n+     * @return decoded integer\n      */\n     private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n         int remainingLength = 0;\n"}}, {"oid": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "url": "https://github.com/netty/netty/commit/60a7360c49f19dc60ba8e908ca1d5707cb78b918", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-20T07:12:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1ODYxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475358613", "bodyText": "nit: use MqttProperties.notNull", "author": "normanmaurer", "createdAt": "2020-08-24T05:57:59Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -56,7 +59,27 @@ public MqttConnectPayload(\n             byte[] willMessage,\n             String userName,\n             byte[] password) {\n+        this(clientIdentifier,\n+                MqttProperties.NO_PROPERTIES,\n+                willTopic,\n+                willMessage,\n+                userName,\n+                password);\n+    }\n+\n+    public MqttConnectPayload(\n+            String clientIdentifier,\n+            MqttProperties willProperties,\n+            String willTopic,\n+            byte[] willMessage,\n+            String userName,\n+            byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n+        if (willProperties == null) {\n+            this.willProperties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.willProperties = willProperties;\n+        }", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\nindex 7169e4900c..6d4619e2c2 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java\n\n@@ -75,11 +75,7 @@ public final class MqttConnectPayload {\n             String userName,\n             byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n-        if (willProperties == null) {\n-            this.willProperties = MqttProperties.NO_PROPERTIES;\n-        } else {\n-            this.willProperties = willProperties;\n-        }\n+        this.willProperties = MqttProperties.withEmptyDefaults(willProperties);\n         this.willTopic = willTopic;\n         this.willMessage = willMessage;\n         this.userName = userName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1OTI4Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475359286", "bodyText": "nit: use new ArrayList<Short>(bytesRemainingInVariablePart); as we already know how many elements we will add.", "author": "normanmaurer", "createdAt": "2020-08-24T06:00:10Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -402,6 +556,25 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<MqttSubAckPayload>(new MqttSubAckPayload(grantedQos), numberOfBytesConsumed);\n     }\n \n+    private static Result<MqttUnsubAckPayload> decodeUnsubAckPayload(\n+            ChannelHandlerContext ctx,\n+            ByteBuf buffer,\n+            int bytesRemainingInVariablePart) {\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            final List<Short> reasonCodes = new ArrayList<Short>();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\nindex 7ea215392b..fce56d4342 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java\n\n@@ -557,22 +560,17 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {\n     }\n \n     private static Result<MqttUnsubAckPayload> decodeUnsubAckPayload(\n-            ChannelHandlerContext ctx,\n-            ByteBuf buffer,\n-            int bytesRemainingInVariablePart) {\n-        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n-        if (mqttVersion == MqttVersion.MQTT_5) {\n-            final List<Short> reasonCodes = new ArrayList<Short>();\n-            int numberOfBytesConsumed = 0;\n-            while (numberOfBytesConsumed < bytesRemainingInVariablePart) {\n-                short reasonCode = buffer.readUnsignedByte();\n-                numberOfBytesConsumed++;\n-                reasonCodes.add(reasonCode);\n-            }\n-            return new Result<MqttUnsubAckPayload>(new MqttUnsubAckPayload(reasonCodes), numberOfBytesConsumed);\n-        } else {\n-            return new Result<MqttUnsubAckPayload>(null, 0);\n+        ChannelHandlerContext ctx,\n+        ByteBuf buffer,\n+        int bytesRemainingInVariablePart) {\n+        final List<Short> reasonCodes = new ArrayList<Short>(bytesRemainingInVariablePart);\n+        int numberOfBytesConsumed = 0;\n+        while (numberOfBytesConsumed < bytesRemainingInVariablePart) {\n+            short reasonCode = buffer.readUnsignedByte();\n+            numberOfBytesConsumed++;\n+            reasonCodes.add(reasonCode);\n         }\n+        return new Result<MqttUnsubAckPayload>(new MqttUnsubAckPayload(reasonCodes), numberOfBytesConsumed);\n     }\n \n     private static Result<MqttUnsubscribePayload> decodeUnsubscribePayload(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1OTk3OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475359978", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:27Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +221,33 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n+        ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n+        writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -228,15 +237,17 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.variableHeader().properties());\n \n-        ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n-        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n-        buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n-        buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        return buf;\n+        try {\n+            ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n+            buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n+            buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+            buf.writeBytes(propertiesBuf);\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDAyOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360029", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -153,11 +174,15 @@ private static ByteBuf encodeConnectMessage(\n         buf.writeByte(variableHeader.version());\n         buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n         buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -154,49 +156,56 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 mqttVersion,\n                 ctx.alloc(),\n                 message.variableHeader().properties());\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n-        final ByteBuf willPropertiesBuf;\n-        if (variableHeader.isWillFlag()) {\n-            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n-            payloadBufferSize += willPropertiesBuf.readableBytes();\n-        } else {\n-            willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n-        }\n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n-\n-        buf.writeShort(protocolNameBytes.length);\n-        buf.writeBytes(protocolNameBytes);\n-\n-        buf.writeByte(variableHeader.version());\n-        buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n-        buf.writeShort(variableHeader.keepAliveTimeSeconds());\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        // Payload\n-        buf.writeShort(clientIdentifierBytes.length);\n-        buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n-        if (variableHeader.isWillFlag()) {\n-            buf.writeBytes(willPropertiesBuf);\n-            willPropertiesBuf.release();\n-            buf.writeShort(willTopicBytes.length);\n-            buf.writeBytes(willTopicBytes, 0, willTopicBytes.length);\n-            buf.writeShort(willMessageBytes.length);\n-            buf.writeBytes(willMessageBytes, 0, willMessageBytes.length);\n-        }\n-        if (variableHeader.hasUserName()) {\n-            buf.writeShort(userNameBytes.length);\n-            buf.writeBytes(userNameBytes, 0, userNameBytes.length);\n-        }\n-        if (variableHeader.hasPassword()) {\n-            buf.writeShort(passwordBytes.length);\n-            buf.writeBytes(passwordBytes, 0, passwordBytes.length);\n+        try {\n+            final ByteBuf willPropertiesBuf;\n+            if (variableHeader.isWillFlag()) {\n+                willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n+                payloadBufferSize += willPropertiesBuf.readableBytes();\n+            } else {\n+                willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n+            }\n+            try {\n+                int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n+\n+                int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+                int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+                ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+                buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+                writeVariableLengthInt(buf, variablePartSize);\n+\n+                buf.writeShort(protocolNameBytes.length);\n+                buf.writeBytes(protocolNameBytes);\n+\n+                buf.writeByte(variableHeader.version());\n+                buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n+                buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+                buf.writeBytes(propertiesBuf);\n+\n+                // Payload\n+                buf.writeShort(clientIdentifierBytes.length);\n+                buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n+                if (variableHeader.isWillFlag()) {\n+                    buf.writeBytes(willPropertiesBuf);\n+                    buf.writeShort(willTopicBytes.length);\n+                    buf.writeBytes(willTopicBytes, 0, willTopicBytes.length);\n+                    buf.writeShort(willMessageBytes.length);\n+                    buf.writeBytes(willMessageBytes, 0, willMessageBytes.length);\n+                }\n+                if (variableHeader.hasUserName()) {\n+                    buf.writeShort(userNameBytes.length);\n+                    buf.writeBytes(userNameBytes, 0, userNameBytes.length);\n+                }\n+                if (variableHeader.hasPassword()) {\n+                    buf.writeShort(passwordBytes.length);\n+                    buf.writeBytes(passwordBytes, 0, passwordBytes.length);\n+                }\n+                return buf;\n+            } finally {\n+                willPropertiesBuf.release();\n+            }\n+        } finally {\n+            propertiesBuf.release();\n         }\n-        return buf;\n     }\n \n     private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableHeader) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDE0Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360143", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:59Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -153,11 +174,15 @@ private static ByteBuf encodeConnectMessage(\n         buf.writeByte(variableHeader.version());\n         buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n         buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n \n         // Payload\n         buf.writeShort(clientIdentifierBytes.length);\n         buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n         if (variableHeader.isWillFlag()) {\n+            buf.writeBytes(willPropertiesBuf);\n+            willPropertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDM4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360382", "bodyText": "Also I think we should always call release() ... so please do it outside of the if block. I know at the moment it not really matters as you use EMPTY_BUFFER but this is more of an implementation detail.", "author": "normanmaurer", "createdAt": "2020-08-24T06:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -154,49 +156,56 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 mqttVersion,\n                 ctx.alloc(),\n                 message.variableHeader().properties());\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n-        final ByteBuf willPropertiesBuf;\n-        if (variableHeader.isWillFlag()) {\n-            willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n-            payloadBufferSize += willPropertiesBuf.readableBytes();\n-        } else {\n-            willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n-        }\n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n-\n-        buf.writeShort(protocolNameBytes.length);\n-        buf.writeBytes(protocolNameBytes);\n-\n-        buf.writeByte(variableHeader.version());\n-        buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n-        buf.writeShort(variableHeader.keepAliveTimeSeconds());\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        // Payload\n-        buf.writeShort(clientIdentifierBytes.length);\n-        buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n-        if (variableHeader.isWillFlag()) {\n-            buf.writeBytes(willPropertiesBuf);\n-            willPropertiesBuf.release();\n-            buf.writeShort(willTopicBytes.length);\n-            buf.writeBytes(willTopicBytes, 0, willTopicBytes.length);\n-            buf.writeShort(willMessageBytes.length);\n-            buf.writeBytes(willMessageBytes, 0, willMessageBytes.length);\n-        }\n-        if (variableHeader.hasUserName()) {\n-            buf.writeShort(userNameBytes.length);\n-            buf.writeBytes(userNameBytes, 0, userNameBytes.length);\n-        }\n-        if (variableHeader.hasPassword()) {\n-            buf.writeShort(passwordBytes.length);\n-            buf.writeBytes(passwordBytes, 0, passwordBytes.length);\n+        try {\n+            final ByteBuf willPropertiesBuf;\n+            if (variableHeader.isWillFlag()) {\n+                willPropertiesBuf = encodePropertiesIfNeeded(mqttVersion, ctx.alloc(), payload.willProperties());\n+                payloadBufferSize += willPropertiesBuf.readableBytes();\n+            } else {\n+                willPropertiesBuf = Unpooled.EMPTY_BUFFER;\n+            }\n+            try {\n+                int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n+\n+                int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+                int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+                ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+                buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+                writeVariableLengthInt(buf, variablePartSize);\n+\n+                buf.writeShort(protocolNameBytes.length);\n+                buf.writeBytes(protocolNameBytes);\n+\n+                buf.writeByte(variableHeader.version());\n+                buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n+                buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+                buf.writeBytes(propertiesBuf);\n+\n+                // Payload\n+                buf.writeShort(clientIdentifierBytes.length);\n+                buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n+                if (variableHeader.isWillFlag()) {\n+                    buf.writeBytes(willPropertiesBuf);\n+                    buf.writeShort(willTopicBytes.length);\n+                    buf.writeBytes(willTopicBytes, 0, willTopicBytes.length);\n+                    buf.writeShort(willMessageBytes.length);\n+                    buf.writeBytes(willMessageBytes, 0, willMessageBytes.length);\n+                }\n+                if (variableHeader.hasUserName()) {\n+                    buf.writeShort(userNameBytes.length);\n+                    buf.writeBytes(userNameBytes, 0, userNameBytes.length);\n+                }\n+                if (variableHeader.hasPassword()) {\n+                    buf.writeShort(passwordBytes.length);\n+                    buf.writeBytes(passwordBytes, 0, passwordBytes.length);\n+                }\n+                return buf;\n+            } finally {\n+                willPropertiesBuf.release();\n+            }\n+        } finally {\n+            propertiesBuf.release();\n         }\n-        return buf;\n     }\n \n     private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableHeader) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDQ0NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360444", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:03Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -227,30 +264,45 @@ private static ByteBuf encodeSubscribeMessage(\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -247,51 +258,54 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttSubscribePayload payload = message.payload();\n-\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-            payloadBufferSize += 1;\n-        }\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttSubscribePayload payload = message.payload();\n+\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                String topicName = topic.topicName();\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+                payloadBufferSize += 1;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n-\n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        // Payload\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            writeUTF8String(buf, topic.topicName());\n-            final MqttSubscriptionOption option = topic.option();\n-\n-            int optionEncoded =  option.retainHandling().value() << 4;\n-            if (option.isRetainAsPublished()) {\n-                optionEncoded |= 0x08;\n-            }\n-            if (option.isNoLocal()) {\n-                optionEncoded |= 0x04;\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n+\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n+\n+            // Payload\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                writeUTF8String(buf, topic.topicName());\n+                final MqttSubscriptionOption option = topic.option();\n+\n+                int optionEncoded = option.retainHandling().value() << 4;\n+                if (option.isRetainAsPublished()) {\n+                    optionEncoded |= 0x08;\n+                }\n+                if (option.isNoLocal()) {\n+                    optionEncoded |= 0x04;\n+                }\n+                optionEncoded |= option.qos().value();\n+\n+                buf.writeByte(optionEncoded);\n             }\n-            optionEncoded |= option.qos().value();\n \n-            buf.writeByte(optionEncoded);\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n         }\n-\n-        return buf;\n     }\n \n     private static ByteBuf encodeUnsubscribeMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDU3MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360571", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:26Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -265,13 +317,15 @@ private static ByteBuf encodeUnsubscribeMessage(\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -302,39 +316,42 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttUnsubscribePayload payload = message.payload();\n \n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-        }\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n \n-        // Payload\n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-        }\n+            // Payload\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                buf.writeShort(topicNameBytes.length);\n+                buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n+            }\n \n-        return buf;\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDU5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360598", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -302,39 +316,42 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttUnsubscribePayload payload = message.payload();\n \n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-        }\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n \n-        // Payload\n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-        }\n+            // Payload\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                buf.writeShort(topicNameBytes.length);\n+                buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n+            }\n \n-        return buf;\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDY1Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360652", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:41Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -302,39 +316,42 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttUnsubscribePayload payload = message.payload();\n \n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-        }\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n \n-        // Payload\n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-        }\n+            // Payload\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                buf.writeShort(topicNameBytes.length);\n+                buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n+            }\n \n-        return buf;\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDczNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360737", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:55Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();\n+\n+            for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+                buf.writeByte(reasonCode);\n+            }\n+\n+            return buf;\n+        } else {\n+            return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n+        }\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n         int variableHeaderBufferSize = 2 + topicNameBytes.length +\n-                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0);\n+                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0) + propertiesBuf.readableBytes();\n         int payloadBufferSize = payload.readableBytes();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(topicNameBytes.length);\n         buf.writeBytes(topicNameBytes);\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -302,39 +316,42 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttUnsubscribePayload payload = message.payload();\n \n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-        }\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n \n-        // Payload\n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-        }\n+            // Payload\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                buf.writeShort(topicNameBytes.length);\n+                buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n+            }\n \n-        return buf;\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDgxNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360816", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();\n+\n+            for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+                buf.writeByte(reasonCode);\n+            }\n+\n+            return buf;\n+        } else {\n+            return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n+        }\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n         int variableHeaderBufferSize = 2 + topicNameBytes.length +\n-                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0);\n+                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0) + propertiesBuf.readableBytes();\n         int payloadBufferSize = payload.readableBytes();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(topicNameBytes.length);\n         buf.writeBytes(topicNameBytes);\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         buf.writeBytes(payload);\n \n         return buf;\n     }\n \n+    private static ByteBuf encodePubReplyMessage(ChannelHandlerContext ctx,\n+                                          MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttPubReplyMessageVariableHeader) {\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttPubReplyMessageVariableHeader variableHeader =\n+                    (MqttPubReplyMessageVariableHeader) message.variableHeader();\n+            int msgId = variableHeader.messageId();\n+\n+            final ByteBuf propertiesBuf;\n+            final boolean includeReasonCode;\n+            final int variableHeaderBufferSize;\n+            final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            if (mqttVersion == MqttVersion.MQTT_5 &&\n+                    (variableHeader.reasonCode() != MqttPubReplyMessageVariableHeader.REASON_CODE_OK ||\n+                            !variableHeader.properties().isEmpty())) {\n+                propertiesBuf = encodeProperties(ctx.alloc(), variableHeader.properties());\n+                includeReasonCode = true;\n+                variableHeaderBufferSize = 3 + propertiesBuf.readableBytes();\n+            } else {\n+                propertiesBuf = Unpooled.EMPTY_BUFFER;\n+                includeReasonCode = false;\n+                variableHeaderBufferSize = 2;\n+            }\n+\n+            final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variableHeaderBufferSize);\n+            buf.writeShort(msgId);\n+            if (includeReasonCode) {\n+                buf.writeByte(variableHeader.reasonCode());\n+            }\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -302,39 +316,42 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 ctx.alloc(),\n                 message.idAndPropertiesVariableHeader().properties());\n \n-        final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n-        int payloadBufferSize = 0;\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n \n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttUnsubscribePayload payload = message.payload();\n \n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-        }\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+            }\n \n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n-        buf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n \n-        // Payload\n-        for (String topicName : payload.topics()) {\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-        }\n+            // Payload\n+            for (String topicName : payload.topics()) {\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                buf.writeShort(topicNameBytes.length);\n+                buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n+            }\n \n-        return buf;\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDg2MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360861", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -347,6 +484,46 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(\n         return buf;\n     }\n \n+    private static ByteBuf encodeReasonCodePlusPropertiesMessage(\n+            ChannelHandlerContext ctx,\n+            MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttReasonCodeAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttReasonCodeAndPropertiesVariableHeader variableHeader =\n+                    (MqttReasonCodeAndPropertiesVariableHeader) message.variableHeader();\n+\n+            final ByteBuf propertiesBuf;\n+            final boolean includeReasonCode;\n+            final int variableHeaderBufferSize;\n+            if (mqttVersion == MqttVersion.MQTT_5 &&\n+                    (variableHeader.reasonCode() != MqttReasonCodeAndPropertiesVariableHeader.REASON_CODE_OK ||\n+                            !variableHeader.properties().isEmpty())) {\n+                propertiesBuf = encodeProperties(ctx.alloc(), variableHeader.properties());\n+                includeReasonCode = true;\n+                variableHeaderBufferSize = 1 + propertiesBuf.readableBytes();\n+            } else {\n+                propertiesBuf = Unpooled.EMPTY_BUFFER;\n+                includeReasonCode = false;\n+                variableHeaderBufferSize = 0;\n+            }\n+\n+            final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variableHeaderBufferSize);\n+            if (includeReasonCode) {\n+                buf.writeByte(variableHeader.reasonCode());\n+            }\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -508,17 +537,20 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                 variableHeaderBufferSize = 0;\n             }\n \n-            final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n-            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n-            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-            writeVariableLengthInt(buf, variableHeaderBufferSize);\n-            if (includeReasonCode) {\n-                buf.writeByte(variableHeader.reasonCode());\n-            }\n-            buf.writeBytes(propertiesBuf);\n-            propertiesBuf.release();\n+            try {\n+                final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n+                ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n+                buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+                writeVariableLengthInt(buf, variableHeaderBufferSize);\n+                if (includeReasonCode) {\n+                    buf.writeByte(variableHeader.reasonCode());\n+                }\n+                buf.writeBytes(propertiesBuf);\n \n-            return buf;\n+                return buf;\n+            } finally {\n+                propertiesBuf.release();\n+            }\n         } else {\n             return encodeMessageWithOnlySingleByteFixedHeader(ctx.alloc(), message);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDk2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360967", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:34Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +535,94 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -540,87 +572,97 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                                              MqttProperties mqttProperties) {\n         if (mqttVersion == MqttVersion.MQTT_5) {\n             return encodeProperties(byteBufAllocator, mqttProperties);\n-        } else {\n-            return Unpooled.EMPTY_BUFFER;\n         }\n+        return Unpooled.EMPTY_BUFFER;\n     }\n \n     private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n                                             MqttProperties mqttProperties) {\n         ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n         // encode also the Properties part\n-        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n-        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n-            MqttProperties.MqttPropertyType propertyType = MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n-            switch (propertyType) {\n-                case PAYLOAD_FORMAT_INDICATOR:\n-                case REQUEST_PROBLEM_INFORMATION:\n-                case REQUEST_RESPONSE_INFORMATION:\n-                case MAXIMUM_QOS:\n-                case RETAIN_AVAILABLE:\n-                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n-                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n-                case SHARED_SUBSCRIPTION_AVAILABLE:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n-                    propertiesBuf.writeByte(bytePropValue);\n-                    break;\n-                case SERVER_KEEP_ALIVE:\n-                case RECEIVE_MAXIMUM:\n-                case TOPIC_ALIAS_MAXIMUM:\n-                case TOPIC_ALIAS:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n-                    propertiesBuf.writeShort(twoBytesInPropValue);\n-                    break;\n-                case PUBLICATION_EXPIRY_INTERVAL:\n-                case SESSION_EXPIRY_INTERVAL:\n-                case WILL_DELAY_INTERVAL:\n-                case MAXIMUM_PACKET_SIZE:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n-                    propertiesBuf.writeInt(fourBytesIntPropValue);\n-                    break;\n-                case SUBSCRIPTION_IDENTIFIER:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n-                    writeVariableLengthInt(propertiesBuf, vbi);\n-                    break;\n-                case CONTENT_TYPE:\n-                case RESPONSE_TOPIC:\n-                case ASSIGNED_CLIENT_IDENTIFIER:\n-                case AUTHENTICATION_METHOD:\n-                case RESPONSE_INFORMATION:\n-                case SERVER_REFERENCE:\n-                case REASON_STRING:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n-                    break;\n-                case USER_PROPERTY:\n-                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n-                    for (MqttProperties.StringPair pair: pairs) {\n-                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                        writeUTF8String(propertiesBuf, pair.key);\n-                        writeUTF8String(propertiesBuf, pair.value);\n+        try {\n+            ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+            try {\n+                for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+                    MqttProperties.MqttPropertyType propertyType =\n+                            MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n+                    switch (propertyType) {\n+                        case PAYLOAD_FORMAT_INDICATOR:\n+                        case REQUEST_PROBLEM_INFORMATION:\n+                        case REQUEST_RESPONSE_INFORMATION:\n+                        case MAXIMUM_QOS:\n+                        case RETAIN_AVAILABLE:\n+                        case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                        case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                        case SHARED_SUBSCRIPTION_AVAILABLE:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                            propertiesBuf.writeByte(bytePropValue);\n+                            break;\n+                        case SERVER_KEEP_ALIVE:\n+                        case RECEIVE_MAXIMUM:\n+                        case TOPIC_ALIAS_MAXIMUM:\n+                        case TOPIC_ALIAS:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final short twoBytesInPropValue =\n+                                    ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                            propertiesBuf.writeShort(twoBytesInPropValue);\n+                            break;\n+                        case PUBLICATION_EXPIRY_INTERVAL:\n+                        case SESSION_EXPIRY_INTERVAL:\n+                        case WILL_DELAY_INTERVAL:\n+                        case MAXIMUM_PACKET_SIZE:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                            propertiesBuf.writeInt(fourBytesIntPropValue);\n+                            break;\n+                        case SUBSCRIPTION_IDENTIFIER:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                            writeVariableLengthInt(propertiesBuf, vbi);\n+                            break;\n+                        case CONTENT_TYPE:\n+                        case RESPONSE_TOPIC:\n+                        case ASSIGNED_CLIENT_IDENTIFIER:\n+                        case AUTHENTICATION_METHOD:\n+                        case RESPONSE_INFORMATION:\n+                        case SERVER_REFERENCE:\n+                        case REASON_STRING:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                            break;\n+                        case USER_PROPERTY:\n+                            final List<MqttProperties.StringPair> pairs =\n+                                    ((MqttProperties.UserProperties) property).value;\n+                            for (MqttProperties.StringPair pair : pairs) {\n+                                writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                                writeUTF8String(propertiesBuf, pair.key);\n+                                writeUTF8String(propertiesBuf, pair.value);\n+                            }\n+                            break;\n+                        case CORRELATION_DATA:\n+                        case AUTHENTICATION_DATA:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                            propertiesBuf.writeShort(binaryPropValue.length);\n+                            propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                            break;\n+                        default:\n+                            //shouldn't reach here\n+                            throw new EncoderException(\"Unknown property type: \" + propertyType);\n                     }\n-                    break;\n-                case CORRELATION_DATA:\n-                case AUTHENTICATION_DATA:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n-                    propertiesBuf.writeShort(binaryPropValue.length);\n-                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n-                    break;\n-                default:\n-                    //shouldn't reach here\n-                    throw new EncoderException(\"Unknown property type: \" + propertyType);\n+                }\n+                writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n+                propertiesHeaderBuf.writeBytes(propertiesBuf);\n+\n+                return propertiesHeaderBuf;\n+            } finally {\n+                propertiesBuf.release();\n             }\n+        } catch (RuntimeException e) {\n+            propertiesHeaderBuf.release();\n+            throw e;\n         }\n-        writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n-        propertiesHeaderBuf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        return propertiesHeaderBuf;\n     }\n \n     private static int getFixedHeaderByte1(MqttFixedHeader header) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTIzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475361239", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory... This will also cover the default: case then", "author": "normanmaurer", "createdAt": "2020-08-24T06:06:23Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +535,94 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {\n+            return Unpooled.EMPTY_BUFFER;\n+        }\n+    }\n+\n+    private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n+                                            MqttProperties mqttProperties) {\n+        ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n+        // encode also the Properties part\n+        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+            MqttProperties.MqttPropertyType propertyType = MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n+            switch (propertyType) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                    propertiesBuf.writeByte(bytePropValue);\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                    propertiesBuf.writeShort(twoBytesInPropValue);\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                    propertiesBuf.writeInt(fourBytesIntPropValue);\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                    writeVariableLengthInt(propertiesBuf, vbi);\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                    break;\n+                case USER_PROPERTY:\n+                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n+                    for (MqttProperties.StringPair pair: pairs) {\n+                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                        writeUTF8String(propertiesBuf, pair.key);\n+                        writeUTF8String(propertiesBuf, pair.value);\n+                    }\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                    propertiesBuf.writeShort(binaryPropValue.length);\n+                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                    break;\n+                default:\n+                    //shouldn't reach here\n+                    throw new EncoderException(\"Unknown property type: \" + propertyType);\n+            }\n+        }\n+        writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n+        propertiesHeaderBuf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\nindex 74f6b8911e..417655717b 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java\n\n@@ -540,87 +572,97 @@ public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n                                              MqttProperties mqttProperties) {\n         if (mqttVersion == MqttVersion.MQTT_5) {\n             return encodeProperties(byteBufAllocator, mqttProperties);\n-        } else {\n-            return Unpooled.EMPTY_BUFFER;\n         }\n+        return Unpooled.EMPTY_BUFFER;\n     }\n \n     private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n                                             MqttProperties mqttProperties) {\n         ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n         // encode also the Properties part\n-        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n-        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n-            MqttProperties.MqttPropertyType propertyType = MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n-            switch (propertyType) {\n-                case PAYLOAD_FORMAT_INDICATOR:\n-                case REQUEST_PROBLEM_INFORMATION:\n-                case REQUEST_RESPONSE_INFORMATION:\n-                case MAXIMUM_QOS:\n-                case RETAIN_AVAILABLE:\n-                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n-                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n-                case SHARED_SUBSCRIPTION_AVAILABLE:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n-                    propertiesBuf.writeByte(bytePropValue);\n-                    break;\n-                case SERVER_KEEP_ALIVE:\n-                case RECEIVE_MAXIMUM:\n-                case TOPIC_ALIAS_MAXIMUM:\n-                case TOPIC_ALIAS:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n-                    propertiesBuf.writeShort(twoBytesInPropValue);\n-                    break;\n-                case PUBLICATION_EXPIRY_INTERVAL:\n-                case SESSION_EXPIRY_INTERVAL:\n-                case WILL_DELAY_INTERVAL:\n-                case MAXIMUM_PACKET_SIZE:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n-                    propertiesBuf.writeInt(fourBytesIntPropValue);\n-                    break;\n-                case SUBSCRIPTION_IDENTIFIER:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n-                    writeVariableLengthInt(propertiesBuf, vbi);\n-                    break;\n-                case CONTENT_TYPE:\n-                case RESPONSE_TOPIC:\n-                case ASSIGNED_CLIENT_IDENTIFIER:\n-                case AUTHENTICATION_METHOD:\n-                case RESPONSE_INFORMATION:\n-                case SERVER_REFERENCE:\n-                case REASON_STRING:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n-                    break;\n-                case USER_PROPERTY:\n-                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n-                    for (MqttProperties.StringPair pair: pairs) {\n-                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                        writeUTF8String(propertiesBuf, pair.key);\n-                        writeUTF8String(propertiesBuf, pair.value);\n+        try {\n+            ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+            try {\n+                for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+                    MqttProperties.MqttPropertyType propertyType =\n+                            MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n+                    switch (propertyType) {\n+                        case PAYLOAD_FORMAT_INDICATOR:\n+                        case REQUEST_PROBLEM_INFORMATION:\n+                        case REQUEST_RESPONSE_INFORMATION:\n+                        case MAXIMUM_QOS:\n+                        case RETAIN_AVAILABLE:\n+                        case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                        case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                        case SHARED_SUBSCRIPTION_AVAILABLE:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                            propertiesBuf.writeByte(bytePropValue);\n+                            break;\n+                        case SERVER_KEEP_ALIVE:\n+                        case RECEIVE_MAXIMUM:\n+                        case TOPIC_ALIAS_MAXIMUM:\n+                        case TOPIC_ALIAS:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final short twoBytesInPropValue =\n+                                    ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                            propertiesBuf.writeShort(twoBytesInPropValue);\n+                            break;\n+                        case PUBLICATION_EXPIRY_INTERVAL:\n+                        case SESSION_EXPIRY_INTERVAL:\n+                        case WILL_DELAY_INTERVAL:\n+                        case MAXIMUM_PACKET_SIZE:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                            propertiesBuf.writeInt(fourBytesIntPropValue);\n+                            break;\n+                        case SUBSCRIPTION_IDENTIFIER:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                            writeVariableLengthInt(propertiesBuf, vbi);\n+                            break;\n+                        case CONTENT_TYPE:\n+                        case RESPONSE_TOPIC:\n+                        case ASSIGNED_CLIENT_IDENTIFIER:\n+                        case AUTHENTICATION_METHOD:\n+                        case RESPONSE_INFORMATION:\n+                        case SERVER_REFERENCE:\n+                        case REASON_STRING:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                            break;\n+                        case USER_PROPERTY:\n+                            final List<MqttProperties.StringPair> pairs =\n+                                    ((MqttProperties.UserProperties) property).value;\n+                            for (MqttProperties.StringPair pair : pairs) {\n+                                writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                                writeUTF8String(propertiesBuf, pair.key);\n+                                writeUTF8String(propertiesBuf, pair.value);\n+                            }\n+                            break;\n+                        case CORRELATION_DATA:\n+                        case AUTHENTICATION_DATA:\n+                            writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                            final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                            propertiesBuf.writeShort(binaryPropValue.length);\n+                            propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                            break;\n+                        default:\n+                            //shouldn't reach here\n+                            throw new EncoderException(\"Unknown property type: \" + propertyType);\n                     }\n-                    break;\n-                case CORRELATION_DATA:\n-                case AUTHENTICATION_DATA:\n-                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n-                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n-                    propertiesBuf.writeShort(binaryPropValue.length);\n-                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n-                    break;\n-                default:\n-                    //shouldn't reach here\n-                    throw new EncoderException(\"Unknown property type: \" + propertyType);\n+                }\n+                writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n+                propertiesHeaderBuf.writeBytes(propertiesBuf);\n+\n+                return propertiesHeaderBuf;\n+            } finally {\n+                propertiesBuf.release();\n             }\n+        } catch (RuntimeException e) {\n+            propertiesHeaderBuf.release();\n+            throw e;\n         }\n-        writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n-        propertiesHeaderBuf.writeBytes(propertiesBuf);\n-        propertiesBuf.release();\n-\n-        return propertiesHeaderBuf;\n     }\n \n     private static int getFixedHeaderByte1(MqttFixedHeader header) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTc2Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475361766", "bodyText": "I am not in love with the method name...  Maybe just make it package-private for now so we can change it later on.", "author": "normanmaurer", "createdAt": "2020-08-24T06:08:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public static MqttProperties notNull(MqttProperties properties) {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NTkxMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476265910", "bodyText": "Made it package-private, also renamed to withEmptyDefaults. Is it a better name?", "author": "paul-lysak", "createdAt": "2020-08-25T08:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTc2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\nindex c5682d2899..d5fbea2468 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n\n@@ -16,6 +16,7 @@\n package io.netty.handler.codec.mqtt;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzMyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475363326", "bodyText": "So after inspecting the code it seems like this is problematic. The static field here is still mutable which means users can store stuff in there etc. We need to make this instance immutable as otherwise bad things can happen", "author": "normanmaurer", "createdAt": "2020-08-24T06:13:16Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NjQzNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476266435", "bodyText": "Changed it to be backed by an unmodifiable empty map.", "author": "paul-lysak", "createdAt": "2020-08-25T08:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\nindex c5682d2899..d5fbea2468 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java\n\n@@ -16,6 +16,7 @@\n package io.netty.handler.codec.mqtt;\n \n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.List;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzgzOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475363838", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-24T06:14:42Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,43 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {\n-        super(mqttFixedHeader, variableHeader, null);\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdAndPropertiesVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        super(mqttFixedHeader, variableHeader, payload);\n+    }\n+\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n+    }\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader) {\n+        this(mqttFixedHeader, variableHeader, null);\n+    }\n+\n+    private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n+            MqttMessageIdVariableHeader variableHeader) {\n+        if (variableHeader instanceof MqttMessageIdAndPropertiesVariableHeader) {\n+            return (MqttMessageIdAndPropertiesVariableHeader) variableHeader;\n+        } else {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\nindex 3f50e4a9ad..54e61957f9 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java\n\n@@ -41,10 +41,8 @@ public final class MqttUnsubAckMessage extends MqttMessage {\n             MqttMessageIdVariableHeader variableHeader) {\n         if (variableHeader instanceof MqttMessageIdAndPropertiesVariableHeader) {\n             return (MqttMessageIdAndPropertiesVariableHeader) variableHeader;\n-        } else {\n-            return new MqttMessageIdAndPropertiesVariableHeader(variableHeader.messageId(),\n-                    MqttProperties.NO_PROPERTIES);\n         }\n+        return new MqttMessageIdAndPropertiesVariableHeader(variableHeader.messageId(), MqttProperties.NO_PROPERTIES);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2NDAyNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475364025", "bodyText": "nit: you can use ObjectUtils.checkNotNull(...)", "author": "normanmaurer", "createdAt": "2020-08-24T06:15:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\nindex abc4546004..1eee50cc49 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n\n@@ -15,6 +15,7 @@\n  */\n package io.netty.handler.codec.mqtt;\n \n+import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.StringUtil;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2NDEyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475364126", "bodyText": "nit: you can use ObjectUtils.checkNotNull(...)", "author": "normanmaurer", "createdAt": "2020-08-24T06:15:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");\n+        }\n+\n+        List<Short> list = new ArrayList<Short>(unsubscribeReasonCodes.length);\n+        for (Short v: unsubscribeReasonCodes) {\n+            list.add(v);\n+        }\n+        this.unsubscribeReasonCodes = Collections.unmodifiableList(list);\n+    }\n+\n+    public MqttUnsubAckPayload(Iterable<Short> unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\nindex abc4546004..1eee50cc49 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n\n@@ -15,6 +15,7 @@\n  */\n package io.netty.handler.codec.mqtt;\n \n+import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.StringUtil;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r474812943", "bodyText": "No need to call static methods in the instance. Just call them directly.", "author": "chrisvest", "createdAt": "2020-08-21T16:50:07Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -67,12 +80,14 @@\n     public void setup() {\n         MockitoAnnotations.initMocks(this);\n         when(ctx.channel()).thenReturn(channel);\n+        when(ctx.alloc()).thenReturn(ALLOCATOR);\n+        when(channel.attr(MqttCodecUtil.MQTT_VERSION_KEY)).thenReturn(versionAttrMock);\n     }\n \n     @Test\n     public void testConnectMessageForMqtt31() throws Exception {\n         final MqttConnectMessage message = createConnectMessage(MqttVersion.MQTT_3_1);\n-        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);\n+        ByteBuf byteBuf = MqttEncoder.INSTANCE.doEncode(ctx, message);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3OTcyMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476279722", "bodyText": "I see you fixed this particular one, but there are many instances of this throughout the file \ud83d\ude05", "author": "chrisvest", "createdAt": "2020-08-25T08:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5MTc1NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476291754", "bodyText": "oh, right :)", "author": "paul-lysak", "createdAt": "2020-08-25T09:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\nindex b7f51ab95b..cfdbd3105a 100644\n--- a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n+++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n\n@@ -87,7 +87,7 @@ public class MqttCodecTest {\n     @Test\n     public void testConnectMessageForMqtt31() throws Exception {\n         final MqttConnectMessage message = createConnectMessage(MqttVersion.MQTT_3_1);\n-        ByteBuf byteBuf = MqttEncoder.INSTANCE.doEncode(ctx, message);\n+        ByteBuf byteBuf = MqttEncoder.doEncode(ctx, message);\n \n         final List<Object> out = new LinkedList<Object>();\n         mqttDecoder.decode(ctx, byteBuf, out);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNjc5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r474816798", "bodyText": "The new exception makes sense, but I wonder if it's an API change. I don't see a lot of docs around this, so maybe it's unspecified.", "author": "chrisvest", "createdAt": "2020-08-21T16:57:42Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -295,8 +316,8 @@ public void testUnknownMessageType() throws Exception {\n             final MqttMessage decodedMessage = (MqttMessage) out.get(0);\n             assertTrue(decodedMessage.decoderResult().isFailure());\n             Throwable cause = decodedMessage.decoderResult().cause();\n-            assertTrue(cause instanceof IllegalArgumentException);\n-            assertEquals(\"unknown message type: 15\", cause.getMessage());\n+            assertTrue(cause instanceof DecoderException);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MzgzMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475453830", "bodyText": "Is it safe to rely on \"default\" encoding for these tests?", "author": "chrisvest", "createdAt": "2020-08-24T09:17:31Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -500,36 +801,57 @@ private static MqttMessage createMessageWithFixedHeaderAndMessageIdVariableHeade\n     }\n \n     private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion) {\n-        return createConnectMessage(mqttVersion, USER_NAME, PASSWORD);\n+        return createConnectMessage(mqttVersion,\n+                USER_NAME,\n+                PASSWORD,\n+                MqttProperties.NO_PROPERTIES,\n+                MqttProperties.NO_PROPERTIES);\n     }\n \n-    private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion, String username, String password) {\n+    private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion,\n+                                                           String username,\n+                                                           String password,\n+                                                           MqttProperties properties,\n+                                                           MqttProperties willProperties) {\n         return MqttMessageBuilders.connect()\n                 .clientId(CLIENT_ID)\n                 .protocolVersion(mqttVersion)\n                 .username(username)\n-                .password(password)\n+                .password(password.getBytes())", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2ODk1Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476268957", "bodyText": "Changed to password.getBytes(CharsetUtil.UTF_8)", "author": "paul-lysak", "createdAt": "2020-08-25T08:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MzgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\nindex b7f51ab95b..cfdbd3105a 100644\n--- a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n+++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n\n@@ -817,13 +817,13 @@ public class MqttCodecTest {\n                 .clientId(CLIENT_ID)\n                 .protocolVersion(mqttVersion)\n                 .username(username)\n-                .password(password.getBytes())\n+                .password(password.getBytes(CharsetUtil.UTF_8))\n                 .properties(properties)\n                 .willRetain(true)\n                 .willQoS(MqttQoS.AT_LEAST_ONCE)\n                 .willFlag(true)\n                 .willTopic(WILL_TOPIC)\n-                .willMessage(WILL_MESSAGE.getBytes())\n+                .willMessage(WILL_MESSAGE.getBytes(CharsetUtil.UTF_8))\n                 .willProperties(willProperties)\n                 .cleanSession(true)\n                 .keepAlive(KEEP_ALIVE_SECONDS)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTg5OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475455899", "bodyText": "Can we keep both asserts, to cover the API surface?", "author": "chrisvest", "createdAt": "2020-08-24T09:20:56Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -664,9 +1002,9 @@ private static void validateTopicSubscription(\n             MqttTopicSubscription actual) {\n         assertEquals(\"MqttTopicSubscription TopicName mismatch \", expected.topicName(), actual.topicName());\n         assertEquals(\n-                \"MqttTopicSubscription Qos mismatch \",\n-                expected.qualityOfService(),\n-                actual.qualityOfService());\n+                \"MqttTopicSubscription options mismatch \",\n+                expected.option(),\n+                actual.option());", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6908317339952efbb8397bd93359bff7ff597245", "chunk": "diff --git a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\nindex b7f51ab95b..cfdbd3105a 100644\n--- a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n+++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java\n\n@@ -1001,6 +1001,10 @@ public class MqttCodecTest {\n             MqttTopicSubscription expected,\n             MqttTopicSubscription actual) {\n         assertEquals(\"MqttTopicSubscription TopicName mismatch \", expected.topicName(), actual.topicName());\n+        assertEquals(\n+                \"MqttTopicSubscription Qos mismatch \",\n+                expected.qualityOfService(),\n+                actual.qualityOfService());\n         assertEquals(\n                 \"MqttTopicSubscription options mismatch \",\n                 expected.option(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ2MDEzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475460139", "bodyText": "Please update the class javadoc to indicate that we also decode MQTT 5.0.", "author": "chrisvest", "createdAt": "2020-08-24T09:25:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -227,7 +240,7 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         final int willQos = (b1 & 0x18) >> 3;\n         final boolean willFlag = (b1 & 0x04) == 0x04;\n         final boolean cleanSession = (b1 & 0x02) == 0x02;\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (version == MqttVersion.MQTT_3_1_1 || version == MqttVersion.MQTT_5) {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDcwNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475474707", "bodyText": "Please update the class javadoc to indicate that we can also encode messages using MQTT version 5.0.", "author": "chrisvest", "createdAt": "2020-08-24T09:40:10Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -102,10 +111,11 @@ private static ByteBuf encodeConnectMessage(\n         MqttConnectPayload payload = message.payload();\n         MqttVersion mqttVersion = MqttVersion.fromProtocolNameAndLevel(variableHeader.name(),\n                 (byte) variableHeader.version());\n+        MqttCodecUtil.setMqttVersion(ctx, mqttVersion);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "6908317339952efbb8397bd93359bff7ff597245", "url": "https://github.com/netty/netty/commit/6908317339952efbb8397bd93359bff7ff597245", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T07:28:03Z", "type": "forcePushed"}, {"oid": "6652e05cd5f625287ae1e2fea358ea4a03dfca02", "url": "https://github.com/netty/netty/commit/6652e05cd5f625287ae1e2fea358ea4a03dfca02", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T08:22:19Z", "type": "forcePushed"}, {"oid": "f577a8d28bd469a612635813d7b743680e6c3a08", "url": "https://github.com/netty/netty/commit/f577a8d28bd469a612635813d7b743680e6c3a08", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T08:59:25Z", "type": "forcePushed"}, {"oid": "42794df42a9cffcd5610e527213f7b610b087a47", "url": "https://github.com/netty/netty/commit/42794df42a9cffcd5610e527213f7b610b087a47", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-26T07:25:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MzAyNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477193024", "bodyText": "There's a lot of integers in this file, 1, 2, 4, 0x04, 0x08, 0x01, etc. Would be nice if they were named constants.", "author": "chrisvest", "createdAt": "2020-08-26T10:16:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,138 +230,270 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n-        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n-        buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n-        buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n-\n-        return buf;\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n+        try {\n+            ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n+            buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n+            buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+            buf.writeBytes(propertiesBuf);\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n-        int payloadBufferSize = 0;\n-\n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttSubscribePayload payload = message.payload();\n-\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-            payloadBufferSize += 1;\n-        }\n-\n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n+\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttSubscribePayload payload = message.payload();\n+\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                String topicName = topic.topicName();\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+                payloadBufferSize += 1;\n+            }\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n+\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n+\n+            // Payload\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                writeUTF8String(buf, topic.topicName());\n+                final MqttSubscriptionOption option = topic.option();\n+\n+                int optionEncoded = option.retainHandling().value() << 4;\n+                if (option.isRetainAsPublished()) {\n+                    optionEncoded |= 0x08;\n+                }\n+                if (option.isNoLocal()) {\n+                    optionEncoded |= 0x04;\n+                }\n+                optionEncoded |= option.qos().value();\n+\n+                buf.writeByte(optionEncoded);\n+            }\n \n-        // Payload\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n         }\n-\n-        return buf;\n     }\n \n     private static ByteBuf encodeUnsubscribeMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttUnsubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n-        int payloadBufferSize = 0;\n-\n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1Njg2Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477356863", "bodyText": "Eventually, this may be a nice improvement. I think, better do it as a separate PR - refactoring can be done infinitely long :)", "author": "paul-lysak", "createdAt": "2020-08-26T14:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MzAyNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzM0MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477427341", "bodyText": "Remove this getter?", "author": "johnou", "createdAt": "2020-08-26T16:22:11Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+/**\n+ * Model the SubscriptionOption used in Subscribe MQTT v5 packet\n+ */\n+public final class MqttSubscriptionOption {\n+\n+    enum RetainedHandlingPolicy {\n+        SEND_AT_SUBSCRIBE(0),\n+        SEND_AT_SUBSCRIBE_IF_NOT_YET_EXISTS(1),\n+        DONT_SEND_AT_SUBSCRIBE(2);\n+\n+        private final int value;\n+\n+        RetainedHandlingPolicy(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static RetainedHandlingPolicy valueOf(int value) {\n+            for (RetainedHandlingPolicy q: values()) {\n+                if (q.value == value) {\n+                    return q;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"invalid RetainedHandlingPolicy: \" + value);\n+        }\n+    }\n+\n+    private final MqttQoS qos;\n+    private final boolean noLocal;\n+    private final boolean retainAsPublished;\n+    private final RetainedHandlingPolicy retainHandling;\n+\n+    public static MqttSubscriptionOption onlyFromQos(MqttQoS qos) {\n+        return new MqttSubscriptionOption(qos, false, false, RetainedHandlingPolicy.SEND_AT_SUBSCRIBE);\n+    }\n+\n+    public MqttSubscriptionOption(MqttQoS qos,\n+                                  boolean noLocal,\n+                                  boolean retainAsPublished,\n+                                  RetainedHandlingPolicy retainHandling) {\n+        this.qos = qos;\n+        this.noLocal = noLocal;\n+        this.retainAsPublished = retainAsPublished;\n+        this.retainHandling = retainHandling;\n+    }\n+\n+    public MqttQoS qos() {\n+        return qos;\n+    }\n+\n+    public MqttQoS getQos() {", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE4ODE2Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478188162", "bodyText": "@paul-lysak ^^", "author": "normanmaurer", "createdAt": "2020-08-27T06:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzM0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\nindex 2ad2ce26bc..3da9501661 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java\n\n@@ -68,10 +68,6 @@ public final class MqttSubscriptionOption {\n         return qos;\n     }\n \n-    public MqttQoS getQos() {\n-        return qos;\n-    }\n-\n     public boolean isNoLocal() {\n         return noLocal;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477427882", "bodyText": "Break or continue?", "author": "johnou", "createdAt": "2020-08-26T16:23:07Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        ObjectUtil.checkNotNull(unsubscribeReasonCodes, \"unsubscribeReasonCodes\");\n+\n+        List<Short> list = new ArrayList<Short>(unsubscribeReasonCodes.length);\n+        for (Short v: unsubscribeReasonCodes) {\n+            list.add(v);\n+        }\n+        this.unsubscribeReasonCodes = Collections.unmodifiableList(list);\n+    }\n+\n+    public MqttUnsubAckPayload(Iterable<Short> unsubscribeReasonCodes) {\n+        ObjectUtil.checkNotNull(unsubscribeReasonCodes, \"unsubscribeReasonCodes\");\n+\n+        List<Short> list = new ArrayList<Short>();\n+        for (Short v: unsubscribeReasonCodes) {\n+            if (v == null) {\n+                break;", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE5NTc5Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478195793", "bodyText": "imo makes sense to filter out nulls (continue), not stop on the first null value.", "author": "johnou", "createdAt": "2020-08-27T06:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzE1Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478223153", "bodyText": "Going to change it to throw exceptions - nulls aren't actually valid here. And if you've sent UNSUBSCRIBE for N topics, you'd expect N reason codes in UNSUBACK in MQTT 5 - having some other number is a protocol violation.", "author": "paul-lysak", "createdAt": "2020-08-27T07:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "chunk": "diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\nindex 1ab5774f1b..2ab1d42b11 100644\n--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java\n\n@@ -44,9 +44,7 @@ public final class MqttUnsubAckPayload {\n \n         List<Short> list = new ArrayList<Short>();\n         for (Short v: unsubscribeReasonCodes) {\n-            if (v == null) {\n-                break;\n-            }\n+            ObjectUtil.checkNotNull(v, \"unsubscribeReasonCode\");\n             list.add(v);\n         }\n         this.unsubscribeReasonCodes = Collections.unmodifiableList(list);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478217079", "bodyText": "Given nothing was parsed in the past for old mqtt protocol is this change compatible?", "author": "johnou", "createdAt": "2020-08-27T07:35:52Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +182,54 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjgxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478226818", "bodyText": "decodeReasonCodeAndPropertiesVariableHeader checks for bytesRemainingInVariablePart. If there's no bytes remaining it will substitute default values in MqttReasonCodeAndPropertiesVariableHeader (reason code 0 and no properties).", "author": "paul-lysak", "createdAt": "2020-08-27T07:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3ODQ4NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478278484", "bodyText": "@johnou I think this should work... any concerns ?", "author": "normanmaurer", "createdAt": "2020-08-27T09:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NDk3Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478864976", "bodyText": "@johnou please resolve if you agree and if not leave another comment", "author": "normanmaurer", "createdAt": "2020-08-28T06:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYyMzQ2NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r479623464", "bodyText": "Cannot resolve, change was force pushed.", "author": "johnou", "createdAt": "2020-08-29T08:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYyMzY1OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r479623658", "bodyText": "But yes I agree, should be okay.", "author": "johnou", "createdAt": "2020-08-29T08:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "url": "https://github.com/netty/netty/commit/9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-27T07:55:37Z", "type": "commit"}, {"oid": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "url": "https://github.com/netty/netty/commit/9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-27T07:55:37Z", "type": "forcePushed"}]}