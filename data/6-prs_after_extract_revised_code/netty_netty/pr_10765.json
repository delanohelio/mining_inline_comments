{"pr_number": 10765, "pr_title": "Add PushPromise and Priority Frame support in Http2FrameCodec", "pr_createdAt": "2020-11-02T18:58:17Z", "pr_url": "https://github.com/netty/netty/pull/10765", "timeline": [{"oid": "d296fd1892f3a0110fed5148089371f6b908f015", "url": "https://github.com/netty/netty/commit/d296fd1892f3a0110fed5148089371f6b908f015", "message": "Add PushPromiseRead support", "committedDate": "2020-11-02T18:55:07Z", "type": "commit"}, {"oid": "46dd775b7dc6dba8aff7e19e4937557276b2df52", "url": "https://github.com/netty/netty/commit/46dd775b7dc6dba8aff7e19e4937557276b2df52", "message": "change http2StreamFrame to stream", "committedDate": "2020-11-02T19:03:12Z", "type": "commit"}, {"oid": "24483ce917cc83b18d2ecc7ffafa3188b20b70cd", "url": "https://github.com/netty/netty/commit/24483ce917cc83b18d2ecc7ffafa3188b20b70cd", "message": "Add Priority Read and unit tests", "committedDate": "2020-11-07T08:40:36Z", "type": "commit"}, {"oid": "596a18eee1299fdbe61fd07cb4b196c06276e4e5", "url": "https://github.com/netty/netty/commit/596a18eee1299fdbe61fd07cb4b196c06276e4e5", "message": "Shutdown eventloopgroup in test once done", "committedDate": "2020-11-07T08:46:08Z", "type": "commit"}, {"oid": "d62b4793676b4bfb208a097b7f9d5d078d9a7b44", "url": "https://github.com/netty/netty/commit/d62b4793676b4bfb208a097b7f9d5d078d9a7b44", "message": "Release bytebuf", "committedDate": "2020-11-07T08:47:34Z", "type": "commit"}, {"oid": "e0694494c9bd9ba78c4635d47e29c00a59297289", "url": "https://github.com/netty/netty/commit/e0694494c9bd9ba78c4635d47e29c00a59297289", "message": "make #initializeNewStream public", "committedDate": "2020-11-08T12:45:01Z", "type": "commit"}, {"oid": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "url": "https://github.com/netty/netty/commit/c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "message": "Fix NPE", "committedDate": "2020-11-10T03:56:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2MDM1NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520660355", "bodyText": "Why 2?", "author": "bryce-anderson", "createdAt": "2020-11-10T15:39:48Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5NzEzNQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521397135", "bodyText": "Just wanted to give Server and Client dedicated threads.", "author": "hyperxpro", "createdAt": "2020-11-11T14:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2MDM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex bcca3da734..eb0e928772 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -18,6 +18,7 @@ package io.netty.handler.codec.http2;\n import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4MTg2OQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520681869", "bodyText": "It looks like we return the newly created stream id in two places: as the return value and as the newly populated http2FrameStream.id field. What do you think about making the return value of this method void and using the latter when it's necessary? To me, that avoids the ambiguity up higher as to whether we should use streamId returned by this method or pushPromiseFrame.pushStream().id() (or the parallel in the writeHeaders method).", "author": "bryce-anderson", "createdAt": "2020-11-10T16:07:18Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +422,66 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            final int streamId = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(),\n+                    promise);\n+\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }\n+        }\n+    }\n+\n+    public int initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 2f9d882365..5935c0202f 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -434,7 +434,9 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n                     pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n \n-            if (!promise.isDone()) {\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n                 numBufferedStreams++;\n                 // Clean up the stream being initialized if writing the headers fails and also\n                 // decrement the number of buffered streams.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4NDY0MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520684640", "bodyText": "ffti: it's easier to read these branches if you put the simple case first and you get an added bonus of being able to drop the boolean not operator from the predicate.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:10:44Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +422,66 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            final int streamId = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(),\n+                    promise);\n+\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODgwOA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398808", "bodyText": "Will fix this.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4NDY0MA=="}], "type": "inlineReview", "revised_code": {"commit": "d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 2f9d882365..5935c0202f 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -434,7 +434,9 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), streamId,\n                     pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n \n-            if (!promise.isDone()) {\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n                 numBufferedStreams++;\n                 // Clean up the stream being initialized if writing the headers fails and also\n                 // decrement the number of buffered streams.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTE4Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520689187", "bodyText": "Would it be easier to just add the tests to Http2FrameCodecTest.java? It already has a well developed testing scaffold.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:16:46Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODU4Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398583", "bodyText": "I tried but Http2FrameCodecTest.java was already big and complex and adding this made it 2x complex. So decided to move it into a separate test class.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex bcca3da734..eb0e928772 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -18,6 +18,7 @@ package io.netty.handler.codec.http2;\n import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTk5NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r520689995", "bodyText": "In general, it's not a great idea to hard code ports for tests since you can't be sure they're available to you in all environments.", "author": "bryce-anderson", "createdAt": "2020-11-10T16:17:55Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        serverBootstrap.bind(\"127.0.0.1\", 5555);", "originalCommit": "c362f6a2b2ad67a81b39f2ddf65f215565fc6703", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM5ODcyNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r521398727", "bodyText": "Alright, will fix this.", "author": "hyperxpro", "createdAt": "2020-11-11T14:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4OTk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex bcca3da734..eb0e928772 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -18,6 +18,7 @@ package io.netty.handler.codec.http2;\n import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n"}}, {"oid": "d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "url": "https://github.com/netty/netty/commit/d5b239bf7c284963a8b5ca225f6b4c0ecb61b643", "message": "Swap handleHeaderFuture", "committedDate": "2020-11-11T17:58:14Z", "type": "commit"}, {"oid": "ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "url": "https://github.com/netty/netty/commit/ddc57e0e04c87c9d98dc31e76ba87a02185aa9be", "message": "Use automatic address binding", "committedDate": "2020-11-11T18:00:31Z", "type": "commit"}, {"oid": "313b2f84f83a914b94b050bb0d98fe0e7be75c1c", "url": "https://github.com/netty/netty/commit/313b2f84f83a914b94b050bb0d98fe0e7be75c1c", "message": "Simplify Stream Initialization", "committedDate": "2020-11-11T18:04:24Z", "type": "commit"}, {"oid": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "url": "https://github.com/netty/netty/commit/317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "message": "Use https instead of http", "committedDate": "2020-11-26T11:06:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547845360", "bodyText": "@hyperxpro why is this public ?", "author": "normanmaurer", "createdAt": "2020-12-23T09:19:07Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            final int streamId = pushPromiseFrame.stream().id();\n+\n+            encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzAxMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847012", "bodyText": "Also this should return boolean so when using this you can detect when it failed and when not to early return.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyMzA2Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547923063", "bodyText": "Some use case needs Stream ID to be generated early before sending HeadersFrame. That's why I made it public. If this approach is not good then I will change it back to package-private.\nMy use case:\nHttp2FrameCodec.DefaultHttp2FrameStream http2FrameStream = (Http2FrameCodec.DefaultHttp2FrameStream) newStream();\nframeCodec.initializeNewStream(ctx, http2FrameStream, promise);\nlong id = httpFrame.id();\n\n// Put the stream ID and Outbound Property into the map.\naddStream(new OutboundProperty(id, http2FrameStream, httpFrame.protocol()));", "author": "hyperxpro", "createdAt": "2020-12-23T11:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0MDIwOQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547940209", "bodyText": "I think we need to solve this in a better way...  Maybe we should at least expose this via the Http2ChannelDuplexHandler", "author": "normanmaurer", "createdAt": "2020-12-23T12:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex f7873f5f28..4515bd84ab 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,28 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            final int streamId = headersFrame.stream().id();\n-\n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n-\n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n-\n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NTkwNQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547845905", "bodyText": "missing return.", "author": "normanmaurer", "createdAt": "2020-12-23T09:19:38Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            final int streamId = pushPromiseFrame.stream().id();\n+\n+            encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+\n+            if (promise.isDone()) {\n+                handleHeaderFuture(promise, streamId);\n+            } else {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture channelFuture) {\n+                        numBufferedStreams--;\n+\n+                        handleHeaderFuture(channelFuture, streamId);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,\n+                                    ChannelPromise promise) {\n+        final Http2Connection connection = connection();\n+        final int streamId = connection.local().incrementAndGetNextStreamId();\n+        if (streamId < 0) {\n+            promise.setFailure(new Http2NoMoreStreamIdsException());\n+\n+            // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n+            // valid stream ID for the current peer.\n+            onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n+                    Integer.MAX_VALUE - 1, NO_ERROR.code(),\n+                    writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex f7873f5f28..4515bd84ab 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,28 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            final int streamId = headersFrame.stream().id();\n-\n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n-\n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n-\n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzUyMw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847523", "bodyText": "like said below this should return a boolean and you should return early when the method failed.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:41Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -436,6 +423,62 @@ public void operationComplete(ChannelFuture channelFuture) {\n         }\n     }\n \n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjIxMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547926211", "bodyText": "Sorry, I didn't get it completely. PTAL at latest commit and suggest.", "author": "hyperxpro", "createdAt": "2020-12-23T12:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex f7873f5f28..4515bd84ab 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,28 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            final int streamId = headersFrame.stream().id();\n-\n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n-\n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n-\n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0NzU3NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547847575", "bodyText": "like said below this should return a boolean and you should return early when the method failed.", "author": "normanmaurer", "createdAt": "2020-12-23T09:21:49Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,37 +392,15 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);", "originalCommit": "317c54fdcf0daecec24ea60a4ef4ff319ab7e764", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex f7873f5f28..4515bd84ab 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,28 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            final int streamId = headersFrame.stream().id();\n-\n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n-\n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n-\n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n         }\n     }\n"}}, {"oid": "99820408095e4b1a8b72079955a58cf3e2d096ee", "url": "https://github.com/netty/netty/commit/99820408095e4b1a8b72079955a58cf3e2d096ee", "message": "address review", "committedDate": "2020-12-23T12:03:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNjk2NA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547926964", "bodyText": "just merge these two lines", "author": "normanmaurer", "createdAt": "2020-12-23T12:06:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 4515bd84ab..61c9a877c6 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,8 +399,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            if (init) {\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n                 final int streamId = headersFrame.stream().id();\n \n                 encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzA0Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927047", "bodyText": "just merge the two lines", "author": "normanmaurer", "createdAt": "2020-12-23T12:07:12Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            if (init) {", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 4515bd84ab..61c9a877c6 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,8 +399,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            if (init) {\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n                 final int streamId = headersFrame.stream().id();\n \n                 encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzI4MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927280", "bodyText": "So I strongly believe this should not be public... If the user needs this method we need to find a better way of exposing this", "author": "normanmaurer", "createdAt": "2020-12-23T12:07:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,100 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n+            if (init) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise);\n+            if (init) {\n+                final int streamId = pushPromiseFrame.stream().id();\n \n-            if (!promise.isDone()) {\n-                numBufferedStreams++;\n-                // Clean up the stream being initialized if writing the headers fails and also\n-                // decrement the number of buffered streams.\n-                promise.addListener(new ChannelFutureListener() {\n-                    @Override\n-                    public void operationComplete(ChannelFuture channelFuture) {\n-                        numBufferedStreams--;\n+                encoder().writePushPromise(ctx, streamId, pushPromiseFrame.pushStream().id(),\n+                        pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n \n-                        handleHeaderFuture(channelFuture, streamId);\n-                    }\n-                });\n-            } else {\n-                handleHeaderFuture(promise, streamId);\n+                if (promise.isDone()) {\n+                    handleHeaderFuture(promise, streamId);\n+                } else {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                }\n             }\n         }\n     }\n \n+    public boolean initializeNewStream(ChannelHandlerContext ctx, DefaultHttp2FrameStream http2FrameStream,", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTUwNA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045504", "bodyText": "@hyperxpro ^^", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzI4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 4515bd84ab..61c9a877c6 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,8 +399,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            boolean init = initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise);\n-            if (init) {\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n                 final int streamId = headersFrame.stream().id();\n \n                 encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyNzY0MA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547927640", "bodyText": "Seeing a sleep here seems like there needs to be something else that needs to be fixed", "author": "normanmaurer", "createdAt": "2020-12-23T12:08:47Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        bootstrap.connect(channelFuture.channel().localAddress()).sync();\n+    }\n+\n+    @Test\n+    public void send() throws InterruptedException {\n+        Thread.sleep(100);", "originalCommit": "99820408095e4b1a8b72079955a58cf3e2d096ee", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex a4bb9fd6bf..cce74790f3 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -43,6 +43,8 @@ public class DefaultHttp2PushPromiseFrameTest {\n     private final ClientHandler clientHandler = new ClientHandler();\n     private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n \n+    private ChannelFuture connectionFuture;\n+\n     @Before\n     public void setup() throws InterruptedException {\n         ServerBootstrap serverBootstrap = new ServerBootstrap()\n"}}, {"oid": "ee7ff80e555ecf30beac89b424904e859de4ae94", "url": "https://github.com/netty/netty/commit/ee7ff80e555ecf30beac89b424904e859de4ae94", "message": "fix more issues", "committedDate": "2020-12-23T12:22:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTM1OQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935359", "bodyText": "This should have no get prefix... Also it missed javadocs. Beside this I wonder why this is not part of the interface ?", "author": "normanmaurer", "createdAt": "2020-12-23T12:28:55Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@link Http2PushPromiseFrame}\n+ */\n+public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {\n+\n+    private Http2FrameStream pushStreamFrame;\n+    private final Http2Headers http2Headers;\n+    private Http2FrameStream streamFrame;\n+    private final int padding;\n+    private final int promisedStreamId;\n+\n+    public DefaultHttp2PushPromiseFrame(Http2Headers http2Headers) {\n+        this(http2Headers, 0);\n+    }\n+\n+    public DefaultHttp2PushPromiseFrame(Http2Headers http2Headers, int padding) {\n+        this(http2Headers, padding, -1);\n+    }\n+\n+    DefaultHttp2PushPromiseFrame(Http2Headers http2Headers, int padding, int promisedStreamId) {\n+        this.http2Headers = http2Headers;\n+        this.padding = padding;\n+        this.promisedStreamId = promisedStreamId;\n+    }\n+\n+    @Override\n+    public Http2StreamFrame pushStream(Http2FrameStream stream) {\n+        pushStreamFrame = stream;\n+        return this;\n+    }\n+\n+    @Override\n+    public Http2FrameStream pushStream() {\n+        return pushStreamFrame;\n+    }\n+\n+    @Override\n+    public Http2Headers http2Headers() {\n+        return http2Headers;\n+    }\n+\n+    @Override\n+    public int padding() {\n+        return padding;\n+    }\n+\n+    @Override\n+    public Http2StreamFrame stream(Http2FrameStream stream) {\n+        streamFrame = stream;\n+        return this;\n+    }\n+\n+    @Override\n+    public Http2FrameStream stream() {\n+        return streamFrame;\n+    }\n+\n+    public int getPromisedStreamId() {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\nindex 8c182bf89f..3cbb2178c6 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\n\n@@ -61,6 +61,15 @@ public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {\n         return padding;\n     }\n \n+    @Override\n+    public int promisedStreamId() {\n+        if (pushStreamFrame != null) {\n+            return pushStreamFrame.id();\n+        } else {\n+            return promisedStreamId;\n+        }\n+    }\n+\n     @Override\n     public Http2StreamFrame stream(Http2FrameStream stream) {\n         streamFrame = stream;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935722", "bodyText": "never call sync() in the eventloop. Remove this call and also remove the throws...", "author": "normanmaurer", "createdAt": "2020-12-23T12:29:49Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() throws InterruptedException {\n+        connectionFuture.sync();\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame).sync();\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame).sync();\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame).sync();\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame).sync();\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            Http2Headers http2Headers = new DefaultHttp2Headers();\n+            http2Headers.path(\"/\")\n+                    .authority(\"localhost\")\n+                    .method(\"GET\")\n+                    .scheme(\"https\");\n+\n+            Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, true);\n+            headersFrame.stream(newStream());\n+            ctx.writeAndFlush(headersFrame).sync();", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzODk2Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547938966", "bodyText": "Then I get NPE if I don't block it with something. That's why I had Thread#sleep.", "author": "hyperxpro", "createdAt": "2020-12-23T12:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0MDMyOA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547940328", "bodyText": "show me the stack trace", "author": "normanmaurer", "createdAt": "2020-12-23T12:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk0NDk4Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547944986", "bodyText": "Tried adding a listener. PTAL.", "author": "hyperxpro", "createdAt": "2020-12-23T12:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex cce74790f3..22450364d1 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -19,6 +19,7 @@ import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTkwMw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935903", "bodyText": "nit: you could even merge this with the else and make it if else", "author": "normanmaurer", "createdAt": "2020-12-23T12:30:20Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,98 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 61c9a877c6..b5f641d3a0 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -398,8 +398,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n                 final int streamId = headersFrame.stream().id();\n \n                 encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkzNTk4MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547935981", "bodyText": "nit: you could even merge this with the else and make it if else", "author": "normanmaurer", "createdAt": "2020-12-23T12:30:31Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,98 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n             }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else {\n+            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise)) {", "originalCommit": "ee7ff80e555ecf30beac89b424904e859de4ae94", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex 61c9a877c6..b5f641d3a0 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -398,8 +398,7 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n                 final int streamId = headersFrame.stream().id();\n \n                 encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n"}}, {"oid": "4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "url": "https://github.com/netty/netty/commit/4cbf31a0e3a7015c3ca4921551ed1606f50b2513", "message": "use if-else", "committedDate": "2020-12-23T12:46:41Z", "type": "commit"}, {"oid": "2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "url": "https://github.com/netty/netty/commit/2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "message": "use listener", "committedDate": "2020-12-23T12:53:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1MDkyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547950922", "bodyText": "This method should not block... You need to not call sync() in it when you call it in a handler", "author": "normanmaurer", "createdAt": "2020-12-23T13:09:23Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -90,8 +91,17 @@ protected void initChannel(SocketChannel ch) {\n     }\n \n     @Test\n-    public void send() throws InterruptedException {\n-        connectionFuture.sync();\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();", "originalCommit": "2787177868efd17479d6b4b06c2fb6b2cd2c0edd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1Mjc3Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r547952776", "bodyText": "Done", "author": "hyperxpro", "createdAt": "2020-12-23T13:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1MDkyMg=="}], "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex 22450364d1..79b6a394d9 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -95,11 +96,7 @@ public class DefaultHttp2PushPromiseFrameTest {\n         connectionFuture.addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) {\n-                try {\n-                    clientHandler.write();\n-                } catch (InterruptedException e) {\n-                    // Ignore\n-                }\n+                clientHandler.write();\n             }\n         });\n     }\n"}}, {"oid": "d673e90e71fba557ca91701afaea419d788c3e8c", "url": "https://github.com/netty/netty/commit/d673e90e71fba557ca91701afaea419d788c3e8c", "message": "dont block", "committedDate": "2020-12-23T13:13:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTAxNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045016", "bodyText": "final...", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:19Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@linkplain Http2PriorityFrame}\n+ */\n+public class DefaultHttp2PriorityFrame implements Http2PriorityFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTA5MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045091", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java\nindex a0d5d8621c..694441ce40 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PriorityFrame.java\n\n@@ -15,10 +15,13 @@\n  */\n package io.netty.handler.codec.http2;\n \n+import io.netty.util.internal.UnstableApi;\n+\n /**\n  * Default implementation of {@linkplain Http2PriorityFrame}\n  */\n-public class DefaultHttp2PriorityFrame implements Http2PriorityFrame {\n+@UnstableApi\n+public final class DefaultHttp2PriorityFrame implements Http2PriorityFrame {\n \n     private final int streamDependency;\n     private final short weight;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTE2Ng==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045166", "bodyText": "final\nAdd @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:38:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * Default implementation of {@link Http2PushPromiseFrame}\n+ */\n+public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\nindex 3cbb2178c6..e9c4aa1ba8 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrame.java\n\n@@ -15,10 +15,13 @@\n  */\n package io.netty.handler.codec.http2;\n \n+import io.netty.util.internal.UnstableApi;\n+\n /**\n  * Default implementation of {@link Http2PushPromiseFrame}\n  */\n-public class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {\n+@UnstableApi\n+public final class DefaultHttp2PushPromiseFrame implements Http2PushPromiseFrame {\n \n     private Http2FrameStream pushStreamFrame;\n     private final Http2Headers http2Headers;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTU4Mw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045583", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+public interface Http2PriorityFrame extends Http2StreamFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\nindex e2a6639cca..bedbd80629 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\n@@ -15,9 +15,12 @@\n  */\n package io.netty.handler.codec.http2;\n \n+import io.netty.util.internal.UnstableApi;\n+\n /**\n  * HTTP/2 Priority Frame\n  */\n+@UnstableApi\n public interface Http2PriorityFrame extends Http2StreamFrame {\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTYxNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045616", "bodyText": "Add @UnstableApi", "author": "normanmaurer", "createdAt": "2020-12-23T16:39:42Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\nindex 40b800c183..154789d3f2 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\n@@ -15,9 +15,12 @@\n  */\n package io.netty.handler.codec.http2;\n \n+import io.netty.util.internal.UnstableApi;\n+\n /**\n  * HTTP/2 Push Promise Frame\n  */\n+@UnstableApi\n public interface Http2PushPromiseFrame extends Http2StreamFrame {\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTkwNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548045907", "bodyText": "Remove throws InterruptedException and also remove the catch for it above", "author": "normanmaurer", "createdAt": "2020-12-23T16:40:21Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        private ChannelHandlerContext ctx;\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            this.ctx = ctx;\n+        }\n+\n+        void write() throws InterruptedException {", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex 5b5758038c..79b6a394d9 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -29,6 +29,7 @@ import io.netty.channel.socket.SocketChannel;\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.channel.socket.nio.NioSocketChannel;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NjYyMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548046621", "bodyText": "consider removing all these release and just add a big try {... } finally { ReferenceCountUtil.release(msg); }", "author": "normanmaurer", "createdAt": "2020-12-23T16:42:01Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                try {\n+                    clientHandler.write();\n+                } catch (InterruptedException e) {\n+                    // Ignore\n+                }\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n+\n+                // Write headers for actual request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"false\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of actual request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(\"Meow\".getBytes()), true);\n+                dataFrame.stream(receivedFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            } else if (msg instanceof Http2PriorityFrame) {\n+                Http2PriorityFrame priorityFrame = (Http2PriorityFrame) msg;\n+                String content = contentMap.get(priorityFrame.stream().id());\n+                if (content == null) {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                    return;\n+                }\n+\n+                // Write headers for Priority request\n+                Http2Headers http2Headers = new DefaultHttp2Headers();\n+                http2Headers.status(\"200\");\n+                http2Headers.add(\"push\", \"true\");\n+                Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+                headersFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(headersFrame);\n+\n+                // Write Data of Priority request\n+                Http2DataFrame dataFrame = new DefaultHttp2DataFrame(Unpooled.wrappedBuffer(content.getBytes()), true);\n+                dataFrame.stream(priorityFrame.stream());\n+                ctx.writeAndFlush(dataFrame);\n+            }\n+        }\n+    }\n+\n+    private static final class ClientHandler extends Http2ChannelDuplexHandler {\n+\n+        private ChannelHandlerContext ctx;\n+\n+        @Override\n+        public void channelActive(ChannelHandlerContext ctx) throws InterruptedException {\n+            this.ctx = ctx;\n+        }\n+\n+        void write() throws InterruptedException {\n+            Http2Headers http2Headers = new DefaultHttp2Headers();\n+            http2Headers.path(\"/\")\n+                    .authority(\"localhost\")\n+                    .method(\"GET\")\n+                    .scheme(\"https\");\n+\n+            Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, true);\n+            headersFrame.stream(newStream());\n+            ctx.writeAndFlush(headersFrame);\n+        }\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+\n+            if (msg instanceof Http2PushPromiseFrame) {\n+                Http2PushPromiseFrame pushPromiseFrame = (Http2PushPromiseFrame) msg;\n+\n+                assertEquals(\"/meow\", pushPromiseFrame.http2Headers().path().toString());\n+                assertEquals(\"GET\", pushPromiseFrame.http2Headers().method().toString());\n+                assertEquals(\"https\", pushPromiseFrame.http2Headers().scheme().toString());\n+                assertEquals(\"localhost:5555\", pushPromiseFrame.http2Headers().authority().toString());\n+\n+                Http2PriorityFrame priorityFrame = new DefaultHttp2PriorityFrame(pushPromiseFrame.stream().id(),\n+                        Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT, true);\n+                priorityFrame.stream(pushPromiseFrame.pushStream());\n+                ctx.writeAndFlush(priorityFrame);\n+            } else if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame headersFrame = (Http2HeadersFrame) msg;\n+\n+                if (headersFrame.stream().id() == 3) {\n+                    assertEquals(\"200\", headersFrame.headers().status().toString());\n+                    assertEquals(\"false\", headersFrame.headers().get(\"push\").toString());\n+                } else if (headersFrame.stream().id() == 2) {\n+                    assertEquals(\"200\", headersFrame.headers().status().toString());\n+                    assertEquals(\"true\", headersFrame.headers().get(\"push\").toString());\n+                } else {\n+                    ctx.writeAndFlush(new DefaultHttp2GoAwayFrame(Http2Error.REFUSED_STREAM));\n+                }\n+            } else if (msg instanceof Http2DataFrame) {\n+                Http2DataFrame dataFrame = (Http2DataFrame) msg;\n+\n+                if (dataFrame.stream().id() == 3) {\n+                    assertEquals(\"Meow\", dataFrame.content().toString(CharsetUtil.UTF_8));\n+                    dataFrame.content().release();\n+                } else if (dataFrame.stream().id() == 2) {\n+                    assertEquals(\"Meow, I am Pushed via HTTP/2\", dataFrame.content().toString(CharsetUtil.UTF_8));\n+                    dataFrame.content().release();\n+                } else {\n+                    dataFrame.content().release();", "originalCommit": "d673e90e71fba557ca91701afaea419d788c3e8c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex 5b5758038c..79b6a394d9 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -29,6 +29,7 @@ import io.netty.channel.socket.SocketChannel;\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.channel.socket.nio.NioSocketChannel;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n"}}, {"oid": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "url": "https://github.com/netty/netty/commit/fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "message": "Address review", "committedDate": "2020-12-23T16:49:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2Mjk3NQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548062975", "bodyText": "This interface should add an override like:\n@Override\nHttp2PriorityFrame stream(Http2FrameStream stream) {", "author": "normanmaurer", "createdAt": "2020-12-23T17:19:22Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();", "originalCommit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM2Nzk4OA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548367988", "bodyText": "Done, PTAL.", "author": "hyperxpro", "createdAt": "2020-12-24T03:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2Mjk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\nindex bedbd80629..4747195bb1 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\n@@ -37,4 +37,10 @@ public interface Http2PriorityFrame extends Http2StreamFrame {\n      * Set to {@code true} if this stream is exclusive else set to {@code false}\n      */\n     boolean exclusive();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2MzE2Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548063167", "bodyText": "This interface should add an override like:\n@Override\nHttp2PushPromiseFrame stream(Http2FrameStream stream) {", "author": "normanmaurer", "createdAt": "2020-12-23T17:19:33Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();", "originalCommit": "fdaabd5434923b5ae64e68b33c99b8e594e6cd78", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\nindex 154789d3f2..5bf63fd7fd 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\n@@ -48,4 +48,10 @@ public interface Http2PushPromiseFrame extends Http2StreamFrame {\n      * Promised Stream ID\n      */\n     int promisedStreamId();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();\n }\n"}}, {"oid": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "url": "https://github.com/netty/netty/commit/d99cfc570523d740770c3b6b50fc25501a7c94f8", "message": "override methods", "committedDate": "2020-12-24T03:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMDkzMQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548400931", "bodyText": "Is this override needed ? Seems like it returns the same type as the parent method", "author": "normanmaurer", "createdAt": "2020-12-24T06:03:19Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\nindex 5bf63fd7fd..9150681b49 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\n@@ -52,6 +52,4 @@ public interface Http2PushPromiseFrame extends Http2StreamFrame {\n     @Override\n     Http2StreamFrame stream(Http2FrameStream stream);\n \n-    @Override\n-    Http2FrameStream stream();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMDk5Mg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548400992", "bodyText": "Is this override needed ? Seems like it returns the same type as the parent method", "author": "normanmaurer", "createdAt": "2020-12-24T06:03:37Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);\n+\n+    @Override\n+    Http2FrameStream stream();\n+}", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\nindex 4747195bb1..a09dd95332 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\n@@ -41,6 +41,4 @@ public interface Http2PriorityFrame extends Http2StreamFrame {\n     @Override\n     Http2StreamFrame stream(Http2FrameStream stream);\n \n-    @Override\n-    Http2FrameStream stream();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQwMTQ1Mg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548401452", "bodyText": "Never call sync in the eventloop", "author": "normanmaurer", "createdAt": "2020-12-24T06:05:41Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                clientHandler.write();\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame).sync();", "originalCommit": "d99cfc570523d740770c3b6b50fc25501a7c94f8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex 79b6a394d9..2dde1b3ade 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -125,7 +125,7 @@ public class DefaultHttp2PushPromiseFrameTest {\n                 Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n                 pushPromiseFrame.stream(receivedFrame.stream());\n                 pushPromiseFrame.pushStream(newPushFrameStream);\n-                ctx.writeAndFlush(pushPromiseFrame).sync();\n+                ctx.writeAndFlush(pushPromiseFrame);\n \n                 contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");\n \n"}}, {"oid": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "url": "https://github.com/netty/netty/commit/ab51220fb495dfd9928957c6cc96c81af4141f3d", "message": "address more review", "committedDate": "2020-12-24T06:18:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548744022", "bodyText": "s/Http2StreamFrame/Http2PushPromiseFrame/", "author": "normanmaurer", "createdAt": "2020-12-24T20:24:12Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Push Promise Frame\n+ */\n+@UnstableApi\n+public interface Http2PushPromiseFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Set the Promise {@link Http2FrameStream} object for this frame.\n+     */\n+    Http2StreamFrame pushStream(Http2FrameStream stream);\n+\n+    /**\n+     * Returns the Promise {@link Http2FrameStream} object for this frame, or {@code null} if the\n+     * frame has yet to be associated with a stream.\n+     */\n+    Http2FrameStream pushStream();\n+\n+    /**\n+     * {@link Http2Headers} sent in Push Promise\n+     */\n+    Http2Headers http2Headers();\n+\n+    /**\n+     * Frame padding to use. Will be non-negative and less than 256.\n+     */\n+    int padding();\n+\n+    /**\n+     * Promised Stream ID\n+     */\n+    int promisedStreamId();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);", "originalCommit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4Mjg1MQ==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548782851", "bodyText": "Sorry, I didn't get it. Do you want me to rename Http2StreamFrame stream(Http2FrameStream stream); to     Http2PriorityFrame stream(Http2PriorityFrame stream);?", "author": "hyperxpro", "createdAt": "2020-12-25T02:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1MTgzNw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548851837", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Http2StreamFrame stream(Http2FrameStream stream);\n          \n          \n            \n                Http2PushPromiseFrame stream(Http2FrameStream stream);", "author": "normanmaurer", "createdAt": "2020-12-25T10:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDAyMg=="}], "type": "inlineReview", "revised_code": {"commit": "c1059f3a216ba18568f28934deb38e037dfe35b6", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\nindex 9150681b49..dc5d7cb42e 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\n@@ -50,6 +50,6 @@ public interface Http2PushPromiseFrame extends Http2StreamFrame {\n     int promisedStreamId();\n \n     @Override\n-    Http2StreamFrame stream(Http2FrameStream stream);\n+    Http2PushPromiseFrame stream(Http2FrameStream stream);\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDA0Nw==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548744047", "bodyText": "s/Http2StreamFrame/Http2PriorityFrame/", "author": "normanmaurer", "createdAt": "2020-12-24T20:24:27Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.util.internal.UnstableApi;\n+\n+/**\n+ * HTTP/2 Priority Frame\n+ */\n+@UnstableApi\n+public interface Http2PriorityFrame extends Http2StreamFrame {\n+\n+    /**\n+     * Parent Stream Id of this Priority request\n+     */\n+    int streamDependency();\n+\n+    /**\n+     * Stream weight\n+     */\n+    short weight();\n+\n+    /**\n+     * Set to {@code true} if this stream is exclusive else set to {@code false}\n+     */\n+    boolean exclusive();\n+\n+    @Override\n+    Http2StreamFrame stream(Http2FrameStream stream);", "originalCommit": "ab51220fb495dfd9928957c6cc96c81af4141f3d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1MTkzMA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r548851930", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Http2StreamFrame stream(Http2FrameStream stream);\n          \n          \n            \n                Http2PriorityFrame stream(Http2FrameStream stream);", "author": "normanmaurer", "createdAt": "2020-12-25T10:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NDA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "f3e1a6c71f1e2dded5e81dbb336451448f2b59be", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\nindex a09dd95332..403028fa39 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\n@@ -39,6 +39,6 @@ public interface Http2PriorityFrame extends Http2StreamFrame {\n     boolean exclusive();\n \n     @Override\n-    Http2StreamFrame stream(Http2FrameStream stream);\n+    Http2PriorityFrame stream(Http2FrameStream stream);\n \n }\n"}}, {"oid": "c1059f3a216ba18568f28934deb38e037dfe35b6", "url": "https://github.com/netty/netty/commit/c1059f3a216ba18568f28934deb38e037dfe35b6", "message": "Update codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PushPromiseFrame.java\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-12-26T03:03:06Z", "type": "commit"}, {"oid": "f3e1a6c71f1e2dded5e81dbb336451448f2b59be", "url": "https://github.com/netty/netty/commit/f3e1a6c71f1e2dded5e81dbb336451448f2b59be", "message": "Update codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PriorityFrame.java\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>", "committedDate": "2020-12-26T03:03:21Z", "type": "commit"}, {"oid": "1e5c29a2dd026e428dc51db903e97943c563515b", "url": "https://github.com/netty/netty/commit/1e5c29a2dd026e428dc51db903e97943c563515b", "message": "refactor", "committedDate": "2020-12-26T03:13:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTMwNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089306", "bodyText": "remove 4 spaces in all lines in the if block... you use 8 spaces while we use 4 everywhere", "author": "normanmaurer", "createdAt": "2020-12-27T09:33:16Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,94 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex ba4ea93e35..63181c901d 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,25 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n-                final int streamId = headersFrame.stream().id();\n+            final int streamId = headersFrame.stream().id();\n \n-                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n                         headersFrame.isEndStream(), promise);\n \n-                if (!promise.isDone()) {\n-                    numBufferedStreams++;\n-                    // Clean up the stream being initialized if writing the headers fails and also\n-                    // decrement the number of buffered streams.\n-                    promise.addListener(new ChannelFutureListener() {\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n                         @Override\n                         public void operationComplete(ChannelFuture channelFuture) {\n                             numBufferedStreams--;\n-\n                             handleHeaderFuture(channelFuture, streamId);\n                         }\n-                    });\n-                } else {\n-                    handleHeaderFuture(promise, streamId);\n-                }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTMzNg==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089336", "bodyText": "remove 4 spaces in all lines in the if block... you use 8 spaces while we use 4 everywhere", "author": "normanmaurer", "createdAt": "2020-12-27T09:33:26Z", "path": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java", "diffHunk": "@@ -383,59 +392,94 @@ private void writeGoAwayFrame(ChannelHandlerContext ctx, Http2GoAwayFrame frame,\n         goAway(ctx, (int) lastStreamId, frame.errorCode(), frame.content(), promise);\n     }\n \n-    private void writeHeadersFrame(\n-            final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame, final ChannelPromise promise) {\n+    private void writeHeadersFrame(final ChannelHandlerContext ctx, Http2HeadersFrame headersFrame,\n+                                   final ChannelPromise promise) {\n \n         if (isStreamIdValid(headersFrame.stream().id())) {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n-        } else {\n-            final DefaultHttp2FrameStream stream = (DefaultHttp2FrameStream) headersFrame.stream();\n-            final Http2Connection connection = connection();\n-            final int streamId = connection.local().incrementAndGetNextStreamId();\n-            if (streamId < 0) {\n-                promise.setFailure(new Http2NoMoreStreamIdsException());\n-\n-                // Simulate a GOAWAY being received due to stream exhaustion on this connection. We use the maximum\n-                // valid stream ID for the current peer.\n-                onHttp2Frame(ctx, new DefaultHttp2GoAwayFrame(connection.isServer() ? Integer.MAX_VALUE :\n-                        Integer.MAX_VALUE - 1, NO_ERROR.code(),\n-                        writeAscii(ctx.alloc(), \"Stream IDs exhausted on local stream creation\")));\n-                return;\n-            }\n-            stream.id = streamId;\n-\n-            // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the\n-            // stream in a field directly we may override the stored field before onStreamAdded(...) was called\n-            // and so not correctly set the property for the buffered stream.\n-            //\n-            // See https://github.com/netty/netty/issues/8692\n-            Object old = frameStreamToInitializeMap.put(streamId, stream);\n-\n-            // We should not re-use ids.\n-            assert old == null;\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n+                final int streamId = headersFrame.stream().id();\n+\n+                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+                        headersFrame.isEndStream(), promise);\n+\n+                if (!promise.isDone()) {\n+                    numBufferedStreams++;\n+                    // Clean up the stream being initialized if writing the headers fails and also\n+                    // decrement the number of buffered streams.\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture channelFuture) {\n+                            numBufferedStreams--;\n+\n+                            handleHeaderFuture(channelFuture, streamId);\n+                        }\n+                    });\n+                } else {\n+                    handleHeaderFuture(promise, streamId);\n+                }\n+        }\n+    }\n \n-            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n-                    headersFrame.isEndStream(), promise);\n+    private void writePushPromise(final ChannelHandlerContext ctx, Http2PushPromiseFrame pushPromiseFrame,\n+                                  final ChannelPromise promise) {\n+        if (isStreamIdValid(pushPromiseFrame.pushStream().id())) {\n+            encoder().writePushPromise(ctx, pushPromiseFrame.stream().id(), pushPromiseFrame.pushStream().id(),\n+                    pushPromiseFrame.http2Headers(), pushPromiseFrame.padding(), promise);\n+        } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) pushPromiseFrame.pushStream(), promise)) {\n+                final int streamId = pushPromiseFrame.stream().id();", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "chunk": "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\nindex ba4ea93e35..63181c901d 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java\n\n@@ -399,26 +399,25 @@ public class Http2FrameCodec extends Http2ConnectionHandler {\n             encoder().writeHeaders(ctx, headersFrame.stream().id(), headersFrame.headers(), headersFrame.padding(),\n                     headersFrame.isEndStream(), promise);\n         } else if (initializeNewStream(ctx, (DefaultHttp2FrameStream) headersFrame.stream(), promise)) {\n-                final int streamId = headersFrame.stream().id();\n+            final int streamId = headersFrame.stream().id();\n \n-                encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n+            encoder().writeHeaders(ctx, streamId, headersFrame.headers(), headersFrame.padding(),\n                         headersFrame.isEndStream(), promise);\n \n-                if (!promise.isDone()) {\n-                    numBufferedStreams++;\n-                    // Clean up the stream being initialized if writing the headers fails and also\n-                    // decrement the number of buffered streams.\n-                    promise.addListener(new ChannelFutureListener() {\n+            if (!promise.isDone()) {\n+                numBufferedStreams++;\n+                // Clean up the stream being initialized if writing the headers fails and also\n+                // decrement the number of buffered streams.\n+                promise.addListener(new ChannelFutureListener() {\n                         @Override\n                         public void operationComplete(ChannelFuture channelFuture) {\n                             numBufferedStreams--;\n-\n                             handleHeaderFuture(channelFuture, streamId);\n                         }\n-                    });\n-                } else {\n-                    handleHeaderFuture(promise, streamId);\n-                }\n+                });\n+            } else {\n+                handleHeaderFuture(promise, streamId);\n+            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA4OTQ5NA==", "url": "https://github.com/netty/netty/pull/10765#discussion_r549089494", "bodyText": "Honestly I think this should be done in a ChannelFutureListener so you are sure the write was actually done and so the id was set... Basically move this line and everything below in a a ChannelFutureListener that is added to the headers write.", "author": "normanmaurer", "createdAt": "2020-12-27T09:34:58Z", "path": "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http2;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class DefaultHttp2PushPromiseFrameTest {\n+\n+    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+    private final ClientHandler clientHandler = new ClientHandler();\n+    private final Map<Integer, String> contentMap = new ConcurrentHashMap<Integer, String>();\n+\n+    private ChannelFuture connectionFuture;\n+\n+    @Before\n+    public void setup() throws InterruptedException {\n+        ServerBootstrap serverBootstrap = new ServerBootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forServer()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(new ServerHandler());\n+                    }\n+                });\n+\n+        ChannelFuture channelFuture = serverBootstrap.bind(0).sync();\n+\n+        final Bootstrap bootstrap = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioSocketChannel.class)\n+                .handler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    protected void initChannel(SocketChannel ch) {\n+                        ChannelPipeline pipeline = ch.pipeline();\n+\n+                        Http2FrameCodec frameCodec = Http2FrameCodecBuilder.forClient()\n+                                .autoAckSettingsFrame(true)\n+                                .autoAckPingFrame(true)\n+                                .initialSettings(Http2Settings.defaultSettings().pushEnabled(true))\n+                                .build();\n+\n+                        pipeline.addLast(frameCodec);\n+                        pipeline.addLast(clientHandler);\n+                    }\n+                });\n+\n+        connectionFuture = bootstrap.connect(channelFuture.channel().localAddress());\n+    }\n+\n+    @Test\n+    public void send() {\n+        connectionFuture.addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                clientHandler.write();\n+            }\n+        });\n+    }\n+\n+    @After\n+    public void shutdown() {\n+        eventLoopGroup.shutdownGracefully();\n+    }\n+\n+    private final class ServerHandler extends Http2ChannelDuplexHandler {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+\n+            if (msg instanceof Http2HeadersFrame) {\n+                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+\n+                Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n+                pushRequestHeaders.path(\"/meow\")\n+                        .method(\"GET\")\n+                        .scheme(\"https\")\n+                        .authority(\"localhost:5555\");\n+\n+                // Write PUSH_PROMISE request headers\n+                Http2FrameStream newPushFrameStream = newStream();\n+                Http2PushPromiseFrame pushPromiseFrame = new DefaultHttp2PushPromiseFrame(pushRequestHeaders);\n+                pushPromiseFrame.stream(receivedFrame.stream());\n+                pushPromiseFrame.pushStream(newPushFrameStream);\n+                ctx.writeAndFlush(pushPromiseFrame);\n+\n+                contentMap.put(newPushFrameStream.id(), \"Meow, I am Pushed via HTTP/2\");", "originalCommit": "1e5c29a2dd026e428dc51db903e97943c563515b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "chunk": "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\nindex 2dde1b3ade..c56a5ddf52 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2PushPromiseFrameTest.java\n\n@@ -109,10 +109,10 @@ public class DefaultHttp2PushPromiseFrameTest {\n     private final class ServerHandler extends Http2ChannelDuplexHandler {\n \n         @Override\n-        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {\n \n             if (msg instanceof Http2HeadersFrame) {\n-                Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n+                final Http2HeadersFrame receivedFrame = (Http2HeadersFrame) msg;\n \n                 Http2Headers pushRequestHeaders = new DefaultHttp2Headers();\n                 pushRequestHeaders.path(\"/meow\")\n"}}, {"oid": "53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "url": "https://github.com/netty/netty/commit/53eeaf1d33270dc24db0077b6528e36c6f63b2d7", "message": "address more issues", "committedDate": "2020-12-27T09:46:54Z", "type": "commit"}, {"oid": "c861f2351c13fc203a61a7d18873ba518f119a94", "url": "https://github.com/netty/netty/commit/c861f2351c13fc203a61a7d18873ba518f119a94", "message": "refactor code with IDE", "committedDate": "2020-12-27T09:49:48Z", "type": "commit"}, {"oid": "d3fecf72d6337ce005b310046d78ec4518ec1a91", "url": "https://github.com/netty/netty/commit/d3fecf72d6337ce005b310046d78ec4518ec1a91", "message": "remove extra empty line", "committedDate": "2020-12-27T09:51:56Z", "type": "commit"}]}