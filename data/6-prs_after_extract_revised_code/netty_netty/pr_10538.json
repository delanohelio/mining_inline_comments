{"pr_number": 10538, "pr_title": "Only execute the close once the already added write operations completes", "pr_createdAt": "2020-09-07T08:01:37Z", "pr_url": "https://github.com/netty/netty/pull/10538", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MTc5NQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484261795", "bodyText": "Wildcard not allowed.", "author": "hyperxpro", "createdAt": "2020-09-07T08:06:58Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -19,18 +19,7 @@\n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.ByteBufUtil;\n import io.netty.buffer.Unpooled;\n-import io.netty.channel.AbstractChannel;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelConfig;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelMetadata;\n-import io.netty.channel.ChannelOutboundBuffer;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.ConnectTimeoutException;\n-import io.netty.channel.DefaultChannelConfig;\n-import io.netty.channel.EventLoop;\n-import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.*;", "originalCommit": "56a998c03ceeb36caa6d825b6828f91cda91750a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0b164de4f3d8dc166103af2b82f07b216ceaf49a", "chunk": "diff --git a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\nindex 4b4a4287eb..42442ba3da 100644\n--- a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n+++ b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n\n@@ -19,11 +19,29 @@ import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.ByteBufUtil;\n import io.netty.buffer.Unpooled;\n-import io.netty.channel.*;\n+import io.netty.channel.AbstractChannel;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelMetadata;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ChannelPromiseNotifier;\n+import io.netty.channel.ConnectTimeoutException;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n import io.netty.channel.socket.ChannelInputShutdownEvent;\n import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n import io.netty.channel.socket.SocketChannelConfig;\n-import io.netty.channel.unix.*;\n+import io.netty.channel.unix.Buffer;\n+import io.netty.channel.unix.Errors;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.channel.unix.NativeInetAddress;\n+import io.netty.channel.unix.Socket;\n+import io.netty.channel.unix.UnixChannel;\n+import io.netty.channel.unix.UnixChannelUtil;\n import io.netty.util.ReferenceCountUtil;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MjE0NQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484262145", "bodyText": "Can we use a Logger instead of System.out.println(Object)?", "author": "hyperxpro", "createdAt": "2020-09-07T08:07:43Z", "path": "transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java", "diffHunk": "@@ -81,7 +81,7 @@ public void initChannel(SocketChannel ch) throws Exception {\n     public void test() throws Exception {\n \n         io_uring_test();\n-\n+        Thread.sleep(1000);\n         System.out.println(\"io_uring --------------------------------\");", "originalCommit": "56a998c03ceeb36caa6d825b6828f91cda91750a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NDAwOQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484264009", "bodyText": "yes... I will do a full cleanup now so check style will pass etc.", "author": "normanmaurer", "createdAt": "2020-09-07T08:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2MjE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0b164de4f3d8dc166103af2b82f07b216ceaf49a", "chunk": "diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java\nindex fdb6745c81..8d85694f7b 100644\n--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java\n+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java\n\n@@ -74,18 +59,15 @@ public class PollRemoveTest {\n             bossGroup.shutdownGracefully();\n             workerGroup.shutdownGracefully();\n         }\n-\n     }\n \n     @Test\n     public void test() throws Exception {\n-\n         io_uring_test();\n+\n         Thread.sleep(1000);\n-        System.out.println(\"io_uring --------------------------------\");\n \n         io_uring_test();\n-\n     }\n }\n \n"}}, {"oid": "0b164de4f3d8dc166103af2b82f07b216ceaf49a", "url": "https://github.com/netty/netty/commit/0b164de4f3d8dc166103af2b82f07b216ceaf49a", "message": "Address nicks comments", "committedDate": "2020-09-07T08:34:04Z", "type": "forcePushed"}, {"oid": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "url": "https://github.com/netty/netty/commit/ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "message": "Address nicks comments", "committedDate": "2020-09-07T08:42:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484294458", "bodyText": "A sleep in a test is always suspicious.", "author": "chrisvest", "createdAt": "2020-09-07T09:02:53Z", "path": "transport-native-io_uring/src/test/java/io/netty/channel/uring/PollRemoveTest.java", "diffHunk": "@@ -64,6 +64,9 @@ public void initChannel(SocketChannel ch) { }\n     @Test\n     public void test() throws Exception {\n         io_uring_test();\n+\n+        Thread.sleep(1000);", "originalCommit": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwODUyOA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484308528", "bodyText": "I agree... that said this sleep has nothing to do with the PR itself ... I just added it as the test failed sometimes for me as the fd was not completely closed when we did rerun the test (was the case before as well)", "author": "normanmaurer", "createdAt": "2020-09-07T09:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2NDk0MA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484364940", "bodyText": "this test also failed for me as well..", "author": "1Jo1", "createdAt": "2020-09-07T11:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5NDQ1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484298297", "bodyText": "An alternative to delay enqueueing the close operation, could be to enqueue it with the IOSQE_IO_DRAIN flag. Then the close operation will not be started until prior operations have completed, though following operations will also not be started until the close operation has completion, thus creating a slight queue hiccup. The hiccup might not be a big deal, though, compared to the state tracking we otherwise have to do.", "author": "chrisvest", "createdAt": "2020-09-07T09:09:04Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +346,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);", "originalCommit": "ae5a8d795a2be7ec9e2f1fa7aefc2189fee4d8b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwNzg0Nw==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484307847", "bodyText": "The problem with this is that this is not only about the \"close sys call\" but also about other state that is set in netty itself. So this will not help at all :)", "author": "normanmaurer", "createdAt": "2020-09-07T09:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1OTMxOQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484359319", "bodyText": "it might cause an issue if we set IOSQE_IO_DRAIN, when some fd submit another fd polling event before, sqe wouldn't be executed as it waits until the socket is readable", "author": "1Jo1", "createdAt": "2020-09-07T11:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI5ODI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "chunk": "diff --git a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\nindex 2215c930bc..aa818046e8 100644\n--- a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n+++ b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n\n@@ -323,24 +294,15 @@ abstract class AbstractIOUringChannel extends AbstractChannel implements UnixCha\n     }\n \n      private void doWriteMultiple(ChannelOutboundBuffer in) {\n-\n-         final IovecArrayPool iovecArray = ((IOUringEventLoop) eventLoop()).getIovecArrayPool();\n-\n-         iovecMemoryAddress = iovecArray.createNewIovecMemoryAddress();\n-         if (iovecMemoryAddress != -1) {\n-             try {\n-                 in.forEachFlushedMessage(iovecArray);\n-             } catch (Exception e) {\n-                 // This should never happem, anyway fallback to single write.\n-                 doWriteSingle((ByteBuf) in.current());\n-             }\n-\n-             if (iovecArray.count() > 0) {\n-                 submissionQueue().addWritev(socket.intValue(), iovecMemoryAddress, iovecArray.count());\n-                 ioState |= WRITE_SCHEDULED;\n-             }\n-         } else {\n-             // We were not be able to create a new iovec, fallback to single write.\n+         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n+         try {\n+             int offset = iovecArray.count();\n+             in.forEachFlushedMessage(iovecArray);\n+             submissionQueue().addWritev(socket.intValue(),\n+                     iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n+             ioState |= WRITE_SCHEDULED;\n+         } catch (Exception e) {\n+             // This should never happen, anyway fallback to single write.\n              doWriteSingle((ByteBuf) in.current());\n          }\n      }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNTE2NA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484325164", "bodyText": "This is not needed anymore as even with SO_LINGER we are fine as the close will not block this method ;)", "author": "normanmaurer", "createdAt": "2020-09-07T09:54:20Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -247,29 +243,16 @@ protected void doClose() throws Exception {\n \n             cancelConnectTimeoutFuture();\n \n-            if (isRegistered()) {\n-                // Need to check if we are on the EventLoop as doClose() may be triggered by the GlobalEventExecutor\n-                // if SO_LINGER is used.\n-                //\n-                // See https://github.com/netty/netty/issues/7159", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNTU0OA==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484325548", "bodyText": "I need this one for now... We will refactor this later on.", "author": "normanmaurer", "createdAt": "2020-09-07T09:55:02Z", "path": "transport-native-unix-common/src/main/java/io/netty/channel/unix/FileDescriptor.java", "diffHunk": "@@ -62,23 +62,28 @@ public final int intValue() {\n         return fd;\n     }\n \n-    /**\n-     * Close the file descriptor.\n-     */\n-    public void close() throws IOException {\n+    protected boolean markClosed() {", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMzk1MQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484523951", "bodyText": "nit: combine these?", "author": "njhill", "createdAt": "2020-09-07T17:01:57Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -288,6 +271,16 @@ protected void doWrite(ChannelOutboundBuffer in) {\n         if ((ioState & WRITE_SCHEDULED) != 0) {\n             return;\n         }\n+        scheduleWrite(in);\n+    }\n+\n+    private void scheduleWrite(ChannelOutboundBuffer in) {\n+        if (delayedClose != null) {\n+            return;\n+        }\n+        if (in == null) {\n+            return;\n+        }", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NjUyMQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484546521", "bodyText": "nit: write -> io", "author": "njhill", "createdAt": "2020-09-07T19:00:31Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +320,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);\n+            } else {\n+                if (delayedClose == null || delayedClose.isVoid()) {\n+                    // We have a write operation pending that should be completed asap.\n+                    // We will do the actual close operation one this write result is returned as otherwise\n+                    // we may get into trouble as we may close the fd while we did not process the write yet.", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NzU5Ng==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484547596", "bodyText": "nit: else if?", "author": "njhill", "createdAt": "2020-09-07T19:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NjUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "chunk": "diff --git a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\nindex 0d14ecfba8..aa818046e8 100644\n--- a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n+++ b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n\n@@ -297,24 +294,15 @@ abstract class AbstractIOUringChannel extends AbstractChannel implements UnixCha\n     }\n \n      private void doWriteMultiple(ChannelOutboundBuffer in) {\n-\n-         final IovecArrayPool iovecArray = ((IOUringEventLoop) eventLoop()).getIovecArrayPool();\n-\n-         iovecMemoryAddress = iovecArray.createNewIovecMemoryAddress();\n-         if (iovecMemoryAddress != -1) {\n-             try {\n-                 in.forEachFlushedMessage(iovecArray);\n-             } catch (Exception e) {\n-                 // This should never happem, anyway fallback to single write.\n-                 doWriteSingle((ByteBuf) in.current());\n-             }\n-\n-             if (iovecArray.count() > 0) {\n-                 submissionQueue().addWritev(socket.intValue(), iovecMemoryAddress, iovecArray.count());\n-                 ioState |= WRITE_SCHEDULED;\n-             }\n-         } else {\n-             // We were not be able to create a new iovec, fallback to single write.\n+         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n+         try {\n+             int offset = iovecArray.count();\n+             in.forEachFlushedMessage(iovecArray);\n+             submissionQueue().addWritev(socket.intValue(),\n+                     iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n+             ioState |= WRITE_SCHEDULED;\n+         } catch (Exception e) {\n+             // This should never happen, anyway fallback to single write.\n              doWriteSingle((ByteBuf) in.current());\n          }\n      }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NzcwMg==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484547702", "bodyText": "nit: could simplify to:\n} else if (!promise.isVoid()) {\n    delayedClose.addListener(new ChannelPromiseNotifier(promise));\n}", "author": "njhill", "createdAt": "2020-09-07T19:07:34Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -327,23 +320,54 @@ private void doWriteMultiple(ChannelOutboundBuffer in) {\n      }\n \n     protected final void doWriteSingle(ByteBuf buf) {\n+        assert (ioState & WRITE_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n                 buf.writerIndex());\n         ioState |= WRITE_SCHEDULED;\n     }\n \n     //POLLOUT\n-    private void addPollOut() {\n+    private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n-        ioState |= POLL_OUT_SCHEDULED;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n+        ioState |= POLL_OUT_SCHEDULED;\n+    }\n+\n+    void schedulePollRdHup() {\n+        assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n+        IOUringSubmissionQueue submissionQueue = submissionQueue();\n+        submissionQueue.addPollRdHup(fd().intValue());\n+        ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n     abstract class AbstractUringUnsafe extends AbstractUnsafe {\n         private IOUringRecvByteAllocatorHandle allocHandle;\n \n+        @Override\n+        public void close(ChannelPromise promise) {\n+            if ((ioState & (WRITE_SCHEDULED | READ_SCHEDULED | CONNECT_SCHEDULED)) == 0) {\n+                forceClose(promise);\n+            } else {\n+                if (delayedClose == null || delayedClose.isVoid()) {\n+                    // We have a write operation pending that should be completed asap.\n+                    // We will do the actual close operation one this write result is returned as otherwise\n+                    // we may get into trouble as we may close the fd while we did not process the write yet.\n+                    delayedClose = promise;\n+                } else {\n+                    if (promise.isVoid()) {\n+                        return;\n+                    }\n+                    delayedClose.addListener(new ChannelPromiseNotifier(promise));\n+                }", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "chunk": "diff --git a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\nindex 0d14ecfba8..aa818046e8 100644\n--- a/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n+++ b/transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java\n\n@@ -297,24 +294,15 @@ abstract class AbstractIOUringChannel extends AbstractChannel implements UnixCha\n     }\n \n      private void doWriteMultiple(ChannelOutboundBuffer in) {\n-\n-         final IovecArrayPool iovecArray = ((IOUringEventLoop) eventLoop()).getIovecArrayPool();\n-\n-         iovecMemoryAddress = iovecArray.createNewIovecMemoryAddress();\n-         if (iovecMemoryAddress != -1) {\n-             try {\n-                 in.forEachFlushedMessage(iovecArray);\n-             } catch (Exception e) {\n-                 // This should never happem, anyway fallback to single write.\n-                 doWriteSingle((ByteBuf) in.current());\n-             }\n-\n-             if (iovecArray.count() > 0) {\n-                 submissionQueue().addWritev(socket.intValue(), iovecMemoryAddress, iovecArray.count());\n-                 ioState |= WRITE_SCHEDULED;\n-             }\n-         } else {\n-             // We were not be able to create a new iovec, fallback to single write.\n+         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n+         try {\n+             int offset = iovecArray.count();\n+             in.forEachFlushedMessage(iovecArray);\n+             submissionQueue().addWritev(socket.intValue(),\n+                     iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n+             ioState |= WRITE_SCHEDULED;\n+         } catch (Exception e) {\n+             // This should never happen, anyway fallback to single write.\n              doWriteSingle((ByteBuf) in.current());\n          }\n      }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0ODUwMg==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484548502", "bodyText": "clear RDHUP_SCHEDULED here?", "author": "njhill", "createdAt": "2020-09-07T19:12:18Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -464,6 +495,9 @@ final void readComplete(int res) {\n          * Called once POLLRDHUP event is ready to be processed\n          */\n         final void pollRdHup(int res) {", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0OTQxMQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484549411", "bodyText": "Could do as a follow-on but this would probably be cleaner to cover non-channel-specific cases first, then lookup the channel once and pass it to appropriate handler if non-null (rather than looking up separately in each of the handlers)", "author": "njhill", "createdAt": "2020-09-07T19:17:53Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -168,53 +168,69 @@ protected void run() {\n     @Override\n     public boolean handle(int fd, int res, long flags, int op, int pollMask) {\n         IOUringSubmissionQueue submissionQueue = ringBuffer.getIoUringSubmissionQueue();\n+        final AbstractIOUringChannel channel;", "originalCommit": "657864aaae906e1195d7ec3546d2db0984be8dac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDM4OQ==", "url": "https://github.com/netty/netty/pull/10538#discussion_r484684389", "bodyText": "let me do a followup", "author": "normanmaurer", "createdAt": "2020-09-08T06:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0OTQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "354d0cbbcd95142604172f59d5f6e0a17d2af392", "chunk": "diff --git a/transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java b/transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java\nindex bd4ebe92d2..2238be4d74 100644\n--- a/transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java\n+++ b/transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java\n\n@@ -203,8 +203,6 @@ final class IOUringEventLoop extends SingleThreadEventLoop implements\n                 prevDeadlineNanos = NONE;\n             }\n             channel = null;\n-        } else if (op == Native.IORING_OP_CLOSE) {\n-            return true;\n         } else {\n             return true;\n         }\n"}}, {"oid": "354d0cbbcd95142604172f59d5f6e0a17d2af392", "url": "https://github.com/netty/netty/commit/354d0cbbcd95142604172f59d5f6e0a17d2af392", "message": "Fixes", "committedDate": "2020-09-08T19:46:15Z", "type": "forcePushed"}, {"oid": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "url": "https://github.com/netty/netty/commit/1cc47c439952596fb5b55db4d4a85c5672f4d99d", "message": "Only execute the close once the already added write operations completes\n\nMotivation:\n\nWe need to be careful that we only execute the close(...) once the write\noperation completes as otherwise we may close the underlying socket too\nfast and also the writes\n\nModifications:\n\nKeep track of if we need to delay the close or not and if so execute it\nonce the write completes\n\nResult:\n\nNo more test failures", "committedDate": "2020-09-09T07:59:27Z", "type": "commit"}, {"oid": "1cc47c439952596fb5b55db4d4a85c5672f4d99d", "url": "https://github.com/netty/netty/commit/1cc47c439952596fb5b55db4d4a85c5672f4d99d", "message": "Only execute the close once the already added write operations completes\n\nMotivation:\n\nWe need to be careful that we only execute the close(...) once the write\noperation completes as otherwise we may close the underlying socket too\nfast and also the writes\n\nModifications:\n\nKeep track of if we need to delay the close or not and if so execute it\nonce the write completes\n\nResult:\n\nNo more test failures", "committedDate": "2020-09-09T07:59:27Z", "type": "forcePushed"}]}