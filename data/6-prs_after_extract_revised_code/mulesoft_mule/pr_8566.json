{"pr_number": 8566, "pr_title": "MULE-17939: Operation considers applied policies regarding thread switches", "pr_createdAt": "2020-01-13T12:54:28Z", "pr_url": "https://github.com/mulesoft/mule/pull/8566", "timeline": [{"oid": "d98364539be12c7ab87aed8c8fbd6350049d5199", "url": "https://github.com/mulesoft/mule/commit/d98364539be12c7ab87aed8c8fbd6350049d5199", "message": "adfgsdf", "committedDate": "2020-01-12T21:44:06Z", "type": "commit"}, {"oid": "10c2666d621f1b8750c3cb39f0e51e4a7eb27e21", "url": "https://github.com/mulesoft/mule/commit/10c2666d621f1b8750c3cb39f0e51e4a7eb27e21", "message": "str", "committedDate": "2020-01-12T21:44:07Z", "type": "commit"}, {"oid": "64e8ad8de55b11a361fe9ff28f671762db5829e5", "url": "https://github.com/mulesoft/mule/commit/64e8ad8de55b11a361fe9ff28f671762db5829e5", "message": "async", "committedDate": "2020-01-12T21:44:08Z", "type": "commit"}, {"oid": "1e10ce209b55c3c8b97088d825764cfa437c0fa5", "url": "https://github.com/mulesoft/mule/commit/1e10ce209b55c3c8b97088d825764cfa437c0fa5", "message": "lalala", "committedDate": "2020-01-12T21:44:09Z", "type": "commit"}, {"oid": "7219ce43162ccba181275f3d441ce434ce43e633", "url": "https://github.com/mulesoft/mule/commit/7219ce43162ccba181275f3d441ce434ce43e633", "message": "lalal", "committedDate": "2020-01-12T21:44:10Z", "type": "commit"}, {"oid": "a4c7ddea74de91080625d3f657426ed55e011fe9", "url": "https://github.com/mulesoft/mule/commit/a4c7ddea74de91080625d3f657426ed55e011fe9", "message": "sdg", "committedDate": "2020-01-12T21:44:11Z", "type": "commit"}, {"oid": "6c272381a4d23c4ffcf3968ffd2d3ed65209d99e", "url": "https://github.com/mulesoft/mule/commit/6c272381a4d23c4ffcf3968ffd2d3ed65209d99e", "message": "sadf", "committedDate": "2020-01-12T21:44:13Z", "type": "commit"}, {"oid": "e5a79f3206c481ffa6e9dbf98a80b6d80190c0b5", "url": "https://github.com/mulesoft/mule/commit/e5a79f3206c481ffa6e9dbf98a80b6d80190c0b5", "message": "Revert \"sadf\"\n\nThis reverts commit 02bf7ccbb00e4ec569a0c99fd724859b1e993e4f.", "committedDate": "2020-01-12T21:44:14Z", "type": "commit"}, {"oid": "d67e4ada81fee09709981abba5be8d8227d9d9ff", "url": "https://github.com/mulesoft/mule/commit/d67e4ada81fee09709981abba5be8d8227d9d9ff", "message": "Revert \"sdg\"\n\nThis reverts commit 86cefe375d16188696631f7aed24bc9954f9bf70.", "committedDate": "2020-01-12T21:44:15Z", "type": "commit"}, {"oid": "1216db73e3f73ed019c7b2b9330079bf291a5399", "url": "https://github.com/mulesoft/mule/commit/1216db73e3f73ed019c7b2b9330079bf291a5399", "message": "asd", "committedDate": "2020-01-12T21:44:16Z", "type": "commit"}, {"oid": "217339a6d47d3a22fea84e06fc1f758181840824", "url": "https://github.com/mulesoft/mule/commit/217339a6d47d3a22fea84e06fc1f758181840824", "message": "fix", "committedDate": "2020-01-12T21:44:17Z", "type": "commit"}, {"oid": "4ea5edfa45979854570a30e401934220c11e50e6", "url": "https://github.com/mulesoft/mule/commit/4ea5edfa45979854570a30e401934220c11e50e6", "message": "sfh", "committedDate": "2020-01-12T21:44:18Z", "type": "commit"}, {"oid": "ded3156a94fe9cd8cbd7d071476114896b0eed8a", "url": "https://github.com/mulesoft/mule/commit/ded3156a94fe9cd8cbd7d071476114896b0eed8a", "message": "more more", "committedDate": "2020-01-12T21:44:20Z", "type": "commit"}, {"oid": "cea50a42abfd314f9bd385c97234f519636847a5", "url": "https://github.com/mulesoft/mule/commit/cea50a42abfd314f9bd385c97234f519636847a5", "message": "agaga", "committedDate": "2020-01-12T21:44:21Z", "type": "commit"}, {"oid": "033b531eb865096d37cadaa9c633fa82ed27b3eb", "url": "https://github.com/mulesoft/mule/commit/033b531eb865096d37cadaa9c633fa82ed27b3eb", "message": "fix for mono users", "committedDate": "2020-01-12T21:44:22Z", "type": "commit"}, {"oid": "9def563524bd6f916c70ac94fe20b0c1b0392778", "url": "https://github.com/mulesoft/mule/commit/9def563524bd6f916c70ac94fe20b0c1b0392778", "message": "fix unit tests", "committedDate": "2020-01-12T21:44:23Z", "type": "commit"}, {"oid": "f2f642894bf571c530ca620586a48e3ceca9e36c", "url": "https://github.com/mulesoft/mule/commit/f2f642894bf571c530ca620586a48e3ceca9e36c", "message": "more fixes", "committedDate": "2020-01-12T21:44:25Z", "type": "commit"}, {"oid": "5338a9bdd2ae83939b6a9480e6108271517e0a27", "url": "https://github.com/mulesoft/mule/commit/5338a9bdd2ae83939b6a9480e6108271517e0a27", "message": "Revert \"more more\"\n\nThis reverts commit 86ecaf6dd81448a8038e0f45bfacff2538998e90.", "committedDate": "2020-01-12T21:44:26Z", "type": "commit"}, {"oid": "f3507a18e28b8dea4a344a35c718036fcbc0d669", "url": "https://github.com/mulesoft/mule/commit/f3507a18e28b8dea4a344a35c718036fcbc0d669", "message": "fix policies again", "committedDate": "2020-01-12T21:44:27Z", "type": "commit"}, {"oid": "86a8d70641d0b26269c2f36fcf3230086cda0741", "url": "https://github.com/mulesoft/mule/commit/86a8d70641d0b26269c2f36fcf3230086cda0741", "message": "possible optimizations to test", "committedDate": "2020-01-12T21:44:29Z", "type": "commit"}, {"oid": "cb3ab5ca1f2695bf5845dc9abf3f3b745dd45c04", "url": "https://github.com/mulesoft/mule/commit/cb3ab5ca1f2695bf5845dc9abf3f3b745dd45c04", "message": "bring tback the synchronous optimization to test it", "committedDate": "2020-01-12T21:44:30Z", "type": "commit"}, {"oid": "d1bdbe852bf44c0292e5b467f6db1adb8d738757", "url": "https://github.com/mulesoft/mule/commit/d1bdbe852bf44c0292e5b467f6db1adb8d738757", "message": "fixes for the perf workaround", "committedDate": "2020-01-12T21:44:31Z", "type": "commit"}, {"oid": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "url": "https://github.com/mulesoft/mule/commit/8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "message": "finally!", "committedDate": "2020-01-13T12:54:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMjA0NA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365832044", "bodyText": "jdoc", "author": "marianogonzalez", "createdAt": "2020-01-13T14:27:30Z", "path": "core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java", "diffHunk": "@@ -48,6 +48,10 @@ default void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresen\n     Flux.from(flux).subscribe();\n   }\n \n+  default Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java b/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\nindex 65c4d5b08c8..724cace62bd 100644\n--- a/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\n+++ b/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\n\n@@ -48,7 +48,14 @@ public interface ProcessingStrategy {\n     Flux.from(flux).subscribe();\n   }\n \n-  default Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {\n+  /**\n+   * For fluxes created outside of the main flux for a flow, have them accounted for in the processing strategy for a graceful\n+   * shutdown.\n+   *\n+   * @param flux the flux whose lifecycle will be tied to the main flux.\n+   * @return the provided flux with the additional callbacks observed.\n+   */\n+  default Publisher<CoreEvent> configureInternalFlux(Publisher<CoreEvent> flux) {\n     return flux;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMjMxNA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365832314", "bodyText": "I would expose this through a getter", "author": "marianogonzalez", "createdAt": "2020-01-13T14:27:56Z", "path": "core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java", "diffHunk": "@@ -61,7 +61,7 @@\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(DefaultPolicyManager.class);\n \n-  private static final OperationPolicy NO_POLICY_OPERATION =\n+  public static final OperationPolicy NO_POLICY_OPERATION =", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java b/core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java\nindex d3260af0e13..554cec2b9a4 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/policy/DefaultPolicyManager.java\n\n@@ -61,10 +61,25 @@ public class DefaultPolicyManager implements PolicyManager, Initialisable, Dispo\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(DefaultPolicyManager.class);\n \n-  public static final OperationPolicy NO_POLICY_OPERATION =\n+  private static final OperationPolicy NO_POLICY_OPERATION =\n       (operationEvent, operationExecutionFunction, opParamProcessor, componentLocation, callback) -> operationExecutionFunction\n           .execute(opParamProcessor.getOperationParameters(), operationEvent, callback);\n \n+  /**\n+   * @return A no-op policy that will directly execute the operation function.\n+   */\n+  public static OperationPolicy noPolicyOperation() {\n+    return NO_POLICY_OPERATION;\n+  }\n+\n+  /**\n+   * @param policy the {@link OperationPolicy} to evaluate\n+   * @return {@code true} if the provided policy is a no-op, {@code false} if a policy is actually applied.\n+   */\n+  public static boolean isNoPolicyOperation(OperationPolicy policy) {\n+    return NO_POLICY_OPERATION.equals(policy);\n+  }\n+\n   @Inject\n   private ErrorTypeLocator errorTypeLocator;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMzAxNA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365833014", "bodyText": "this should be wrapped in FunctionalUtils.safely() so that if this fails, the rest is disposed correctly", "author": "marianogonzalez", "createdAt": "2020-01-13T14:29:05Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -192,15 +198,14 @@ public void start() throws MuleException {\n   public void stop() throws MuleException {\n     super.stop();\n     stopIfNeeded(delegate);\n-\n+    stopIfNeeded(backpressureHandler);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4c30643c83c801810e16370076b83edeba7ecb", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\nindex 5902deb9f77..85e2e34a427 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n\n@@ -198,7 +200,8 @@ public class AsyncDelegateMessageProcessor extends AbstractMessageProcessorOwner\n   public void stop() throws MuleException {\n     super.stop();\n     stopIfNeeded(delegate);\n-    stopIfNeeded(backpressureHandler);\n+\n+    safely(() -> stopIfNeeded(backpressureHandler));\n     disposeIfNeeded(sink, logger);\n     sink = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNDgzMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365834833", "bodyText": "isn't this too much frequency?\nAlso:\na) isn't a busy wait preferable in cases of high throughput\nb) isn't a wait()/notify() approach preferable in most cases?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:32:35Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -293,4 +309,57 @@ public void setMaxConcurrency(Integer maxConcurrency) {\n     // Lifecycle of inner objects is already handled by this class' lifecycle methods\n     return emptyList();\n   }\n+\n+  private static class QueueBackpressureHandler implements Startable, Stoppable {\n+\n+    private final BlockingQueue<CoreEvent> asyncQueue;\n+    private final SchedulerService schedulerService;\n+    private final Supplier<SchedulerConfig> schedulerConfigSupplier;\n+    private final String location;\n+    private final Consumer<CoreEvent> eventDispatcher;\n+\n+    private Scheduler queueDispatcherScheduler;\n+\n+    public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n+                                    Consumer<CoreEvent> eventDispatcher, String location) {\n+      this.schedulerService = schedulerService;\n+      this.schedulerConfigSupplier = schedulerConfigSupplier;\n+\n+      this.asyncQueue = new LinkedBlockingQueue<>();\n+      this.eventDispatcher = eventDispatcher;\n+\n+      this.location = location;\n+    }\n+\n+    public void handleBackpressure(CoreEvent event) {\n+      asyncQueue.offer(event);\n+    }\n+\n+    @Override\n+    public void start() {\n+      final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\");\n+      queueDispatcherScheduler = schedulerService.ioScheduler(schedulerConfig);\n+\n+      queueDispatcherScheduler.scheduleWithFixedDelay(() -> {\n+        try {\n+          final CoreEvent event = asyncQueue.peek();\n+          if (event != null) {\n+            eventDispatcher.accept(event);\n+            asyncQueue.remove(event);\n+          }\n+        } catch (FromFlowRejectedExecutionException free) {\n+          // nothing to do, a retry will come next\n+        }\n+      }, 0, 2, MILLISECONDS);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f4c30643c83c801810e16370076b83edeba7ecb", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\nindex 5902deb9f77..85e2e34a427 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n\n@@ -319,6 +324,7 @@ public class AsyncDelegateMessageProcessor extends AbstractMessageProcessorOwner\n     private final Consumer<CoreEvent> eventDispatcher;\n \n     private Scheduler queueDispatcherScheduler;\n+    private volatile ScheduledFuture<?> scheduledDrain;\n \n     public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n                                     Consumer<CoreEvent> eventDispatcher, String location) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTE4MA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365835180", "bodyText": "weren't you going to actually increase the size of this buffer to reduce the error rate?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:33:12Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java", "diffHunk": "@@ -144,7 +144,7 @@ public final BackPressureReason emit(CoreEvent event) {\n       long remainingCapacity = fluxSink.requestedFromDownstream();\n       if (remainingCapacity == 0) {\n         return EVENTS_ACCUMULATED;\n-      } else if (remainingCapacity > (bufferSize > CORES * 4 ? CORES : 0)) {\n+      } else if (remainingCapacity > (bufferSize > CORES * 2 ? CORES : 0)) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0ODg4OQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365848889", "bodyText": "no need to do that, this remained of a test i made, will revert it", "author": "elrodro83", "createdAt": "2020-01-13T14:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java\nindex 6629d7740e1..bcfdc4c50fb 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/AbstractProcessingStrategy.java\n\n@@ -144,7 +144,7 @@ public abstract class AbstractProcessingStrategy implements ProcessingStrategyAd\n       long remainingCapacity = fluxSink.requestedFromDownstream();\n       if (remainingCapacity == 0) {\n         return EVENTS_ACCUMULATED;\n-      } else if (remainingCapacity > (bufferSize > CORES * 2 ? CORES : 0)) {\n+      } else if (remainingCapacity > (bufferSize > CORES * 4 ? CORES : 0)) {\n         // If there is sufficient room in buffer to significantly reduce change of concurrent emission when buffer is full then\n         // emit without synchronized block.\n         fluxSink.next(intoSink(event));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNTY2Mg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365835662", "bodyText": "remove", "author": "marianogonzalez", "createdAt": "2020-01-13T14:34:06Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -161,6 +150,7 @@ public ReactiveProcessor onProcessor(ReactiveProcessor processor) {\n       }\n     }\n \n+", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\nindex 93e2a58b834..44a3d893a4e 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\n\n@@ -150,7 +150,6 @@ public class ProactorStreamEmitterProcessingStrategyFactory extends AbstractStre\n       }\n     }\n \n-\n     protected ReactiveProcessor proactor(ReactiveProcessor processor, ScheduledExecutorService scheduler) {\n       LOGGER.debug(\"Doing proactor() for {} on {}. maxConcurrency={}, parallelism={}, subscribers={}\", processor, scheduler,\n                    maxConcurrency, getParallelism(), subscribers);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365836539", "bodyText": "this is shady.. this is assuming SDK behavior by testing an interface that any component can implement, not just the SDK. Is this wrong or the comment below should be updated?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:35:44Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -174,10 +164,7 @@ protected ReactiveProcessor proactor(ReactiveProcessor processor, ScheduledExecu\n         return publisher -> scheduleProcessor(processor, retryScheduler, from(publisher))\n             .subscriberContext(ctx -> ctx.put(PROCESSOR_SCHEDULER_CONTEXT_KEY, scheduler));\n       } else if (maxConcurrency == MAX_VALUE) {\n-        if (processor.getProcessingType() == CPU_INTENSIVE\n-            && (processor instanceof InterceptedReactiveProcessor)\n-            && SDK_OPERATION_CLASS != null\n-            && SDK_OPERATION_CLASS.isAssignableFrom(((InterceptedReactiveProcessor) processor).getProcessor().getClass())) {\n+        if (processor instanceof OperationInnerProcessor) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkxMjQ5Mw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365912493", "bodyText": "OperationInnerProcessor is not API", "author": "elrodro83", "createdAt": "2020-01-13T16:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMDM4MA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366010380", "bodyText": "but still, some other dev which doesn't have the full context could implement that interface and a problem could appear here", "author": "marianogonzalez", "createdAt": "2020-01-13T20:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxNzA1Ng==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366017056", "bodyText": "will add a note on the jdoc for OperationInnerProcessor", "author": "elrodro83", "createdAt": "2020-01-13T20:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNjUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\nindex 93e2a58b834..44a3d893a4e 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/ProactorStreamEmitterProcessingStrategyFactory.java\n\n@@ -165,7 +164,7 @@ public class ProactorStreamEmitterProcessingStrategyFactory extends AbstractStre\n             .subscriberContext(ctx -> ctx.put(PROCESSOR_SCHEDULER_CONTEXT_KEY, scheduler));\n       } else if (maxConcurrency == MAX_VALUE) {\n         if (processor instanceof OperationInnerProcessor) {\n-          // For no limit, the java SDK already does a flatMap internally, so no need to do an additional one here\n+          // For no limit, the java SDK already handles parallelism internally, so no need to do that here\n           return publisher -> scheduleProcessor(processor, retryScheduler, from(publisher))\n               .subscriberContext(ctx -> ctx.put(PROCESSOR_SCHEDULER_CONTEXT_KEY, scheduler));\n         } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzNzYxMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365837613", "bodyText": "This method name is not really appropriate.. It seems to be more something like configureFlux or something like this.... Actually, if this were about configuring something internal, then it shouldn't return anything", "author": "marianogonzalez", "createdAt": "2020-01-13T14:37:39Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java", "diffHunk": "@@ -206,6 +207,13 @@ public void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresent\n       activeSinksCount.incrementAndGet();\n     }\n \n+    @Override\n+    public Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java\nindex 129f015179c..2226e3ef4be 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/strategy/StreamEmitterProcessingStrategyFactory.java\n\n@@ -208,7 +208,7 @@ public class StreamEmitterProcessingStrategyFactory extends AbstractStreamProces\n     }\n \n     @Override\n-    public Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {\n+    public Publisher<CoreEvent> configureInternalFlux(Publisher<CoreEvent> flux) {\n       return Flux.from(flux)\n           .doAfterTerminate(() -> stopSchedulersIfNeeded())\n           .doOnSubscribe(s -> activeSinksCount.incrementAndGet());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzODYwMQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365838601", "bodyText": "jdoc", "author": "marianogonzalez", "createdAt": "2020-01-13T14:39:30Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.runtime.execution;\n+\n+import static java.util.function.Function.identity;\n+\n+import org.mule.runtime.core.api.event.CoreEvent;\n+import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.policy.OperationPolicy;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import reactor.util.context.Context;\n+\n+public class SdkInternalContext implements EventInternalContext<SdkInternalContext> {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\nindex ff5da04f064..255051c60fa 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\n\n@@ -10,6 +10,8 @@ import static java.util.function.Function.identity;\n \n import org.mule.runtime.core.api.event.CoreEvent;\n import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.message.InternalEvent;\n+import org.mule.runtime.core.internal.policy.DefaultPolicyManager;\n import org.mule.runtime.core.internal.policy.OperationPolicy;\n import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQzOA==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839438", "bodyText": "don't you need to copy the execution params? Is it ok to make a copy in which the callbacks are all the same?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:04Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com\n+ * The software in this package is published under the terms of the CPAL v1.0\n+ * license, a copy of which has been included with this distribution in the\n+ * LICENSE.txt file.\n+ */\n+package org.mule.runtime.module.extension.internal.runtime.execution;\n+\n+import static java.util.function.Function.identity;\n+\n+import org.mule.runtime.core.api.event.CoreEvent;\n+import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.policy.OperationPolicy;\n+import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n+import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import reactor.util.context.Context;\n+\n+public class SdkInternalContext implements EventInternalContext<SdkInternalContext> {\n+\n+  private OperationExecutionParams operationExecutionParams;\n+\n+  private Function<Context, Context> innerChainSubscriberContextMapping = identity();\n+\n+  private Optional<ConfigurationInstance> configuration;\n+\n+  private Map<String, Object> resolutionResult;\n+\n+  private OperationPolicy policyToApply;\n+\n+  public OperationExecutionParams getOperationExecutionParams() {\n+    return operationExecutionParams;\n+  }\n+\n+  public void setOperationExecutionParams(Optional<ConfigurationInstance> configuration, Map<String, Object> parameters,\n+                                          CoreEvent operationEvent, ExecutorCallback callback) {\n+    this.operationExecutionParams = new OperationExecutionParams(configuration, parameters, operationEvent, callback);\n+  }\n+\n+  public Function<Context, Context> getInnerChainSubscriberContextMapping() {\n+    return innerChainSubscriberContextMapping;\n+  }\n+\n+  public void setInnerChainSubscriberContextMapping(Function<Context, Context> innerChainSubscriberContextMapping) {\n+    this.innerChainSubscriberContextMapping = innerChainSubscriberContextMapping;\n+  }\n+\n+  public Optional<ConfigurationInstance> getConfiguration() {\n+    return configuration;\n+  }\n+\n+  public void setConfiguration(Optional<ConfigurationInstance> configuration) {\n+    this.configuration = configuration;\n+  }\n+\n+  public Map<String, Object> getResolutionResult() {\n+    return resolutionResult;\n+  }\n+\n+  public void setResolutionResult(Map<String, Object> resolutionResult) {\n+    this.resolutionResult = resolutionResult;\n+  }\n+\n+  public OperationPolicy getPolicyToApply() {\n+    return policyToApply;\n+  }\n+\n+  public void setPolicyToApply(OperationPolicy policyToApply) {\n+    this.policyToApply = policyToApply;\n+  }\n+\n+  @Override\n+  public SdkInternalContext copy() {\n+    return this;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkxNTI4NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365915285", "bodyText": "this is the most consistent with the current behavior, where all internal parameters are just copied over.", "author": "elrodro83", "createdAt": "2020-01-13T16:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTQzOA=="}], "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\nindex ff5da04f064..255051c60fa 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/execution/SdkInternalContext.java\n\n@@ -10,6 +10,8 @@ import static java.util.function.Function.identity;\n \n import org.mule.runtime.core.api.event.CoreEvent;\n import org.mule.runtime.core.internal.message.EventInternalContext;\n+import org.mule.runtime.core.internal.message.InternalEvent;\n+import org.mule.runtime.core.internal.policy.DefaultPolicyManager;\n import org.mule.runtime.core.internal.policy.OperationPolicy;\n import org.mule.runtime.extension.api.runtime.config.ConfigurationInstance;\n import org.mule.runtime.extension.api.runtime.operation.CompletableComponentExecutor.ExecutorCallback;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTgwMw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839803", "bodyText": "group all final fields together", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:46Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -179,6 +197,15 @@\n   private String resolvedProcessorRepresentation;\n   private boolean initialised = false;\n \n+  private ProcessingStrategy processingStrategy;\n+  private boolean ownedProcessingStrategy = false;\n+  private FluxSinkSupplier<CoreEvent> fluxSupplier;\n+  private final Object fluxSupplierDisposeLock = new Object();", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -200,12 +205,9 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n   private ProcessingStrategy processingStrategy;\n   private boolean ownedProcessingStrategy = false;\n   private FluxSinkSupplier<CoreEvent> fluxSupplier;\n-  private final Object fluxSupplierDisposeLock = new Object();\n \n   private Scheduler outerFluxCompletionScheduler;\n \n-  private final AtomicInteger activeOuterPublishersCount = new AtomicInteger(0);\n-\n   protected ExecutionMediator executionMediator;\n   protected CompletableComponentExecutor componentExecutor;\n   protected ReturnDelegate returnDelegate;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzOTg1NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365839855", "bodyText": "group all final fields together", "author": "marianogonzalez", "createdAt": "2020-01-13T14:41:51Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -179,6 +197,15 @@\n   private String resolvedProcessorRepresentation;\n   private boolean initialised = false;\n \n+  private ProcessingStrategy processingStrategy;\n+  private boolean ownedProcessingStrategy = false;\n+  private FluxSinkSupplier<CoreEvent> fluxSupplier;\n+  private final Object fluxSupplierDisposeLock = new Object();\n+\n+  private Scheduler outerFluxCompletionScheduler;\n+\n+  private final AtomicInteger activeOuterPublishersCount = new AtomicInteger(0);", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -200,12 +205,9 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n   private ProcessingStrategy processingStrategy;\n   private boolean ownedProcessingStrategy = false;\n   private FluxSinkSupplier<CoreEvent> fluxSupplier;\n-  private final Object fluxSupplierDisposeLock = new Object();\n \n   private Scheduler outerFluxCompletionScheduler;\n \n-  private final AtomicInteger activeOuterPublishersCount = new AtomicInteger(0);\n-\n   protected ExecutionMediator executionMediator;\n   protected CompletableComponentExecutor componentExecutor;\n   protected ReturnDelegate returnDelegate;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MDA3Nw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365840077", "bodyText": "hasNestedChain", "author": "marianogonzalez", "createdAt": "2020-01-13T14:42:15Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -161,6 +178,7 @@\n   private final RetryPolicyTemplate fallbackRetryPolicyTemplate = new NoRetryPolicyTemplate();\n \n   protected final ExtensionModel extensionModel;\n+  private final boolean hasChainNested;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -178,12 +179,16 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n   private final RetryPolicyTemplate fallbackRetryPolicyTemplate = new NoRetryPolicyTemplate();\n \n   protected final ExtensionModel extensionModel;\n-  private final boolean hasChainNested;\n+  private final boolean hasNestedChain;\n   protected final ResolverSet resolverSet;\n   protected final String target;\n   protected final String targetValue;\n   protected final RetryPolicyTemplate retryPolicyTemplate;\n \n+  private final Object fluxSupplierDisposeLock = new Object();\n+\n+  private final AtomicInteger activeOuterPublishersCount = new AtomicInteger(0);\n+\n   @Inject\n   private ErrorTypeLocator errorTypeLocator;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTA0Mg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365841042", "bodyText": "add comments clarifying or extract to method with meaningful name, or both, or make a netflix documentary explaining this", "author": "marianogonzalez", "createdAt": "2020-01-13T14:44:01Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -287,16 +289,16 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n                       }\n                     };\n \n-                    if (!isAsync() && NO_POLICY_OPERATION\n-                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())\n-                            .getPolicyToApply())) {\n+                    if (!isAsync() && from(event).isNoPolicyOperation()) {\n                       onEventSynchronous(event, executorCallback, ctx);\n                     } else {\n                       onEvent(event, executorCallback);\n                     }\n                   }), () -> errorSwitchSinkSinkRef.complete(), t -> errorSwitchSinkSinkRef.error(t),\n                                                                  muleContext.getConfiguration().getShutdownTimeout(),\n-                                                                 outerFluxCompletionScheduler));\n+                                                                 outerFluxCompletionScheduler))\n+                                                                     .doOnNext(event -> ((InternalEvent) event)\n+                                                                         .setSdkInternalContext(null));\n \n           if (publisher instanceof Flux && !ctx.getOrEmpty(WITHIN_PROCESS_TO_APPLY).isPresent()) {\n             return transformed\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MTQ4Ng==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365841486", "bodyText": "turn this condition into a method in the SDK internal context", "author": "marianogonzalez", "createdAt": "2020-01-13T14:44:52Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {\n+                  throw propagateWrappingFatal(me);\n+                }, response -> response);\n+              }), pub -> from(pub)\n+                  .map(event -> {\n+                    try {\n+                      return addContextToEvent(event, ctx);\n+                    } catch (MuleException t) {\n+                      throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+                    }\n+                  })\n+                  .doOnNext(event -> {\n+                    final ExecutorCallback executorCallback = new ExecutorCallback() {\n+\n+                      @Override\n+                      public void error(Throwable e) {\n+                        // if `sink.error` is called here, it will cancel the flux altogether.\n+                        // That's why an `Either` is used here,\n+                        // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                        errorSwitchSinkSinkRef.next(left(\n+                                                         // Force the error mapper from the chain to be used.\n+                                                         // When using Mono.create with sink.error, the error mapper from the\n+                                                         // context is ignored, so it has to be explicitly used here.\n+                                                         localOperatorErrorHook.apply(e, event), CoreEvent.class));\n+                      }\n+\n+                      @Override\n+                      public void complete(Object value) {\n+                        errorSwitchSinkSinkRef.next(right(Throwable.class, (CoreEvent) value));\n+                      }\n+                    };\n+\n+                    if (!isAsync() && NO_POLICY_OPERATION\n+                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -287,16 +289,16 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n                       }\n                     };\n \n-                    if (!isAsync() && NO_POLICY_OPERATION\n-                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())\n-                            .getPolicyToApply())) {\n+                    if (!isAsync() && from(event).isNoPolicyOperation()) {\n                       onEventSynchronous(event, executorCallback, ctx);\n                     } else {\n                       onEvent(event, executorCallback);\n                     }\n                   }), () -> errorSwitchSinkSinkRef.complete(), t -> errorSwitchSinkSinkRef.error(t),\n                                                                  muleContext.getConfiguration().getShutdownTimeout(),\n-                                                                 outerFluxCompletionScheduler));\n+                                                                 outerFluxCompletionScheduler))\n+                                                                     .doOnNext(event -> ((InternalEvent) event)\n+                                                                         .setSdkInternalContext(null));\n \n           if (publisher instanceof Flux && !ctx.getOrEmpty(WITHIN_PROCESS_TO_APPLY).isPresent()) {\n             return transformed\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MjAwNg==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365842006", "bodyText": "extract to static method in org.mule.runtime.module.extension.api.util.MuleExtensionUtils", "author": "marianogonzalez", "createdAt": "2020-01-13T14:45:52Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -212,73 +246,89 @@ public CoreEvent process(CoreEvent event) throws MuleException {\n \n   @Override\n   public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-    Flux<CoreEvent> flux = from(publisher)\n-        .flatMap(event -> subscriberContext().map(ctx -> addContextToEvent(event, ctx)));\n-\n-    if (isAsync()) {\n-      final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n-          getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n-      return flux\n-          // This flatMap allows the operation to run in parallel. The processing strategy relies on this\n-          // (ProactorStreamProcessingStrategy#proactor) to do some performance optimizations.\n-          .flatMap(event -> {\n-            // Force the error mapper from the chain to be used.\n-            // When using Mono.create with sink.error, the error mapper from the context is ignored, so it has to be\n-            // explicitly used here.\n-            DeferredMonoSinkExecutorCallback callback =\n-                new DeferredMonoSinkExecutorCallback<>(t -> localOperatorErrorHook.apply(t, event));\n-\n-            onEvent(event, callback);\n-\n-            return create(callback::setSink);\n-          });\n-    } else {\n-      return flux.handle((event, sink) -> {\n-        try {\n-          onEvent(event, new SynchronousSinkExecutorCallback(sink));\n-        } catch (Throwable t) {\n-          sink.error(unwrap(t));\n-        }\n-      });\n-    }\n+    final BiFunction<Throwable, Object, Throwable> localOperatorErrorHook =\n+        getLocalOperatorErrorHook(this, errorTypeLocator, exceptionContextProviders);\n+\n+    return subscriberContext()\n+        .flatMapMany(ctx -> {\n+          final FluxSinkRecorder<Either<Throwable, CoreEvent>> errorSwitchSinkSinkRef = new FluxSinkRecorder<>();\n+\n+          Flux<CoreEvent> transformed = from(propagateCompletion(from(publisher), create(errorSwitchSinkSinkRef)\n+              .map(result -> {\n+                return result.reduce(me -> {\n+                  throw propagateWrappingFatal(me);\n+                }, response -> response);\n+              }), pub -> from(pub)\n+                  .map(event -> {\n+                    try {\n+                      return addContextToEvent(event, ctx);\n+                    } catch (MuleException t) {\n+                      throw propagateWrappingFatal(localOperatorErrorHook.apply(t, event));\n+                    }\n+                  })\n+                  .doOnNext(event -> {\n+                    final ExecutorCallback executorCallback = new ExecutorCallback() {\n+\n+                      @Override\n+                      public void error(Throwable e) {\n+                        // if `sink.error` is called here, it will cancel the flux altogether.\n+                        // That's why an `Either` is used here,\n+                        // so the error can be propagated afterwards in a way consistent with our expected error handling.\n+                        errorSwitchSinkSinkRef.next(left(\n+                                                         // Force the error mapper from the chain to be used.\n+                                                         // When using Mono.create with sink.error, the error mapper from the\n+                                                         // context is ignored, so it has to be explicitly used here.\n+                                                         localOperatorErrorHook.apply(e, event), CoreEvent.class));\n+                      }\n+\n+                      @Override\n+                      public void complete(Object value) {\n+                        errorSwitchSinkSinkRef.next(right(Throwable.class, (CoreEvent) value));\n+                      }\n+                    };\n+\n+                    if (!isAsync() && NO_POLICY_OPERATION\n+                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())\n+                            .getPolicyToApply())) {\n+                      onEventSynchronous(event, executorCallback, ctx);\n+                    } else {\n+                      onEvent(event, executorCallback);\n+                    }\n+                  }), () -> errorSwitchSinkSinkRef.complete(), t -> errorSwitchSinkSinkRef.error(t),\n+                                                                 muleContext.getConfiguration().getShutdownTimeout(),\n+                                                                 outerFluxCompletionScheduler));\n+\n+          if (publisher instanceof Flux && !ctx.getOrEmpty(WITHIN_PROCESS_TO_APPLY).isPresent()) {\n+            return transformed\n+                .doAfterTerminate(this::outerPublisherTerminated)\n+                .doOnSubscribe(s -> outerPublisherSubscribedTo());\n+          } else {\n+            // Certain features (ext client, batch, flow runner) use Mono, so we don't want to dispose the inner stuff after the\n+            // first event comes through\n+            return transformed;\n+          }\n+        });\n   }\n \n   private void onEvent(CoreEvent event, ExecutorCallback executorCallback) {\n     try {\n+      SdkInternalContext sdkInternalContext =\n+          ((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext());", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -287,16 +289,16 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n                       }\n                     };\n \n-                    if (!isAsync() && NO_POLICY_OPERATION\n-                        .equals(((SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext())\n-                            .getPolicyToApply())) {\n+                    if (!isAsync() && from(event).isNoPolicyOperation()) {\n                       onEventSynchronous(event, executorCallback, ctx);\n                     } else {\n                       onEvent(event, executorCallback);\n                     }\n                   }), () -> errorSwitchSinkSinkRef.complete(), t -> errorSwitchSinkSinkRef.error(t),\n                                                                  muleContext.getConfiguration().getShutdownTimeout(),\n-                                                                 outerFluxCompletionScheduler));\n+                                                                 outerFluxCompletionScheduler))\n+                                                                     .doOnNext(event -> ((InternalEvent) event)\n+                                                                         .setSdkInternalContext(null));\n \n           if (publisher instanceof Flux && !ctx.getOrEmpty(WITHIN_PROCESS_TO_APPLY).isPresent()) {\n             return transformed\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzM2NQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365843365", "bodyText": "where is this context cleared/replaced?", "author": "marianogonzalez", "createdAt": "2020-01-13T14:48:17Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -369,15 +416,120 @@ protected void doInitialise() throws InitialisationException {\n       executionMediator = createExecutionMediator();\n       initialiseIfNeeded(componentExecutor, true, muleContext);\n \n-      if (getLocation() != null) {\n-        resolvedProcessorRepresentation =\n-            resolveProcessorRepresentation(muleContext.getConfiguration().getId(), getLocation().getLocation(), this);\n-      }\n+      resolvedProcessorRepresentation =\n+          resolveProcessorRepresentation(muleContext.getConfiguration().getId(), toString(), this);\n \n+      initProcessingStrategy();\n       initialised = true;\n     }\n   }\n \n+  private void initProcessingStrategy() throws InitialisationException {\n+    final Optional<ProcessingStrategy> processingStrategyFromRootContainer =\n+        getProcessingStrategy(componentLocator, getRootContainerLocation());\n+\n+    processingStrategy = processingStrategyFromRootContainer\n+        .orElseGet(() -> createDefaultProcessingStrategyFactory().create(muleContext, toString() + \".ps\"));\n+\n+    if (!processingStrategyFromRootContainer.isPresent()) {\n+      ownedProcessingStrategy = true;\n+      initialiseIfNeeded(processingStrategy);\n+    }\n+  }\n+\n+  private void startInnerFlux() {\n+    fluxSupplier = createRoundRobinFluxSupplier(p -> {\n+      final OperationInnerProcessor operationInnerProcessor = new OperationInnerProcessor() {\n+\n+        @Override\n+        public ProcessingType getProcessingType() {\n+          return getInnerProcessingType();\n+        }\n+\n+        @Override\n+        public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n+          return subscriberContext()\n+              .flatMapMany(ctx -> from(publisher)\n+                  .doOnNext(event -> prepareAndExecuteOperation(event,\n+                                                                () -> {\n+                                                                  OperationExecutionParams oep =\n+                                                                      ((SdkInternalContext) ((InternalEvent) event)\n+                                                                          .<SdkInternalContext>getSdkInternalContext())\n+                                                                              .getOperationExecutionParams();\n+                                                                  return oep.getCallback();\n+                                                                },\n+                                                                ctx)));\n+        }\n+\n+        @Override\n+        public boolean isAsync() {\n+          return ComponentMessageProcessor.this.isAsync();\n+        }\n+      };\n+\n+      final Flux<CoreEvent> transformed = from(p)\n+          .transform(processingStrategy.onProcessor(operationInnerProcessor))\n+          .onErrorContinue((t, event) -> LOGGER.error(\"Unhandler error in operation (\" + toString() + \") flux\",\n+                                                      t));\n+      return from(processingStrategy.registerInternalFlux(transformed));\n+    },\n+                                                getRuntime().availableProcessors());\n+  }\n+\n+  private CoreEvent addContextToEvent(CoreEvent event, Context ctx) throws MuleException {\n+    SdkInternalContext sdkInternalContext =\n+        (SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext();\n+    if (((InternalEvent) event).getSdkInternalContext() == null) {\n+      sdkInternalContext = new SdkInternalContext();\n+      ((InternalEvent) event).setSdkInternalContext(sdkInternalContext);\n+    }\n+\n+    if (hasChainNested\n+        && (ctx.hasKey(POLICY_NEXT_OPERATION) || ctx.hasKey(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS))) {\n+      sdkInternalContext.setInnerChainSubscriberContextMapping(innerChainCtx -> {\n+        if (ctx.hasKey(POLICY_NEXT_OPERATION)) {\n+          innerChainCtx = innerChainCtx.put(POLICY_NEXT_OPERATION, ctx.get(POLICY_NEXT_OPERATION));\n+        }\n+        if (ctx.hasKey(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS)) {\n+          innerChainCtx = innerChainCtx.put(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS,\n+                                            ctx.get(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS));\n+        }\n+        return innerChainCtx;\n+      });\n+    }\n+\n+    sdkInternalContext.setConfiguration(resolveConfiguration(event));\n+    final Map<String, Object> resolutionResult = getResolutionResult(event, sdkInternalContext.getConfiguration());\n+    sdkInternalContext.setResolutionResult(resolutionResult);\n+    sdkInternalContext.setPolicyToApply(getLocation() != null", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMDYxNw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365920617", "bodyText": "this is create above in this method. Will add a clear for it", "author": "elrodro83", "createdAt": "2020-01-13T17:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0MzM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -438,53 +438,44 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n   }\n \n   private void startInnerFlux() {\n+    // Create and register an internal flux, which will be the one to really use the processing strategy for this operation.\n+    // This is a round robin so it can handle concurrent events, and its lifecycle is tied to the lifecycle of the main flux.\n     fluxSupplier = createRoundRobinFluxSupplier(p -> {\n-      final OperationInnerProcessor operationInnerProcessor = new OperationInnerProcessor() {\n-\n-        @Override\n-        public ProcessingType getProcessingType() {\n-          return getInnerProcessingType();\n-        }\n-\n-        @Override\n-        public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-          return subscriberContext()\n-              .flatMapMany(ctx -> from(publisher)\n-                  .doOnNext(event -> prepareAndExecuteOperation(event,\n-                                                                () -> {\n-                                                                  OperationExecutionParams oep =\n-                                                                      ((SdkInternalContext) ((InternalEvent) event)\n-                                                                          .<SdkInternalContext>getSdkInternalContext())\n-                                                                              .getOperationExecutionParams();\n-                                                                  return oep.getCallback();\n-                                                                },\n-                                                                ctx)));\n-        }\n-\n-        @Override\n-        public boolean isAsync() {\n-          return ComponentMessageProcessor.this.isAsync();\n-        }\n-      };\n-\n-      final Flux<CoreEvent> transformed = from(p)\n-          .transform(processingStrategy.onProcessor(operationInnerProcessor))\n-          .onErrorContinue((t, event) -> LOGGER.error(\"Unhandler error in operation (\" + toString() + \") flux\",\n-                                                      t));\n-      return from(processingStrategy.registerInternalFlux(transformed));\n+      return from(processingStrategy\n+          .configureInternalFlux(from(p)\n+              .transform(processingStrategy.onProcessor(new OperationInnerProcessor() {\n+\n+                @Override\n+                public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n+                  return subscriberContext()\n+                      .flatMapMany(ctx -> from(publisher)\n+                          .doOnNext(event -> prepareAndExecuteOperation(event,\n+                                                                        () -> from(event).getOperationExecutionParams()\n+                                                                            .getCallback(),\n+                                                                        ctx)));\n+                }\n+\n+                @Override\n+                public ProcessingType getProcessingType() {\n+                  return getInnerProcessingType();\n+                }\n+\n+                @Override\n+                public boolean isAsync() {\n+                  return ComponentMessageProcessor.this.isAsync();\n+                }\n+              }))\n+              .onErrorContinue((t, event) -> LOGGER.error(\"Unhandler error in operation (\" + toString() + \") flux\",\n+                                                          t))));\n     },\n                                                 getRuntime().availableProcessors());\n   }\n \n   private CoreEvent addContextToEvent(CoreEvent event, Context ctx) throws MuleException {\n-    SdkInternalContext sdkInternalContext =\n-        (SdkInternalContext) ((InternalEvent) event).<SdkInternalContext>getSdkInternalContext();\n-    if (((InternalEvent) event).getSdkInternalContext() == null) {\n-      sdkInternalContext = new SdkInternalContext();\n-      ((InternalEvent) event).setSdkInternalContext(sdkInternalContext);\n-    }\n+    SdkInternalContext sdkInternalContext = new SdkInternalContext();\n+    ((InternalEvent) event).setSdkInternalContext(sdkInternalContext);\n \n-    if (hasChainNested\n+    if (hasNestedChain\n         && (ctx.hasKey(POLICY_NEXT_OPERATION) || ctx.hasKey(POLICY_IS_PROPAGATE_MESSAGE_TRANSFORMATIONS))) {\n       sdkInternalContext.setInnerChainSubscriberContextMapping(innerChainCtx -> {\n         if (ctx.hasKey(POLICY_NEXT_OPERATION)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg0NDI4Nw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r365844287", "bodyText": "add a clarifying comment about the inner chain processing type being the one that actually reflects the operation", "author": "marianogonzalez", "createdAt": "2020-01-13T14:49:55Z", "path": "modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java", "diffHunk": "@@ -666,8 +861,9 @@ protected ParameterValueResolver getParameterValueResolver() {\n     }\n   }\n \n-  @Override\n-  public abstract ProcessingType getProcessingType();\n+  public ProcessingType getInnerProcessingType() {\n+    return CPU_LITE;", "originalCommit": "8bce0c1a2597bb51b9a6bc3b05a504c3e32035e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "chunk": "diff --git a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\nindex b2956c988b4..da4b5fa877d 100644\n--- a/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n+++ b/modules/extensions-support/src/main/java/org/mule/runtime/module/extension/internal/runtime/operation/ComponentMessageProcessor.java\n\n@@ -861,6 +850,10 @@ public abstract class ComponentMessageProcessor<T extends ComponentModel> extend\n     }\n   }\n \n+  /**\n+   * This is the processing type that is actually taken into account when the processing strategy is applied. This is used by the\n+   * flux created in {@link #startInnerFlux()}.\n+   */\n   public ProcessingType getInnerProcessingType() {\n     return CPU_LITE;\n   }\n"}}, {"oid": "ba16df522b269413f0e4ea97dc3629e194b134e2", "url": "https://github.com/mulesoft/mule/commit/ba16df522b269413f0e4ea97dc3629e194b134e2", "message": "review bulk", "committedDate": "2020-01-13T17:48:07Z", "type": "commit"}, {"oid": "5f4c30643c83c801810e16370076b83edeba7ecb", "url": "https://github.com/mulesoft/mule/commit/5f4c30643c83c801810e16370076b83edeba7ecb", "message": "review async", "committedDate": "2020-01-13T18:33:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwOTkwOQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366009909", "bodyText": "is graceful shutdown a particular use case of this method or is the only and sole purpose of it? Depending on that, either change the jdoc or rename to something more specific", "author": "marianogonzalez", "createdAt": "2020-01-13T20:24:00Z", "path": "core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java", "diffHunk": "@@ -48,7 +48,14 @@ default void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresen\n     Flux.from(flux).subscribe();\n   }\n \n-  default Publisher<CoreEvent> registerInternalFlux(Publisher<CoreEvent> flux) {\n+  /**\n+   * For fluxes created outside of the main flux for a flow, have them accounted for in the processing strategy for a graceful", "originalCommit": "ba16df522b269413f0e4ea97dc3629e194b134e2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4e3bcd179f7b3e1e9e591057186833778ce133cd", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java b/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\nindex 724cace62bd..ce8e260d995 100644\n--- a/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\n+++ b/core/src/main/java/org/mule/runtime/core/api/processor/strategy/ProcessingStrategy.java\n\n@@ -44,7 +44,7 @@ public interface ProcessingStrategy {\n    * @param flux the flux whose sink will be registered\n    * @param sinkRepresentation a representation of the chain for it to appear in log entries.\n    */\n-  default void registerInternalSink(Publisher<CoreEvent> flux, String sinkRepresentation) {\n+  default void registerInternalSinkForShutdown(Publisher<CoreEvent> flux, String sinkRepresentation) {\n     Flux.from(flux).subscribe();\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMTY1OQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366011659", "bodyText": "why do we still need to keep this polling every 200 ms? If this tasks gets scheduled because of a brief high demand lapse, then this task will continue to run every 200ms without need. Can't we use a traditional single threaded wait/notify()?", "author": "marianogonzalez", "createdAt": "2020-01-13T20:28:27Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -335,22 +341,36 @@ public void handleBackpressure(CoreEvent event) {\n       asyncQueue.offer(event);\n     }\n \n+    public void asyncTaskFinished() {\n+      if (scheduledDrain == null) {\n+        synchronized (this) {\n+          if (scheduledDrain == null) {\n+            scheduledDrain = queueDispatcherScheduler.schedule(() -> {\n+              while (asyncQueue.size() > 0) {\n+                try {\n+                  final CoreEvent event = asyncQueue.peek();\n+                  if (event != null) {\n+                    eventDispatcher.accept(event);\n+                    asyncQueue.remove(event);\n+                  }\n+                } catch (FromFlowRejectedExecutionException free) {\n+                  synchronized (this) {\n+                    scheduledDrain = null;\n+                  }\n+                  // nothing to do, a retry will come next\n+                  return;\n+                }\n+              }\n+            }, 200, MILLISECONDS);", "originalCommit": "5f4c30643c83c801810e16370076b83edeba7ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxNDU0MQ==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366014541", "bodyText": "the thing is that the wait/notify mechanism will still keep a thread busy waiting for elements to arrive at the queue.\nWith this approach, this task is active only while it makes sense to poll the queue.", "author": "elrodro83", "createdAt": "2020-01-13T20:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAxMTY1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\nindex 85e2e34a427..3b017cdf4ea 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n\n@@ -318,67 +317,61 @@ public class AsyncDelegateMessageProcessor extends AbstractMessageProcessorOwner\n   private static class QueueBackpressureHandler implements Startable, Stoppable {\n \n     private final BlockingQueue<CoreEvent> asyncQueue;\n-    private final SchedulerService schedulerService;\n-    private final Supplier<SchedulerConfig> schedulerConfigSupplier;\n-    private final String location;\n     private final Consumer<CoreEvent> eventDispatcher;\n \n-    private Scheduler queueDispatcherScheduler;\n-    private volatile ScheduledFuture<?> scheduledDrain;\n+    private final LazyValue<Scheduler> queueDispatcherScheduler;\n \n     public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n                                     Consumer<CoreEvent> eventDispatcher, String location) {\n-      this.schedulerService = schedulerService;\n-      this.schedulerConfigSupplier = schedulerConfigSupplier;\n-\n       this.asyncQueue = new LinkedBlockingQueue<>();\n       this.eventDispatcher = eventDispatcher;\n \n-      this.location = location;\n+      this.queueDispatcherScheduler = new LazyValue(() -> {\n+        final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\")\n+            .withMaxConcurrentTasks(1);\n+        return schedulerService.customScheduler(schedulerConfig);\n+      });\n     }\n \n     public void handleBackpressure(CoreEvent event) {\n       asyncQueue.offer(event);\n-    }\n \n-    public void asyncTaskFinished() {\n-      if (scheduledDrain == null) {\n-        synchronized (this) {\n-          if (scheduledDrain == null) {\n-            scheduledDrain = queueDispatcherScheduler.schedule(() -> {\n-              while (asyncQueue.size() > 0) {\n-                try {\n-                  final CoreEvent event = asyncQueue.peek();\n-                  if (event != null) {\n-                    eventDispatcher.accept(event);\n-                    asyncQueue.remove(event);\n-                  }\n-                } catch (FromFlowRejectedExecutionException free) {\n-                  synchronized (this) {\n-                    scheduledDrain = null;\n-                  }\n-                  // nothing to do, a retry will come next\n-                  return;\n-                }\n+      synchronized (asyncQueue) {\n+        asyncQueue.notify();\n+      }\n+\n+      queueDispatcherScheduler.get().execute(() -> {\n+        while (!currentThread().isInterrupted()) {\n+          try {\n+            final CoreEvent queuedEvent = asyncQueue.peek();\n+            if (queuedEvent != null) {\n+              eventDispatcher.accept(queuedEvent);\n+              asyncQueue.remove(queuedEvent);\n+            } else {\n+              synchronized (asyncQueue) {\n+                asyncQueue.wait();\n               }\n-            }, 200, MILLISECONDS);\n+            }\n+          } catch (FromFlowRejectedExecutionException free) {\n+            // Nothing to do, let next iteration catch it.\n+            yield();\n+          } catch (InterruptedException e) {\n+            currentThread().interrupt();\n+            return;\n           }\n         }\n-      }\n+      });\n     }\n \n     @Override\n     public void start() {\n-      final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\");\n-      queueDispatcherScheduler = schedulerService.ioScheduler(schedulerConfig);\n+      // Nothing to do\n     }\n \n     @Override\n     public void stop() {\n-      if (queueDispatcherScheduler != null) {\n-        queueDispatcherScheduler.stop();\n-        queueDispatcherScheduler = null;\n-      }\n+      queueDispatcherScheduler.ifComputed(Scheduler::stop);\n+\n       asyncQueue.clear();\n     }\n   }\n"}}, {"oid": "4e3bcd179f7b3e1e9e591057186833778ce133cd", "url": "https://github.com/mulesoft/mule/commit/4e3bcd179f7b3e1e9e591057186833778ce133cd", "message": "more review", "committedDate": "2020-01-13T20:55:32Z", "type": "commit"}, {"oid": "a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "url": "https://github.com/mulesoft/mule/commit/a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "message": "more review", "committedDate": "2020-01-13T21:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0MjU0Mw==", "url": "https://github.com/mulesoft/mule/pull/8566#discussion_r366042543", "bodyText": "delete method then. Doesn't look like you're actually forced to implement Startable", "author": "marianogonzalez", "createdAt": "2020-01-13T21:39:24Z", "path": "core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java", "diffHunk": "@@ -318,67 +317,61 @@ public void setMaxConcurrency(Integer maxConcurrency) {\n   private static class QueueBackpressureHandler implements Startable, Stoppable {\n \n     private final BlockingQueue<CoreEvent> asyncQueue;\n-    private final SchedulerService schedulerService;\n-    private final Supplier<SchedulerConfig> schedulerConfigSupplier;\n-    private final String location;\n     private final Consumer<CoreEvent> eventDispatcher;\n \n-    private Scheduler queueDispatcherScheduler;\n-    private volatile ScheduledFuture<?> scheduledDrain;\n+    private final LazyValue<Scheduler> queueDispatcherScheduler;\n \n     public QueueBackpressureHandler(SchedulerService schedulerService, Supplier<SchedulerConfig> schedulerConfigSupplier,\n                                     Consumer<CoreEvent> eventDispatcher, String location) {\n-      this.schedulerService = schedulerService;\n-      this.schedulerConfigSupplier = schedulerConfigSupplier;\n-\n       this.asyncQueue = new LinkedBlockingQueue<>();\n       this.eventDispatcher = eventDispatcher;\n \n-      this.location = location;\n+      this.queueDispatcherScheduler = new LazyValue(() -> {\n+        final SchedulerConfig schedulerConfig = schedulerConfigSupplier.get().withName(location + \" - queue dispatcher\")\n+            .withMaxConcurrentTasks(1);\n+        return schedulerService.customScheduler(schedulerConfig);\n+      });\n     }\n \n     public void handleBackpressure(CoreEvent event) {\n       asyncQueue.offer(event);\n-    }\n \n-    public void asyncTaskFinished() {\n-      if (scheduledDrain == null) {\n-        synchronized (this) {\n-          if (scheduledDrain == null) {\n-            scheduledDrain = queueDispatcherScheduler.schedule(() -> {\n-              while (asyncQueue.size() > 0) {\n-                try {\n-                  final CoreEvent event = asyncQueue.peek();\n-                  if (event != null) {\n-                    eventDispatcher.accept(event);\n-                    asyncQueue.remove(event);\n-                  }\n-                } catch (FromFlowRejectedExecutionException free) {\n-                  synchronized (this) {\n-                    scheduledDrain = null;\n-                  }\n-                  // nothing to do, a retry will come next\n-                  return;\n-                }\n+      synchronized (asyncQueue) {\n+        asyncQueue.notify();\n+      }\n+\n+      queueDispatcherScheduler.get().execute(() -> {\n+        while (!currentThread().isInterrupted()) {\n+          try {\n+            final CoreEvent queuedEvent = asyncQueue.peek();\n+            if (queuedEvent != null) {\n+              eventDispatcher.accept(queuedEvent);\n+              asyncQueue.remove(queuedEvent);\n+            } else {\n+              synchronized (asyncQueue) {\n+                asyncQueue.wait();\n               }\n-            }, 200, MILLISECONDS);\n+            }\n+          } catch (FromFlowRejectedExecutionException free) {\n+            // Nothing to do, let next iteration catch it.\n+            yield();\n+          } catch (InterruptedException e) {\n+            currentThread().interrupt();\n+            return;\n           }\n         }\n-      }\n+      });\n     }\n \n     @Override\n     public void start() {", "originalCommit": "a85290dc01c5491ed4a43d8286d8f5ed3aaf2541", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34fd9bb610860234c66935b445fd1bc77416df09", "chunk": "diff --git a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\nindex 3b017cdf4ea..38241025d2c 100644\n--- a/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n+++ b/core/src/main/java/org/mule/runtime/core/internal/processor/AsyncDelegateMessageProcessor.java\n\n@@ -314,7 +314,7 @@ public class AsyncDelegateMessageProcessor extends AbstractMessageProcessorOwner\n     return emptyList();\n   }\n \n-  private static class QueueBackpressureHandler implements Startable, Stoppable {\n+  private static class QueueBackpressureHandler implements Stoppable {\n \n     private final BlockingQueue<CoreEvent> asyncQueue;\n     private final Consumer<CoreEvent> eventDispatcher;\n"}}, {"oid": "34fd9bb610860234c66935b445fd1bc77416df09", "url": "https://github.com/mulesoft/mule/commit/34fd9bb610860234c66935b445fd1bc77416df09", "message": "making MG happy", "committedDate": "2020-01-13T21:43:42Z", "type": "commit"}]}