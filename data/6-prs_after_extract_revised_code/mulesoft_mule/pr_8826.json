{"pr_number": 8826, "pr_title": "MULE-18102: Concurrent subflow instantiations are corrupting their inner processors location", "pr_createdAt": "2020-04-27T18:09:30Z", "pr_url": "https://github.com/mulesoft/mule/pull/8826", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056205", "bodyText": "doesn't this affect any other tests?", "author": "elrodro83", "createdAt": "2020-04-27T18:37:52Z", "path": "tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java", "diffHunk": "@@ -171,7 +172,7 @@ public static MuleContextWithRegistry mockMuleContext() {\n \n     StreamingManager streamingManager = mock(StreamingManager.class, RETURNS_DEEP_STUBS);\n     try {\n-      MuleRegistry registry = mock(MuleRegistry.class, withSettings().lenient());\n+      MuleRegistry registry = mock(MuleRegistryHelper.class, withSettings().lenient());", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NTM0MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416065340", "bodyText": "Ran all the tests and found no side effects (all passing) Will check again just in case.", "author": "IvanAndresFritzler", "createdAt": "2020-04-27T18:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzk0MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417633940", "bodyText": "All tests passing, no side effects.", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjIwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java b/tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java\nindex 719ffe742ea..d8fa2ae8223 100644\n--- a/tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java\n+++ b/tests/unit/src/main/java/org/mule/tck/util/MuleContextUtils.java\n\n@@ -172,7 +171,7 @@ public class MuleContextUtils {\n \n     StreamingManager streamingManager = mock(StreamingManager.class, RETURNS_DEEP_STUBS);\n     try {\n-      MuleRegistry registry = mock(MuleRegistryHelper.class, withSettings().lenient());\n+      MuleRegistry registry = mock(MuleRegistry.class, withSettings().lenient());\n       when(muleContext.getRegistry()).thenReturn(registry);\n       ComponentInitialStateManager componentInitialStateManager =\n           mock(ComponentInitialStateManager.class, withSettings().lenient());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjI5NQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056295", "bodyText": "formatter", "author": "elrodro83", "createdAt": "2020-04-27T18:38:01Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n+    }, \"Parallel Flow Events\");\n+    flowEvents.start();\n+    parallelFlowEvents.start();\n+    flowEvents.join();\n+    parallelFlowEvents.join();\n+    // Assertions over each parent flow processing strategies\n+    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n+    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n+  }\n+\n+  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n+    try {\n+      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+      initialiseIfNeeded(flowRefProcessor);\n+      startIfNeeded(flowRefProcessor);\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      stopIfNeeded(flowRefProcessor);\n+      disposeIfNeeded(flowRefProcessor, null);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n+    }\n+  }\n+\n+  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n+    MuleArtifactContext muleArtifactContext =\n+            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n+                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n+                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n+\n+              @Override\n+              protected DefaultListableBeanFactory createBeanFactory() {\n+                return mockedBeanFactory;\n+              }\n+\n+              @Override\n+              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean invocation here\n+              }\n+\n+              @Override\n+              protected void registerListeners() {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishRefresh() {\n+                // Bean factory is mocked, so no nothing to do here\n+              }\n+            };\n+    muleArtifactContext.refresh();\n+    return muleArtifactContext;\n+  }\n+\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n+                                                      ApplicationContext applicationContext)\n+          throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(name);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(\"flow\")));\n+    flowRefFactoryBean.setName(referencedFlowName);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n+          throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n-    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n-        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n-                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                  any(ComponentLocation.class), eq(true));\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n+                                                             ApplicationContext applicationContext)\n+          throws Exception {\n     if (targetBuilder != null) {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n+      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     } else {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n+      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-          .cast(CoreEvent.class)\n-          .doOnNext(event -> ((BaseEventContext) event.getContext())\n-              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+              .cast(CoreEvent.class)\n+              .doOnNext(event -> ((BaseEventContext) event.getContext())\n+                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n-      throws Exception {\n-    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-    initialiseIfNeeded(flowRefProcessor);\n-    startIfNeeded(flowRefProcessor);\n-\n-    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n+          throws Exception {\n+    sendEventsThroughFlowRef(flowRefFactoryBean);\n     verify(applicationContext).getBean(anyString());\n-\n     verify(target, times(2)).apply(any(Publisher.class));\n-\n-    stopIfNeeded(flowRefProcessor);\n-    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-      throws Exception {\n+          throws Exception {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -272,182 +250,95 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  @Test\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-            .getComponentBuildingDefinitions()\n-            .stream()\n-            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-            .findFirst()\n-            .get();\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n-      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n-      return subFlowProcessor;\n-    }).getBeanDefinition();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                    () -> true, empty()))\n-            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-            .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    Thread flowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(flowRefFactoryBean);\n-    }, \"Flow Events\");\n-    Thread parallelFlowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n-    }, \"Parallel Flow Events\");\n-    flowEvents.start();\n-    parallelFlowEvents.start();\n-    flowEvents.join();\n-    parallelFlowEvents.join();\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-              @Override\n-              protected DefaultListableBeanFactory createBeanFactory() {\n-                return mockedBeanFactory;\n-              }\n-\n-              @Override\n-              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean invocation here\n-              }\n-\n-              @Override\n-              protected void registerListeners() {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishRefresh() {\n-                // Bean factory is mocked, so no nothing to do here\n-              }\n-            };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-          throws Exception {\n+      throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n-                                                             ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n+      throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n+    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n+        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n+                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                  any(ComponentLocation.class), eq(true));\n     if (targetBuilder != null) {\n-      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n-      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-              .cast(CoreEvent.class)\n-              .doOnNext(event -> ((BaseEventContext) event.getContext())\n-                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+          .cast(CoreEvent.class)\n+          .doOnNext(event -> ((BaseEventContext) event.getContext())\n+              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n-          throws Exception {\n-    sendEventsThroughFlowRef(flowRefFactoryBean);\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n+      throws Exception {\n+    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+    initialiseIfNeeded(flowRefProcessor);\n+    startIfNeeded(flowRefProcessor);\n+\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+\n     verify(applicationContext).getBean(anyString());\n+\n     verify(target, times(2)).apply(any(Publisher.class));\n+\n+    stopIfNeeded(flowRefProcessor);\n+    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-          throws Exception {\n+      throws Exception {\n     verify((Initialisable) target, times(lifecycleRounds)).initialise();\n \n     verify(targetSubFlow, times(lifecycleRounds)).initialise();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NjY5Nw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416056697", "bodyText": "static import", "author": "elrodro83", "createdAt": "2020-04-27T18:38:37Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n+    }, \"Parallel Flow Events\");\n+    flowEvents.start();\n+    parallelFlowEvents.start();\n+    flowEvents.join();\n+    parallelFlowEvents.join();\n+    // Assertions over each parent flow processing strategies\n+    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n+    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n+  }\n+\n+  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n+    try {\n+      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+      initialiseIfNeeded(flowRefProcessor);\n+      startIfNeeded(flowRefProcessor);\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+      stopIfNeeded(flowRefProcessor);\n+      disposeIfNeeded(flowRefProcessor, null);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n+    }\n+  }\n+\n+  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n+    MuleArtifactContext muleArtifactContext =\n+            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n+                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n+                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n+\n+              @Override\n+              protected DefaultListableBeanFactory createBeanFactory() {\n+                return mockedBeanFactory;\n+              }\n+\n+              @Override\n+              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean invocation here\n+              }\n+\n+              @Override\n+              protected void registerListeners() {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n+                // Bean factory is mocked, so no bean registering here\n+              }\n+\n+              @Override\n+              protected void finishRefresh() {\n+                // Bean factory is mocked, so no nothing to do here\n+              }\n+            };\n+    muleArtifactContext.refresh();\n+    return muleArtifactContext;\n+  }\n+\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n+                                                      ApplicationContext applicationContext)\n+          throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(name);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(\"flow\")));\n+    flowRefFactoryBean.setName(referencedFlowName);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n+          throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n-      throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n-    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n-        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n-                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                  any(ComponentLocation.class), eq(true));\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n+                                                             ApplicationContext applicationContext)\n+          throws Exception {\n     if (targetBuilder != null) {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n+      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     } else {\n-      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n+      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n     }\n-\n-    if (target instanceof MessageProcessorChain) {\n-      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n-      when(processor.apply(any())).thenAnswer(successAnswer());\n-    } else {\n-      when(target.apply(any())).thenAnswer(successAnswer());\n-    }\n-\n-    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n+    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -272,182 +250,95 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  @Test\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-            .getComponentBuildingDefinitions()\n-            .stream()\n-            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-            .findFirst()\n-            .get();\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n-      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n-      return subFlowProcessor;\n-    }).getBeanDefinition();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                    () -> true, empty()))\n-            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-            .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    Thread flowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(flowRefFactoryBean);\n-    }, \"Flow Events\");\n-    Thread parallelFlowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n-    }, \"Parallel Flow Events\");\n-    flowEvents.start();\n-    parallelFlowEvents.start();\n-    flowEvents.join();\n-    parallelFlowEvents.join();\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-              @Override\n-              protected DefaultListableBeanFactory createBeanFactory() {\n-                return mockedBeanFactory;\n-              }\n-\n-              @Override\n-              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean invocation here\n-              }\n-\n-              @Override\n-              protected void registerListeners() {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishRefresh() {\n-                // Bean factory is mocked, so no nothing to do here\n-              }\n-            };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-          throws Exception {\n+      throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n-                                                             ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n+      throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n+    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n+        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n+                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                  any(ComponentLocation.class), eq(true));\n     if (targetBuilder != null) {\n-      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n-      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-              .cast(CoreEvent.class)\n-              .doOnNext(event -> ((BaseEventContext) event.getContext())\n-                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+          .cast(CoreEvent.class)\n+          .doOnNext(event -> ((BaseEventContext) event.getContext())\n+              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n-          throws Exception {\n-    sendEventsThroughFlowRef(flowRefFactoryBean);\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n+      throws Exception {\n+    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+    initialiseIfNeeded(flowRefProcessor);\n+    startIfNeeded(flowRefProcessor);\n+\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+\n     verify(applicationContext).getBean(anyString());\n+\n     verify(target, times(2)).apply(any(Publisher.class));\n+\n+    stopIfNeeded(flowRefProcessor);\n+    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-          throws Exception {\n+      throws Exception {\n     verify((Initialisable) target, times(lifecycleRounds)).initialise();\n \n     verify(targetSubFlow, times(lifecycleRounds)).initialise();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzIyOA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416057228", "bodyText": "add allure @Issue", "author": "elrodro83", "createdAt": "2020-04-27T18:39:26Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzcyNg==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417633726", "bodyText": "Added new annotations to AllureConstants", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -272,182 +250,95 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  @Test\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-            .getComponentBuildingDefinitions()\n-            .stream()\n-            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-            .findFirst()\n-            .get();\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n-      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n-      return subFlowProcessor;\n-    }).getBeanDefinition();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                    () -> true, empty()))\n-            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-            .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    Thread flowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(flowRefFactoryBean);\n-    }, \"Flow Events\");\n-    Thread parallelFlowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n-    }, \"Parallel Flow Events\");\n-    flowEvents.start();\n-    parallelFlowEvents.start();\n-    flowEvents.join();\n-    parallelFlowEvents.join();\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-              @Override\n-              protected DefaultListableBeanFactory createBeanFactory() {\n-                return mockedBeanFactory;\n-              }\n-\n-              @Override\n-              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean invocation here\n-              }\n-\n-              @Override\n-              protected void registerListeners() {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishRefresh() {\n-                // Bean factory is mocked, so no nothing to do here\n-              }\n-            };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-          throws Exception {\n+      throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n-                                                             ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n+      throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n+    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n+        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n+                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                  any(ComponentLocation.class), eq(true));\n     if (targetBuilder != null) {\n-      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n-      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-              .cast(CoreEvent.class)\n-              .doOnNext(event -> ((BaseEventContext) event.getContext())\n-                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+          .cast(CoreEvent.class)\n+          .doOnNext(event -> ((BaseEventContext) event.getContext())\n+              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n-          throws Exception {\n-    sendEventsThroughFlowRef(flowRefFactoryBean);\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n+      throws Exception {\n+    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+    initialiseIfNeeded(flowRefProcessor);\n+    startIfNeeded(flowRefProcessor);\n+\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+\n     verify(applicationContext).getBean(anyString());\n+\n     verify(target, times(2)).apply(any(Publisher.class));\n+\n+    stopIfNeeded(flowRefProcessor);\n+    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-          throws Exception {\n+      throws Exception {\n     verify((Initialisable) target, times(lifecycleRounds)).initialise();\n \n     verify(targetSubFlow, times(lifecycleRounds)).initialise();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NzU4Nw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416057587", "bodyText": "use an Executor instead of threads", "author": "elrodro83", "createdAt": "2020-04-27T18:40:04Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -272,182 +250,95 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  @Test\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-            .getComponentBuildingDefinitions()\n-            .stream()\n-            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-            .findFirst()\n-            .get();\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n-      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n-      return subFlowProcessor;\n-    }).getBeanDefinition();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                    () -> true, empty()))\n-            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-            .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    Thread flowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(flowRefFactoryBean);\n-    }, \"Flow Events\");\n-    Thread parallelFlowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n-    }, \"Parallel Flow Events\");\n-    flowEvents.start();\n-    parallelFlowEvents.start();\n-    flowEvents.join();\n-    parallelFlowEvents.join();\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-              @Override\n-              protected DefaultListableBeanFactory createBeanFactory() {\n-                return mockedBeanFactory;\n-              }\n-\n-              @Override\n-              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean invocation here\n-              }\n-\n-              @Override\n-              protected void registerListeners() {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishRefresh() {\n-                // Bean factory is mocked, so no nothing to do here\n-              }\n-            };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-          throws Exception {\n+      throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n-                                                             ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n+      throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n+    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n+        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n+                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                  any(ComponentLocation.class), eq(true));\n     if (targetBuilder != null) {\n-      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n-      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-              .cast(CoreEvent.class)\n-              .doOnNext(event -> ((BaseEventContext) event.getContext())\n-                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+          .cast(CoreEvent.class)\n+          .doOnNext(event -> ((BaseEventContext) event.getContext())\n+              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n-          throws Exception {\n-    sendEventsThroughFlowRef(flowRefFactoryBean);\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n+      throws Exception {\n+    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+    initialiseIfNeeded(flowRefProcessor);\n+    startIfNeeded(flowRefProcessor);\n+\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+\n     verify(applicationContext).getBean(anyString());\n+\n     verify(target, times(2)).apply(any(Publisher.class));\n+\n+    stopIfNeeded(flowRefProcessor);\n+    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-          throws Exception {\n+      throws Exception {\n     verify((Initialisable) target, times(lifecycleRounds)).initialise();\n \n     verify(targetSubFlow, times(lifecycleRounds)).initialise();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416058013", "bodyText": "can this be executed more times to force the manifestation of the race condition?", "author": "elrodro83", "createdAt": "2020-04-27T18:40:42Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -250,95 +272,182 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n-    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-                                                                                 any(ComponentLocation.class), eq(true));\n+            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+            any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n+  @Test\n+  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n+    // MuleArtifactContext stubbing\n+    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n+    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n+    // BeanFactory stubbing (subFlow and subFlow processor factories)\n+    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n+            .getComponentBuildingDefinitions()\n+            .stream()\n+            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n+            .findFirst()\n+            .get();\n+    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n+      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n+      return subFlowProcessor;\n+    }).getBeanDefinition();\n+    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n+            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n+                    () -> true, empty()))\n+            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n+            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n+            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n+            .getBeanDefinition();\n+    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n+    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n+    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n+    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n+    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n+    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n+    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n+            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n+    // Two flowRef dynamically pointing to the same subFlow\n+    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n+    FlowRefFactoryBean parallelFlowRefFactoryBean =\n+            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n+    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n+    Thread flowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(flowRefFactoryBean);\n+    }, \"Flow Events\");\n+    Thread parallelFlowEvents = new Thread(() -> {\n+      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2ODYzNA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416068634", "bodyText": "Will try. With some modifications it might be possible to make it fail \"almost all the executions\".", "author": "IvanAndresFritzler", "createdAt": "2020-04-27T18:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNDU3MQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417634571", "bodyText": "New version failed 1000 of 1000 runs without the fix", "author": "IvanAndresFritzler", "createdAt": "2020-04-29T21:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -272,182 +250,95 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  @Test\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-            .getComponentBuildingDefinitions()\n-            .stream()\n-            .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-            .findFirst()\n-            .get();\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Processor.class, () -> {\n-      Processor subFlowProcessor = (Processor) mock(Object.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-      when(subFlowProcessor.apply(any())).thenAnswer(successAnswer());\n-      return subFlowProcessor;\n-    }).getBeanDefinition();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-            .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                    () -> true, empty()))\n-            .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-            .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-            .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-            .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-            .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-            createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    Thread flowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(flowRefFactoryBean);\n-    }, \"Flow Events\");\n-    Thread parallelFlowEvents = new Thread(() -> {\n-      sendEventsThroughFlowRef(parallelFlowRefFactoryBean);\n-    }, \"Parallel Flow Events\");\n-    flowEvents.start();\n-    parallelFlowEvents.start();\n-    flowEvents.join();\n-    parallelFlowEvents.join();\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-            new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                    mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                    Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-              @Override\n-              protected DefaultListableBeanFactory createBeanFactory() {\n-                return mockedBeanFactory;\n-              }\n-\n-              @Override\n-              protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean invocation here\n-              }\n-\n-              @Override\n-              protected void registerListeners() {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-                // Bean factory is mocked, so no bean registering here\n-              }\n-\n-              @Override\n-              protected void finishRefresh() {\n-                // Bean factory is mocked, so no nothing to do here\n-              }\n-            };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n   }\n \n   private FlowRefFactoryBean createStaticFlowRefFactoryBean(Processor target, Object targetBuilder)\n-          throws Exception {\n+      throws Exception {\n     doReturn(false).when(expressionManager).isExpression(anyString());\n     if (targetBuilder != null) {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n       when(applicationContext.getBean(eq(STATIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(STATIC_REFERENCED_FLOW);\n   }\n \n-  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder,\n-                                                             ApplicationContext applicationContext)\n-          throws Exception {\n+  private FlowRefFactoryBean createDynamicFlowRefFactoryBean(Processor target, Object targetBuilder)\n+      throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n+    doReturn(new TypedValue<>(PARSED_DYNAMIC_REFERENCED_FLOW, STRING)).when(expressionManager)\n+        .evaluate(eq(DYNAMIC_REFERENCED_FLOW), eq(DataType.STRING),\n+                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                  any(ComponentLocation.class), eq(true));\n     if (targetBuilder != null) {\n-      doReturn(targetBuilder).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(targetBuilder);\n     } else {\n-      doReturn(target).when(applicationContext).getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW));\n+      when(applicationContext.getBean(eq(PARSED_DYNAMIC_REFERENCED_FLOW))).thenReturn(target);\n     }\n-    return createFlowRefFactoryBean(FlowRefFactoryBeanTestCase.DYNAMIC_REFERENCED_FLOW, \"flow\", applicationContext);\n+\n+    if (target instanceof MessageProcessorChain) {\n+      Processor processor = ((MessageProcessorChain) target).getMessageProcessors().get(0);\n+      when(processor.apply(any())).thenAnswer(successAnswer());\n+    } else {\n+      when(target.apply(any())).thenAnswer(successAnswer());\n+    }\n+\n+    return createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW);\n   }\n \n   private Answer<?> successAnswer() {\n     return invocation -> {\n       return from(invocation.getArgument(0))\n-              .cast(CoreEvent.class)\n-              .doOnNext(event -> ((BaseEventContext) event.getContext())\n-                      .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n-              .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n+          .cast(CoreEvent.class)\n+          .doOnNext(event -> ((BaseEventContext) event.getContext())\n+              .success(CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build()))\n+          .map(event -> CoreEvent.builder(event).message(result.getMessage()).variables(result.getVariables()).build());\n     };\n   }\n \n-  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target, ApplicationContext applicationContext)\n-          throws Exception {\n-    sendEventsThroughFlowRef(flowRefFactoryBean);\n+  private void verifyProcess(FlowRefFactoryBean flowRefFactoryBean, Processor target)\n+      throws Exception {\n+    Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n+    initialiseIfNeeded(flowRefProcessor);\n+    startIfNeeded(flowRefProcessor);\n+\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+    assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n+\n     verify(applicationContext).getBean(anyString());\n+\n     verify(target, times(2)).apply(any(Publisher.class));\n+\n+    stopIfNeeded(flowRefProcessor);\n+    disposeIfNeeded(flowRefProcessor, null);\n   }\n \n   private void verifyLifecycle(Processor target, int lifecycleRounds)\n-          throws Exception {\n+      throws Exception {\n     verify((Initialisable) target, times(lifecycleRounds)).initialise();\n \n     verify(targetSubFlow, times(lifecycleRounds)).initialise();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1ODU4MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r416058580", "bodyText": "no * imports", "author": "elrodro83", "createdAt": "2020-04-27T18:41:25Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -66,10 +73,12 @@\n import org.mule.runtime.core.privileged.event.BaseEventContext;\n import org.mule.runtime.core.privileged.processor.chain.MessageProcessorChain;\n import org.mule.runtime.core.privileged.routing.RoutePathNotFoundException;\n+import org.mule.runtime.dsl.api.ConfigResource;\n+import org.mule.runtime.dsl.api.component.ComponentBuildingDefinition;\n import org.mule.tck.junit4.AbstractMuleTestCase;\n import org.mule.tck.size.SmallTest;\n \n-import java.util.List;\n+import java.util.*;", "originalCommit": "10005fcec834f332016482fe4aec70fbd1ee08f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 45f080f67d9..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -73,12 +65,11 @@ import org.mule.runtime.core.internal.processor.chain.SubflowMessageProcessorCha\n import org.mule.runtime.core.privileged.event.BaseEventContext;\n import org.mule.runtime.core.privileged.processor.chain.MessageProcessorChain;\n import org.mule.runtime.core.privileged.routing.RoutePathNotFoundException;\n-import org.mule.runtime.dsl.api.ConfigResource;\n-import org.mule.runtime.dsl.api.component.ComponentBuildingDefinition;\n+import org.mule.runtime.dsl.api.component.config.DefaultComponentLocation;\n import org.mule.tck.junit4.AbstractMuleTestCase;\n import org.mule.tck.size.SmallTest;\n \n-import java.util.*;\n+import java.util.List;\n \n import javax.inject.Inject;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5NjUzOQ==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417996539", "bodyText": "static imports of these constants", "author": "elrodro83", "createdAt": "2020-04-30T13:09:45Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -273,63 +289,86 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n     getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  @Test\n+  @Test()\n+  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)", "originalCommit": "b5c96a035fdce204358bd0bc575c695b1649e38c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 9fbb3a96eac..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -288,182 +250,19 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n                                                                                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n                                                                                  any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n-  }\n-\n-  @Test()\n-  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)\n-  @Story(AllureConstants.SpringConfiguration.ComponentFactories.COMPONENT_FACTORIES)\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    List<Component> stubbedSubFlowProcessors = new ArrayList<>(2);\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Component.class, () -> {\n-      Component stubbedProcessor = new StubbedProcessor(result);\n-      stubbedSubFlowProcessors.add(stubbedProcessor);\n-      return stubbedProcessor;\n-    }).getBeanDefinition();\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-        .getComponentBuildingDefinitions()\n-        .stream()\n-        .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-        .findFirst()\n-        .get();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-        .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                               () -> true, empty()))\n-                                   .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-                                   .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-                                   .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-                                   .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-        .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-        createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    CountDownLatch threadCountdown = new CountDownLatch(2);\n-    Callable<Void> flowRefEvents = sendEventsThroughFlowRefAsynchronously(threadCountdown, flowRefFactoryBean);\n-    Callable<Void> parallelFlowRefEvents = sendEventsThroughFlowRefAsynchronously(threadCountdown, parallelFlowRefFactoryBean);\n-    ExecutorService executorService = Executors.newFixedThreadPool(2);\n-    try {\n-      executorService.invokeAll(asList(flowRefEvents, parallelFlowRefEvents), 1, TimeUnit.SECONDS);\n-    } finally {\n-      executorService.shutdown();\n-    }\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    // Asssertions over subflow components root container location\n-    assertThat(stubbedSubFlowProcessors.get(0).getRootContainerLocation().getGlobalName(),\n-               not(equalTo(stubbedSubFlowProcessors.get(1).getRootContainerLocation().getGlobalName())));\n-  }\n-\n-  private Callable<Void> sendEventsThroughFlowRefAsynchronously(CountDownLatch countDownLatch,\n-                                                                FlowRefFactoryBean flowRefFactoryBean) {\n-    return new Callable<Void>() {\n-\n-      @Override\n-      public Void call() throws Exception {\n-        try {\n-          countDownLatch.countDown();\n-          countDownLatch.await();\n-          sendEventsThroughFlowRef(flowRefFactoryBean);\n-        } catch (Exception e) {\n-          throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-        }\n-        return null;\n-      }\n-    };\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  private static class StubbedProcessor extends AbstractComponent implements Processor {\n-\n-    private CoreEvent applyResult;\n-\n-    public StubbedProcessor(CoreEvent applyResult) {\n-      this.applyResult = applyResult;\n-    }\n-\n-    @Override\n-    public CoreEvent process(CoreEvent event) throws MuleException {\n-      throw new RuntimeException(new IllegalAccessException(\"This method should never be called\"));\n-    }\n-\n-    @Override\n-    public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-      return from(publisher)\n-          .doOnNext(event -> ((BaseEventContext) event.getContext())\n-              .success(CoreEvent.builder(event).message(applyResult.getMessage()).variables(applyResult.getVariables()).build()))\n-          .map(event -> CoreEvent.builder(event).message(applyResult.getMessage()).variables(applyResult.getVariables()).build());\n-    }\n-\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-        new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                                mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                                Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-          @Override\n-          protected DefaultListableBeanFactory createBeanFactory() {\n-            return mockedBeanFactory;\n-          }\n-\n-          @Override\n-          protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean invocation here\n-          }\n-\n-          @Override\n-          protected void registerListeners() {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void finishRefresh() {\n-            // Bean factory is mocked, so no nothing to do here\n-          }\n-        };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-      throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417997860", "bodyText": "isn't there allure constants for flow-ref? that would be mor appropriate here.", "author": "elrodro83", "createdAt": "2020-04-30T13:11:54Z", "path": "modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java", "diffHunk": "@@ -273,63 +289,86 @@ private Processor getFlowRefProcessor(FlowRefFactoryBean factoryBean) throws Exc\n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n-            eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n-            any(ComponentLocation.class), eq(true));\n+                                                                                 eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n+                                                                                 any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n     getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n   }\n \n-  @Test\n+  @Test()\n+  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)", "originalCommit": "b5c96a035fdce204358bd0bc575c695b1649e38c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5ODU1Mw==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r417998553", "bodyText": "what i mean is, the values of this annotations should match features of the runtime and stories for its users. spring is just an internally used library.", "author": "elrodro83", "createdAt": "2020-04-30T13:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0MTk5Ng==", "url": "https://github.com/mulesoft/mule/pull/8826#discussion_r418041996", "bodyText": "Changed to Flow Reference Story", "author": "IvanAndresFritzler", "createdAt": "2020-04-30T14:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5Nzg2MA=="}], "type": "inlineReview", "revised_code": {"commit": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "chunk": "diff --git a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\nindex 9fbb3a96eac..1de16c13df1 100644\n--- a/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n+++ b/modules/spring-config/src/test/java/org/mule/runtime/config/internal/factories/FlowRefFactoryBeanTestCase.java\n\n@@ -288,182 +250,19 @@ public class FlowRefFactoryBeanTestCase extends AbstractMuleTestCase {\n \n   @Test\n   public void dynamicFlowRefDoesNotExist() throws Exception {\n+    doReturn(true).when(expressionManager).isExpression(anyString());\n     doReturn(new TypedValue<>(\"other\", STRING)).when(expressionManager).evaluate(eq(DYNAMIC_NON_EXISTANT), eq(DataType.STRING),\n                                                                                  eq(NULL_BINDING_CONTEXT), any(CoreEvent.class),\n                                                                                  any(ComponentLocation.class), eq(true));\n \n     expectedException.expect(instanceOf(RoutePathNotFoundException.class));\n-    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT, \"flow\", applicationContext)).process(testEvent());\n-  }\n-\n-  @Test()\n-  @Feature(AllureConstants.SpringConfiguration.SPRING_CONFIGURATION)\n-  @Story(AllureConstants.SpringConfiguration.ComponentFactories.COMPONENT_FACTORIES)\n-  public void concurrentDynamicSubFlowInstantiation() throws Exception {\n-    // MuleArtifactContext stubbing\n-    DefaultListableBeanFactory beanFactory = new ObjectProviderAwareBeanFactory(null);\n-    MuleArtifactContext muleArtifactContext = spy(createMuleArtifactContextStub(beanFactory));\n-    // BeanFactory stubbing (subFlow and subFlow processor factories)\n-    List<Component> stubbedSubFlowProcessors = new ArrayList<>(2);\n-    BeanDefinition subFlowProcessorBeanDefinition = genericBeanDefinition(Component.class, () -> {\n-      Component stubbedProcessor = new StubbedProcessor(result);\n-      stubbedSubFlowProcessors.add(stubbedProcessor);\n-      return stubbedProcessor;\n-    }).getBeanDefinition();\n-    ComponentBuildingDefinition subFlowComponentBuildingDefinition = new CoreComponentBuildingDefinitionProvider()\n-        .getComponentBuildingDefinitions()\n-        .stream()\n-        .filter(componentBuildingDefinition -> componentBuildingDefinition.getComponentIdentifier().getName().equals(\"sub-flow\"))\n-        .findFirst()\n-        .get();\n-    BeanDefinition subFlowBeanDefinition = genericBeanDefinition(new ObjectFactoryClassRepository()\n-        .getObjectFactoryClass(subFlowComponentBuildingDefinition, SubflowMessageProcessorChainFactoryBean.class, Object.class,\n-                               () -> true, empty()))\n-                                   .addPropertyValue(\"name\", PARSED_DYNAMIC_REFERENCED_FLOW)\n-                                   .addPropertyValue(\"messageProcessors\", subFlowProcessorBeanDefinition)\n-                                   .setScope(BeanDefinition.SCOPE_PROTOTYPE)\n-                                   .getBeanDefinition();\n-    beanFactory.registerBeanDefinition(PARSED_DYNAMIC_REFERENCED_FLOW, subFlowBeanDefinition);\n-    //Additional flow and processing strategy (needed to generate a concurrent subflow instantiation)\n-    Flow concurrentCallerFlow = mock(Flow.class, INITIALIZABLE_MESSAGE_PROCESSOR);\n-    ProcessingStrategy concurrentCallerFlowProcessingStrategy = mock(ProcessingStrategy.class);\n-    when(locator.find(Location.builder().globalName(\"concurrentFlow\").build())).thenReturn(of(concurrentCallerFlow));\n-    when(concurrentCallerFlow.getProcessingStrategy()).thenReturn(concurrentCallerFlowProcessingStrategy);\n-    when(concurrentCallerFlowProcessingStrategy.onProcessor(any()))\n-        .thenAnswer(invocationOnMock -> invocationOnMock.getArguments()[0]);\n-    // Two flowRef dynamically pointing to the same subFlow\n-    FlowRefFactoryBean flowRefFactoryBean = createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"flow\", muleArtifactContext);\n-    FlowRefFactoryBean parallelFlowRefFactoryBean =\n-        createFlowRefFactoryBean(DYNAMIC_REFERENCED_FLOW, \"concurrentFlow\", muleArtifactContext);\n-    // Events are sent to both flowRefs in parallel in order to trigger a concurrent subflow instantiation\n-    CountDownLatch threadCountdown = new CountDownLatch(2);\n-    Callable<Void> flowRefEvents = sendEventsThroughFlowRefAsynchronously(threadCountdown, flowRefFactoryBean);\n-    Callable<Void> parallelFlowRefEvents = sendEventsThroughFlowRefAsynchronously(threadCountdown, parallelFlowRefFactoryBean);\n-    ExecutorService executorService = Executors.newFixedThreadPool(2);\n-    try {\n-      executorService.invokeAll(asList(flowRefEvents, parallelFlowRefEvents), 1, TimeUnit.SECONDS);\n-    } finally {\n-      executorService.shutdown();\n-    }\n-    // Assertions over each parent flow processing strategies\n-    verify(callerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    verify(concurrentCallerFlowProcessingStrategy, times(2)).onProcessor(any());\n-    // Asssertions over subflow components root container location\n-    assertThat(stubbedSubFlowProcessors.get(0).getRootContainerLocation().getGlobalName(),\n-               not(equalTo(stubbedSubFlowProcessors.get(1).getRootContainerLocation().getGlobalName())));\n-  }\n-\n-  private Callable<Void> sendEventsThroughFlowRefAsynchronously(CountDownLatch countDownLatch,\n-                                                                FlowRefFactoryBean flowRefFactoryBean) {\n-    return new Callable<Void>() {\n-\n-      @Override\n-      public Void call() throws Exception {\n-        try {\n-          countDownLatch.countDown();\n-          countDownLatch.await();\n-          sendEventsThroughFlowRef(flowRefFactoryBean);\n-        } catch (Exception e) {\n-          throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-        }\n-        return null;\n-      }\n-    };\n-  }\n-\n-  private void sendEventsThroughFlowRef(FlowRefFactoryBean flowRefFactoryBean) {\n-    try {\n-      Processor flowRefProcessor = getFlowRefProcessor(flowRefFactoryBean);\n-      initialiseIfNeeded(flowRefProcessor);\n-      startIfNeeded(flowRefProcessor);\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      assertSame(result.getMessage(), just(newEvent()).cast(CoreEvent.class).transform(flowRefProcessor).block().getMessage());\n-      stopIfNeeded(flowRefProcessor);\n-      disposeIfNeeded(flowRefProcessor, null);\n-    } catch (Exception e) {\n-      throw new RuntimeException(\"Error sending events to a flowRef\", e);\n-    }\n+    getFlowRefProcessor(createFlowRefFactoryBean(DYNAMIC_NON_EXISTANT)).process(testEvent());\n   }\n \n-  private static class StubbedProcessor extends AbstractComponent implements Processor {\n-\n-    private CoreEvent applyResult;\n-\n-    public StubbedProcessor(CoreEvent applyResult) {\n-      this.applyResult = applyResult;\n-    }\n-\n-    @Override\n-    public CoreEvent process(CoreEvent event) throws MuleException {\n-      throw new RuntimeException(new IllegalAccessException(\"This method should never be called\"));\n-    }\n-\n-    @Override\n-    public Publisher<CoreEvent> apply(Publisher<CoreEvent> publisher) {\n-      return from(publisher)\n-          .doOnNext(event -> ((BaseEventContext) event.getContext())\n-              .success(CoreEvent.builder(event).message(applyResult.getMessage()).variables(applyResult.getVariables()).build()))\n-          .map(event -> CoreEvent.builder(event).message(applyResult.getMessage()).variables(applyResult.getVariables()).build());\n-    }\n-\n-  }\n-\n-  private MuleArtifactContext createMuleArtifactContextStub(DefaultListableBeanFactory mockedBeanFactory) {\n-    MuleArtifactContext muleArtifactContext =\n-        new MuleArtifactContext(mockMuleContext, new ConfigResource[0], new ArtifactDeclaration(),\n-                                mock(OptionalObjectsController.class), new HashMap<>(), ArtifactType.APP, new ArrayList<>(),\n-                                Optional.empty(), true, mock(CoreComponentBuildingDefinitionProvider.class)) {\n-\n-          @Override\n-          protected DefaultListableBeanFactory createBeanFactory() {\n-            return mockedBeanFactory;\n-          }\n-\n-          @Override\n-          protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean invocation here\n-          }\n-\n-          @Override\n-          protected void registerListeners() {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n-            // Bean factory is mocked, so no bean registering here\n-          }\n-\n-          @Override\n-          protected void finishRefresh() {\n-            // Bean factory is mocked, so no nothing to do here\n-          }\n-        };\n-    muleArtifactContext.refresh();\n-    return muleArtifactContext;\n-  }\n-\n-  private FlowRefFactoryBean createFlowRefFactoryBean(String referencedFlowName, String flowRefLocation,\n-                                                      ApplicationContext applicationContext)\n-      throws Exception {\n+  private FlowRefFactoryBean createFlowRefFactoryBean(String name) throws Exception {\n     FlowRefFactoryBean flowRefFactoryBean = new FlowRefFactoryBean();\n-    flowRefFactoryBean.setName(referencedFlowName);\n-    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, fromSingleComponent(flowRefLocation)));\n+    flowRefFactoryBean.setName(name);\n+    flowRefFactoryBean.setAnnotations(singletonMap(LOCATION_KEY, DefaultComponentLocation.from(\"flow\")));\n     flowRefFactoryBean.setApplicationContext(applicationContext);\n     mockMuleContext.getInjector().inject(flowRefFactoryBean);\n     return flowRefFactoryBean;\n"}}, {"oid": "1298de285016d6a1fdfb38b6f04dc12c40877f05", "url": "https://github.com/mulesoft/mule/commit/1298de285016d6a1fdfb38b6f04dc12c40877f05", "message": "MULE-18102: Concurrent flow reference instantiation issue", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "edaf42b6d633c8530d601f0eb62dc1b4ea811535", "url": "https://github.com/mulesoft/mule/commit/edaf42b6d633c8530d601f0eb62dc1b4ea811535", "message": "MULE-18102: Solution improvements", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "333994d88b215473f28d2572da2d5f9ea6dd1e50", "url": "https://github.com/mulesoft/mule/commit/333994d88b215473f28d2572da2d5f9ea6dd1e50", "message": "MULE-18102: Code review changes", "committedDate": "2020-04-30T19:20:26Z", "type": "commit"}, {"oid": "f2b46ce2eb9aaf3ba6daa52f33d6bc41865f3f88", "url": "https://github.com/mulesoft/mule/commit/f2b46ce2eb9aaf3ba6daa52f33d6bc41865f3f88", "message": "Unit testing and minor modifications in code comments", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "f7bd6cae5d8445386e5e7da2a5d18cd6f51c5283", "url": "https://github.com/mulesoft/mule/commit/f7bd6cae5d8445386e5e7da2a5d18cd6f51c5283", "message": "MULE-18102: Imports and MuleContext mocking correction", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "a2ebf8dbbbd67e0b9c73aedad4fbab0be11ba8ac", "url": "https://github.com/mulesoft/mule/commit/a2ebf8dbbbd67e0b9c73aedad4fbab0be11ba8ac", "message": "MULE-18102: Test improvements and Code Review changes", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "54ae9d59205053771ea295f9992d49576a61a38c", "url": "https://github.com/mulesoft/mule/commit/54ae9d59205053771ea295f9992d49576a61a38c", "message": "MULE-18102: Code review changes", "committedDate": "2020-04-30T19:41:11Z", "type": "commit"}, {"oid": "32e32691931478d632f08b6cecb17758124f3a1b", "url": "https://github.com/mulesoft/mule/commit/32e32691931478d632f08b6cecb17758124f3a1b", "message": "MULE-18102: Fixing rebase issue and adding static import", "committedDate": "2020-04-30T20:50:31Z", "type": "commit"}, {"oid": "e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "url": "https://github.com/mulesoft/mule/commit/e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "message": "MULE-18102: Static import", "committedDate": "2020-04-30T20:51:49Z", "type": "commit"}, {"oid": "e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "url": "https://github.com/mulesoft/mule/commit/e896bf1d4f042450b9ba9b10ca17cf7ad100182b", "message": "MULE-18102: Static import", "committedDate": "2020-04-30T20:51:49Z", "type": "forcePushed"}]}